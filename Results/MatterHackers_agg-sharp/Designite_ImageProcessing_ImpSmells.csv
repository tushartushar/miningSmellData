Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The method has 127 lines of code.
Complex Method,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,Cyclomatic complexity of the method is 11
Long Statement,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The length of the statement  "								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]); " is 128.
Long Statement,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The length of the statement  "								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0 " is 135.
Complex Conditional,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The conditional expression  "imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha"  is complex.
Complex Conditional,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The conditional expression  "imageToSubtractFrom.Width != imageToSubtract.Width || imageToSubtractFrom.Height != imageToSubtract.Height  				|| imageToSubtractFrom.Width != result.Width || imageToSubtractFrom.Height != result.Height"  is complex.
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: sourceDest.BitDepth != 8
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: int newValue = (cache[y - 1] + cache[y] * 2 + cache[y + 1] + 2) / 4;
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: int newValue = (cache[y - 1] + cache[y] * 2 + cache[y + 1] + 2) / 4;
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: int newValue = (cache[y - 1] + cache[y] * 2 + cache[y + 1] + 2) / 4;
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: sourceDest.BitDepth != 8
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: int newValue = (cache[x - 1] + cache[x] * 2 + cache[x + 1] + 2) / 4;
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: int newValue = (cache[x - 1] + cache[x] * 2 + cache[x + 1] + 2) / 4;
Magic Number,MatterHackers.ImageProcessing,Blur,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: int newValue = (cache[x - 1] + cache[x] * 2 + cache[x + 1] + 2) / 4;
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AjustAlpha,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								var alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									imageABuffer[offsetA + 3] = (byte) (alpha * factor);  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AjustAlpha,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								var alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									imageABuffer[offsetA + 3] = (byte) (alpha * factor);  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AjustAlpha,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								var alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									imageABuffer[offsetA + 3] = (byte) (alpha * factor);  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AjustAlpha,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								var alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									imageABuffer[offsetA + 3] = (byte) (alpha * factor);  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha)  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = newColor.blue;  									imageABuffer[offsetA + 1] = newColor.green;  									imageABuffer[offsetA + 2] = newColor.red;    									if (!keepExistingAlpha)  									{  										imageABuffer[offsetA + 3] = newColor.alpha;  									}  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha)  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = newColor.blue;  									imageABuffer[offsetA + 1] = newColor.green;  									imageABuffer[offsetA + 2] = newColor.red;    									if (!keepExistingAlpha)  									{  										imageABuffer[offsetA + 3] = newColor.alpha;  									}  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha)  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = newColor.blue;  									imageABuffer[offsetA + 1] = newColor.green;  									imageABuffer[offsetA + 2] = newColor.red;    									if (!keepExistingAlpha)  									{  										imageABuffer[offsetA + 3] = newColor.alpha;  									}  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha)  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = newColor.blue;  									imageABuffer[offsetA + 1] = newColor.green;  									imageABuffer[offsetA + 2] = newColor.red;    									if (!keepExistingAlpha)  									{  										imageABuffer[offsetA + 3] = newColor.alpha;  									}  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha)  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = newColor.blue;  									imageABuffer[offsetA + 1] = newColor.green;  									imageABuffer[offsetA + 2] = newColor.red;    									if (!keepExistingAlpha)  									{  										imageABuffer[offsetA + 3] = newColor.alpha;  									}  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,ReplaceColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (imageABuffer[offsetA + 0] == existingColor.blue  									&& imageABuffer[offsetA + 1] == existingColor.green  									&& imageABuffer[offsetA + 2] == existingColor.red  									&& imageABuffer[offsetA + 3] == existingColor.alpha)  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = newColor.blue;  									imageABuffer[offsetA + 1] = newColor.green;  									imageABuffer[offsetA + 2] = newColor.red;    									if (!keepExistingAlpha)  									{  										imageABuffer[offsetA + 3] = newColor.alpha;  									}  								}    								offsetA += 4;  							}  						}    						outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AnyAlphaToColor,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					{  						int height = outputImage.Height;  						int width = outputImage.Width;  						byte[] imageABuffer = outputImage.GetBuffer();    						for (int y = 0; y < height; y++)  						{  							int offsetA = outputImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									// Set semi-transparent colors  									imageABuffer[offsetA + 0] = color.blue;  									imageABuffer[offsetA + 1] = color.green;  									imageABuffer[offsetA + 2] = color.red;  									//imageABuffer[offsetA + 3] = (byte) (alpha == 255 ? 255 : 255 - alpha);  									imageABuffer[offsetA + 3] = (byte) alpha;  								}  								else  								{  									// Set transparent colors  									imageABuffer[offsetA + 0] = transparency.blue;  									imageABuffer[offsetA + 1] = transparency.green;  									imageABuffer[offsetA + 2] = transparency.red;  									imageABuffer[offsetA + 3] = transparency.alpha;  								}    								offsetA += 4;  							}  						}    						//outputImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AllWhite,The following statement contains a magic number: switch (destImage.BitDepth)  			{  				case 32:  					{  						int height = destImage.Height;  						int width = destImage.Width;  						byte[] resultBuffer = sourceImage.GetBuffer();  						byte[] imageABuffer = destImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = destImage.GetBufferOffsetY(y);  							int offsetResult = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)alpha; offsetA++;  								}  								else  								{  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  								}  							}  						}    						destImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AllWhite,The following statement contains a magic number: switch (destImage.BitDepth)  			{  				case 32:  					{  						int height = destImage.Height;  						int width = destImage.Width;  						byte[] resultBuffer = sourceImage.GetBuffer();  						byte[] imageABuffer = destImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = destImage.GetBufferOffsetY(y);  							int offsetResult = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)alpha; offsetA++;  								}  								else  								{  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  								}  							}  						}    						destImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AllWhite,The following statement contains a magic number: switch (destImage.BitDepth)  			{  				case 32:  					{  						int height = destImage.Height;  						int width = destImage.Width;  						byte[] resultBuffer = sourceImage.GetBuffer();  						byte[] imageABuffer = destImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = destImage.GetBufferOffsetY(y);  							int offsetResult = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)alpha; offsetA++;  								}  								else  								{  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  								}  							}  						}    						destImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AllWhite,The following statement contains a magic number: switch (destImage.BitDepth)  			{  				case 32:  					{  						int height = destImage.Height;  						int width = destImage.Width;  						byte[] resultBuffer = sourceImage.GetBuffer();  						byte[] imageABuffer = destImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = destImage.GetBufferOffsetY(y);  							int offsetResult = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)alpha; offsetA++;  								}  								else  								{  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  								}  							}  						}    						destImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\ExtensionMethods.cs,AllWhite,The following statement contains a magic number: switch (destImage.BitDepth)  			{  				case 32:  					{  						int height = destImage.Height;  						int width = destImage.Width;  						byte[] resultBuffer = sourceImage.GetBuffer();  						byte[] imageABuffer = destImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = destImage.GetBufferOffsetY(y);  							int offsetResult = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								int alpha = imageABuffer[offsetA + 3];  								if (alpha > 0)  								{  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)255; offsetA++;  									resultBuffer[offsetResult++] = (byte)alpha; offsetA++;  								}  								else  								{  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  									resultBuffer[offsetResult++] = (byte)0; offsetA++;  								}  							}  						}    						destImage.SetRecieveBlender(new BlenderPreMultBGRA());  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,SetToColor,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoSetToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)(color.blue); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: source.BitDepth != 32 || dest.BitDepth != 32
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: source.BitDepth != 32 || dest.BitDepth != 32
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: destBuffer[destOffset++] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: destBuffer[destOffset++] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: destBuffer[destOffset++] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: destBuffer[destOffset++] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: source.BitDepth != 32 || dest.BitDepth != 32
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: source.BitDepth != 32 || dest.BitDepth != 32
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: destBuffer[destOffset + 2] = maxColor.red;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: destBuffer[destOffset + 3] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: destBuffer[destOffset + 3] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,MaxColor,The following statement contains a magic number: maxColor.red = Math.Max(maxColor.red' sourceBuffer[sourceOffset + 2]);
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: switch (source.BitDepth)  			{  				case 8:  					{  						int height = source.Height;  						int width = source.Width;  						int strideInBytes = source.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						System.Threading.Tasks.Parallel.For(1' height' y =>  						//for (int y = 1; y < height - 1; y++)  						{  							int rowOffset = source.GetBufferOffsetY(y);  							for (int x = 1; x < width - 1; x++)  							{  								int bufferOffset = rowOffset + x;  								// make sure it is set to 1 if we don't change it to 0  								destBuffer[bufferOffset] = 255;    								// do the upper left  								int checkOffset = bufferOffset - strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  								// do the upper center  								checkOffset = bufferOffset - strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the upper right  								checkOffset = bufferOffset - strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  							}  						});  					}  					break;    				case 32:  					{  						int height = source.Height;  						int width = source.Width;  						int sourceStrideInBytes = source.StrideInBytes();  						int destStrideInBytes = dest.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						for (int destY = 1; destY < height - 1; destY++)  						{  							for (int destX = 1; destX < width - 1; destX++)  							{  								for (int sourceY = -1; sourceY <= 1; sourceY++)  								{  									for (int sourceX = -1; sourceX <= 1; sourceX++)  									{  										int sourceOffset = source.GetBufferOffsetXY(destX + sourceX' destY + sourceY);  										if (sourceBuffer[sourceOffset] < threshold)  										{  											int destOffset = dest.GetBufferOffsetXY(destX' destY);  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 255;  										}  									}  								}  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: switch (source.BitDepth)  			{  				case 8:  					{  						int height = source.Height;  						int width = source.Width;  						int strideInBytes = source.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						System.Threading.Tasks.Parallel.For(1' height' y =>  						//for (int y = 1; y < height - 1; y++)  						{  							int rowOffset = source.GetBufferOffsetY(y);  							for (int x = 1; x < width - 1; x++)  							{  								int bufferOffset = rowOffset + x;  								// make sure it is set to 1 if we don't change it to 0  								destBuffer[bufferOffset] = 255;    								// do the upper left  								int checkOffset = bufferOffset - strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  								// do the upper center  								checkOffset = bufferOffset - strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the upper right  								checkOffset = bufferOffset - strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  							}  						});  					}  					break;    				case 32:  					{  						int height = source.Height;  						int width = source.Width;  						int sourceStrideInBytes = source.StrideInBytes();  						int destStrideInBytes = dest.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						for (int destY = 1; destY < height - 1; destY++)  						{  							for (int destX = 1; destX < width - 1; destX++)  							{  								for (int sourceY = -1; sourceY <= 1; sourceY++)  								{  									for (int sourceX = -1; sourceX <= 1; sourceX++)  									{  										int sourceOffset = source.GetBufferOffsetXY(destX + sourceX' destY + sourceY);  										if (sourceBuffer[sourceOffset] < threshold)  										{  											int destOffset = dest.GetBufferOffsetXY(destX' destY);  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 255;  										}  									}  								}  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: switch (source.BitDepth)  			{  				case 8:  					{  						int height = source.Height;  						int width = source.Width;  						int strideInBytes = source.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						System.Threading.Tasks.Parallel.For(1' height' y =>  						//for (int y = 1; y < height - 1; y++)  						{  							int rowOffset = source.GetBufferOffsetY(y);  							for (int x = 1; x < width - 1; x++)  							{  								int bufferOffset = rowOffset + x;  								// make sure it is set to 1 if we don't change it to 0  								destBuffer[bufferOffset] = 255;    								// do the upper left  								int checkOffset = bufferOffset - strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  								// do the upper center  								checkOffset = bufferOffset - strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the upper right  								checkOffset = bufferOffset - strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  							}  						});  					}  					break;    				case 32:  					{  						int height = source.Height;  						int width = source.Width;  						int sourceStrideInBytes = source.StrideInBytes();  						int destStrideInBytes = dest.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						for (int destY = 1; destY < height - 1; destY++)  						{  							for (int destX = 1; destX < width - 1; destX++)  							{  								for (int sourceY = -1; sourceY <= 1; sourceY++)  								{  									for (int sourceX = -1; sourceX <= 1; sourceX++)  									{  										int sourceOffset = source.GetBufferOffsetXY(destX + sourceX' destY + sourceY);  										if (sourceBuffer[sourceOffset] < threshold)  										{  											int destOffset = dest.GetBufferOffsetXY(destX' destY);  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 255;  										}  									}  								}  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: switch (source.BitDepth)  			{  				case 8:  					{  						int height = source.Height;  						int width = source.Width;  						int strideInBytes = source.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						System.Threading.Tasks.Parallel.For(1' height' y =>  						//for (int y = 1; y < height - 1; y++)  						{  							int rowOffset = source.GetBufferOffsetY(y);  							for (int x = 1; x < width - 1; x++)  							{  								int bufferOffset = rowOffset + x;  								// make sure it is set to 1 if we don't change it to 0  								destBuffer[bufferOffset] = 255;    								// do the upper left  								int checkOffset = bufferOffset - strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  								// do the upper center  								checkOffset = bufferOffset - strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the upper right  								checkOffset = bufferOffset - strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the center center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower left  								checkOffset = bufferOffset + strideInBytes - 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower center  								checkOffset = bufferOffset + strideInBytes + 0;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}    								// do the lower right  								checkOffset = bufferOffset + strideInBytes + 1;  								if (sourceBuffer[checkOffset] < threshold)  								{  									destBuffer[bufferOffset] = 0;  									continue;  								}  							}  						});  					}  					break;    				case 32:  					{  						int height = source.Height;  						int width = source.Width;  						int sourceStrideInBytes = source.StrideInBytes();  						int destStrideInBytes = dest.StrideInBytes();  						byte[] sourceBuffer = source.GetBuffer();  						byte[] destBuffer = dest.GetBuffer();    						for (int destY = 1; destY < height - 1; destY++)  						{  							for (int destX = 1; destX < width - 1; destX++)  							{  								for (int sourceY = -1; sourceY <= 1; sourceY++)  								{  									for (int sourceX = -1; sourceX <= 1; sourceX++)  									{  										int sourceOffset = source.GetBufferOffsetXY(destX + sourceX' destY + sourceY);  										if (sourceBuffer[sourceOffset] < threshold)  										{  											int destOffset = dest.GetBufferOffsetXY(destX' destY);  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 0;  											destBuffer[destOffset++] = 255;  										}  									}  								}  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: source.BitDepth != 32 || dest.BitDepth != 32
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: source.BitDepth != 32 || dest.BitDepth != 32
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: destBuffer[destOffset + 2] = minColor.red;
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: destBuffer[destOffset + 3] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: destBuffer[destOffset + 3] = 255;
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,MinColor,The following statement contains a magic number: minColor.red = Math.Min(minColor.red' sourceBuffer[sourceOffset + 2]);
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								Color invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.red;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								Color invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.red;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								Color invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.red;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								Color invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.red;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								Color invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.red;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								Color color = new Color(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								Color invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.red;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Match,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Match.cs,DoMatch,The following statement contains a magic number: result = new ImageBufferFloat(imageToSearch.Width' imageToSearch.Height' 32' new BlenderBGRAFloat());
Magic Number,MatterHackers.Agg.ImageProcessing,Match,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Match.cs,DoMatch,The following statement contains a magic number: int floatsPerPixel = imageToSearch.BitDepth / 32;
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,CreateLookup,The following statement contains a magic number: lookupSubtractAndClamp = new int[512];
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,CreateLookup,The following statement contains a magic number: lookupSubtractAndClamp[i] = Math.Max(0' Math.Min(255' i - 255));
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,CreateLookup,The following statement contains a magic number: lookupSubtractAndClamp[i] = Math.Max(0' Math.Min(255' i - 255));
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 8:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset] = (byte)255;  								}  								else  								{  									resultBuffer[offset] = (byte)0;  								}  								offset += 1;  							}  						}  					}  					break;    				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
