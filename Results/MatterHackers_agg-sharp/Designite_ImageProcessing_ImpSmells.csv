Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,Cyclomatic complexity of the method is 8
Long Statement,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The length of the statement  "								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]); " is 138.
Long Statement,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The length of the statement  "								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0 " is 135.
Complex Conditional,MatterHackers.ImageProcessing,Multiply,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,DoMultiply,The conditional expression  "imageA.Width != imageB.Width || imageA.Height != imageB.Height  				|| imageA.Width != result.Width || imageA.Height != result.Height"  is complex.
Complex Conditional,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The conditional expression  "imageToSubtractFrom.Width != imageToSubtract.Width || imageToSubtractFrom.Height != imageToSubtract.Height  				|| imageToSubtractFrom.Width != result.Width || imageToSubtractFrom.Height != result.Height"  is complex.
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: if (sourceDest.BitDepth != 8)  			{  				throw new NotImplementedException("We only work with 8 bit at the moment.");  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: for (int x = 0; x < width; x++)  			{  				int offset = x;  				for (int y = 0; y < height; y++)  				{  					cache[y] = buffer[offset];  					offset += strideInBytes;  				}    				offset = x;  				for (int y = 1; y < height - 1; y++)  				{  					int newValue = (cache[y - 1] + cache[y] * 2 + cache[y + 1] + 2) / 4; // the + 2 is so that we will round correctly  					buffer[offset] = (byte)newValue;  					offset += strideInBytes;  				}  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: for (int x = 0; x < width; x++)  			{  				int offset = x;  				for (int y = 0; y < height; y++)  				{  					cache[y] = buffer[offset];  					offset += strideInBytes;  				}    				offset = x;  				for (int y = 1; y < height - 1; y++)  				{  					int newValue = (cache[y - 1] + cache[y] * 2 + cache[y + 1] + 2) / 4; // the + 2 is so that we will round correctly  					buffer[offset] = (byte)newValue;  					offset += strideInBytes;  				}  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoYBlur,The following statement contains a magic number: for (int x = 0; x < width; x++)  			{  				int offset = x;  				for (int y = 0; y < height; y++)  				{  					cache[y] = buffer[offset];  					offset += strideInBytes;  				}    				offset = x;  				for (int y = 1; y < height - 1; y++)  				{  					int newValue = (cache[y - 1] + cache[y] * 2 + cache[y + 1] + 2) / 4; // the + 2 is so that we will round correctly  					buffer[offset] = (byte)newValue;  					offset += strideInBytes;  				}  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: if (sourceDest.BitDepth != 8)  			{  				throw new NotImplementedException("We only work with 8 bit at the moment.");  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: for (int y = 0; y < height; y++)  			{  				int offset = sourceDest.GetBufferOffsetY(y);  				for (int x = 0; x < width; x++)  				{  					cache[x] = buffer[offset + x];  				}    				for (int x = 1; x < width - 1; x++)  				{  					int newValue = (cache[x - 1] + cache[x] * 2 + cache[x + 1] + 2) / 4; // the + 2 is so that we will round correctly  					buffer[offset + x] = (byte)newValue;  				}  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: for (int y = 0; y < height; y++)  			{  				int offset = sourceDest.GetBufferOffsetY(y);  				for (int x = 0; x < width; x++)  				{  					cache[x] = buffer[offset + x];  				}    				for (int x = 1; x < width - 1; x++)  				{  					int newValue = (cache[x - 1] + cache[x] * 2 + cache[x + 1] + 2) / 4; // the + 2 is so that we will round correctly  					buffer[offset + x] = (byte)newValue;  				}  			}
Magic Number,MatterHackers.ImageProcessing,Blur,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Blur.cs,DoXBlur,The following statement contains a magic number: for (int y = 0; y < height; y++)  			{  				int offset = sourceDest.GetBufferOffsetY(y);  				for (int x = 0; x < width; x++)  				{  					cache[x] = buffer[offset + x];  				}    				for (int x = 1; x < width - 1; x++)  				{  					int newValue = (cache[x - 1] + cache[x] * 2 + cache[x + 1] + 2) / 4; // the + 2 is so that we will round correctly  					buffer[offset + x] = (byte)newValue;  				}  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,C:\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,C:\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,C:\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,WhiteToColor,C:\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoWhiteToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								byte amountOfWhite = imageABuffer[offsetA];  								resultBuffer[offsetResult++] = (byte)(color.blue * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red * amountOfWhite / 255); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,SetToColor,C:\repos\MatterHackers_agg-sharp\ImageProcessing\WhiteToColor.cs,DoSetToColor,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)(color.blue); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.green); offsetA++;  								resultBuffer[offsetResult++] = (byte)(color.red); offsetA++;  								resultBuffer[offsetResult++] = imageABuffer[offsetA++];  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,ExtensionMethods,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,Multiply,The following statement contains a magic number: switch (outputImage.BitDepth)  			{  				case 32:  					int height = outputImage.Height;  					int width = outputImage.Width;  					byte[] imageABuffer = outputImage.GetBuffer();  					for (int y = 0; y < height; y++)  					{  						int offsetA = outputImage.GetBufferOffsetY(y);    						for (int x = 0; x < width; x++)  						{  							imageABuffer[offsetA + 0] = (byte)((imageABuffer[offsetA + 0] * color.blue) / 255);  							imageABuffer[offsetA + 1] = (byte)((imageABuffer[offsetA + 1] * color.green) / 255);  							imageABuffer[offsetA + 2] = (byte)((imageABuffer[offsetA + 2] * color.red) / 255);  							imageABuffer[offsetA + 3] = (byte)((imageABuffer[offsetA + 3] * color.alpha) / 255);  							offsetA += 4;  						}  					}    					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,Multiply,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,DoMultiply,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						byte[] imageBBuffer = imageB.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetB = imageB.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = 255; offsetA++; offsetB++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,Multiply,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,DoMultiply,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						byte[] imageBBuffer = imageB.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetB = imageB.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = 255; offsetA++; offsetB++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,Multiply,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,DoMultiply,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						byte[] imageBBuffer = imageB.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetB = imageB.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = 255; offsetA++; offsetB++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,Multiply,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,DoMultiply,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						byte[] imageBBuffer = imageB.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetB = imageB.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = 255; offsetA++; offsetB++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.ImageProcessing,Multiply,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Multiply.cs,DoMultiply,The following statement contains a magic number: switch (imageA.BitDepth)  			{  				case 32:  					{  						int height = imageA.Height;  						int width = imageA.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageA.GetBuffer();  						byte[] imageBBuffer = imageB.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offsetA = imageA.GetBufferOffsetY(y);  							int offsetB = imageB.GetBufferOffsetY(y);  							int offsetResult = result.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = (byte)((imageABuffer[offsetA++] * imageBBuffer[offsetB++]) / 255);  								resultBuffer[offsetResult++] = 255; offsetA++; offsetB++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								RGBA_Bytes invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.blue;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								RGBA_Bytes invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.blue;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								RGBA_Bytes invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.blue;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								RGBA_Bytes invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.blue;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								RGBA_Bytes invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.blue;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,InvertLightness,C:\repos\MatterHackers_agg-sharp\ImageProcessing\InvertLightness.cs,DoInvertLightness,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								RGBA_Bytes color = new RGBA_Bytes(resultBuffer[offset + 2]' resultBuffer[offset + 1]' resultBuffer[offset + 0]' resultBuffer[offset + 3]);  								RGBA_Bytes invertedColor = InvertColor(color);    								resultBuffer[offset + 0] = invertedColor.blue;  								resultBuffer[offset + 1] = invertedColor.green;  								resultBuffer[offset + 2] = invertedColor.blue;  								resultBuffer[offset + 3] = invertedColor.alpha;    								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					for (int sourceY = -1; sourceY <= 1; sourceY++)  					{  						for (int sourceX = -1; sourceX <= 1; sourceX++)  						{  							int sourceOffset = source.GetBufferOffsetXY(testX + sourceX' testY + sourceY);  							if (sourceBuffer[sourceOffset] > threshold)  							{  								int destOffset = dest.GetBufferOffsetXY(testX' testY);  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					for (int sourceY = -1; sourceY <= 1; sourceY++)  					{  						for (int sourceX = -1; sourceX <= 1; sourceX++)  						{  							int sourceOffset = source.GetBufferOffsetXY(testX + sourceX' testY + sourceY);  							if (sourceBuffer[sourceOffset] > threshold)  							{  								int destOffset = dest.GetBufferOffsetXY(testX' testY);  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					for (int sourceY = -1; sourceY <= 1; sourceY++)  					{  						for (int sourceX = -1; sourceX <= 1; sourceX++)  						{  							int sourceOffset = source.GetBufferOffsetXY(testX + sourceX' testY + sourceY);  							if (sourceBuffer[sourceOffset] > threshold)  							{  								int destOffset = dest.GetBufferOffsetXY(testX' testY);  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3Binary,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					for (int sourceY = -1; sourceY <= 1; sourceY++)  					{  						for (int sourceX = -1; sourceX <= 1; sourceX++)  						{  							int sourceOffset = source.GetBufferOffsetXY(testX + sourceX' testY + sourceY);  							if (sourceBuffer[sourceOffset] > threshold)  							{  								int destOffset = dest.GetBufferOffsetXY(testX' testY);  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  								destBuffer[destOffset++] = 255;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes maxColor = RGBA_Bytes.Black;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset - 4);  					// x0' y-1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 0);  					// x1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 4);    					// x-1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = maxColor.red;  					destBuffer[destOffset + 1] = maxColor.green;  					destBuffer[destOffset + 0] = maxColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes maxColor = RGBA_Bytes.Black;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset - 4);  					// x0' y-1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 0);  					// x1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 4);    					// x-1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = maxColor.red;  					destBuffer[destOffset + 1] = maxColor.green;  					destBuffer[destOffset + 0] = maxColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes maxColor = RGBA_Bytes.Black;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset - 4);  					// x0' y-1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 0);  					// x1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 4);    					// x-1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = maxColor.red;  					destBuffer[destOffset + 1] = maxColor.green;  					destBuffer[destOffset + 0] = maxColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes maxColor = RGBA_Bytes.Black;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset - 4);  					// x0' y-1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 0);  					// x1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 4);    					// x-1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = maxColor.red;  					destBuffer[destOffset + 1] = maxColor.green;  					destBuffer[destOffset + 0] = maxColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes maxColor = RGBA_Bytes.Black;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset - 4);  					// x0' y-1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 0);  					// x1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 4);    					// x-1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = maxColor.red;  					destBuffer[destOffset + 1] = maxColor.green;  					destBuffer[destOffset + 0] = maxColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,DoDilate3x3MaxValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes maxColor = RGBA_Bytes.Black;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset - 4);  					// x0' y-1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 0);  					// x1' y-1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + 4);    					// x-1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//maxColor = MaxColor(sourceBuffer' maxColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = maxColor.red;  					destBuffer[destOffset + 1] = maxColor.green;  					destBuffer[destOffset + 0] = maxColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Dilate,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Dilate.cs,MaxColor,The following statement contains a magic number: maxColor.red = Math.Max(maxColor.red' sourceBuffer[sourceOffset + 2]);
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3Binary,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					for (int sourceY = -1; sourceY <= 1; sourceY++)  					{  						for (int sourceX = -1; sourceX <= 1; sourceX++)  						{  							int sourceOffset = source.GetBufferOffsetXY(testX + sourceX' testY + sourceY);  							if (sourceBuffer[sourceOffset] < threshold)  							{  								int destOffset = dest.GetBufferOffsetXY(testX' testY);  								destBuffer[destOffset++] = 0;  								destBuffer[destOffset++] = 0;  								destBuffer[destOffset++] = 0;  								destBuffer[destOffset++] = 255;  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: if (source.BitDepth != 32 || dest.BitDepth != 32)  			{  				throw new NotImplementedException("We only work with 32 bit at the moment.");  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes minColor = RGBA_Bytes.White;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset - 4);  					// x0' y-1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + 0);  					// x1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + 4);    					// x-1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = minColor.red;  					destBuffer[destOffset + 1] = minColor.green;  					destBuffer[destOffset + 0] = minColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes minColor = RGBA_Bytes.White;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset - 4);  					// x0' y-1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + 0);  					// x1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + 4);    					// x-1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = minColor.red;  					destBuffer[destOffset + 1] = minColor.green;  					destBuffer[destOffset + 0] = minColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes minColor = RGBA_Bytes.White;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset - 4);  					// x0' y-1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + 0);  					// x1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + 4);    					// x-1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = minColor.red;  					destBuffer[destOffset + 1] = minColor.green;  					destBuffer[destOffset + 0] = minColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes minColor = RGBA_Bytes.White;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset - 4);  					// x0' y-1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + 0);  					// x1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + 4);    					// x-1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = minColor.red;  					destBuffer[destOffset + 1] = minColor.green;  					destBuffer[destOffset + 0] = minColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes minColor = RGBA_Bytes.White;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset - 4);  					// x0' y-1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + 0);  					// x1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + 4);    					// x-1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = minColor.red;  					destBuffer[destOffset + 1] = minColor.green;  					destBuffer[destOffset + 0] = minColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,DoErode3x3MinValue,The following statement contains a magic number: for (int testY = 1; testY < height - 1; testY++)  			{  				for (int testX = 1; testX < width - 1; testX++)  				{  					RGBA_Bytes minColor = RGBA_Bytes.White;  					int sourceOffset = source.GetBufferOffsetXY(testX' testY - 1);    					// x-1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset - 4);  					// x0' y-1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + 0);  					// x1' y-1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + 4);    					// x-1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes - 4);  					// x0' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 0);  					// x+1' y0  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes + 4);    					// x-1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 - 4);  					// x0' y+1  					minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 0);  					// x+1' y+1  					//minColor = MinColor(sourceBuffer' minColor' sourceOffset + sourceStrideInBytes * 2 + 4);    					int destOffset = dest.GetBufferOffsetXY(testX' testY);  					destBuffer[destOffset + 2] = minColor.red;  					destBuffer[destOffset + 1] = minColor.green;  					destBuffer[destOffset + 0] = minColor.blue;  					destBuffer[destOffset + 3] = 255;  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Erode,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Erode.cs,MinColor,The following statement contains a magic number: minColor.red = Math.Min(minColor.red' sourceBuffer[sourceOffset + 2]);
Magic Number,MatterHackers.Agg.ImageProcessing,Match,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Match.cs,DoMatch,The following statement contains a magic number: result = new ImageBufferFloat(imageToSearch.Width' imageToSearch.Height' 32' new BlenderBGRAFloat());
Magic Number,MatterHackers.Agg.ImageProcessing,Match,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Match.cs,DoMatch,The following statement contains a magic number: if (imageToSearch.Width >= imageToFind.Width                  && imageToSearch.Height >= imageToFind.Height                  && imageToSearch.BitDepth == imageToFind.BitDepth)              {                  int floatsPerPixel = imageToSearch.BitDepth / 32;                  int searchDistanceBetweenPixels = imageToSearch.GetFloatsBetweenPixelsInclusive();                  int findDistanceBetweenPixels = imageToFind.GetFloatsBetweenPixelsInclusive();                  float[] searchBuffer = imageToSearch.GetBuffer();                  float[] findBuffer = imageToFind.GetBuffer();                  float[] resultBuffer = imageToFind.GetBuffer();                  int resutsBufferOffset = 0;                  for (int matchY = 0; matchY <= imageToSearch.Height - imageToFind.Height; matchY++)                  {                      for (int matchX = 0; matchX <= imageToSearch.Width - imageToFind.Width; matchX++)                      {                          double currentLeastSquares = 0;                            for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)                          {                              int searchBufferOffset = imageToSearch.GetBufferOffsetXY(matchX' matchY + imageToFindY);                              int findBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);                              for (int findX = 0; findX < imageToFind.Width; findX++)                              {                                  for (int byteIndex = 0; byteIndex < floatsPerPixel; byteIndex++)                                  {                                      float aByte = searchBuffer[searchBufferOffset + byteIndex];                                      float bByte = findBuffer[findBufferOffset + byteIndex];                                      int difference = (int)aByte - (int)bByte;                                      currentLeastSquares += difference * difference;                                  }                                  searchBufferOffset += searchDistanceBetweenPixels;                                  findBufferOffset += findDistanceBetweenPixels;                              }                          }                            resultBuffer[resutsBufferOffset] = (float)currentLeastSquares;                          resutsBufferOffset++;                      }                  }              }
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,CreateLookup,The following statement contains a magic number: if (lookupSubtractAndClamp == null)  			{  				lookupSubtractAndClamp = new int[512];  				for (int i = 0; i < lookupSubtractAndClamp.Length; i++)  				{  					lookupSubtractAndClamp[i] = Math.Max(0' Math.Min(255' i - 255));  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,CreateLookup,The following statement contains a magic number: if (lookupSubtractAndClamp == null)  			{  				lookupSubtractAndClamp = new int[512];  				for (int i = 0; i < lookupSubtractAndClamp.Length; i++)  				{  					lookupSubtractAndClamp[i] = Math.Max(0' Math.Min(255' i - 255));  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,CreateLookup,The following statement contains a magic number: if (lookupSubtractAndClamp == null)  			{  				lookupSubtractAndClamp = new int[512];  				for (int i = 0; i < lookupSubtractAndClamp.Length; i++)  				{  					lookupSubtractAndClamp[i] = Math.Max(0' Math.Min(255' i - 255));  				}  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Subtract,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Subtract.cs,DoSubtract,The following statement contains a magic number: switch (imageToSubtractFrom.BitDepth)  			{  				case 32:  					{  						int height = imageToSubtractFrom.Height;  						int width = imageToSubtractFrom.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] imageABuffer = imageToSubtractFrom.GetBuffer();  						byte[] imageBBuffer = imageToSubtract.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = imageToSubtractFrom.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255]; // add 255 to make sure not < 0  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = (byte)lookupSubtractAndClamp[imageABuffer[offset] - imageBBuffer[offset] + 255];  								offset++;  								resultBuffer[offset] = 255;  								offset++;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.ImageProcessing,Threshold,C:\repos\MatterHackers_agg-sharp\ImageProcessing\Threshold.cs,DoThreshold,The following statement contains a magic number: switch (sourceImage.BitDepth)  			{  				case 32:  					{  						int height = sourceImage.Height;  						int width = sourceImage.Width;  						byte[] resultBuffer = result.GetBuffer();  						byte[] sourceBuffer = sourceImage.GetBuffer();  						for (int y = 0; y < height; y++)  						{  							int offset = sourceImage.GetBufferOffsetY(y);    							for (int x = 0; x < width; x++)  							{  								if (testFunction(sourceBuffer' offset' threshold))  								{  									resultBuffer[offset + 0] = (byte)255;  									resultBuffer[offset + 1] = (byte)255;  									resultBuffer[offset + 2] = (byte)255;  									resultBuffer[offset + 3] = (byte)255;  								}  								else  								{  									resultBuffer[offset + 0] = (byte)0;  									resultBuffer[offset + 1] = (byte)0;  									resultBuffer[offset + 2] = (byte)0;  									resultBuffer[offset + 3] = (byte)0;  								}  								offset += 4;  							}  						}  					}  					break;    				default:  					throw new NotImplementedException();  			}
