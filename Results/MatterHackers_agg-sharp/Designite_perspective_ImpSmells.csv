Implementation smell,Namespace,Class,File,Method,Description
Long Statement,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The length of the statement  "				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon()); " is 151.
Long Statement,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The length of the statement  "					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths); " is 144.
Long Statement,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The length of the statement  "					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5' " is 181.
Long Statement,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The length of the statement  "				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon()); " is 157.
Long Statement,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The length of the statement  "					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths); " is 144.
Long Statement,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The length of the statement  "					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5' " is 191.
Virtual Method Call from Constructor,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The constructor "perspective_application" calls a virtual method "AddChild".
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: quadPolygonControl = new MatterHackers.Agg.UI.PolygonEditWidget(4' 5.0);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: quadPolygonControl = new MatterHackers.Agg.UI.PolygonEditWidget(4' 5.0);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: transformationTypeRadioButton = new MatterHackers.Agg.UI.RadioButtonGroup(new Vector2(420' 5.0)' new Vector2(130.0' 50.0));
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: transformationTypeRadioButton = new MatterHackers.Agg.UI.RadioButtonGroup(new Vector2(420' 5.0)' new Vector2(130.0' 50.0));
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: transformationTypeRadioButton = new MatterHackers.Agg.UI.RadioButtonGroup(new Vector2(420' 5.0)' new Vector2(130.0' 50.0));
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: transformationTypeRadioButton = new MatterHackers.Agg.UI.RadioButtonGroup(new Vector2(420' 5.0)' new Vector2(130.0' 50.0));
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: quadPolygonControl.SetXN(2' lionShape.Bounds.Right);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: quadPolygonControl.SetYN(2' lionShape.Bounds.Bottom);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: quadPolygonControl.SetXN(3' lionShape.Bounds.Left);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,perspective_application,The following statement contains a magic number: quadPolygonControl.SetYN(3' lionShape.Bounds.Bottom);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: double dx = Width / 2.0 - (quadPolygonControl.GetXN(1) - quadPolygonControl.GetXN(0)) / 2.0;
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: double dx = Width / 2.0 - (quadPolygonControl.GetXN(1) - quadPolygonControl.GetXN(0)) / 2.0;
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: double dy = Height / 2.0 - (quadPolygonControl.GetYN(0) - quadPolygonControl.GetYN(2)) / 2.0;
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: double dy = Height / 2.0 - (quadPolygonControl.GetYN(0) - quadPolygonControl.GetYN(2)) / 2.0;
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: double dy = Height / 2.0 - (quadPolygonControl.GetYN(0) - quadPolygonControl.GetYN(2)) / 2.0;
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: quadPolygonControl.AddXN(2' dx);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: quadPolygonControl.AddYN(2' dy);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: quadPolygonControl.AddXN(3' dx);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnInitialize,The following statement contains a magic number: quadPolygonControl.AddYN(3' dy);
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (backBuffer.BitDepth == 32)  			{  				image = new ImageBuffer();  				image.Attach(backBuffer' new BlenderBGRA());  			}  			else  			{  				if (backBuffer.BitDepth != 24)  				{  					throw new System.NotSupportedException();  				}  				image = new ImageBuffer();  				image.Attach(backBuffer' new BlenderBGR());  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (backBuffer.BitDepth == 32)  			{  				image = new ImageBuffer();  				image.Attach(backBuffer' new BlenderBGRA());  			}  			else  			{  				if (backBuffer.BitDepth != 24)  				{  					throw new System.NotSupportedException();  				}  				image = new ImageBuffer();  				image.Attach(backBuffer' new BlenderBGR());  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: if (transformationTypeRadioButton.SelectedIndex == 0)  			{  				Bilinear tr = new Bilinear(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					//--------------------------  					// Render transformed lion  					//  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);  					//--------------------------    					//--------------------------  					// Render transformed ellipse  					//  					VertexSource.Ellipse ell = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);  					Stroke ell_stroke = new Stroke(ell);  					ell_stroke.width(3.0);  					VertexSourceApplyTransform trans_ell = new VertexSourceApplyTransform(ell' tr);    					VertexSourceApplyTransform trans_ell_stroke = new VertexSourceApplyTransform(ell_stroke' tr);    					g_rasterizer.add_path(trans_ell);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(trans_ell_stroke);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}  			else  			{  				Perspective tr = new Perspective(lionShape.Bounds.Left' lionShape.Bounds.Bottom' lionShape.Bounds.Right' lionShape.Bounds.Top' quadPolygonControl.polygon());  				if (tr.is_valid())  				{  					// Render transformed lion  					VertexSourceApplyTransform trans = new VertexSourceApplyTransform(lionShape.Path' tr);    					scanlineRenderer.RenderSolidAllPaths(clippingProxy' g_rasterizer' g_scanline' trans' lionShape.Colors' lionShape.PathIndex' lionShape.NumPaths);    					// Render transformed ellipse  					VertexSource.Ellipse FilledEllipse = new MatterHackers.Agg.VertexSource.Ellipse((lionShape.Bounds.Left + lionShape.Bounds.Right) * 0.5' (lionShape.Bounds.Bottom + lionShape.Bounds.Top) * 0.5'  									 (lionShape.Bounds.Right - lionShape.Bounds.Left) * 0.5' (lionShape.Bounds.Top - lionShape.Bounds.Bottom) * 0.5'  									 200);    					Stroke EllipseOutline = new Stroke(FilledEllipse);  					EllipseOutline.width(3.0);  					VertexSourceApplyTransform TransformedFilledEllipse = new VertexSourceApplyTransform(FilledEllipse' tr);    					VertexSourceApplyTransform TransformedEllipesOutline = new VertexSourceApplyTransform(EllipseOutline' tr);    					g_rasterizer.add_path(TransformedFilledEllipse);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.5' 0.3' 0.0' 0.3));    					g_rasterizer.add_path(TransformedEllipesOutline);  					scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0.0' 0.3' 0.2' 1.0));  				}  			}
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0' 0.3' 0.5' 0.6));
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0' 0.3' 0.5' 0.6));
Magic Number,MatterHackers.Agg,perspective_application,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,OnDraw,The following statement contains a magic number: scanlineRenderer.RenderSolid(clippingProxy' g_rasterizer' g_scanline' new RGBA_Bytes(0' 0.3' 0.5' 0.6));
Magic Number,MatterHackers.Agg,PerspectiveFactory,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  				"Vector"'  				"Perspective Rendering"'  				"Perspective and bilinear transformations. In general' these classes can transform an arbitrary quadrangle "  			+ " to another arbitrary quadrangle (with some restrictions). The example demonstrates how to transform "  			+ "a rectangle to a quadrangle defined by 4 vertices. You can drag the 4 corners of the quadrangle' "  			+ "as well as its boundaries. Note' that the perspective transformations don't work correctly if "  			+ "the destination quadrangle is concave. Bilinear thansformations give a different result' but "  			+ "remain valid with any shape of the destination quadrangle."'  				600'  				600);
Magic Number,MatterHackers.Agg,PerspectiveFactory,C:\repos\MatterHackers_agg-sharp\examples\perspective\perspective.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  				"Vector"'  				"Perspective Rendering"'  				"Perspective and bilinear transformations. In general' these classes can transform an arbitrary quadrangle "  			+ " to another arbitrary quadrangle (with some restrictions). The example demonstrates how to transform "  			+ "a rectangle to a quadrangle defined by 4 vertices. You can drag the 4 corners of the quadrangle' "  			+ "as well as its boundaries. Note' that the perspective transformations don't work correctly if "  			+ "the destination quadrangle is concave. Bilinear thansformations give a different result' but "  			+ "remain valid with any shape of the destination quadrangle."'  				600'  				600);
