Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The method has 136 lines of code.
Long Method,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The method has 104 lines of code.
Long Method,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The method has 114 lines of code.
Long Method,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The method has 103 lines of code.
Complex Method,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,GetClosestIntersection,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,IntersectionIterator,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,GetIntersect,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,RayTraceScene,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,Cyclomatic complexity of the method is 12
Long Parameter List,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The method has 6 parameters. Parameters: leftNormal' rightNormal' bottomNormal' topNormal' backNormal' distanceToBack
Long Parameter List,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The method has 6 parameters. Parameters: left' right' bottom' top' front' back
Long Parameter List,MatterHackers.RayTracer,ChessboardMaterial,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\ChessboardMaterial.cs,ChessboardMaterial,The method has 6 parameters. Parameters: coloreven' colorodd' reflection' transparency' gloss' density
Long Parameter List,MatterHackers.RayTracer,TextureMaterial,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\TextureMaterial.cs,TextureMaterial,The method has 5 parameters. Parameters: texture' reflection' transparency' gloss' density
Long Parameter List,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The method has 5 parameters. Parameters: viewport' scene' imageBufferAsDoubles' maxSamples' y
Long Parameter List,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthXSpan,The method has 6 parameters. Parameters: destImage' viewport' y' destBuffer' minZ' divisor
Long Parameter List,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,intersect,The method has 5 parameters. Parameters: ray' minDistFound' maxDistFound' minAxis' maxAxis
Long Parameter List,MatterHackers.RayTracer,PlaneShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\PlaneShape.cs,PlaneShape,The method has 6 parameters. Parameters: planeNormal' distanceFromOrigin' color' oddcolor' reflection' transparency
Long Identifier,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The length of the parameter directiorFromHitToLightNormalized is 33.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter deltaFromShpereCenterToRayOrigin is 32.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter distanceFromCircleCenterToRayOrigin is 35.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter lengthFromRayOrginToCircleCenterSquared is 39.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter lengthFromRayOrigintoNearEdgeOfCircleSquared is 44.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter distanceFromCircleCenterToRaySquared is 36.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared is 58.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter distanceFromRayOriginToCircleCenter is 35.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the parameter amountCircleCenterToRayIsGreaterThanRayOriginToEdge is 51.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter deltaFromShpereCenterToRayOrigin is 32.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter distanceFromCircleCenterToRayOrigin is 35.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter lengthFromRayOrginToCircleCenterSquared is 39.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter lengthFromRayOrigintoNearEdgeOfCircleSquared is 44.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter distanceFromCircleCenterToRaySquared is 36.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared is 58.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter distanceFromRayOriginToCircleCenter is 35.
Long Identifier,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the parameter amountCircleCenterToRayIsGreaterThanRayOriginToEdge is 51.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter deltaFromShpereCenterToRayOrigin is 32.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter distanceFromSphereCenterToRayOrigin is 35.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter lengthFromRayOrginToSphereCenterSquared is 39.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter lengthFromRayOrigintoNearEdgeOfSphereSquared is 44.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter distanceFromSphereCenterToRaySquared is 36.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter amountSphereCenterToRayIsGreaterThanRayOriginToEdgeSquared is 58.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter distanceFromRayOriginToSphereCenter is 35.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the parameter amountSphereCenterToRayIsGreaterThanRayOriginToEdge is 51.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter deltaFromShpereCenterToRayOrigin is 32.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter distanceFromSphereCenterToRayOrigin is 35.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter lengthFromRayOrginToSphereCenterSquared is 39.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter lengthFromRayOrigintoNearEdgeOfSphereSquared is 44.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter distanceFromSphereCenterToRaySquared is 36.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter amountSphereCenterToRayIsGreaterThanRayOriginToEdgeSquared is 58.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter distanceFromRayOriginToSphereCenter is 35.
Long Identifier,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the parameter amountSphereCenterToRayIsGreaterThanRayOriginToEdge is 51.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,SubtractRemoveRegion,The length of the statement  "						// We are in front of the remove start. If the next backface is behind the remove start' add a back face at the remove start. " is 125.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,SubtractRemoveRegion,The length of the statement  "						// there should always be a back face so it should be safe to + 1 this index.  I will let the bounds checker get it because it will throw an assert.  If not I would throw one instead. " is 183.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,SubtractRemoveRegion,The length of the statement  "					else if (primaryInfo.distanceToHit >= (startRemoveInfo.distanceToHit - Ray.sameSurfaceOffset) && primaryInfo.distanceToHit < (endRemoveInfo.distanceToHit + Ray.sameSurfaceOffset)) " is 179.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,SubtractRemoveRegion,The length of the statement  "						if (primaryInfo.distanceToHit > (startRemoveInfo.distanceToHit - Ray.sameSurfaceOffset) && primaryInfo.distanceToHit < (endRemoveInfo.distanceToHit + Ray.sameSurfaceOffset)) " is 173.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,SubtractRemoveRegion,The length of the statement  "							// We should be guaranteed that the front face is within the remove distance because if it was we should have returned above. " is 125.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,SubtractRemoveRegion,The length of the statement  "						if (primaryInfo.distanceToHit > (startRemoveInfo.distanceToHit - Ray.sameSurfaceOffset) && primaryInfo.distanceToHit < (endRemoveInfo.distanceToHit + Ray.sameSurfaceOffset)) " is 173.
Long Statement,MatterHackers.RayTracer,IntersectInfo,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\IntersectInfo.cs,GetRemoveRegion,The length of the statement  "						if (nextIndex >= subtractCount || subtractList[subtractIndex].distanceToHit + Ray.sameSurfaceOffset < subtractList[nextIndex].distanceToHit) " is 140.
Long Statement,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,GetClosestIntersection,The length of the statement  "						if (infoSecond != null && infoSecond.hitType != IntersectionType.None && infoSecond.distanceToHit < infoFirst.distanceToHit && infoSecond.distanceToHit >= 0) " is 157.
Long Statement,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The length of the statement  "							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]); " is 134.
Long Statement,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The length of the statement  "									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best " is 137.
Long Statement,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The length of the statement  "						Ray refractionRay = new Ray(info.hitPosition' ray.directionNormal' Ray.sameSurfaceOffset' double.MaxValue);  // GetRefractionRay(info.hitPosition' info.normalAtHit' ray.direction' info.closestHit.Material.Refraction); " is 217.
Long Statement,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The length of the statement  "					Ray shadowRay = new Ray(info.hitPosition' directiorFromHitToLightNormalized' Ray.sameSurfaceOffset' double.MaxValue); // it may be usefull to limit the legth to te dist to the camera (but I doubt it LBB). " is 204.
Long Statement,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The length of the statement  "						if (shadow.hitType != IntersectionType.None && shadow.closestHitObject != info.closestHitObject && shadow.distanceToHit < distanceToLight) " is 138.
Long Statement,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,TracePrimaryRay,The length of the statement  "				if (info != null && info.hitType != IntersectionType.None && info.distanceToHit < primaryRayIntersection.distanceToHit && info.distanceToHit >= 0) " is 146.
Long Statement,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The length of the statement  "				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] + " is 125.
Long Statement,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,GetColor,The length of the statement  "                Vector3 vecU = new Vector3D((P1.y + P2.y) / 2 - Position.y' (P1.z + P2.z) / 2 - Position.z' Position.x - (P1.x + P2.x) / 2).GetNormal(); " is 136.
Long Statement,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,IntersectionIterator,The length of the statement  "					info.normalAtHit[minAxis] = ray.sign[minAxis] == Ray.Sign.negative ? 1 : -1; // you hit the side that is oposite your sign " is 122.
Long Statement,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,GetClosestIntersection,The length of the statement  "						info.normalAtHit[minAxis] = ray.sign[minAxis] == Ray.Sign.negative ? 1 : -1; // you hit the side that is oposite your sign " is 122.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "			double distanceFromCircleCenterToRayOrigin = Vector2.Dot(deltaFromShpereCenterToRayOrigin' rayDirection); // negative means the Circle is in front of the ray. " is 158.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "			double lengthFromRayOrginToCircleCenterSquared = Vector2.Dot(deltaFromShpereCenterToRayOrigin' deltaFromShpereCenterToRayOrigin); " is 129.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "			double distanceFromCircleCenterToRaySquared = distanceFromCircleCenterToRayOrigin * distanceFromCircleCenterToRayOrigin; " is 120.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "			double amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared = distanceFromCircleCenterToRaySquared - lengthFromRayOrigintoNearEdgeOfCircleSquared; " is 152.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "					bool wantFrontAndInFront = (ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTop; " is 125.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "					bool wantBackAndInBack = (ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTop; " is 122.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared); " is 131.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio; " is 133.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The length of the statement  "					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio; " is 132.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the statement  "			double lengthFromRayOrginToCircleCenterSquared = Vector2.Dot(deltaFromShpereCenterToRayOrigin' deltaFromShpereCenterToRayOrigin); " is 129.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the statement  "			double distanceFromCircleCenterToRaySquared = distanceFromCircleCenterToRayOrigin * distanceFromCircleCenterToRayOrigin; " is 120.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the statement  "			double amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared = distanceFromCircleCenterToRaySquared - lengthFromRayOrigintoNearEdgeOfCircleSquared; " is 152.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the statement  "				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared); " is 131.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the statement  "					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio; " is 133.
Long Statement,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The length of the statement  "					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio; " is 132.
Long Statement,MatterHackers.RayTracer,PlaneShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\PlaneShape.cs,ToString,The length of the statement  "			return string.Format("Sphere {0}x+{1}y+{2}z+{3}=0)"' plane.PlaneNormal.x' plane.PlaneNormal.y' plane.PlaneNormal.z' plane.DistanceToPlaneFromOrigin); " is 149.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the statement  "			double distanceFromSphereCenterToRayOrigin = Vector3.Dot(deltaFromShpereCenterToRayOrigin' ray.directionNormal); // negative means the sphere is in front of the ray. " is 165.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the statement  "			double lengthFromRayOrginToSphereCenterSquared = Vector3.Dot(deltaFromShpereCenterToRayOrigin' deltaFromShpereCenterToRayOrigin); " is 129.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the statement  "			double distanceFromSphereCenterToRaySquared = distanceFromSphereCenterToRayOrigin * distanceFromSphereCenterToRayOrigin; " is 120.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the statement  "			double amountSphereCenterToRayIsGreaterThanRayOriginToEdgeSquared = distanceFromSphereCenterToRaySquared - lengthFromRayOrigintoNearEdgeOfSphereSquared; " is 152.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the statement  "				|| (ray.intersectionType == IntersectionType.BackFace && lengthFromRayOrginToSphereCenterSquared < radiusSquared)) // yes' that's it' we found the intersection! " is 160.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetClosestIntersection,The length of the statement  "				double amountSphereCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountSphereCenterToRayIsGreaterThanRayOriginToEdgeSquared); " is 131.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the statement  "			double distanceFromSphereCenterToRayOrigin = Vector3.Dot(deltaFromShpereCenterToRayOrigin' ray.directionNormal); // negative means the sphere is in front of the ray. " is 165.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the statement  "			double lengthFromRayOrginToSphereCenterSquared = Vector3.Dot(deltaFromShpereCenterToRayOrigin' deltaFromShpereCenterToRayOrigin); " is 129.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the statement  "			double distanceFromSphereCenterToRaySquared = distanceFromSphereCenterToRayOrigin * distanceFromSphereCenterToRayOrigin; " is 120.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the statement  "			double amountSphereCenterToRayIsGreaterThanRayOriginToEdgeSquared = distanceFromSphereCenterToRaySquared - lengthFromRayOrigintoNearEdgeOfSphereSquared; " is 152.
Long Statement,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,IntersectionIterator,The length of the statement  "				double amountSphereCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountSphereCenterToRayIsGreaterThanRayOriginToEdgeSquared); " is 131.
Long Statement,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetClosestIntersection,The length of the statement  "				bool wantFrontAndInFront = (ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFront; " is 120.
Long Statement,MatterHackers.RayTracer.Traceable,Difference,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Difference.cs,FindNextIntersections,The length of the statement  "			currentRayCheckBackfaces.minDistanceToConsider = ((info.hitPosition + ray.directionNormal * Ray.sameSurfaceOffset) - ray.origin).Length; " is 136.
Long Statement,MatterHackers.RayTracer.Traceable,Transform,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Transform.cs,GetLocalSpaceRay,The length of the statement  "			return new Ray(transformedOrigin' transformedDirecton' ray.minDistanceToConsider' ray.maxDistanceToConsider' ray.intersectionType); " is 131.
Complex Conditional,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,GetClosestIntersection,The conditional expression  "infoSecond != null && infoSecond.hitType != IntersectionType.None && infoSecond.distanceToHit < infoFirst.distanceToHit && infoSecond.distanceToHit >= 0"  is complex.
Complex Conditional,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,TracePrimaryRay,The conditional expression  "info != null && info.hitType != IntersectionType.None && info.distanceToHit < primaryRayIntersection.distanceToHit && info.distanceToHit >= 0"  is complex.
Complex Conditional,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The conditional expression  "ray.intersectionType == IntersectionType.FrontFace && inFrontOfBottom  						|| ray.intersectionType == IntersectionType.BackFace && !inFrontOfBottom"  is complex.
Complex Conditional,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,Check2DHitOnMajorAxis,The conditional expression  "x >= boundsOnMajorAxis.Left && x <= boundsOnMajorAxis.Right &&  				y >= boundsOnMajorAxis.Bottom && y <= boundsOnMajorAxis.Top"  is complex.
Empty Catch Block,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,FullyTraceRayBundle,The method has an empty catch block.
Empty Catch Block,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,RayTraceScene,The method has an empty catch block.
Magic Number,MatterHackers.RayTracer.Light,PointLight,C:\repos\MatterHackers_agg-sharp\RayTracer\Light\PointLight.cs,PointLight,The following statement contains a magic number: strength = 10;
Magic Number,MatterHackers.RayTracer.Light,PointLight,C:\repos\MatterHackers_agg-sharp\RayTracer\Light\PointLight.cs,Strength,The following statement contains a magic number: return Math.Pow((strength - distance) / strength' .2);
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToAbsolute,The following statement contains a magic number: AxisToWorld[3' 0] = x;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToAbsolute,The following statement contains a magic number: AxisToWorld[3' 1] = y;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToAbsolute,The following statement contains a magic number: AxisToWorld[3' 2] = z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToAbsolute,The following statement contains a magic number: AxisToWorld[3' 2] = z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelative,The following statement contains a magic number: if (x != 0 || y != 0 || z != 0)  			{  				Vector3 add;    				add.x = x;  				add.y = y;  				add.z = z;    				add = Vector3.Transform(add' AxisToWorld);    				AxisToWorld[3' 0] += add.x;  				AxisToWorld[3' 1] += add.y;  				AxisToWorld[3' 2] += add.z;    				WorldToAxis = Matrix4X4.Invert(AxisToWorld);  			}
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelative,The following statement contains a magic number: if (x != 0 || y != 0 || z != 0)  			{  				Vector3 add;    				add.x = x;  				add.y = y;  				add.z = z;    				add = Vector3.Transform(add' AxisToWorld);    				AxisToWorld[3' 0] += add.x;  				AxisToWorld[3' 1] += add.y;  				AxisToWorld[3' 2] += add.z;    				WorldToAxis = Matrix4X4.Invert(AxisToWorld);  			}
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelative,The following statement contains a magic number: if (x != 0 || y != 0 || z != 0)  			{  				Vector3 add;    				add.x = x;  				add.y = y;  				add.z = z;    				add = Vector3.Transform(add' AxisToWorld);    				AxisToWorld[3' 0] += add.x;  				AxisToWorld[3' 1] += add.y;  				AxisToWorld[3' 2] += add.z;    				WorldToAxis = Matrix4X4.Invert(AxisToWorld);  			}
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelative,The following statement contains a magic number: if (x != 0 || y != 0 || z != 0)  			{  				Vector3 add;    				add.x = x;  				add.y = y;  				add.z = z;    				add = Vector3.Transform(add' AxisToWorld);    				AxisToWorld[3' 0] += add.x;  				AxisToWorld[3' 1] += add.y;  				AxisToWorld[3' 2] += add.z;    				WorldToAxis = Matrix4X4.Invert(AxisToWorld);  			}
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: AxisToWorld[3' 0] += add.x;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: AxisToWorld[3' 1] += add.y;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: AxisToWorld[3' 2] += add.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: AxisToWorld[3' 2] += add.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: WorldToAxis[3' 0] -= add.x;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: WorldToAxis[3' 1] -= add.y;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: WorldToAxis[3' 2] -= add.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,MoveToRelativeTo,The following statement contains a magic number: WorldToAxis[3' 2] -= add.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.x = AxisToWorld[3' 0];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.y = AxisToWorld[3' 1];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.z = AxisToWorld[3' 2];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.z = AxisToWorld[3' 2];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 0] = save1.x;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 1] = save1.y;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 2] = save1.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 2] = save1.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.x = AxisToWorld[3' 0];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.y = AxisToWorld[3' 1];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.z = AxisToWorld[3' 2];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: save1.z = AxisToWorld[3' 2];
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 0] = save1.x;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 1] = save1.y;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 2] = save1.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,RotateAbsolute,The following statement contains a magic number: AxisToWorld[3' 2] = save1.z;
Magic Number,MatterHackers.RayTracer,Axis3D,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Axis3D.cs,GetXAngleToTarget,The following statement contains a magic number: return Math.Atan2(-TargetPos.z' TargetPos.y) - MathHelper.Tau / 4;
Magic Number,MatterHackers.RayTracer,FrustumRayBundle,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\RayBundle.cs,CalculateFrustum,The following statement contains a magic number: frustumForRays.Planes = new Plane[4];
Magic Number,MatterHackers.RayTracer,FrustumRayBundle,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\RayBundle.cs,CalculateFrustum,The following statement contains a magic number: {  				Vector3 normal = Vector3.Cross(cornerRay2' cornerRay3).GetNormal();  				frustumForRays.Planes[2] = new Plane(normal' Vector3.Dot(normal' origin));  			}
Magic Number,MatterHackers.RayTracer,FrustumRayBundle,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\RayBundle.cs,CalculateFrustum,The following statement contains a magic number: {  				Vector3 normal = Vector3.Cross(cornerRay3' cornerRay0).GetNormal();  				frustumForRays.Planes[3] = new Plane(normal' Vector3.Dot(normal' origin));  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{  						IPrimitive item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,SimpleCamera,C:\repos\MatterHackers_agg-sharp\RayTracer\Camera\SimpleCamera.cs,SimpleCamera,The following statement contains a magic number: if (fieldOfViewRad > 3.14)  			{  				throw new Exception("You need to give the Field of View in radians.");  			}
Magic Number,MatterHackers.RayTracer,SimpleCamera,C:\repos\MatterHackers_agg-sharp\RayTracer\Camera\SimpleCamera.cs,SimpleCamera,The following statement contains a magic number: double sin = Math.Sin(cameraFOV / 2);
Magic Number,MatterHackers.RayTracer,SimpleCamera,C:\repos\MatterHackers_agg-sharp\RayTracer\Camera\SimpleCamera.cs,SimpleCamera,The following statement contains a magic number: distanceToCameraPlane = Math.Cos(cameraFOV / 2) / sin;
Magic Number,MatterHackers.RayTracer,SimpleCamera,C:\repos\MatterHackers_agg-sharp\RayTracer\Camera\SimpleCamera.cs,GetDirectionMinus1To1,The following statement contains a magic number: double oneOverScale = 1.0 / (widthInPixels / 2.0);
Magic Number,MatterHackers.RayTracer,SimpleCamera,C:\repos\MatterHackers_agg-sharp\RayTracer\Camera\SimpleCamera.cs,GetDirectionMinus1To1,The following statement contains a magic number: double x = screenX - widthInPixels / 2.0;
Magic Number,MatterHackers.RayTracer,SimpleCamera,C:\repos\MatterHackers_agg-sharp\RayTracer\Camera\SimpleCamera.cs,GetDirectionMinus1To1,The following statement contains a magic number: double y = screenY - heightInPixels / 2.0;
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes = new Plane[6];
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes = new Plane[5];
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[2] = new Plane(bottomNormal.GetNormal()' 0);
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[3] = new Plane(topNormal.GetNormal()' 0);
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[4] = new Plane(backNormal.GetNormal()' distanceToBack);
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes = new Plane[6];
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[2] = bottom;
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[3] = top;
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[4] = front;
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes[5] = back;
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: Planes = new Plane[6];
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: if (sixPlanes.Length != 6)  			{  				throw new Exception("Must create with six planes");  			}
Magic Number,MatterHackers.RayTracer,Frustum,C:\repos\MatterHackers_agg-sharp\RayTracer\TraceData\Frustum.cs,Frustum,The following statement contains a magic number: for (int i = 0; i < 6; i++)  			{  				Planes[i] = sixPlanes[i];  			}
Magic Number,MatterHackers.RayTracer,MaterialAbstract,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\MaterialAbstract.cs,MaterialAbstract,The following statement contains a magic number: gloss = 2;
Magic Number,MatterHackers.RayTracer,MaterialAbstract,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\MaterialAbstract.cs,MaterialAbstract,The following statement contains a magic number: refraction = 0.50;
Magic Number,MatterHackers.RayTracer,MaterialAbstract,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\MaterialAbstract.cs,WrapUp,The following statement contains a magic number: t = t % 2.0;
Magic Number,MatterHackers.RayTracer,MaterialAbstract,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\MaterialAbstract.cs,WrapUp,The following statement contains a magic number: if (t < -1) t = t + 2.0;
Magic Number,MatterHackers.RayTracer,MaterialAbstract,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\MaterialAbstract.cs,WrapUp,The following statement contains a magic number: if (t >= 1) t -= 2.0;
Magic Number,MatterHackers.RayTracer,TextureMaterial,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\TextureMaterial.cs,GetColor,The following statement contains a magic number: double nu1 = u * Texture.Width / 2;
Magic Number,MatterHackers.RayTracer,TextureMaterial,C:\repos\MatterHackers_agg-sharp\RayTracer\Materials\TextureMaterial.cs,GetColor,The following statement contains a magic number: double nv1 = v * Texture.Width / 2;
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyColorBufferToImage,The following statement contains a magic number: if (destImage.BitDepth != 32)  			{  				throw new Exception("We can only render to 32 bit dest at the moment.");  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthBufferToImage,The following statement contains a magic number: if (destImage.BitDepth != 32)  			{  				throw new Exception("We can only render to 32 bit dest at the moment.");  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthBufferToImage,The following statement contains a magic number: double minZ = 5000;
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthBufferToImage,The following statement contains a magic number: for (int y = viewport.Bottom; y < viewport.Height; y++)  			{  				for (int x = viewport.Left; x < viewport.Right; x++)  				{  					double depthAtXY = DepthBuffer[x][y];  					if (depthAtXY < 5000)  					{  						minZ = Math.Min(minZ' depthAtXY);  						maxZ = Math.Max(maxZ' depthAtXY);  					}  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyNoramlBufferToImage,The following statement contains a magic number: if (destImage.BitDepth != 32)  			{  				throw new Exception("We can only render to 32 bit dest at the moment.");  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyNoramlBufferToImage,The following statement contains a magic number: for (int y = viewport.Bottom; y < viewport.Height; y++)  			{  				for (int x = viewport.Left; x < viewport.Right; x++)  				{  					int bufferOffset = destImage.GetBufferOffsetY(y);    					// we don't need to set this if we are anti-aliased  					int totalOffset = bufferOffset + x * 4;  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].x + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].y + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].z + 1) * 128);  					destBuffer[totalOffset] = 255;  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyNoramlBufferToImage,The following statement contains a magic number: for (int y = viewport.Bottom; y < viewport.Height; y++)  			{  				for (int x = viewport.Left; x < viewport.Right; x++)  				{  					int bufferOffset = destImage.GetBufferOffsetY(y);    					// we don't need to set this if we are anti-aliased  					int totalOffset = bufferOffset + x * 4;  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].x + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].y + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].z + 1) * 128);  					destBuffer[totalOffset] = 255;  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyNoramlBufferToImage,The following statement contains a magic number: for (int y = viewport.Bottom; y < viewport.Height; y++)  			{  				for (int x = viewport.Left; x < viewport.Right; x++)  				{  					int bufferOffset = destImage.GetBufferOffsetY(y);    					// we don't need to set this if we are anti-aliased  					int totalOffset = bufferOffset + x * 4;  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].x + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].y + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].z + 1) * 128);  					destBuffer[totalOffset] = 255;  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyNoramlBufferToImage,The following statement contains a magic number: for (int y = viewport.Bottom; y < viewport.Height; y++)  			{  				for (int x = viewport.Left; x < viewport.Right; x++)  				{  					int bufferOffset = destImage.GetBufferOffsetY(y);    					// we don't need to set this if we are anti-aliased  					int totalOffset = bufferOffset + x * 4;  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].x + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].y + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].z + 1) * 128);  					destBuffer[totalOffset] = 255;  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyNoramlBufferToImage,The following statement contains a magic number: for (int y = viewport.Bottom; y < viewport.Height; y++)  			{  				for (int x = viewport.Left; x < viewport.Right; x++)  				{  					int bufferOffset = destImage.GetBufferOffsetY(y);    					// we don't need to set this if we are anti-aliased  					int totalOffset = bufferOffset + x * 4;  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].x + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].y + 1) * 128);  					destBuffer[totalOffset++] = (byte)((NormalBuffer[x][y].z + 1) * 128);  					destBuffer[totalOffset] = 255;  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The following statement contains a magic number: double shininess = Math.Pow(10' info.closestHitObject.Material.Gloss + 1);
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The following statement contains a magic number: foreach (ILight light in scene.lights)  			{  				// calculate diffuse lighting  				Vector3 directiorFromHitToLight = light.Origin - info.hitPosition;  				double distanceToLight = directiorFromHitToLight.Length;  				Vector3 directiorFromHitToLightNormalized = directiorFromHitToLight.GetNormal();    				if (RenderDiffuse)  				{  					double L = Vector3.Dot(directiorFromHitToLightNormalized' info.normalAtHit);  					if (L > 0.0f)  					{  						color += infoColorAtHit * light.Illumination() * L;  					}  				}    				// this is the max depth of raytracing.  				// increasing depth will calculate more accurate color' however it will  				// also take longer (exponentially)  				if (depth < 3)  				{  					// calculate reflection ray  					if (RenderReflection && info.closestHitObject.Material.Reflection > 0)  					{  						Ray reflectionRay = GetReflectionRay(info.hitPosition' info.normalAtHit' ray.directionNormal);  						IntersectInfo reflectionInfo = TracePrimaryRay(reflectionRay' scene);  						RGBA_Floats reflectionColorAtHit;// = reflectionInfo.closestHitObject.GetColor(reflectionInfo);  						if (reflectionInfo.hitType != IntersectionType.None && reflectionInfo.distanceToHit > 0)  						{  							// recursive call' this makes reflections expensive  							reflectionColorAtHit = CreateAndTraceSecondaryRays(reflectionInfo' reflectionRay' scene' depth + 1);  						}  						else // does not reflect an object' then reflect background color  						{  							reflectionColorAtHit = scene.background.Color;  							reflectionColorAtHit.Alpha0To1 = infoColorAtHit.alpha;  						}    						color = color.Blend(reflectionColorAtHit' info.closestHitObject.Material.Reflection);  					}    					//calculate refraction ray  					if (RenderRefraction && info.closestHitObject.Material.Transparency > 0)  					{  						Ray refractionRay = new Ray(info.hitPosition' ray.directionNormal' Ray.sameSurfaceOffset' double.MaxValue);  // GetRefractionRay(info.hitPosition' info.normalAtHit' ray.direction' info.closestHit.Material.Refraction);  						IntersectInfo refractionInfo = TracePrimaryRay(refractionRay' scene);  						RGBA_Floats refractionColorAtHit = refractionInfo.closestHitObject.GetColor(refractionInfo);  						if (refractionInfo.hitType != IntersectionType.None && refractionInfo.distanceToHit > 0)  						{  							// recursive call' this makes refractions expensive  							refractionColorAtHit = CreateAndTraceSecondaryRays(refractionInfo' refractionRay' scene' depth + 1);  						}  						else  						{  							refractionColorAtHit = scene.background.Color;  							refractionColorAtHit.Alpha0To1 = infoColorAtHit.alpha;  						}    						color = refractionColorAtHit.Blend(color' info.closestHitObject.Material.Transparency);  					}  				}    				IntersectInfo shadow = new IntersectInfo();  				if (RenderShadow)  				{  					// calculate shadow' create ray from intersection point to light  					Ray shadowRay = new Ray(info.hitPosition' directiorFromHitToLightNormalized' Ray.sameSurfaceOffset' double.MaxValue); // it may be usefull to limit the legth to te dist to the camera (but I doubt it LBB).  					shadowRay.isShadowRay = true;    					// if the normal at the closest hit is away from the shadow it is already it it's own shadow.  					if (Vector3.Dot(info.normalAtHit' directiorFromHitToLightNormalized) < 0)  					{  						shadow.hitType = IntersectionType.FrontFace;  						color *= 0.5;// +0.5 * Math.Pow(shadow.closestHit.Material.Transparency' 0.5); // Math.Pow(.5' shadow.HitCount);  						color.Alpha0To1 = infoColorAtHit.alpha;  					}  					else  					{  						// find any element in between intersection point and light  						shadow = TracePrimaryRay(shadowRay' scene);  						if (shadow.hitType != IntersectionType.None && shadow.closestHitObject != info.closestHitObject && shadow.distanceToHit < distanceToLight)  						{  							// only cast shadow if the found interesection is another  							// element than the current element  							color *= 0.5;// +0.5 * Math.Pow(shadow.closestHit.Material.Transparency' 0.5); // Math.Pow(.5' shadow.HitCount);  							color.Alpha0To1 = infoColorAtHit.alpha;  						}  					}  				}    				// only show highlights if it is not in the shadow of another object  				if (RenderHighlights && shadow.hitType == IntersectionType.None && info.closestHitObject.Material.Gloss > 0)  				{  					// only show Gloss light if it is not in a shadow of another element.  					// calculate Gloss lighting (Phong)  					Vector3 Lv = (info.hitPosition - light.Origin).GetNormal();  					Vector3 E = (ray.origin - info.hitPosition).GetNormal();  					Vector3 H = (E - Lv).GetNormal();    					double Glossweight = 0.0;  					Glossweight = Math.Pow(Math.Max(Vector3.Dot(info.normalAtHit' H)' 0)' shininess);  					color += light.Illumination() * (Glossweight);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The following statement contains a magic number: foreach (ILight light in scene.lights)  			{  				// calculate diffuse lighting  				Vector3 directiorFromHitToLight = light.Origin - info.hitPosition;  				double distanceToLight = directiorFromHitToLight.Length;  				Vector3 directiorFromHitToLightNormalized = directiorFromHitToLight.GetNormal();    				if (RenderDiffuse)  				{  					double L = Vector3.Dot(directiorFromHitToLightNormalized' info.normalAtHit);  					if (L > 0.0f)  					{  						color += infoColorAtHit * light.Illumination() * L;  					}  				}    				// this is the max depth of raytracing.  				// increasing depth will calculate more accurate color' however it will  				// also take longer (exponentially)  				if (depth < 3)  				{  					// calculate reflection ray  					if (RenderReflection && info.closestHitObject.Material.Reflection > 0)  					{  						Ray reflectionRay = GetReflectionRay(info.hitPosition' info.normalAtHit' ray.directionNormal);  						IntersectInfo reflectionInfo = TracePrimaryRay(reflectionRay' scene);  						RGBA_Floats reflectionColorAtHit;// = reflectionInfo.closestHitObject.GetColor(reflectionInfo);  						if (reflectionInfo.hitType != IntersectionType.None && reflectionInfo.distanceToHit > 0)  						{  							// recursive call' this makes reflections expensive  							reflectionColorAtHit = CreateAndTraceSecondaryRays(reflectionInfo' reflectionRay' scene' depth + 1);  						}  						else // does not reflect an object' then reflect background color  						{  							reflectionColorAtHit = scene.background.Color;  							reflectionColorAtHit.Alpha0To1 = infoColorAtHit.alpha;  						}    						color = color.Blend(reflectionColorAtHit' info.closestHitObject.Material.Reflection);  					}    					//calculate refraction ray  					if (RenderRefraction && info.closestHitObject.Material.Transparency > 0)  					{  						Ray refractionRay = new Ray(info.hitPosition' ray.directionNormal' Ray.sameSurfaceOffset' double.MaxValue);  // GetRefractionRay(info.hitPosition' info.normalAtHit' ray.direction' info.closestHit.Material.Refraction);  						IntersectInfo refractionInfo = TracePrimaryRay(refractionRay' scene);  						RGBA_Floats refractionColorAtHit = refractionInfo.closestHitObject.GetColor(refractionInfo);  						if (refractionInfo.hitType != IntersectionType.None && refractionInfo.distanceToHit > 0)  						{  							// recursive call' this makes refractions expensive  							refractionColorAtHit = CreateAndTraceSecondaryRays(refractionInfo' refractionRay' scene' depth + 1);  						}  						else  						{  							refractionColorAtHit = scene.background.Color;  							refractionColorAtHit.Alpha0To1 = infoColorAtHit.alpha;  						}    						color = refractionColorAtHit.Blend(color' info.closestHitObject.Material.Transparency);  					}  				}    				IntersectInfo shadow = new IntersectInfo();  				if (RenderShadow)  				{  					// calculate shadow' create ray from intersection point to light  					Ray shadowRay = new Ray(info.hitPosition' directiorFromHitToLightNormalized' Ray.sameSurfaceOffset' double.MaxValue); // it may be usefull to limit the legth to te dist to the camera (but I doubt it LBB).  					shadowRay.isShadowRay = true;    					// if the normal at the closest hit is away from the shadow it is already it it's own shadow.  					if (Vector3.Dot(info.normalAtHit' directiorFromHitToLightNormalized) < 0)  					{  						shadow.hitType = IntersectionType.FrontFace;  						color *= 0.5;// +0.5 * Math.Pow(shadow.closestHit.Material.Transparency' 0.5); // Math.Pow(.5' shadow.HitCount);  						color.Alpha0To1 = infoColorAtHit.alpha;  					}  					else  					{  						// find any element in between intersection point and light  						shadow = TracePrimaryRay(shadowRay' scene);  						if (shadow.hitType != IntersectionType.None && shadow.closestHitObject != info.closestHitObject && shadow.distanceToHit < distanceToLight)  						{  							// only cast shadow if the found interesection is another  							// element than the current element  							color *= 0.5;// +0.5 * Math.Pow(shadow.closestHit.Material.Transparency' 0.5); // Math.Pow(.5' shadow.HitCount);  							color.Alpha0To1 = infoColorAtHit.alpha;  						}  					}  				}    				// only show highlights if it is not in the shadow of another object  				if (RenderHighlights && shadow.hitType == IntersectionType.None && info.closestHitObject.Material.Gloss > 0)  				{  					// only show Gloss light if it is not in a shadow of another element.  					// calculate Gloss lighting (Phong)  					Vector3 Lv = (info.hitPosition - light.Origin).GetNormal();  					Vector3 E = (ray.origin - info.hitPosition).GetNormal();  					Vector3 H = (E - Lv).GetNormal();    					double Glossweight = 0.0;  					Glossweight = Math.Pow(Math.Max(Vector3.Dot(info.normalAtHit' H)' 0)' shininess);  					color += light.Illumination() * (Glossweight);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CreateAndTraceSecondaryRays,The following statement contains a magic number: foreach (ILight light in scene.lights)  			{  				// calculate diffuse lighting  				Vector3 directiorFromHitToLight = light.Origin - info.hitPosition;  				double distanceToLight = directiorFromHitToLight.Length;  				Vector3 directiorFromHitToLightNormalized = directiorFromHitToLight.GetNormal();    				if (RenderDiffuse)  				{  					double L = Vector3.Dot(directiorFromHitToLightNormalized' info.normalAtHit);  					if (L > 0.0f)  					{  						color += infoColorAtHit * light.Illumination() * L;  					}  				}    				// this is the max depth of raytracing.  				// increasing depth will calculate more accurate color' however it will  				// also take longer (exponentially)  				if (depth < 3)  				{  					// calculate reflection ray  					if (RenderReflection && info.closestHitObject.Material.Reflection > 0)  					{  						Ray reflectionRay = GetReflectionRay(info.hitPosition' info.normalAtHit' ray.directionNormal);  						IntersectInfo reflectionInfo = TracePrimaryRay(reflectionRay' scene);  						RGBA_Floats reflectionColorAtHit;// = reflectionInfo.closestHitObject.GetColor(reflectionInfo);  						if (reflectionInfo.hitType != IntersectionType.None && reflectionInfo.distanceToHit > 0)  						{  							// recursive call' this makes reflections expensive  							reflectionColorAtHit = CreateAndTraceSecondaryRays(reflectionInfo' reflectionRay' scene' depth + 1);  						}  						else // does not reflect an object' then reflect background color  						{  							reflectionColorAtHit = scene.background.Color;  							reflectionColorAtHit.Alpha0To1 = infoColorAtHit.alpha;  						}    						color = color.Blend(reflectionColorAtHit' info.closestHitObject.Material.Reflection);  					}    					//calculate refraction ray  					if (RenderRefraction && info.closestHitObject.Material.Transparency > 0)  					{  						Ray refractionRay = new Ray(info.hitPosition' ray.directionNormal' Ray.sameSurfaceOffset' double.MaxValue);  // GetRefractionRay(info.hitPosition' info.normalAtHit' ray.direction' info.closestHit.Material.Refraction);  						IntersectInfo refractionInfo = TracePrimaryRay(refractionRay' scene);  						RGBA_Floats refractionColorAtHit = refractionInfo.closestHitObject.GetColor(refractionInfo);  						if (refractionInfo.hitType != IntersectionType.None && refractionInfo.distanceToHit > 0)  						{  							// recursive call' this makes refractions expensive  							refractionColorAtHit = CreateAndTraceSecondaryRays(refractionInfo' refractionRay' scene' depth + 1);  						}  						else  						{  							refractionColorAtHit = scene.background.Color;  							refractionColorAtHit.Alpha0To1 = infoColorAtHit.alpha;  						}    						color = refractionColorAtHit.Blend(color' info.closestHitObject.Material.Transparency);  					}  				}    				IntersectInfo shadow = new IntersectInfo();  				if (RenderShadow)  				{  					// calculate shadow' create ray from intersection point to light  					Ray shadowRay = new Ray(info.hitPosition' directiorFromHitToLightNormalized' Ray.sameSurfaceOffset' double.MaxValue); // it may be usefull to limit the legth to te dist to the camera (but I doubt it LBB).  					shadowRay.isShadowRay = true;    					// if the normal at the closest hit is away from the shadow it is already it it's own shadow.  					if (Vector3.Dot(info.normalAtHit' directiorFromHitToLightNormalized) < 0)  					{  						shadow.hitType = IntersectionType.FrontFace;  						color *= 0.5;// +0.5 * Math.Pow(shadow.closestHit.Material.Transparency' 0.5); // Math.Pow(.5' shadow.HitCount);  						color.Alpha0To1 = infoColorAtHit.alpha;  					}  					else  					{  						// find any element in between intersection point and light  						shadow = TracePrimaryRay(shadowRay' scene);  						if (shadow.hitType != IntersectionType.None && shadow.closestHitObject != info.closestHitObject && shadow.distanceToHit < distanceToLight)  						{  							// only cast shadow if the found interesection is another  							// element than the current element  							color *= 0.5;// +0.5 * Math.Pow(shadow.closestHit.Material.Transparency' 0.5); // Math.Pow(.5' shadow.HitCount);  							color.Alpha0To1 = infoColorAtHit.alpha;  						}  					}  				}    				// only show highlights if it is not in the shadow of another object  				if (RenderHighlights && shadow.hitType == IntersectionType.None && info.closestHitObject.Material.Gloss > 0)  				{  					// only show Gloss light if it is not in a shadow of another element.  					// calculate Gloss lighting (Phong)  					Vector3 Lv = (info.hitPosition - light.Origin).GetNormal();  					Vector3 E = (ray.origin - info.hitPosition).GetNormal();  					Vector3 H = (E - Lv).GetNormal();    					double Glossweight = 0.0;  					Glossweight = Math.Pow(Math.Max(Vector3.Dot(info.normalAtHit' H)' 0)' shininess);  					color += light.Illumination() * (Glossweight);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,RayTraceScene,The following statement contains a magic number: if (TraceWithRayBundles)  			{  				int yStep = 8;  				int xStep = 8;  				for (int y = viewport.Bottom; y < viewport.Height; y += yStep)  				{  					for (int x = viewport.Left; x < viewport.Right; x += xStep)  					{  						try {  							int bundleWidth = Math.Min(xStep' viewport.Right - x);  							int bundleHeight = Math.Min(yStep' viewport.Top - y);  							FrustumRayBundle rayBundle = new FrustumRayBundle(bundleWidth * bundleHeight);  							IntersectInfo[] intersectionsForBundle = new IntersectInfo[bundleWidth * bundleHeight];    							// Calculate all the initial rays  							for (int rayY = 0; rayY < bundleHeight; rayY++)  							{  								for (int rayX = 0; rayX < bundleWidth; rayX++)  								{  									rayBundle.rayArray[rayX + rayY * bundleWidth] = scene.camera.GetRay(x + rayX' y + rayY);  									intersectionsForBundle[rayX + rayY * bundleWidth] = new IntersectInfo();  								}  							}    							// get a ray to find the origin (every ray comes from the camera and should have the same origin)  							rayBundle.CalculateFrustum(bundleWidth' bundleHeight' rayBundle.rayArray[0].origin);    							FullyTraceRayBundle(rayBundle' intersectionsForBundle' scene);    							// get the color data out of the traced rays  							for (int rayY = 0; rayY < bundleHeight; rayY++)  							{  								for (int rayX = 0; rayX < bundleWidth; rayX++)  								{  									ColorBuffer[x + rayX][y + rayY] = intersectionsForBundle[rayX + rayY * bundleWidth].totalColor;  								}  							}  						}  						catch  						{  						}  					}  				}  			}  			else  			{  				if (MultiThreaded)  				{  					System.Threading.Tasks.Parallel.For(viewport.Bottom' viewport.Height' y =>  					{  						TraceXSpan(viewport' scene' y);  					});  				}  				else  				{  					for (int y = viewport.Bottom; y < viewport.Height; y++)  					{  						TraceXSpan(viewport' scene' y);  					}  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,RayTraceScene,The following statement contains a magic number: if (TraceWithRayBundles)  			{  				int yStep = 8;  				int xStep = 8;  				for (int y = viewport.Bottom; y < viewport.Height; y += yStep)  				{  					for (int x = viewport.Left; x < viewport.Right; x += xStep)  					{  						try {  							int bundleWidth = Math.Min(xStep' viewport.Right - x);  							int bundleHeight = Math.Min(yStep' viewport.Top - y);  							FrustumRayBundle rayBundle = new FrustumRayBundle(bundleWidth * bundleHeight);  							IntersectInfo[] intersectionsForBundle = new IntersectInfo[bundleWidth * bundleHeight];    							// Calculate all the initial rays  							for (int rayY = 0; rayY < bundleHeight; rayY++)  							{  								for (int rayX = 0; rayX < bundleWidth; rayX++)  								{  									rayBundle.rayArray[rayX + rayY * bundleWidth] = scene.camera.GetRay(x + rayX' y + rayY);  									intersectionsForBundle[rayX + rayY * bundleWidth] = new IntersectInfo();  								}  							}    							// get a ray to find the origin (every ray comes from the camera and should have the same origin)  							rayBundle.CalculateFrustum(bundleWidth' bundleHeight' rayBundle.rayArray[0].origin);    							FullyTraceRayBundle(rayBundle' intersectionsForBundle' scene);    							// get the color data out of the traced rays  							for (int rayY = 0; rayY < bundleHeight; rayY++)  							{  								for (int rayX = 0; rayX < bundleWidth; rayX++)  								{  									ColorBuffer[x + rayX][y + rayY] = intersectionsForBundle[rayX + rayY * bundleWidth].totalColor;  								}  							}  						}  						catch  						{  						}  					}  				}  			}  			else  			{  				if (MultiThreaded)  				{  					System.Threading.Tasks.Parallel.For(viewport.Bottom' viewport.Height' y =>  					{  						TraceXSpan(viewport' scene' y);  					});  				}  				else  				{  					for (int y = viewport.Bottom; y < viewport.Height; y++)  					{  						TraceXSpan(viewport' scene' y);  					}  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,AntiAliasXSpan,The following statement contains a magic number: for (int x = 1; x < viewport.Width - 1; x++)  			{  				RGBA_Floats avg = (imageBufferAsDoubles[x - 1][y - 1] + imageBufferAsDoubles[x][y - 1] + imageBufferAsDoubles[x + 1][y - 1] +  							 imageBufferAsDoubles[x - 1][y] + imageBufferAsDoubles[x][y] + imageBufferAsDoubles[x + 1][y] +  							 imageBufferAsDoubles[x - 1][y + 1] + imageBufferAsDoubles[x][y + 1] + imageBufferAsDoubles[x + 1][y + 1]) / 9;    				// use a more accurate antialasing method (MonteCarlo implementation)  				// this will fire multiple rays per pixel  				double sumOfDifferencesThreshold = .05; // TODO: figure out a good way to determine this.  				if (avg.SumOfDistances(imageBufferAsDoubles[x][y]) > sumOfDifferencesThreshold)  				{  					RGBA_Floats accumulatedColor = imageBufferAsDoubles[x][y];  					for (int i = 0; i < maxSamples; i++)  					{  						// get some 'random' samples  						double rx = Math.Sign(i % 4 - 1.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + i) + 1) / 4;  						double ry = Math.Sign(i % 2 - 0.5) * (IntNoise(x + y * viewport.Width * maxSamples * 2 + 1 + i) + 1) / 4;    						double xp = x + rx;  						double yp = y + ry;    						Ray ray = scene.camera.GetRay(xp' yp);  						IntersectInfo primaryInfo;    						accumulatedColor += FullyTraceRay(ray' scene' out primaryInfo);  					}  					imageBufferAsDoubles[x][y] = accumulatedColor / (maxSamples + 1);  				}  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyColorXSpan,The following statement contains a magic number: for (int x = viewport.Left; x < viewport.Right; x++)  			{  				int bufferOffset = destImage.GetBufferOffsetY(y);    				// we don't need to set this if we are anti-aliased  				int totalOffset = bufferOffset + x * 4;  				destBuffer[totalOffset++] = (byte)ColorBuffer[x][y].Blue0To255;  				destBuffer[totalOffset++] = (byte)ColorBuffer[x][y].Green0To255;  				destBuffer[totalOffset++] = (byte)ColorBuffer[x][y].Red0To255;  				destBuffer[totalOffset] = (byte)ColorBuffer[x][y].Alpha0To255;  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthXSpan,The following statement contains a magic number: for (int x = viewport.Left; x < viewport.Right; x++)  			{  				int bufferOffset = destImage.GetBufferOffsetY(y);    				// we don't need to set this if we are anti-aliased  				int totalOffset = bufferOffset + x * 4;  				double depthXY = DepthBuffer[x][y];  				double rangedDepth = (depthXY - minZ) / divisor;  				double clampedDepth = Math.Max(0' Math.Min(255' rangedDepth * 255));  				byte depthColor = (byte)(clampedDepth);  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset] = 255;  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthXSpan,The following statement contains a magic number: for (int x = viewport.Left; x < viewport.Right; x++)  			{  				int bufferOffset = destImage.GetBufferOffsetY(y);    				// we don't need to set this if we are anti-aliased  				int totalOffset = bufferOffset + x * 4;  				double depthXY = DepthBuffer[x][y];  				double rangedDepth = (depthXY - minZ) / divisor;  				double clampedDepth = Math.Max(0' Math.Min(255' rangedDepth * 255));  				byte depthColor = (byte)(clampedDepth);  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset] = 255;  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthXSpan,The following statement contains a magic number: for (int x = viewport.Left; x < viewport.Right; x++)  			{  				int bufferOffset = destImage.GetBufferOffsetY(y);    				// we don't need to set this if we are anti-aliased  				int totalOffset = bufferOffset + x * 4;  				double depthXY = DepthBuffer[x][y];  				double rangedDepth = (depthXY - minZ) / divisor;  				double clampedDepth = Math.Max(0' Math.Min(255' rangedDepth * 255));  				byte depthColor = (byte)(clampedDepth);  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset] = 255;  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,CopyDepthXSpan,The following statement contains a magic number: for (int x = viewport.Left; x < viewport.Right; x++)  			{  				int bufferOffset = destImage.GetBufferOffsetY(y);    				// we don't need to set this if we are anti-aliased  				int totalOffset = bufferOffset + x * 4;  				double depthXY = DepthBuffer[x][y];  				double rangedDepth = (depthXY - minZ) / divisor;  				double clampedDepth = Math.Max(0' Math.Min(255' rangedDepth * 255));  				byte depthColor = (byte)(clampedDepth);  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset++] = depthColor;  				destBuffer[totalOffset] = 255;  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,GetReflectionRay,The following statement contains a magic number: Vector3 Rl = V + (N * 2 * c1);
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,GetRefractionRay,The following statement contains a magic number: switch (method)  			{  				case 0:  					return new Ray(P' V' Ray.sameSurfaceOffset' double.MaxValue);    				case 1:  					V = V * -1;  					double n = -0.55; // refraction constant for now  					if (n < 0 || n > 1)  					{  						return new Ray(P' V); // no refraction  					}  					break;    				case 2:  					double c1 = Vector3.Dot(N' V);  					double c2 = 1 - refraction * refraction * (1 - c1 * c1);  					if (c2 < 0)    						c2 = Math.Sqrt(c2);  					Vector3 T = (N * (refraction * c1 - c2) - V * refraction) * -1;  					T.Normalize();    					return new Ray(P' T); // no refraction  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,GetRefractionRay,The following statement contains a magic number: switch (method)  			{  				case 0:  					return new Ray(P' V' Ray.sameSurfaceOffset' double.MaxValue);    				case 1:  					V = V * -1;  					double n = -0.55; // refraction constant for now  					if (n < 0 || n > 1)  					{  						return new Ray(P' V); // no refraction  					}  					break;    				case 2:  					double c1 = Vector3.Dot(N' V);  					double c2 = 1 - refraction * refraction * (1 - c1 * c1);  					if (c2 < 0)    						c2 = Math.Sqrt(c2);  					Vector3 T = (N * (refraction * c1 - c2) - V * refraction) * -1;  					T.Normalize();    					return new Ray(P' T); // no refraction  			}
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,IntNoise,The following statement contains a magic number: x = (x << 13) ^ x;
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,IntNoise,The following statement contains a magic number: return (1.0 - ((x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff) / (int.MaxValue / 2.0));
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,IntNoise,The following statement contains a magic number: return (1.0 - ((x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff) / (int.MaxValue / 2.0));
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,IntNoise,The following statement contains a magic number: return (1.0 - ((x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff) / (int.MaxValue / 2.0));
Magic Number,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,IntNoise,The following statement contains a magic number: return (1.0 - ((x * (x * x * 15731 + 789221) + 1376312589) & 0x7fffffff) / (int.MaxValue / 2.0));
Magic Number,MatterHackers.RayTracer,Scene,C:\repos\MatterHackers_agg-sharp\RayTracer\Scene.cs,Scene,The following statement contains a magic number: if (camera == null)  			{  				camera = new SimpleCamera(512' 512' MathHelper.DegreesToRadians(40));  				((SimpleCamera)camera).Origin = new Vector3(0' 0' -5);  			}
Magic Number,MatterHackers.RayTracer,Scene,C:\repos\MatterHackers_agg-sharp\RayTracer\Scene.cs,Scene,The following statement contains a magic number: if (camera == null)  			{  				camera = new SimpleCamera(512' 512' MathHelper.DegreesToRadians(40));  				((SimpleCamera)camera).Origin = new Vector3(0' 0' -5);  			}
Magic Number,MatterHackers.RayTracer,Scene,C:\repos\MatterHackers_agg-sharp\RayTracer\Scene.cs,Scene,The following statement contains a magic number: if (camera == null)  			{  				camera = new SimpleCamera(512' 512' MathHelper.DegreesToRadians(40));  				((SimpleCamera)camera).Origin = new Vector3(0' 0' -5);  			}
Magic Number,MatterHackers.RayTracer,Scene,C:\repos\MatterHackers_agg-sharp\RayTracer\Scene.cs,Scene,The following statement contains a magic number: if (camera == null)  			{  				camera = new SimpleCamera(512' 512' MathHelper.DegreesToRadians(40));  				((SimpleCamera)camera).Origin = new Vector3(0' 0' -5);  			}
Magic Number,MatterHackers.RayTracer,Scene,C:\repos\MatterHackers_agg-sharp\RayTracer\Scene.cs,Scene,The following statement contains a magic number: background = new Background(new RGBA_Floats(0' 0' 0' 0)' 0.2);
Magic Number,MatterHackers.RayTracer,CompareCentersOnAxis,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\IPrimitive.cs,CompareCentersOnAxis,The following statement contains a magic number: this.whichAxis = whichAxis % 3;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,GetSurfaceArea,The following statement contains a magic number: double frontAndBack = (maxXYZ.x - minXYZ.x) * (maxXYZ.z - minXYZ.z) * 2;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,GetSurfaceArea,The following statement contains a magic number: double leftAndRight = (maxXYZ.y - minXYZ.y) * (maxXYZ.z - minXYZ.z) * 2;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,GetSurfaceArea,The following statement contains a magic number: double topAndBottom = (maxXYZ.x - minXYZ.x) * (maxXYZ.y - minXYZ.y) * 2;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,GetIntersectCost,The following statement contains a magic number: return 452;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,intersect,The following statement contains a magic number: double minDistToZ = (this[(int)ray.sign[2]].z - ray.origin.z) * ray.oneOverDirection.z;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,intersect,The following statement contains a magic number: double maxDistToZ = (this[1 - (int)ray.sign[2]].z - ray.origin.z) * ray.oneOverDirection.z;
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,intersect,The following statement contains a magic number: if (minDistToZ > minDistFound)  			{  				minAxis = 2;  				minDistFound = minDistToZ;  			}
Magic Number,MatterHackers.RayTracer,BoxShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\BoxShape.cs,intersect,The following statement contains a magic number: if (maxDistToZ < maxDistFound)  			{  				maxAxis = 2;  				maxDistFound = maxDistToZ;  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,CylinderShape,The following statement contains a magic number: topPlane = new Plane(Vector3.UnitZ' height / 2);
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,CylinderShape,The following statement contains a magic number: bottomPlane = new Plane(-Vector3.UnitZ' height / 2);
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetSurfaceArea,The following statement contains a magic number: double areaOfCurvedSurface = (bottomPerimeter + topPerimeter) / 2 * height;
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetSurfaceArea,The following statement contains a magic number: double areaOfBottom = MathHelper.Tau / 2 * radius * radius;
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetSurfaceArea,The following statement contains a magic number: double areaOfTop = MathHelper.Tau / 2 * topRadius * topRadius;
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetAxisAlignedBoundingBox,The following statement contains a magic number: return new AxisAlignedBoundingBox(new Vector3(-maxRadius' -maxRadius' -height / 2)'  				new Vector3(maxRadius' maxRadius' height / 2));
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetAxisAlignedBoundingBox,The following statement contains a magic number: return new AxisAlignedBoundingBox(new Vector3(-maxRadius' -maxRadius' -height / 2)'  				new Vector3(maxRadius' maxRadius' height / 2));
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetIntersectCost,The following statement contains a magic number: return 1288;
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				{  					bool inFrontOfTop;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTop);  					bool wantFrontAndInFront = (ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTop;  					bool wantBackAndInBack = (ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTop;  					if (wantFrontAndInFront || wantBackAndInBack)  					{  						Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								topHitInfo.hitType = IntersectionType.FrontFace;  								topHitInfo.normalAtHit = topPlane.PlaneNormal;  							}  							else  							{  								topHitInfo.hitType = IntersectionType.BackFace;  								topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							}  							topHitInfo.distanceToHit = testDistanceToHit;    							return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottom;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottom);  					if (ray.intersectionType == IntersectionType.FrontFace && inFrontOfBottom  						|| ray.intersectionType == IntersectionType.BackFace && !inFrontOfBottom)  					{  						Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								bottomHitInfo.hitType = IntersectionType.FrontFace;  								bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							}  							else  							{  								bottomHitInfo.hitType = IntersectionType.BackFace;  								bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							}  							bottomHitInfo.distanceToHit = testDistanceToHit;    							return bottomHitInfo;  						}  					}  				}    				IntersectInfo info = new IntersectInfo();  				info.closestHitObject = this;  				info.hitType = IntersectionType.FrontFace;  				if (ray.isShadowRay)  				{  					return info;  				}  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;    				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);    				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if (ray.intersectionType == IntersectionType.FrontFace)  				{  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToFrontHit > ray.maxDistanceToConsider || distanceToFrontHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < -height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  				}  				else if (ray.intersectionType == IntersectionType.BackFace)// check back faces  				{  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToBackHit > ray.maxDistanceToConsider || distanceToBackHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.hitType = IntersectionType.BackFace;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  				}    				return info;  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				{  					bool inFrontOfTop;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTop);  					bool wantFrontAndInFront = (ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTop;  					bool wantBackAndInBack = (ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTop;  					if (wantFrontAndInFront || wantBackAndInBack)  					{  						Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								topHitInfo.hitType = IntersectionType.FrontFace;  								topHitInfo.normalAtHit = topPlane.PlaneNormal;  							}  							else  							{  								topHitInfo.hitType = IntersectionType.BackFace;  								topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							}  							topHitInfo.distanceToHit = testDistanceToHit;    							return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottom;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottom);  					if (ray.intersectionType == IntersectionType.FrontFace && inFrontOfBottom  						|| ray.intersectionType == IntersectionType.BackFace && !inFrontOfBottom)  					{  						Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								bottomHitInfo.hitType = IntersectionType.FrontFace;  								bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							}  							else  							{  								bottomHitInfo.hitType = IntersectionType.BackFace;  								bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							}  							bottomHitInfo.distanceToHit = testDistanceToHit;    							return bottomHitInfo;  						}  					}  				}    				IntersectInfo info = new IntersectInfo();  				info.closestHitObject = this;  				info.hitType = IntersectionType.FrontFace;  				if (ray.isShadowRay)  				{  					return info;  				}  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;    				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);    				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if (ray.intersectionType == IntersectionType.FrontFace)  				{  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToFrontHit > ray.maxDistanceToConsider || distanceToFrontHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < -height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  				}  				else if (ray.intersectionType == IntersectionType.BackFace)// check back faces  				{  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToBackHit > ray.maxDistanceToConsider || distanceToBackHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.hitType = IntersectionType.BackFace;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  				}    				return info;  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				{  					bool inFrontOfTop;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTop);  					bool wantFrontAndInFront = (ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTop;  					bool wantBackAndInBack = (ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTop;  					if (wantFrontAndInFront || wantBackAndInBack)  					{  						Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								topHitInfo.hitType = IntersectionType.FrontFace;  								topHitInfo.normalAtHit = topPlane.PlaneNormal;  							}  							else  							{  								topHitInfo.hitType = IntersectionType.BackFace;  								topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							}  							topHitInfo.distanceToHit = testDistanceToHit;    							return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottom;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottom);  					if (ray.intersectionType == IntersectionType.FrontFace && inFrontOfBottom  						|| ray.intersectionType == IntersectionType.BackFace && !inFrontOfBottom)  					{  						Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								bottomHitInfo.hitType = IntersectionType.FrontFace;  								bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							}  							else  							{  								bottomHitInfo.hitType = IntersectionType.BackFace;  								bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							}  							bottomHitInfo.distanceToHit = testDistanceToHit;    							return bottomHitInfo;  						}  					}  				}    				IntersectInfo info = new IntersectInfo();  				info.closestHitObject = this;  				info.hitType = IntersectionType.FrontFace;  				if (ray.isShadowRay)  				{  					return info;  				}  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;    				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);    				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if (ray.intersectionType == IntersectionType.FrontFace)  				{  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToFrontHit > ray.maxDistanceToConsider || distanceToFrontHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < -height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  				}  				else if (ray.intersectionType == IntersectionType.BackFace)// check back faces  				{  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToBackHit > ray.maxDistanceToConsider || distanceToBackHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.hitType = IntersectionType.BackFace;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  				}    				return info;  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,GetClosestIntersection,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				{  					bool inFrontOfTop;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTop);  					bool wantFrontAndInFront = (ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTop;  					bool wantBackAndInBack = (ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTop;  					if (wantFrontAndInFront || wantBackAndInBack)  					{  						Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								topHitInfo.hitType = IntersectionType.FrontFace;  								topHitInfo.normalAtHit = topPlane.PlaneNormal;  							}  							else  							{  								topHitInfo.hitType = IntersectionType.BackFace;  								topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							}  							topHitInfo.distanceToHit = testDistanceToHit;    							return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottom;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottom);  					if (ray.intersectionType == IntersectionType.FrontFace && inFrontOfBottom  						|| ray.intersectionType == IntersectionType.BackFace && !inFrontOfBottom)  					{  						Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    						if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							if (ray.intersectionType == IntersectionType.FrontFace)  							{  								bottomHitInfo.hitType = IntersectionType.FrontFace;  								bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							}  							else  							{  								bottomHitInfo.hitType = IntersectionType.BackFace;  								bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							}  							bottomHitInfo.distanceToHit = testDistanceToHit;    							return bottomHitInfo;  						}  					}  				}    				IntersectInfo info = new IntersectInfo();  				info.closestHitObject = this;  				info.hitType = IntersectionType.FrontFace;  				if (ray.isShadowRay)  				{  					return info;  				}  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;    				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);    				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if (ray.intersectionType == IntersectionType.FrontFace)  				{  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToFrontHit > ray.maxDistanceToConsider || distanceToFrontHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < -height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  				}  				else if (ray.intersectionType == IntersectionType.BackFace)// check back faces  				{  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					if (distanceToBackHit > ray.maxDistanceToConsider || distanceToBackHit < ray.minDistanceToConsider)  					{  						return null;  					}  					info.hitType = IntersectionType.BackFace;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z < height / 2 || info.hitPosition.z > height / 2)  					{  						return null;  					}  					info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  				}    				return info;  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;  				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);  				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.FrontFace;  					info.closestHitObject = this;  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  						yield return info;  					}  				}    				if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.BackFace;  					info.closestHitObject = this;  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  						yield return info;  					}  				}    				{  					bool inFrontOfTopFace;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTopFace);  					Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.FrontFace;  							topHitInfo.normalAtHit = topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.BackFace;  							topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottomFace;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottomFace);  					Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.FrontFace;  							bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.BackFace;  							bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;  				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);  				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.FrontFace;  					info.closestHitObject = this;  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  						yield return info;  					}  				}    				if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.BackFace;  					info.closestHitObject = this;  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  						yield return info;  					}  				}    				{  					bool inFrontOfTopFace;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTopFace);  					Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.FrontFace;  							topHitInfo.normalAtHit = topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.BackFace;  							topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottomFace;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottomFace);  					Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.FrontFace;  							bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.BackFace;  							bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;  				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);  				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.FrontFace;  					info.closestHitObject = this;  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  						yield return info;  					}  				}    				if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.BackFace;  					info.closestHitObject = this;  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  						yield return info;  					}  				}    				{  					bool inFrontOfTopFace;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTopFace);  					Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.FrontFace;  							topHitInfo.normalAtHit = topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.BackFace;  							topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottomFace;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottomFace);  					Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.FrontFace;  							bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.BackFace;  							bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,CylinderShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\Cylinder.cs,IntersectionIterator,The following statement contains a magic number: if (amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared > 0)  			{  				double distanceFromRayOriginToCircleCenter = -distanceFromCircleCenterToRayOrigin;  				double amountCircleCenterToRayIsGreaterThanRayOriginToEdge = Math.Sqrt(amountCircleCenterToRayIsGreaterThanRayOriginToEdgeSquared);  				double scaleRatio = ray.directionNormal.Length / rayDirectionXY.Length;    				if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.FrontFace;  					info.closestHitObject = this;  					double distanceToFrontHit = (distanceFromRayOriginToCircleCenter - amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToFrontHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal();  						yield return info;  					}  				}    				if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace)  				{  					IntersectInfo info = new IntersectInfo();  					info.hitType = IntersectionType.BackFace;  					info.closestHitObject = this;  					double distanceToBackHit = (distanceFromRayOriginToCircleCenter + amountCircleCenterToRayIsGreaterThanRayOriginToEdge) * scaleRatio;  					info.distanceToHit = distanceToBackHit;  					info.hitPosition = ray.origin + ray.directionNormal * info.distanceToHit;  					if (info.hitPosition.z > -height / 2 && info.hitPosition.z < height / 2)  					{  						info.normalAtHit = -(new Vector3(info.hitPosition.x' info.hitPosition.y' 0).GetNormal());  						yield return info;  					}  				}    				{  					bool inFrontOfTopFace;  					double testDistanceToHit = topPlane.GetDistanceToIntersection(ray' out inFrontOfTopFace);  					Vector3 topHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (topHitPosition.x * topHitPosition.x + topHitPosition.y * topHitPosition.y < topRadius * topRadius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.FrontFace;  							topHitInfo.normalAtHit = topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfTopFace)  						{  							IntersectInfo topHitInfo = new IntersectInfo();  							topHitInfo.hitPosition = topHitPosition;  							topHitInfo.closestHitObject = this;  							topHitInfo.hitType = IntersectionType.BackFace;  							topHitInfo.normalAtHit = -topPlane.PlaneNormal;  							topHitInfo.distanceToHit = testDistanceToHit;    							yield return topHitInfo;  						}  					}  				}    				{  					bool inFrontOfBottomFace;  					double testDistanceToHit = bottomPlane.GetDistanceToIntersection(ray' out inFrontOfBottomFace);  					Vector3 bottomHitPosition = ray.origin + ray.directionNormal * testDistanceToHit;    					if (bottomHitPosition.x * bottomHitPosition.x + bottomHitPosition.y * bottomHitPosition.y < radius * radius)  					{  						if ((ray.intersectionType & IntersectionType.FrontFace) == IntersectionType.FrontFace && inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.FrontFace;  							bottomHitInfo.normalAtHit = bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}    						if ((ray.intersectionType & IntersectionType.BackFace) == IntersectionType.BackFace && !inFrontOfBottomFace)  						{  							IntersectInfo bottomHitInfo = new IntersectInfo();  							bottomHitInfo.hitPosition = bottomHitPosition;  							bottomHitInfo.closestHitObject = this;  							bottomHitInfo.hitType = IntersectionType.BackFace;  							bottomHitInfo.normalAtHit = -bottomPlane.PlaneNormal;  							bottomHitInfo.distanceToHit = testDistanceToHit;    							yield return bottomHitInfo;  						}  					}  				}  			}
Magic Number,MatterHackers.RayTracer,PlaneShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\PlaneShape.cs,GetIntersectCost,The following statement contains a magic number: return 350;
Magic Number,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetSurfaceArea,The following statement contains a magic number: return 2 * MathHelper.Tau * radius * radius;
Magic Number,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetIntersectCost,The following statement contains a magic number: return 670;
Magic Number,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetColor,The following statement contains a magic number: if (Material.HasTexture)  			{  				Vector3 vn = new Vector3(0' 1' 0).GetNormal(); // north pole / up  				Vector3 ve = new Vector3(0' 0' 1).GetNormal(); // equator / sphere orientation  				Vector3 vp = (info.hitPosition - position).GetNormal(); //points from center of sphere to intersection    				double phi = Math.Acos(-Vector3.Dot(vp' vn));  				double v = (phi * 2 / Math.PI) - 1;    				double sinphi = Vector3.Dot(ve' vp) / Math.Sin(phi);  				sinphi = sinphi < -1 ? -1 : sinphi > 1 ? 1 : sinphi;  				double theta = Math.Acos(sinphi) * 2 / Math.PI;    				double u;    				if (Vector3.Dot(Vector3.Cross(vn' ve)' vp) > 0)  				{  					u = theta;  				}  				else  				{  					u = 1 - theta;  				}    				// alternative but worse implementation  				//double u = Math.Atan2(vp.x' vp.z);  				//double v = Math.Acos(vp.y);  				return this.Material.GetColor(u' v);  			}  			else  			{  				// skip uv calculation' just get the color  				return this.Material.GetColor(0' 0);  			}
Magic Number,MatterHackers.RayTracer,SphereShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\SphereShape.cs,GetColor,The following statement contains a magic number: if (Material.HasTexture)  			{  				Vector3 vn = new Vector3(0' 1' 0).GetNormal(); // north pole / up  				Vector3 ve = new Vector3(0' 0' 1).GetNormal(); // equator / sphere orientation  				Vector3 vp = (info.hitPosition - position).GetNormal(); //points from center of sphere to intersection    				double phi = Math.Acos(-Vector3.Dot(vp' vn));  				double v = (phi * 2 / Math.PI) - 1;    				double sinphi = Vector3.Dot(ve' vp) / Math.Sin(phi);  				sinphi = sinphi < -1 ? -1 : sinphi > 1 ? 1 : sinphi;  				double theta = Math.Acos(sinphi) * 2 / Math.PI;    				double u;    				if (Vector3.Dot(Vector3.Cross(vn' ve)' vp) > 0)  				{  					u = theta;  				}  				else  				{  					u = 1 - theta;  				}    				// alternative but worse implementation  				//double u = Math.Atan2(vp.x' vp.z);  				//double v = Math.Acos(vp.y);  				return this.Material.GetColor(u' v);  			}  			else  			{  				// skip uv calculation' just get the color  				return this.Material.GetColor(0' 0);  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,TriangleShape,The following statement contains a magic number: vertices[2] = new Vector3Float(vertex2);
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,TriangleShape,The following statement contains a magic number: center = new Vector3Float((vertex0 + vertex1 + vertex2) / 3);
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,TriangleShape,The following statement contains a magic number: if (Math.Abs(planeNormal.x) > Math.Abs(planeNormal.y))  			{  				if (Math.Abs(planeNormal.x) > Math.Abs(planeNormal.z))  				{  					// mostly facing x axis  					majorAxis = 0;  				}  				else if (Math.Abs(planeNormal.y) > Math.Abs(planeNormal.z))  				{  					// mostly facing z  					majorAxis = 2;  				}  			}  			else if (Math.Abs(planeNormal.y) > Math.Abs(planeNormal.z))  			{  				// mostly facing y  				majorAxis = 1;  			}  			else  			{  				// mostly facing z  				majorAxis = 2;  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,TriangleShape,The following statement contains a magic number: if (Math.Abs(planeNormal.x) > Math.Abs(planeNormal.y))  			{  				if (Math.Abs(planeNormal.x) > Math.Abs(planeNormal.z))  				{  					// mostly facing x axis  					majorAxis = 0;  				}  				else if (Math.Abs(planeNormal.y) > Math.Abs(planeNormal.z))  				{  					// mostly facing z  					majorAxis = 2;  				}  			}  			else if (Math.Abs(planeNormal.y) > Math.Abs(planeNormal.z))  			{  				// mostly facing y  				majorAxis = 1;  			}  			else  			{  				// mostly facing z  				majorAxis = 2;  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,TriangleShape,The following statement contains a magic number: for (int i = 0; i < 3; i++)  			{  				boundsOnMajorAxis.Left = Math.Min(vertices[i][xForMajorAxis]' boundsOnMajorAxis.Left);  				boundsOnMajorAxis.Right = Math.Max(vertices[i][xForMajorAxis]' boundsOnMajorAxis.Right);  				boundsOnMajorAxis.Bottom = Math.Min(vertices[i][yForMajorAxis]' boundsOnMajorAxis.Bottom);  				boundsOnMajorAxis.Top = Math.Max(vertices[i][yForMajorAxis]' boundsOnMajorAxis.Top);  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetAxisAlignedBoundingBox,The following statement contains a magic number: if (aabbMinXYZ.x == double.NegativeInfinity)  			{  				aabbMinXYZ = Vector3Float.ComponentMin(Vector3Float.ComponentMin(vertices[0]' vertices[1])' vertices[2]);  				aabbMaxXYZ = Vector3Float.ComponentMax(Vector3Float.ComponentMax(vertices[0]' vertices[1])' vertices[2]);  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetAxisAlignedBoundingBox,The following statement contains a magic number: if (aabbMinXYZ.x == double.NegativeInfinity)  			{  				aabbMinXYZ = Vector3Float.ComponentMin(Vector3Float.ComponentMin(vertices[0]' vertices[1])' vertices[2]);  				aabbMaxXYZ = Vector3Float.ComponentMax(Vector3Float.ComponentMax(vertices[0]' vertices[1])' vertices[2]);  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetIntersectCost,The following statement contains a magic number: return 350;
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetSurfaceArea,The following statement contains a magic number: for (int firstIndex = 0; firstIndex < 3; ++firstIndex)  			{  				int secondIndex = (firstIndex + 1) % 3;  				accumulation += new Vector3(Vector3Float.Cross(vertices[firstIndex]' vertices[secondIndex]));  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetSurfaceArea,The following statement contains a magic number: for (int firstIndex = 0; firstIndex < 3; ++firstIndex)  			{  				int secondIndex = (firstIndex + 1) % 3;  				accumulation += new Vector3(Vector3Float.Cross(vertices[firstIndex]' vertices[secondIndex]));  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,GetSurfaceArea,The following statement contains a magic number: accumulation /= 2;
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,ToString,The following statement contains a magic number: return string.Format("Triangle {0} {1} {2}"' vertices[0]' vertices[1]' vertices[2]);
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,Check2DHitOnMajorAxis,The following statement contains a magic number: if (x >= boundsOnMajorAxis.Left && x <= boundsOnMajorAxis.Right &&  				y >= boundsOnMajorAxis.Bottom && y <= boundsOnMajorAxis.Top)  			{  				Vector2 vertex0 = new Vector2(vertices[0][xForMajorAxis]' vertices[0][yForMajorAxis]);  				Vector2 vertex1 = new Vector2(vertices[1][xForMajorAxis]' vertices[1][yForMajorAxis]);  				Vector2 vertex2 = new Vector2(vertices[2][xForMajorAxis]' vertices[2][yForMajorAxis]);  				Vector2 hitPosition = new Vector2(x' y);  				int sumOfLineSides = FindSideOfLine(vertex0' vertex1' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex1' vertex2' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex2' vertex0' hitPosition);  				if (sumOfLineSides == -3 || sumOfLineSides == 3)  				{  					return true;  				}  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,Check2DHitOnMajorAxis,The following statement contains a magic number: if (x >= boundsOnMajorAxis.Left && x <= boundsOnMajorAxis.Right &&  				y >= boundsOnMajorAxis.Bottom && y <= boundsOnMajorAxis.Top)  			{  				Vector2 vertex0 = new Vector2(vertices[0][xForMajorAxis]' vertices[0][yForMajorAxis]);  				Vector2 vertex1 = new Vector2(vertices[1][xForMajorAxis]' vertices[1][yForMajorAxis]);  				Vector2 vertex2 = new Vector2(vertices[2][xForMajorAxis]' vertices[2][yForMajorAxis]);  				Vector2 hitPosition = new Vector2(x' y);  				int sumOfLineSides = FindSideOfLine(vertex0' vertex1' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex1' vertex2' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex2' vertex0' hitPosition);  				if (sumOfLineSides == -3 || sumOfLineSides == 3)  				{  					return true;  				}  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,Check2DHitOnMajorAxis,The following statement contains a magic number: if (x >= boundsOnMajorAxis.Left && x <= boundsOnMajorAxis.Right &&  				y >= boundsOnMajorAxis.Bottom && y <= boundsOnMajorAxis.Top)  			{  				Vector2 vertex0 = new Vector2(vertices[0][xForMajorAxis]' vertices[0][yForMajorAxis]);  				Vector2 vertex1 = new Vector2(vertices[1][xForMajorAxis]' vertices[1][yForMajorAxis]);  				Vector2 vertex2 = new Vector2(vertices[2][xForMajorAxis]' vertices[2][yForMajorAxis]);  				Vector2 hitPosition = new Vector2(x' y);  				int sumOfLineSides = FindSideOfLine(vertex0' vertex1' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex1' vertex2' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex2' vertex0' hitPosition);  				if (sumOfLineSides == -3 || sumOfLineSides == 3)  				{  					return true;  				}  			}
Magic Number,MatterHackers.RayTracer,TriangleShape,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Shapes\TriangleShape.cs,Check2DHitOnMajorAxis,The following statement contains a magic number: if (x >= boundsOnMajorAxis.Left && x <= boundsOnMajorAxis.Right &&  				y >= boundsOnMajorAxis.Bottom && y <= boundsOnMajorAxis.Top)  			{  				Vector2 vertex0 = new Vector2(vertices[0][xForMajorAxis]' vertices[0][yForMajorAxis]);  				Vector2 vertex1 = new Vector2(vertices[1][xForMajorAxis]' vertices[1][yForMajorAxis]);  				Vector2 vertex2 = new Vector2(vertices[2][xForMajorAxis]' vertices[2][yForMajorAxis]);  				Vector2 hitPosition = new Vector2(x' y);  				int sumOfLineSides = FindSideOfLine(vertex0' vertex1' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex1' vertex2' hitPosition);  				sumOfLineSides += FindSideOfLine(vertex2' vertex0' hitPosition);  				if (sumOfLineSides == -3 || sumOfLineSides == 3)  				{  					return true;  				}  			}
Magic Number,MatterHackers.RayTracer.Traceable,Difference,C:\repos\MatterHackers_agg-sharp\RayTracer\Primitive\Difference.cs,GetIntersectCost,The following statement contains a magic number: return primary.GetIntersectCost() + subtract.GetIntersectCost() / 2;
Missing Default,MatterHackers.RayTracer,RayTracer,C:\repos\MatterHackers_agg-sharp\RayTracer\RayTracer.cs,GetRefractionRay,The following switch statement is missing a default case: switch (method)  			{  				case 0:  					return new Ray(P' V' Ray.sameSurfaceOffset' double.MaxValue);    				case 1:  					V = V * -1;  					double n = -0.55; // refraction constant for now  					if (n < 0 || n > 1)  					{  						return new Ray(P' V); // no refraction  					}  					break;    				case 2:  					double c1 = Vector3.Dot(N' V);  					double c2 = 1 - refraction * refraction * (1 - c1 * c1);  					if (c2 < 0)    						c2 = Math.Sqrt(c2);  					Vector3 T = (N * (refraction * c1 - c2) - V * refraction) * -1;  					T.Normalize();    					return new Ray(P' T); // no refraction  			}
