Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,AForgeCamera,Cyclomatic complexity of the method is 8
Long Statement,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The length of the statement  "                    bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat); " is 171.
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,AForgeCamera,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  //videoCaptureDevice.DesiredFrameRate = 5;                  //videoCaptureDevice.ProvideSnapshots = true;                  //videoCaptureDevice.DesiredSnapshotSize = new Size(preferedWidth' preferedHeight);                  //videoCaptureDevice.SnapshotFrame += new NewFrameEventHandler(videoCaptureDevice_SnapshotFrame);                    asyncCopiedVideoImage = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  if (downSampleVideo == DownSample.HalfSize)                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width / 2' videoCaptureDevice.DesiredFrameSize.Height / 2' 32' new BlenderBGRA());                  }                  else                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  }                  videoCaptureDevice.Start();                  videoCaptureDevice.NewFrame += new NewFrameEventHandler(source_NewFrame);              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,AForgeCamera,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  //videoCaptureDevice.DesiredFrameRate = 5;                  //videoCaptureDevice.ProvideSnapshots = true;                  //videoCaptureDevice.DesiredSnapshotSize = new Size(preferedWidth' preferedHeight);                  //videoCaptureDevice.SnapshotFrame += new NewFrameEventHandler(videoCaptureDevice_SnapshotFrame);                    asyncCopiedVideoImage = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  if (downSampleVideo == DownSample.HalfSize)                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width / 2' videoCaptureDevice.DesiredFrameSize.Height / 2' 32' new BlenderBGRA());                  }                  else                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  }                  videoCaptureDevice.Start();                  videoCaptureDevice.NewFrame += new NewFrameEventHandler(source_NewFrame);              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,AForgeCamera,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  //videoCaptureDevice.DesiredFrameRate = 5;                  //videoCaptureDevice.ProvideSnapshots = true;                  //videoCaptureDevice.DesiredSnapshotSize = new Size(preferedWidth' preferedHeight);                  //videoCaptureDevice.SnapshotFrame += new NewFrameEventHandler(videoCaptureDevice_SnapshotFrame);                    asyncCopiedVideoImage = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  if (downSampleVideo == DownSample.HalfSize)                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width / 2' videoCaptureDevice.DesiredFrameSize.Height / 2' 32' new BlenderBGRA());                  }                  else                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  }                  videoCaptureDevice.Start();                  videoCaptureDevice.NewFrame += new NewFrameEventHandler(source_NewFrame);              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,AForgeCamera,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  //videoCaptureDevice.DesiredFrameRate = 5;                  //videoCaptureDevice.ProvideSnapshots = true;                  //videoCaptureDevice.DesiredSnapshotSize = new Size(preferedWidth' preferedHeight);                  //videoCaptureDevice.SnapshotFrame += new NewFrameEventHandler(videoCaptureDevice_SnapshotFrame);                    asyncCopiedVideoImage = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  if (downSampleVideo == DownSample.HalfSize)                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width / 2' videoCaptureDevice.DesiredFrameSize.Height / 2' 32' new BlenderBGRA());                  }                  else                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  }                  videoCaptureDevice.Start();                  videoCaptureDevice.NewFrame += new NewFrameEventHandler(source_NewFrame);              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,AForgeCamera,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  //videoCaptureDevice.DesiredFrameRate = 5;                  //videoCaptureDevice.ProvideSnapshots = true;                  //videoCaptureDevice.DesiredSnapshotSize = new Size(preferedWidth' preferedHeight);                  //videoCaptureDevice.SnapshotFrame += new NewFrameEventHandler(videoCaptureDevice_SnapshotFrame);                    asyncCopiedVideoImage = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  if (downSampleVideo == DownSample.HalfSize)                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width / 2' videoCaptureDevice.DesiredFrameSize.Height / 2' 32' new BlenderBGRA());                  }                  else                  {                      imageForExternalUse = new ImageBuffer(videoCaptureDevice.DesiredFrameSize.Width' videoCaptureDevice.DesiredFrameSize.Height' 32' new BlenderBGRA());                  }                  videoCaptureDevice.Start();                  videoCaptureDevice.NewFrame += new NewFrameEventHandler(source_NewFrame);              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,IsNewImageReady,The following statement contains a magic number: if (newImageReady)              {                  if (!currentlyUsingCameraImage)                  {                      currentlyUsingCameraImage = true;                      lock (asyncCopiedVideoImage)                      {                          if (downSampleVideo == DownSample.HalfSize)                          {                              imageForExternalUse.NewGraphics2D().Render(asyncCopiedVideoImage' 0' 0' 0' .5' .5);                          }                          else                          {                              imageForExternalUse.NewGraphics2D().Render(asyncCopiedVideoImage' 0' 0);                          }                      }                      imageForExternalUse.MarkImageChanged();                        newImageReady = false;                      currentlyUsingCameraImage = false;                      return true;                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,IsNewImageReady,The following statement contains a magic number: if (newImageReady)              {                  if (!currentlyUsingCameraImage)                  {                      currentlyUsingCameraImage = true;                      lock (asyncCopiedVideoImage)                      {                          if (downSampleVideo == DownSample.HalfSize)                          {                              imageForExternalUse.NewGraphics2D().Render(asyncCopiedVideoImage' 0' 0' 0' .5' .5);                          }                          else                          {                              imageForExternalUse.NewGraphics2D().Render(asyncCopiedVideoImage' 0' 0);                          }                      }                      imageForExternalUse.MarkImageChanged();                        newImageReady = false;                      currentlyUsingCameraImage = false;                      return true;                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,source_NewFrame,The following statement contains a magic number: if (!currentlyUsingCameraImage)              {                  currentlyUsingCameraImage = true;                  Bitmap bitmap = eventArgs.Frame;                  if (bitmap.Width != asyncCopiedVideoImage.Width || bitmap.Height != asyncCopiedVideoImage.Height)                  {                      asyncCopiedVideoImage = new ImageBuffer(bitmap.Width' bitmap.Height' 32' new BlenderBGRA());                  }                  UpdateImageBuffer(asyncCopiedVideoImage' bitmap);                  newImageReady = true;                  currentlyUsingCameraImage = false;              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,CloseCurrentVideoSource,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  videoCaptureDevice.SignalToStop();                    // wait ~ 3 seconds                  for (int i = 0; i < 30; i++)                  {                      if (!videoCaptureDevice.IsRunning)                      {                          break;                      }                      System.Threading.Thread.Sleep(100);                  }                    if (videoCaptureDevice.IsRunning)                  {                      videoCaptureDevice.Stop();                  }                    videoCaptureDevice.Stop();                    videoCaptureDevice = null;              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,CloseCurrentVideoSource,The following statement contains a magic number: if (videoCaptureDevice != null)              {                  videoCaptureDevice.SignalToStop();                    // wait ~ 3 seconds                  for (int i = 0; i < 30; i++)                  {                      if (!videoCaptureDevice.IsRunning)                      {                          break;                      }                      System.Threading.Thread.Sleep(100);                  }                    if (videoCaptureDevice.IsRunning)                  {                      videoCaptureDevice.Stop();                  }                    videoCaptureDevice.Stop();                    videoCaptureDevice = null;              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,AForgeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\AForgeCamera.cs,UpdateImageBuffer,The following statement contains a magic number: if (destImageBuffer != null)              {                  if (!isLocked)                  {                      bitmapData = sourceBitmap.LockBits(new Rectangle(0' 0' sourceBitmap.Width' sourceBitmap.Height)' System.Drawing.Imaging.ImageLockMode.ReadWrite' sourceBitmap.PixelFormat);                  }                  int destBufferStrideInBytes = destImageBuffer.StrideInBytes();                  int destBufferHeight = destImageBuffer.Height;                  int destBufferWidth = destImageBuffer.Width;                  int destBufferHeightMinusOne = destBufferHeight - 1;                  int bitmapDataStride = bitmapData.Stride;                  int offset;                  byte[] buffer = destImageBuffer.GetBuffer(out offset);                  if (flipY)                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (destBufferHeight - 1 - y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  else                  {                      unsafe                      {                          byte* bitmapDataScan0 = (byte*)bitmapData.Scan0;                          fixed (byte* pDestFixed = &buffer[offset])                          {                              byte* pSource = bitmapDataScan0;                              for (int y = 0; y < destBufferHeight; y++)                              {                                  byte* pDest = pDestFixed + destBufferStrideInBytes * (y);                                    for (int x = 0; x < destBufferWidth; x++)                                  {                                      pDest[x * 4 + 0] = pSource[x * 3 + 0];                                      pDest[x * 4 + 1] = pSource[x * 3 + 1];                                      pDest[x * 4 + 2] = pSource[x * 3 + 2];                                      pDest[x * 4 + 3] = 255;                                  }                                    pSource += bitmapDataStride;                              }                          }                      }                  }                  if (!isLocked)                  {                      sourceBitmap.UnlockBits(bitmapData);                  }              }
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,IsNewImageReady,The following statement contains a magic number: if(newImageRead && Monitor.TryEnter(cameraCopyBufferIntPtr' 1))              {                  unsafe                  {                      int width = currentImage.Width;                      int height = currentImage.Height;                        byte[] currentImageBuffer = currentImage.GetBuffer();                      int offset = 0;                      for (int y = 0; y < height; y++)                      {                          for (int x = 0; x < width; x++)                          {                              currentImageBuffer[offset] = ((byte*)cameraCopyBufferIntPtr)[offset];                              offset++;                              currentImageBuffer[offset] = ((byte*)cameraCopyBufferIntPtr)[offset];                              offset++;                              currentImageBuffer[offset] = ((byte*)cameraCopyBufferIntPtr)[offset];                              offset++;                              currentImageBuffer[offset++] = 255;                          }                      }                  }                  newImageRead = false;                  currentImage.MarkImageChanged();                  return true;              }
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,CLEyeCamera,The following statement contains a magic number: hwCameraIntPtr = CLEyeCreateCamera(CameraUUID(0)' colorMode' resolution' 30);
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,CLEyeCamera,The following statement contains a magic number: CLEyeSetCameraParameter(hwCameraIntPtr' CLEyeCameraParameter.CLEYE_WHITEBALANCE_GREEN' 128);
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,CLEyeCamera,The following statement contains a magic number: CLEyeSetCameraParameter(hwCameraIntPtr' CLEyeCameraParameter.CLEYE_WHITEBALANCE_BLUE' 128);
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,CLEyeCamera,The following statement contains a magic number: CLEyeSetCameraParameter(hwCameraIntPtr' CLEyeCameraParameter.CLEYE_WHITEBALANCE_RED' 128);
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,CLEyeCamera,The following statement contains a magic number: currentImage = new ImageBuffer(cameraImageWidth' cameraImageHeight' 32' new BlenderBGRA());
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,CLEyeCamera,The following statement contains a magic number: cameraCopyBufferIntPtr = Marshal.AllocHGlobal(cameraImageWidth * cameraImageHeight * 4);
Magic Number,AForge,CLEyeCamera,C:\repos\MatterHackers_agg-sharp\AForgeCamera\CLEyeCamera.cs,Capture,The following statement contains a magic number: while (_threadRunning)              {                  unsafe                  {                      if (Monitor.TryEnter(cameraCopyBufferIntPtr' 1))                      {                          if (CLEyeCameraGetFrame(hwCameraIntPtr' cameraCopyBufferIntPtr' 500))                          {                              newImageRead = true;                          }                      }                  }              }
