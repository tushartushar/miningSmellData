Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The method has 103 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseDown,The method has 122 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveNotCaptured,The method has 101 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseUp,The method has 134 lines of code.
Long Method,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The method has 193 lines of code.
Long Method,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyDown,The method has 252 lines of code.
Long Method,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,AddGrabControls,The method has 125 lines of code.
Complex Method,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,ButtonViewThreeImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewThreeImage.cs,OnDraw,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.Agg.UI,CheckBoxViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewSates.cs,PostUpdateSetCorrectVisibilityStates,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,FlowLeftRightWithWrapping,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\FLowLeftRightWithWrapping.cs,DoWrappingLayout,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Focus,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseDown,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,ValidateMouseCaptureRecursive,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveWhenCaptured,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveNotCaptured,Cyclomatic complexity of the method is 18
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseUp,Cyclomatic complexity of the method is 26
Complex Method,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,FindDescendants,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,Layout,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,Cyclomatic complexity of the method is 35
Complex Method,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,Layout,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.UI,PopupLayoutEngine,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,recalculatePosition,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,OnMouseDown,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,RelativeTime,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RelativeTime.cs,GetDetail,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,ScrollingArea,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollingArea.cs,ValidateScrollPosition,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,InternalNumberEdit,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,OnKeyPress,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnDraw,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyDown,Cyclomatic complexity of the method is 49
Complex Method,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,OnMouseDown,Cyclomatic complexity of the method is 14
Long Parameter List,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,MatterHackers.Agg.UI,CheckBoxViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewSates.cs,CheckBoxViewStates,The method has 7 parameters. Parameters: normal' normalHover' switchNormalToPressed' pressed' pressedHover' switchPressedToNormal' disabled
Long Parameter List,MatterHackers.Agg.UI,CheckBoxViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewSates.cs,SetViewStates,The method has 7 parameters. Parameters: normal' normalHover' switchNormalToPressed' pressed' pressedHover' switchPressedToNormal' disabled
Long Parameter List,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,FindDescendants,The method has 5 parameters. Parameters: widgetNames' foundChildren' touchingBounds' searchType' allowDisabledOrHidden
Long Parameter List,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The method has 6 parameters. Parameters: noSelectionString' textColor' direction' maxHeight' useLeftIcons' pointSize
Long Parameter List,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The method has 5 parameters. Parameters: itemName' leftImage' color' textColor' pointSize
Long Parameter List,MatterHackers.Agg.UI,PopupLayoutEngine,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,PopupLayoutEngine,The method has 5 parameters. Parameters: contentWidget' widgetRelativeTo' direction' maxHeight' alignToRightEdge
Long Parameter List,MatterHackers.Agg.UI,DropDownContainer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,DropDownContainer,The method has 7 parameters. Parameters: MenuItems' popupContent' widgetRelativeTo' direction' maxHeight' alignToRightEdge' makeScrollable
Long Parameter List,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The method has 5 parameters. Parameters: message' windowTitle' messageType' width' height
Long Parameter List,MatterHackers.Agg.UI,MouseEventArgs,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MouseEventArgs.cs,MouseEventArgs,The method has 6 parameters. Parameters: button' clicks' x' y' wheelDelta' dragDropFiles
Long Parameter List,MatterHackers.Agg.UI,MouseEventArgs,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MouseEventArgs.cs,MouseEventArgs,The method has 5 parameters. Parameters: button' clicks' positions' wheelDelta' dragDropFiles
Long Parameter List,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The method has 6 parameters. Parameters: message' textColor' fillColor' barWidgth' barHeight' leftMargin
Long Parameter List,MatterHackers.Agg.UI,RadioButton,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButton.cs,RadioButton,The method has 5 parameters. Parameters: x' y' label' textColor' fontSize
Long Parameter List,MatterHackers.Agg.UI,RadioButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The method has 5 parameters. Parameters: uncheckedWidget' uncheckedHoverWidget' checkingWidget' checkedWidget' disabledWidget
Long Parameter List,MatterHackers.Agg.UI,RadioImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DrawCircle,The method has 5 parameters. Parameters: graphics2D' center' color' isChecked' isActive
Long Parameter List,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The method has 5 parameters. Parameters: positionOfTrackFirstValue' widthInPixels' minimum' maximum' orientation
Long Parameter List,MatterHackers.Agg.UI,TextTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,TextTab,The method has 9 parameters. Parameters: tabPage' internalTabName' pointSize' selectedTextColor' selectedBackgroundColor' normalTextColor' normalBackgroundColor' fixedSize' useUnderlineStyling
Long Parameter List,MatterHackers.Agg.UI,TextTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,AddText,The method has 8 parameters. Parameters: tabText' viewWidget' textColor' backgroundColor' pointSize' isActive' fixedSize' useUnderlineStyling
Long Parameter List,MatterHackers.Agg.UI,ThreeViewTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,ThreeViewTab,The method has 5 parameters. Parameters: tabName' normalWidget' hoverWidget' selectedWidget' tabPage
Long Parameter List,MatterHackers.Agg.UI,InternalNumberEdit,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,InternalNumberEdit,The method has 10 parameters. Parameters: startingValue' pointSize' pixelWidth' pixelHeight' allowNegatives' allowDecimals' minValue' maxValue' increment' tabIndex
Long Parameter List,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,InternalTextEditWidget,The method has 5 parameters. Parameters: text' pointSize' multiLine' tabIndex' typeFace
Long Parameter List,MatterHackers.Agg.UI,NumberEdit,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\NumberEdit.cs,NumberEdit,The method has 12 parameters. Parameters: startingValue' x' y' pointSize' pixelWidth' pixelHeight' allowNegatives' allowDecimals' minValue' maxValue' increment' tabIndex
Long Parameter List,MatterHackers.Agg.UI,TextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,TextEditWidget,The method has 9 parameters. Parameters: text' x' y' pointSize' pixelWidth' pixelHeight' multiLine' tabIndex' typeFace
Long Parameter List,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,TextWidget,The method has 11 parameters. Parameters: text' x' y' pointSize' justification' textColor' ellipsisIfClipped' underline' backgroundColor' typeFace' bold
Long Parameter List,MatterHackers.Agg.UI,WrappedTextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\WrappedTextWidget.cs,WrappedTextWidget,The method has 8 parameters. Parameters: text' pointSize' justification' textColor' ellipsisIfClipped' underline' backgroundColor' doubleBufferText
Long Parameter List,MatterHackers.Agg.UI,ToggleSwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,ToggleSwitchView,The method has 9 parameters. Parameters: onText' offText' width' height' backgroundColor' interiorColor' thumbColor' textColor' borderColor
Long Parameter List,MatterHackers.Agg.UI,ToggleSwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The method has 9 parameters. Parameters: word' isChecked' width' height' backgroundColor' interiorColor' thumbColor' textColor' borderColor
Long Parameter List,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The method has 8 parameters. Parameters: width' height' startValue' backgroundColor' interiorColor' thumbColor' exteriorColor' borderColor
Long Identifier,MatterHackers.Agg.UI,Animation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Animation.cs,ProcessElapsedTime,The length of the parameter numSecondsPassedSinceLastUpdate is 31.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the parameter boundsOfAllChildrenIncludingMargin is 34.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Focus,The length of the parameter allWidgetsThatWillContainFocus is 30.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Focus,The length of the parameter allWidgetsThatCurrentlyHaveFocus is 32.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,ValidateMouseCaptureRecursive,The length of the parameter countOfChildernThatThinkTheyHaveTheMouseCaptured is 48.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveWhenCaptured,The length of the parameter countOfChildernThatThinkTheyHaveTheMouseCaptured is 48.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseUp,The length of the parameter countOfChildernThatThinkTheyHaveTheMouseCaptured is 48.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,,The length of the parameter mouseMoveEventHasBeenAcceptedByOther is 36.
Long Identifier,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the parameter boundsOfAllChildrenIncludingMargin is 34.
Long Identifier,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,,The length of the parameter mouseDownOffsetFromThumbCenter is 30.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeCurrentToolTipHasBeenShowing is 32.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeCurrentToolTipHasBeenShowingWasRunning is 42.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeSinceLastMouseMoveWasRunning is 32.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeSinceLastToolTipCloseWasRunning is 35.
Long Identifier,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,,The length of the parameter selectAllOnMouseUpIfNoSelection is 31.
Long Statement,MatterHackers.Agg.UI,AverageMillisecondTimer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\AverageMillisecondTimer.cs,Draw,The length of the statement  "			graphics2D.DrawString("{0}ms {1:0.0}mb".FormatWith(GetAverage()' GC.GetTotalMemory(false) / 1000000)' x' y' 16' color: Color.White' drawFromHintedCach: true); " is 158.
Long Statement,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,OnDraw,The length of the statement  "			RectangleDouble clampedRect = new RectangleDouble(1' Math.Floor(0 + bottom)' 1 + Math.Ceiling(CheckBoxWidth)' Math.Ceiling(CheckBoxWidth + bottom)); " is 148.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The length of the statement  "			TextWidget sizeAndPositon = new TextWidget(string.Format("  Size {0}' Position {1}"' widgetToAddInfoAbout.LocalBounds' widgetToAddInfoAbout.OriginRelativeParent)' pointSize: 8' textColor: Color.Red); " is 199.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The length of the statement  "			TextWidget boundsText = new TextWidget(string.Format("  Bounds {0}"' widgetToAddInfoAbout.BoundsRelativeToParent)' pointSize: 8' textColor: Color.Red); " is 151.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,updateWidgetInfo,The length of the statement  "				widgetRefList[widgetToAddInfoAbout].sizeLabel.Text = string.Format("  Size {0}' Position {1}"' widgetToAddInfoAbout.LocalBounds' widgetToAddInfoAbout.OriginRelativeParent); " is 172.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,updateWidgetInfo,The length of the statement  "				widgetRefList[widgetToAddInfoAbout].boundsLabel.Text = string.Format("  Bounds {0}"' widgetToAddInfoAbout.BoundsRelativeToParent); " is 130.
Long Statement,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + lineInset' this.BorderColor); " is 166.
Long Statement,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + lineInset' localBounds.Left + lineInset' localBounds.Bottom + Height - lineInset' this.BorderColor); " is 167.
Long Statement,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + Width - lineInset' localBounds.Bottom + lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + Height - lineInset' this.BorderColor); " is 183.
Long Statement,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + Height - lineInset' groupBoxLabel.BoundsRelativeToParent.Left - 2' localBounds.Bottom + Height - lineInset' this.BorderColor); " is 193.
Long Statement,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(groupBoxLabel.BoundsRelativeToParent.Right + 2' localBounds.Bottom + Height - lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + Height - lineInset' this.BorderColor); " is 202.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the statement  "						bool childHSizeHasBeenAdjusted = flowLayout != null && (flowLayout.FlowDirection == FlowDirection.LeftToRight || flowLayout.FlowDirection == FlowDirection.RightToLeft); " is 168.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the statement  "						bool childVSizeHasBeenAdjusted = flowLayout != null && (flowLayout.FlowDirection == FlowDirection.BottomToTop || flowLayout.FlowDirection == FlowDirection.TopToBottom); " is 168.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the statement  "						boundsOfAllChildrenIncludingMargin.Right = boundsOfAllChildrenIncludingMargin.Left + Max(boundsOfAllChildrenIncludingMargin.Width' minSize.X); " is 142.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the statement  "						boundsOfAllChildrenIncludingMargin.Top = boundsOfAllChildrenIncludingMargin.Bottom + Max(boundsOfAllChildrenIncludingMargin.Height' minSize.Y); " is 143.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,AddChild,The length of the statement  "					throw new Exception("You are adding a child that has previously been removed. You should probably be creating a new widget' or calling ClearRemovedFlag() before adding."); " is 171.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The length of the statement  "								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom) " is 121.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The length of the statement  "					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.X' (int)MinimumSize.Y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)' " is 158.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The length of the statement  "						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center); " is 137.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,The length of the statement  "					graphics2D.Render(new VertexSourceApplyTransform(rightArrow' Affine.NewRotation(MathHelper.DegreesToRadians(180)))' LocalBounds.Center' color); " is 143.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,The length of the statement  "					graphics2D.Render(new VertexSourceApplyTransform(upArrow' Affine.NewRotation(MathHelper.DegreesToRadians(180)))' LocalBounds.Center' color); " is 140.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Close,The length of the statement  "				BreakInDebugger("You should put this close onto the UiThread.RunOnIdle so it can happen after the child list is unlocked."); " is 124.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Close,The length of the statement  "					// This code will only execute if this is the actual widget we called close on (not a child of the widget we called close on). " is 126.
Long Statement,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,TransformToParentSpace,The length of the statement  "				position += new Vector2(widgetToTransformBy.BoundsRelativeToParent.Left' widgetToTransformBy.BoundsRelativeToParent.Bottom); " is 124.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,FixOriginXIfRightToLeft,The length of the statement  "					child.OriginRelativeParent = new Vector2(child.OriginRelativeParent.X - encloseChildrenRect.Left' child.OriginRelativeParent.Y); " is 128.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,FixOriginYIfTopToBottom,The length of the statement  "					child.OriginRelativeParent = new Vector2(child.OriginRelativeParent.X' child.OriginRelativeParent.Y - encloseChildrenRect.Bottom); " is 130.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "						totalMinimumHeightOfAllItems = Math.Max(totalMinimumHeightOfAllItems' child.MinimumSize.Y + child.DeviceMarginAndBorder.Height); " is 128.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "						totalMinimumWidthOfAllItems = Math.Max(totalMinimumWidthOfAllItems' child.MinimumSize.X + child.DeviceMarginAndBorder.Width); " is 125.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newWidth = (parent.LocalBounds.Width - parent.DevicePadding.Width - totalWidthOfStaticItems) / numItemsNeedingExpanding; " is 127.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newWidth = (parent.LocalBounds.Width - parent.DevicePadding.Width - totalWidthOfStaticItems) / numItemsNeedingExpanding; " is 127.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newHeight = (parent.LocalBounds.Height - parent.DevicePadding.Height - totalHeightOfStaticItems) / numItemsNeedingExpanding; " is 131.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newHeight = (parent.LocalBounds.Height - parent.DevicePadding.Height - totalHeightOfStaticItems) / numItemsNeedingExpanding;// - child.DeviceMarginAndBorder.Height; " is 171.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenVertical,The length of the statement  "					if (!GetOriginAndHeightForChild(widgetToAdjustBounds.Parent' widgetToAdjustBounds' out newOriginRelParent' out heightToMatchParent).adjustHeight) " is 145.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "				newOriginRelParent = new Vector2(child.OriginRelativeParent.X' parent.LocalBounds.Bottom + child.DeviceMarginAndBorder.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom); " is 184.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "						parent.DevicePadding.Bottom + child.DeviceMarginAndBorder.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2); " is 145.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2; " is 158.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMarginAndBorder.Bottom + child.DeviceMarginAndBorder.Top) / 2 + child.DeviceMarginAndBorder.Bottom; " is 187.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "				newOriginRelParent = new Vector2(child.OriginRelativeParent.X' parent.LocalBounds.Top - child.DeviceMarginAndBorder.Top - parent.DevicePadding.Top - child.LocalBounds.Top); " is 172.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "					if (!GetOriginAndWidthForChild(widgetToAdjust.Parent' widgetToAdjust' out newOriginRelParent' out widthToMatchParent).adjustWidth) " is 130.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "							// We make the assumption that the parent has set the size correctly assuming flow layout and this can only be made bigger if fit needs to. " is 139.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "							widgetToAdjustBounds.Right = Math.Max(childrenEnclosingBounds.Left + widthToMatchParent' childrenEnclosingBounds.Right); " is 120.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "						widgetToAdjustBounds.Right = Math.Max(childrenEnclosingBounds.Left + widthToMatchParent' childrenEnclosingBounds.Right); " is 120.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "					widgetToAdjustBounds.Right = Math.Max(childrenEnclosingBounds.Left + widthToMatchParent' childrenEnclosingBounds.Right); " is 120.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMarginAndBorder.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.Y); " is 176.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "						parent.DevicePadding.Left + child.DeviceMarginAndBorder.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2' " is 139.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2; " is 155.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMarginAndBorder.Left + child.DeviceMarginAndBorder.Right) / 2 + child.DeviceMarginAndBorder.Left; " is 182.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMarginAndBorder.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.Y); " is 180.
Long Statement,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,ApplyFilter,The length of the statement  "			var firstMatchedItem = MenuItems.Where(m => m.Text.IndexOf(text' StringComparison.OrdinalIgnoreCase) == 0).FirstOrDefault(); " is 124.
Long Statement,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,OnBoundsChanged,The length of the statement  "			dropArrowBounds = new RectangleDouble(LocalBounds.Right - DropArrow.ArrowHeight * 4' 0' LocalBounds.Right' this.Height); " is 120.
Long Statement,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The length of the statement  "				currentPadding = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top); " is 137.
Long Statement,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The length of the statement  "			GuiWidget normalTextWithMargin = GetMenuContent(itemName' leftImage' MenuItemsBackgroundColor' MenuItemsTextColor' pointSize); " is 126.
Long Statement,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The length of the statement  "			GuiWidget hoverTextWithMargin = GetMenuContent(itemName' leftImage' MenuItemsBackgroundHoverColor' MenuItemsTextHoverColor' pointSize); " is 135.
Long Statement,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The length of the statement  "					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top); " is 140.
Long Statement,MatterHackers.Agg.UI,Menu,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,ShowMenu,The length of the statement  "			DropDownContainer = new DropDownContainer(MenuItems' topToBottom' this' MenuDirection' maxHeight' AlignToRightEdge' true) " is 121.
Long Statement,MatterHackers.Agg.UI,PopupLayoutEngine,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,recalculatePosition,The length of the statement  "				var bottomLeftForAlignRight = widgetRelativeTo.Position - new Vector2(popupWidget.Width - widgetRelativeTo.LocalBounds.Width' 0); " is 129.
Long Statement,MatterHackers.Agg.UI,ScrollingArea,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollingArea.cs,CalculateChildrenBounds,The length of the statement  "				RectangleDouble boundsOfChildren = new RectangleDouble(double.MaxValue' double.MaxValue' double.MinValue' double.MinValue); " is 123.
Long Statement,MatterHackers.Agg.UI,SoftKeyboard,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,inputButton_Click,The length of the statement  "				hadFocusWidget.OnKeyPress(new KeyPressEventArgs(((Button)sender).Children.FirstOrDefault().Children.FirstOrDefault().Text[0])); " is 127.
Long Statement,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnBoundsChanged,The length of the statement  "				Panel2.LocalBounds = new RectangleDouble(0' 0' LocalBounds.Width - SplitterDistance - splitterBar.Width' LocalBounds.Height); " is 125.
Long Statement,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnBoundsChanged,The length of the statement  "				Panel1.LocalBounds = new RectangleDouble(Panel1.Border.Left' Panel1.Border.Bottom' LocalBounds.Width - Panel1.DeviceMarginAndBorder.Width' LocalBounds.Height - SplitterDistance - splitterBar.Height - Panel1.DeviceMarginAndBorder.Height); " is 237.
Long Statement,MatterHackers.Agg.UI,SystemWindow,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\SystemWindow.cs,ShowAsSystemWindow,The length of the statement  "				systemWindowProvider = AggContext.CreateInstanceFrom<ISystemWindowProvider>(AggContext.Config.ProviderTypes.SystemWindowProvider); " is 130.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The length of the statement  "				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds); " is 125.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The length of the statement  "				RectangleDouble screenBounds = widgetThatWasShowingToolTip.TransformToScreenSpace(widgetThatWasShowingToolTip.LocalBounds); " is 123.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The length of the statement  "					RectangleDouble screenBounds = widgetThatIsShowingToolTip.TransformToScreenSpace(widgetThatIsShowingToolTip.LocalBounds); " is 121.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The length of the statement  "				RectangleDouble screenBoundsShowingTT = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds); " is 134.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The length of the statement  "					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23); " is 140.
Long Statement,MatterHackers.Agg.UI,TabControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,AddChild,The length of the statement  "			throw new Exception("You cannot add controls directly to a TabControl. Add the controls to a TabPage and then add that to the TabControl."); " is 140.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,UpdateLocalBounds,The length of the statement  "			//LocalBounds = new RectangleDouble(this.BorderWidth - padding' this.BorderWidth - padding' width + this.BorderWidth + padding' height + this.BorderWidth + padding); " is 165.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseDown,The length of the statement  "			CharIndexToInsertBefore = internalTextWidget.Printer.GetCharacterIndexToStartBefore(new Vector2(mouseEvent.X' mouseEvent.Y)); " is 125.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseDown,The length of the statement  "				while (CharIndexToInsertBefore >= Text.Length || (CharIndexToInsertBefore > -1 && !WordBreakChars.Contains(Text[CharIndexToInsertBefore]))) " is 139.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseMove,The length of the statement  "				CharIndexToInsertBefore = internalTextWidget.Printer.GetCharacterIndexToStartBefore(new Vector2(mouseEvent.X' mouseEvent.Y)); " is 125.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,CopySelection,The length of the statement  "					Clipboard.Instance.SetText(internalTextWidget.Text.Substring(CharIndexToInsertBefore' SelectionIndexToStartBefore - CharIndexToInsertBefore)); " is 142.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,CopySelection,The length of the statement  "					Clipboard.Instance.SetText(internalTextWidget.Text.Substring(SelectionIndexToStartBefore' CharIndexToInsertBefore - SelectionIndexToStartBefore)); " is 146.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GetIndexOffset,The length of the statement  "				internalTextWidget.Printer.GetOffset(CharacterStartIndexInclusive' CharacterStartIndexInclusive + OffsetIndex' out offset); " is 123.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GotoLineAbove,The length of the statement  "			GetStartAndEndIndexForLineContainingChar(startIndexInclusive - 1' out prevStartIndexInclusive' out prevEndIndexInclusive); " is 122.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GotoLineBelow,The length of the statement  "			GetStartAndEndIndexForLineContainingChar(endIndexInclusive + 1' out nextStartIndexInclusive' out nextEndIndexInclusive); " is 120.
Long Statement,MatterHackers.Agg.UI,TextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,Focus,The length of the statement  "				throw new Exception("Don't call Focus() until you have a Parent.\nCalling focus without a parent will not result in the focus chain pointing to the widget' so it will not work."); " is 179.
Long Statement,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The length of the statement  "					shortTextPrinter = new TypeFacePrinter(shortTextPrinter.Text.Substring(0' shortTextPrinter.Text.Length - 4).TrimEnd(spaceTrim) + "..."' Printer); " is 145.
Long Statement,MatterHackers.Agg.UI,ToggleSwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The length of the statement  "				new SwitchView(width' height' isChecked' backgroundColor' interiorColor' isChecked ? thumbColor : Color.Gray' textColor' borderColor) " is 133.
Long Statement,MatterHackers.Agg.UI,TitleBarWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\TitleBarWidget.cs,OnMouseMove,The length of the statement  "					dragPosition.Y = agg_basics.Clamp(dragPosition.Y' -windowToDrag.Height + 10' windowToDragParent.Height - windowToDrag.Height); " is 126.
Complex Conditional,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The conditional expression  "m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,AllParentsVisibleAndEnabled,The conditional expression  "!curGUIWidget.Visible || !curGUIWidget.Enabled  					|| visibleBounds.Width <= 0  					|| visibleBounds.Height <= 0"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,DrawBorder,The conditional expression  "childBorderColor == Color.Transparent  				|| (childDeviceBorder.Left == 0  					&& childDeviceBorder.Right == 0  					&& childDeviceBorder.Bottom == 0  					&& childDeviceBorder.Top == 0)"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseDown,The conditional expression  "child.Visible  						&& child.Enabled  						&& child.CanSelect  						&& child.PositionWithinLocalBounds(childX' childY)"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveNotCaptured,The conditional expression  "child.Visible  							&& child.Enabled  							&& child.CanSelect  							&& child.PositionWithinLocalBounds(childX' childY)"  is complex.
Complex Conditional,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,OnMouseUp,The conditional expression  "!scrollingWindow.VerticalScrollBar.ChildHasMouseCaptured  					&& AllowClickingItems()  					&& clickIsInsideScrollArea  					&& !specialChildHasFocus  					&& !descendantIsHoldingOpen  					&& !holdingOpenForChild  					&& !keepMeOpen  					&& !DebugKeepOpen"  is complex.
Complex Conditional,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,OnContainsFocusChanged,The conditional expression  "!this.ContainsFocus  							&& !specialChildHasFocus  							&& !descendantIsHoldingOpen  							&& !holdingOpenForChild  							&& !keepMeOpen  							&& !DebugKeepOpen"  is complex.
Complex Conditional,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnKeyDown,The conditional expression  "!keyEvent.Handled  				&& !keyEvent.Control  				&& !keyEvent.Alt  				&& !keyEvent.Shift"  is complex.
Complex Conditional,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The conditional expression  "(timeSinceLastToolTipClose.IsRunning || timeSinceLastToolTipCloseWasRunning)  				&& timeSinceLastToolTipClose.Elapsed.TotalSeconds < InitialDelay  				&& widgetThatWantsToShowToolTip != null  				&& widgetThatIsShowingToolTip == null"  is complex.
Complex Conditional,MatterHackers.Agg.UI,InternalNumberEdit,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,InternalNumberEdit,The conditional expression  "startingValue < 0 || increment < 0 || minValue < 0 || maxValue < 0"  is complex.
Complex Conditional,MatterHackers.Agg.UI,InternalNumberEdit,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,InternalNumberEdit,The conditional expression  "startingValue != (int)startingValue || increment != (int)increment || minValue != (int)minValue || maxValue != (int)maxValue"  is complex.
Complex Conditional,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The conditional expression  "MergeTypingDuringUndo  					&& charIndexToAcceptAsMerging == CharIndexToInsertBefore - 1  					&& keyPressEvent.KeyChar != '\n' && keyPressEvent.KeyChar != '\r'"  is complex.
Virtual Method Call from Constructor,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The constructor "gamma_ctrl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Button,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\Button.cs,Button,The constructor "Button" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewText.cs,ButtonViewText,The constructor "ButtonViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBox.cs,CheckBox,The constructor "CheckBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The constructor "CheckBoxViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The constructor "CheckBoxViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The constructor "CheckBoxViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The constructor "GroupBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The constructor "GroupBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The constructor "DropDownList" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Menu,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,Menu,The constructor "Menu" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItem,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItem.cs,MenuItem,The constructor "MenuItem" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemStatesView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemStatesView,The constructor "MenuItemStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemStatesView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemStatesView,The constructor "MenuItemStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemColorStatesView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemColorStatesView,The constructor "MenuItemColorStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,PopupWidget,The constructor "PopupWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,PopupWidget,The constructor "PopupWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The constructor "PerformancePanel" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The constructor "PerformancePanel" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The constructor "PerformancePanel" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The constructor "ProgressControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The constructor "ProgressControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The constructor "ProgressControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButton,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButton.cs,RadioButton,The constructor "RadioButton" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,RadioButtonViewText,The constructor "RadioButtonViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,RadioButtonView,The constructor "RadioButtonView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,RadioButtonView,The constructor "RadioButtonView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,ScrollableWidget,The constructor "ScrollableWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,ScrollableWidget,The constructor "ScrollableWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollBar,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,ScrollBar,The constructor "ScrollBar" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollBar,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,ScrollBar,The constructor "ScrollBar" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollBar,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,ScrollBar,The constructor "ScrollBar" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The constructor "Slider" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The constructor "SoftKeyboardDisplayStateManager" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The constructor "SoftKeyboardDisplayStateManager" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardContentOffset,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardContentOffset,The constructor "SoftKeyboardContentOffset" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardContentOffset,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardContentOffset,The constructor "SoftKeyboardContentOffset" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The constructor "Splitter" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The constructor "Splitter" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The constructor "Splitter" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ThreeViewTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,ThreeViewTab,The constructor "ThreeViewTab" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ThreeViewTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,ThreeViewTab,The constructor "ThreeViewTab" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ThreeViewTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,ThreeViewTab,The constructor "ThreeViewTab" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,TabControl,The constructor "TabControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,TabControl,The constructor "TabControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,TabControl,The constructor "TabControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabPage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\TabPage.cs,TabPage,The constructor "TabPage" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,InternalTextEditWidget,The constructor "InternalTextEditWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WrappedTextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\WrappedTextWidget.cs,WrappedTextWidget,The constructor "WrappedTextWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The constructor "WindowWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The constructor "WindowWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The constructor "WindowWidget" calls a virtual method "AddChild".
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(4' 5.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(4' 5.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(0' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(1' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(1' 50.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(3' 0.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(3' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(3' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetXN(2' x3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetYN(2' y3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetXN(3' x4);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetYN(3' y4);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: return m_poly.GetXN(2);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: return m_poly.GetYN(2);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x4,The following statement contains a magic number: return m_poly.GetXN(3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y4,The following statement contains a magic number: return m_poly.GetYN(3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: m_poly.SetXN(2' x);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: m_poly.SetYN(2' y);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x4,The following statement contains a magic number: m_poly.SetXN(3' x);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y4,The following statement contains a magic number: m_poly.SetYN(3' y);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,num_paths,The following statement contains a magic number: return 7;
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(3' 5.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(3' 5.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(0' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(1' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(1' 50.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetXN(2' x3);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetYN(2' y3);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2));
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2));
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: return m_poly.GetXN(2);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: return m_poly.GetYN(2);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: m_poly.SetXN(2' x);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: m_poly.SetYN(2' y);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,num_paths,The following statement contains a magic number: return 6;
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_border_width = (2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_curve_width = (2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_grid_width = (0.2);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_text_thickness = (1.5);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_point_size = (5.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_text_height = (9.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_yc2 = (y2 - m_text_height * 2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_yt1 = (y2 - m_text_height * 2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: gammaText = new TextWidget(""' pointSize: 11)  			{  				VAnchor = VAnchor.Top'  				HAnchor = HAnchor.Stretch'  				Margin = new BorderDouble(8' 4)  			};
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: gammaText = new TextWidget(""' pointSize: 11)  			{  				VAnchor = VAnchor.Top'  				HAnchor = HAnchor.Stretch'  				Margin = new BorderDouble(8' 4)  			};
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: gammaText = new TextWidget(""' pointSize: 11)  			{  				VAnchor = VAnchor.Top'  				HAnchor = HAnchor.Stretch'  				Margin = new BorderDouble(8' 4)  			};
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_background_color = new Color(1.0' 1.0' 0.9);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_grid_color = new Color(0.2' 0.2' 0.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_grid_color = new Color(0.2' 0.2' 0.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_colors[2] = m_inactive_pnt_color;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_colors[3] = m_active_pnt_color;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_colors[4] = m_text_color;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,text_size,The following statement contains a magic number: m_yc2 = BoundsRelativeToParent.Top - m_text_height * 2.0;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,text_size,The following statement contains a magic number: m_yt1 = BoundsRelativeToParent.Top - m_text_height * 2.0;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnMouseDown,The following statement contains a magic number: m_mouse_point = 2;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnMouseMove,The following statement contains a magic number: m_mouse_point == 2
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: kx1 -= 0.005;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: kx1 += 0.005;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: ky1 -= 0.005;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: ky1 += 0.005;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,num_paths,The following statement contains a magic number: return 5;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnDraw,The following statement contains a magic number: rewind(2);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnDraw,The following statement contains a magic number: rewind(3);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.MoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.Stop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.MoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.Stop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.MoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.Stop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.MoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.Stop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.MoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.Stop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.MoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.Stop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_spline_box,The following statement contains a magic number: m_ys2 = m_yc2 - m_border_width * 0.5;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_xp1 = m_xs1 + (m_xs2 - m_xs1) * kx1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_yp1 = m_ys1 + (m_ys2 - m_ys1) * ky1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_xp2 = m_xs2 - (m_xs2 - m_xs1) * kx2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_yp2 = m_ys2 - (m_ys2 - m_ys1) * ky2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: kx1 = (m_xp1 - m_xs1) * 4.0 / (m_xs2 - m_xs1);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: ky1 = (m_yp1 - m_ys1) * 4.0 / (m_ys2 - m_ys1);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: kx2 = (m_xs2 - m_xp2) * 4.0 / (m_xs2 - m_xs1);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: ky2 = (m_ys2 - m_yp2) * 4.0 / (m_ys2 - m_ys1);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx1 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx1 < 0.001
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx1 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx1 > 1.999
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky1 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky1 < 0.001
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky1 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky1 > 1.999
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 < 0.001
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 > 1.999
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 < 0.001
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 > 1.999
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[1] = kx1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[1] = ky1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[2] = 1.0 - kx2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[2] = 1.0 - kx2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[2] = 1.0 - ky2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[2] = 1.0 - ky2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[3] = 1.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[3] = 1.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_spline.init(4' m_x' m_y);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_gamma[i] = (byte)(y((double)(i) / 255.0) * 255.0);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_gamma[i] = (byte)(y((double)(i) / 255.0) * 255.0);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: i < 256
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx1 = m_x[1] * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky1 = m_y[1] * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 = (1.0 - m_x[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 = (1.0 - m_x[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 = (1.0 - m_y[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 = (1.0 - m_y[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,gamma_spline,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_background_color = new Color(1.0' 1.0' 0.9);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_point_size = (3.0);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_num_pnt = 4;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_num_pnt < 4
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_num_pnt = 32;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_num_pnt > 32
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_yp[i] = 0.5;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_spline_values[i] = m_spline.get((double)(i) / 255.0);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: kx -= 0.001;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: kx += 0.001;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: ky -= 0.001;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: ky += 0.001;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,update_spline,The following statement contains a magic number: m_spline_values[i] = m_spline.get((double)(i) / 255.0);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,update_spline,The following statement contains a magic number: m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,update_spline,The following statement contains a magic number: i < 256
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,num_paths,The following statement contains a magic number: return 5;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.Width = m_curve_width;  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.MoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.Stop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.Stop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,calc_curve,The following statement contains a magic number: m_curve_pnt.LineTo(m_xs1 + (m_xs2 - m_xs1) * (double)(i) / 255.0'  									m_ys1 + (m_ys2 - m_ys1) * m_spline_values[i]);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,calc_curve,The following statement contains a magic number: i < 256
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return m_background_color;    				case 1:  					return m_border_color;    				case 2:  					return m_curve_color;    				case 3:  					return m_inactive_pnt_color;    				case 4:  					return m_active_pnt_color;    				default:  					throw new System.IndexOutOfRangeException("You asked for a color out of range.");  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return m_background_color;    				case 1:  					return m_border_color;    				case 2:  					return m_curve_color;    				case 3:  					return m_inactive_pnt_color;    				case 4:  					return m_active_pnt_color;    				default:  					throw new System.IndexOutOfRangeException("You asked for a color out of range.");  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return m_background_color;    				case 1:  					return m_border_color;    				case 2:  					return m_curve_color;    				case 3:  					return m_inactive_pnt_color;    				case 4:  					return m_active_pnt_color;    				default:  					throw new System.IndexOutOfRangeException("You asked for a color out of range.");  			}
Magic Number,MatterHackers.Agg.UI,Animation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Animation.cs,Start,The following statement contains a magic number: runningInterval = UiThread.SetInterval(this.ProcessElapsedTime' this.SecondsPerUpdate / 2);
Magic Number,MatterHackers.Agg.UI,Animation,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Animation.cs,ProcessElapsedTime,The following statement contains a magic number: numSecondsPassedSinceLastUpdate = (double)((currentTimeMs - lastTimeMs) / 1000.0);
Magic Number,MatterHackers.Agg.UI,AverageMillisecondTimer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\AverageMillisecondTimer.cs,Draw,The following statement contains a magic number: graphics2D.DrawString("{0}ms {1:0.0}mb".FormatWith(GetAverage()' GC.GetTotalMemory(false) / 1000000)' x' y' 16' color: Color.White' drawFromHintedCach: true);
Magic Number,MatterHackers.Agg.UI,AverageMillisecondTimer,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\AverageMillisecondTimer.cs,Draw,The following statement contains a magic number: graphics2D.DrawString("{0}ms {1:0.0}mb".FormatWith(GetAverage()' GC.GetTotalMemory(false) / 1000000)' x' y' 16' color: Color.White' drawFromHintedCach: true);
Magic Number,MatterHackers.Agg.UI,ButtonViewThreeImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewThreeImage.cs,OnDraw,The following statement contains a magic number: double x = parentButton.Width / 2 - normalImage.Width / 2;
Magic Number,MatterHackers.Agg.UI,ButtonViewThreeImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewThreeImage.cs,OnDraw,The following statement contains a magic number: double x = parentButton.Width / 2 - normalImage.Width / 2;
Magic Number,MatterHackers.Agg.UI,ButtonViewThreeImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewThreeImage.cs,OnDraw,The following statement contains a magic number: double y = parentButton.Height / 2 - normalImage.Height / 2;
Magic Number,MatterHackers.Agg.UI,ButtonViewThreeImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewThreeImage.cs,OnDraw,The following statement contains a magic number: double y = parentButton.Height / 2 - normalImage.Height / 2;
Magic Number,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The following statement contains a magic number: GuiWidget boxSpace = new GuiWidget(CheckBoxWidth * 2' 1)  			{   				VAnchor = VAnchor.Center'  			};
Magic Number,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,OnDraw,The following statement contains a magic number: double bottom = LocalBounds.Bottom + (Height / 2 - CheckBoxWidth / 2);
Magic Number,MatterHackers.Agg.UI,CheckBoxViewText,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,OnDraw,The following statement contains a magic number: double bottom = LocalBounds.Bottom + (Height / 2 - CheckBoxWidth / 2);
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: indented.AddChild(new LineWidget(15' 5));
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: indented.AddChild(new LineWidget(15' 5));
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: TextWidget sizeAndPositon = new TextWidget(string.Format("  Size {0}' Position {1}"' widgetToAddInfoAbout.LocalBounds' widgetToAddInfoAbout.OriginRelativeParent)' pointSize: 8' textColor: Color.Red);
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: TextWidget boundsText = new TextWidget(string.Format("  Bounds {0}"' widgetToAddInfoAbout.BoundsRelativeToParent)' pointSize: 8' textColor: Color.Red);
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,topLevelWindow_MouseMove,The following statement contains a magic number: count == 20
Magic Number,MatterHackers.Agg.UI,LineWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(Width / 2' 0' Width / 2' Height' Color.Black);
Magic Number,MatterHackers.Agg.UI,LineWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(Width / 2' 0' Width / 2' Height' Color.Black);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: groupBoxLabel.Margin = new BorderDouble(20' 0' 0' -this.Padding.Top);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + Height - lineInset' groupBoxLabel.BoundsRelativeToParent.Left - 2' localBounds.Bottom + Height - lineInset' this.BorderColor);
Magic Number,MatterHackers.Agg.UI,GroupBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(groupBoxLabel.BoundsRelativeToParent.Right + 2' localBounds.Bottom + Height - lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + Height - lineInset' this.BorderColor);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,AllocateBackBuffer,The following statement contains a magic number: backBuffer = new ImageBuffer(intWidth' intHeight' 32' new BlenderPreMultBGRA());
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnLayout,The following statement contains a magic number: (LayoutCount % 11057) == 0
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: DrawBorderAndPaddingBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new Color(Red' 128));
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: DrawBorderAndPaddingBounds(graphics2D' LocalBounds' DevicePadding' new Color(Cyan' 128));
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' new Color(Green' 100)' 3);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' new Color(Green' 100)' 3);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' new Color(Green' 100)' 3);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' new Color(Green' 100)' 3);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.X' (int)MinimumSize.Y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.X' (int)MinimumSize.Y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.X' (int)MinimumSize.Y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.X' (int)MinimumSize.Y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,The following statement contains a magic number: double size = 10;
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,The following statement contains a magic number: rightArrow.MoveTo(new Vector2(size * 2' 0));
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,The following statement contains a magic number: rightArrow.LineTo(new Vector2(size * 1' size * .6));
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,RenderAnchoreInfo,The following statement contains a magic number: rightArrow.LineTo(new Vector2(size * 1' -size * .6));
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,IsDoubleClick,The following statement contains a magic number: mouseEvent.Clicks == 2  				&& LastMouseDownMs > UiThread.CurrentTimerMs - 550
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,IsDoubleClick,The following statement contains a magic number: mouseEvent.Clicks == 2  				&& LastMouseDownMs > UiThread.CurrentTimerMs - 550
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,FindDescendants,The following statement contains a magic number: foundChildren.Add(new WidgetAndPosition(this' new Point2D(Width / 2' Height / 2)' Name));
Magic Number,MatterHackers.Agg.UI,GuiWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,FindDescendants,The following statement contains a magic number: foundChildren.Add(new WidgetAndPosition(this' new Point2D(Width / 2' Height / 2)' Name));
Magic Number,MatterHackers.Agg.UI,ImageSequenceWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ImageSequenceWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(  					currentImage'  					Width / 2 - (currentImage.Width * ratio) / 2'  					Height / 2 - (currentImage.Height * ratio) / 2'  					0'  					ratio'  					ratio);
Magic Number,MatterHackers.Agg.UI,ImageSequenceWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ImageSequenceWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(  					currentImage'  					Width / 2 - (currentImage.Width * ratio) / 2'  					Height / 2 - (currentImage.Height * ratio) / 2'  					0'  					ratio'  					ratio);
Magic Number,MatterHackers.Agg.UI,ImageSequenceWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ImageSequenceWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(  					currentImage'  					Width / 2 - (currentImage.Width * ratio) / 2'  					Height / 2 - (currentImage.Height * ratio) / 2'  					0'  					ratio'  					ratio);
Magic Number,MatterHackers.Agg.UI,ImageSequenceWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ImageSequenceWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(  					currentImage'  					Width / 2 - (currentImage.Width * ratio) / 2'  					Height / 2 - (currentImage.Height * ratio) / 2'  					0'  					ratio'  					ratio);
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The following statement contains a magic number: newHeight = parentUsableHeight / 2 - child.DeviceMarginAndBorder.Height;
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The following statement contains a magic number: newWidth = parentUsableWidth / 2 - (child.DeviceMarginAndBorder.Left + child.DeviceMarginAndBorder.Right);
Magic Number,MatterHackers.Agg.UI,ListBoxTextItem,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ListBox.cs,ListBoxTextItem,The following statement contains a magic number: Padding = new BorderDouble(3);
Magic Number,MatterHackers.Agg.UI,ListBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ListBox.cs,AddChild,The following statement contains a magic number: itemHolder.Margin = new BorderDouble(3' 0' 0' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: mainControlText = new TextWidget(noSelectionString' pointSize: pointSize' textColor: textColor)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.Bottom | VAnchor.Fit'  				HAnchor = HAnchor.Left | HAnchor.Fit'  				Margin = new BorderDouble(10' 7' 7' 7)'  			};
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: mainControlText = new TextWidget(noSelectionString' pointSize: pointSize' textColor: textColor)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.Bottom | VAnchor.Fit'  				HAnchor = HAnchor.Left | HAnchor.Fit'  				Margin = new BorderDouble(10' 7' 7' 7)'  			};
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: mainControlText = new TextWidget(noSelectionString' pointSize: pointSize' textColor: textColor)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.Bottom | VAnchor.Fit'  				HAnchor = HAnchor.Left | HAnchor.Fit'  				Margin = new BorderDouble(10' 7' 7' 7)'  			};
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: mainControlText = new TextWidget(noSelectionString' pointSize: pointSize' textColor: textColor)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.Bottom | VAnchor.Fit'  				HAnchor = HAnchor.Left | HAnchor.Fit'  				Margin = new BorderDouble(10' 7' 7' 7)'  			};
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: var borderColor = new Color(textColor' 40);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 7' 7' 7);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 7' 7' 7);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 7' 7' 7);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 7' 7' 7);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.BackgroundColor = new Color(255' 255' 255' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.BackgroundColor = new Color(255' 255' 255' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.BackgroundColor = new Color(255' 255' 255' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,OnBoundsChanged,The following statement contains a magic number: dropArrowBounds = new RectangleDouble(LocalBounds.Right - DropArrow.ArrowHeight * 4' 0' LocalBounds.Right' this.Height);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The following statement contains a magic number: currentPadding = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The following statement contains a magic number: currentPadding = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: int size = (int)(20 * GuiWidget.DeviceScale + .5);
Magic Number,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: int size = (int)(20 * GuiWidget.DeviceScale + .5);
Magic Number,MatterHackers.Agg.UI,Menu,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,AddHorizontalLine,The following statement contains a magic number: var menuItem = new MenuItem(new GuiWidget()  			{  				HAnchor = HAnchor.Stretch'  				Height = 1'  				BackgroundColor = Color.LightGray'  				Margin = new BorderDouble(10' 1)'  				VAnchor = VAnchor.Center'  			}' "HorizontalLine");
Magic Number,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(new Stroke(outline' BorderWidth * 2)' BorderColor);
Magic Number,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,ScrollIntoView,The following statement contains a magic number: scrollingWindow.ScrollPosition = new Vector2(0' -widget.BoundsRelativeToParent.Bottom + this.Height / 2);
Magic Number,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,AllowClickingItems,The following statement contains a magic number: return (scrollPositionAtMouseDown - scrollPositionAtMouseUp).Length <= 5;
Magic Number,MatterHackers.Agg.UI,PopupWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,MakeMenuHaveScroll,The following statement contains a magic number: scrollingWindow.MinimumSize = new Vector2(Width + 15' 0);
Magic Number,MatterHackers.Agg.UI,PopupLayoutEngine,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\PopupWidget.cs,recalculatePosition,The following statement contains a magic number: var minimumOpenHeight = 50;
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,ShowMessageBox,The following statement contains a magic number: MessageBox messageBox = new MessageBox(message' caption' messageType' 400' 300);
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,ShowMessageBox,The following statement contains a magic number: MessageBox messageBox = new MessageBox(message' caption' messageType' 400' 300);
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new Color(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new Color(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new Color(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new Color(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: topToBottomFlow.AddChild(new GuiWidget(10' 10));
Magic Number,MatterHackers.Agg.UI,MessageBox,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: topToBottomFlow.AddChild(new GuiWidget(10' 10));
Magic Number,MatterHackers.Agg.UI,OutputScroll,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\OutputScroll.cs,OnDraw,The following statement contains a magic number: double y = LocalBounds.Bottom + printer.TypeFaceStyle.EmSizeInPixels * (TOTOL_POW2 - 1) + 5;
Magic Number,MatterHackers.Agg.UI,OutputScroll,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\OutputScroll.cs,OnDraw,The following statement contains a magic number: printer.Origin = new Vector2(Bounds.Left + 2' y);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: Margin = new BorderDouble(5);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: Padding = new BorderDouble(3);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new Color()'  					TextColor = new Color(20' 120' 20)'  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new Color()'  					TextColor = new Color(20' 120' 20)'  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new Color()'  					TextColor = new Color(20' 120' 20)'  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new Color()'  					TextColor = new Color(20' 120' 20)'  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: BackgroundColor = new Color(Color.White' 180);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,Start,The following statement contains a magic number: PerformanceTimerDisplayData newTimerData = new PerformanceTimerDisplayData(timer.Name)  				{  					widget = new TextWidget("waiting")  					{  						AutoExpandBoundsToText = true'  						TextColor = new Color(120' 20' 20)'  						HAnchor = HAnchor.Left'  					}  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,Start,The following statement contains a magic number: PerformanceTimerDisplayData newTimerData = new PerformanceTimerDisplayData(timer.Name)  				{  					widget = new TextWidget("waiting")  					{  						AutoExpandBoundsToText = true'  						TextColor = new Color(120' 20' 20)'  						HAnchor = HAnchor.Left'  					}  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,Start,The following statement contains a magic number: PerformanceTimerDisplayData newTimerData = new PerformanceTimerDisplayData(timer.Name)  				{  					widget = new TextWidget("waiting")  					{  						AutoExpandBoundsToText = true'  						TextColor = new Color(120' 20' 20)'  						HAnchor = HAnchor.Left'  					}  				};
Magic Number,MatterHackers.Agg.UI,PerformancePanel,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,ParentWindow_MouseDown,The following statement contains a magic number: e.NumPositions == 4
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: x = m_polygon[m_vertex * 2];
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: y = m_polygon[m_vertex * 2 + 1];
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: x = Math.Floor(x) + 0.5;
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: y = Math.Floor(y) + 0.5;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,polygon_ctrl_impl,The following statement contains a magic number: m_polygon = new ArrayPOD<double>(np * 2);
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,GetXN,The following statement contains a magic number: return m_polygon.Array[n * 2];
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,SetXN,The following statement contains a magic number: m_polygon.Array[n * 2] = newXN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,AddXN,The following statement contains a magic number: m_polygon.Array[n * 2] += newXN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,GetYN,The following statement contains a magic number: return m_polygon.Array[n * 2 + 1];
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,SetYN,The following statement contains a magic number: m_polygon.Array[n * 2 + 1] = newYN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,AddYN,The following statement contains a magic number: m_polygon.Array[n * 2 + 1] += newYN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: r *= 1.2;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: m_ellipse.init(GetXN(m_status)' GetYN(m_status)' r' r' 32);
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: r *= 1.2;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: m_ellipse.init(GetXN(m_status)' GetYN(m_status)' r' r' 32);
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,check_edge,The following statement contains a magic number: Math.Sqrt(dx * dx + dy * dy) > 0.0000001
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,point_in_polygon,The following statement contains a magic number: m_num_points < 3
Magic Number,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The following statement contains a magic number: this.AddChild(processTextWidget = new TextWidget(message' textColor: textColor)  			{  				AutoExpandBoundsToText = true'  				Margin = new BorderDouble(leftMargin' 0' 5' 0)'  				VAnchor = VAnchor.Center'  			});
Magic Number,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The following statement contains a magic number: this.AddChild(progressTextWidget = new TextWidget(""' textColor: textColor' pointSize: 8)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.Center'  				Margin = new BorderDouble(5' 0)'  			});
Magic Number,MatterHackers.Agg.UI,ProgressControl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The following statement contains a magic number: this.AddChild(progressTextWidget = new TextWidget(""' textColor: textColor' pointSize: 8)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.Center'  				Margin = new BorderDouble(5' 0)'  			});
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,RadioButtonGroup,The following statement contains a magic number: Padding = new BorderDouble(5);
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,RadioButtonGroup,The following statement contains a magic number: backgroundColor = (new ColorF(1.0' 1.0' 0.9));
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,RadioButtonGroup,The following statement contains a magic number: activeColor = (new ColorF(0.4' 0.0' 0.0));
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,OnDraw,The following statement contains a magic number: RoundedRect backgroundRect = new RoundedRect(LocalBounds' 4);
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,AddRadioButton,The following statement contains a magic number: RadioButton newRadioButton = new RadioButton(text)  			{  				TextColor = Color.Black'  				Margin = new BorderDouble(5' 0)'  				HAnchor = UI.HAnchor.Left'  			};
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return backgroundColor;    				case 1:  					return borderColor;    				case 2:  					return textColor;    				case 3:  					return inactiveColor;    				case 4:  					return activeColor;    				default:  					throw new System.IndexOutOfRangeException("There is not a color for this index");  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return backgroundColor;    				case 1:  					return borderColor;    				case 2:  					return textColor;    				case 3:  					return inactiveColor;    				case 4:  					return activeColor;    				default:  					throw new System.IndexOutOfRangeException("There is not a color for this index");  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return backgroundColor;    				case 1:  					return borderColor;    				case 2:  					return textColor;    				case 3:  					return inactiveColor;    				case 4:  					return activeColor;    				default:  					throw new System.IndexOutOfRangeException("There is not a color for this index");  			}
Magic Number,MatterHackers.Agg.UI,RadioCircleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,RadioCircleWidget,The following statement contains a magic number: this.Margin = new BorderDouble(right: 10);
Magic Number,MatterHackers.Agg.UI,RadioImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DrawCircle,The following statement contains a magic number: graphics2D.Circle(center' BoxWidth / 4' color);
Magic Number,MatterHackers.Agg.UI,RadioImage,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DrawCircle,The following statement contains a magic number: int strokeWidth = (isActive) ? 2 : 1;
Magic Number,MatterHackers.Agg.UI,RelativeTime,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\RelativeTime.cs,GetTimeBlock,The following statement contains a magic number: timeToDescribe < now.AddMinutes(10)
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnKeyDown,The following statement contains a magic number: switch (keyEvent.KeyCode)  				{  					case Keys.Down:  						ScrollPosition += new Vector2(0' 16);  						break;    					case Keys.PageDown:  						ScrollPosition += new Vector2(0' Height - 20);  						break;    					case Keys.Up:  						ScrollPosition -= new Vector2(0' 16);  						break;    					case Keys.PageUp:  						ScrollPosition -= new Vector2(0' Height - 20);  						break;  				}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnKeyDown,The following statement contains a magic number: switch (keyEvent.KeyCode)  				{  					case Keys.Down:  						ScrollPosition += new Vector2(0' 16);  						break;    					case Keys.PageDown:  						ScrollPosition += new Vector2(0' Height - 20);  						break;    					case Keys.Up:  						ScrollPosition -= new Vector2(0' 16);  						break;    					case Keys.PageUp:  						ScrollPosition -= new Vector2(0' Height - 20);  						break;  				}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnKeyDown,The following statement contains a magic number: switch (keyEvent.KeyCode)  				{  					case Keys.Down:  						ScrollPosition += new Vector2(0' 16);  						break;    					case Keys.PageDown:  						ScrollPosition += new Vector2(0' Height - 20);  						break;    					case Keys.Up:  						ScrollPosition -= new Vector2(0' 16);  						break;    					case Keys.PageUp:  						ScrollPosition -= new Vector2(0' Height - 20);  						break;  				}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnKeyDown,The following statement contains a magic number: switch (keyEvent.KeyCode)  				{  					case Keys.Down:  						ScrollPosition += new Vector2(0' 16);  						break;    					case Keys.PageDown:  						ScrollPosition += new Vector2(0' Height - 20);  						break;    					case Keys.Up:  						ScrollPosition -= new Vector2(0' 16);  						break;    					case Keys.PageUp:  						ScrollPosition -= new Vector2(0' Height - 20);  						break;  				}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseMove,The following statement contains a magic number: ScrollPosition.Y < scrollOnDownY - 10  				|| ScrollPosition.Y > scrollOnDownY + 10
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseMove,The following statement contains a magic number: ScrollPosition.Y < scrollOnDownY - 10  				|| ScrollPosition.Y > scrollOnDownY + 10
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseWheel,The following statement contains a magic number: ScrollPosition += new Vector2(0' -mouseEvent.WheelDelta / 5);
Magic Number,MatterHackers.Agg.UI,ScrollingArea,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollingArea.cs,ValidateScrollPosition,The following statement contains a magic number: debugRecursionCount < 20
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackHeight = 3;
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackColor = new Color(220' 220' 220);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackColor = new Color(220' 220' 220);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackColor = new Color(220' 220' 220);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackBounds,The following statement contains a magic number: trackBounds = new RectangleDouble(0' -TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels' TrackHeight / 2);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackBounds,The following statement contains a magic number: trackBounds = new RectangleDouble(0' -TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels' TrackHeight / 2);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTextPosition,The following statement contains a magic number: textPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' GetThumbBounds().Bottom - textHeight);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: RoundedRect track = new RoundedRect(GetTrackBounds()' TrackHeight / 2);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: ValuePrintPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' -sliderAttachedTo.ThumbHeight - 12);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: ValuePrintPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' -sliderAttachedTo.ThumbHeight - 12);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: RoundedRect thumbOutside = new RoundedRect(thumbBounds' sliderAttachedTo.ThumbWidth / 2);
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: graphics2D.Render(thumbOutside' ColorF.GetTweenColor(ThumbColor.ToColorF()' ColorF.Black.ToColorF()' .2).ToColor());
Magic Number,MatterHackers.Agg.UI,SlideView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: RoundedRect thumbInside = new RoundedRect(thumbBounds' sliderAttachedTo.ThumbWidth / 2);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The following statement contains a magic number: ThumbWidth = 10;
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The following statement contains a magic number: ThumbHeight = 20;
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetPositionPixelsFromValue,The following statement contains a magic number: return ThumbWidth / 2 + TrackWidth * GetPosition0To1FromValue(value);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackHitBounds,The following statement contains a magic number: return new RectangleDouble(0' -ThumbHeight / 2'  					TotalWidthInPixels' ThumbHeight / 2);
Magic Number,MatterHackers.Agg.UI,Slider,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackHitBounds,The following statement contains a magic number: return new RectangleDouble(0' -ThumbHeight / 2'  					TotalWidthInPixels' ThumbHeight / 2);
Magic Number,MatterHackers.Agg.UI,SoftKeyboard,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,MakeKeyButtons,The following statement contains a magic number: int buttonHeight = (int)Height / 4;
Magic Number,MatterHackers.Agg.UI,SoftKeyboard,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,MakeKeyButtons,The following statement contains a magic number: int y = buttonHeight * 3;
Magic Number,MatterHackers.Agg.UI,SoftKeyboard,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,MakeKeyButtons,The following statement contains a magic number: buttonWidth = (int)Width / (bottonRow3.Length + 2);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The following statement contains a magic number: keyboard = new SoftKeyboard(800' 300);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The following statement contains a magic number: keyboard = new SoftKeyboard(800' 300);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,DoShowSoftwareKeyboard,The following statement contains a magic number: content.OriginRelativeParent = new Vector2(0' topOfKeyboard - textWidgetScreenBounds.Bottom + 3);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardContentOffset,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardContentOffset,The following statement contains a magic number: KeyboardHeight = 253;
Magic Number,MatterHackers.Agg.UI,SoftKeyboardContentOffset,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,EnsureEditControlIsVisible,The following statement contains a magic number: content.OriginRelativeParent = new Vector2(0' topOfKeyboard - textWidgetScreenBounds.Bottom + 10);
Magic Number,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The following statement contains a magic number: splitterBar = new SplitterBar(this)  			{  				BackgroundColor = Color.Transparent'  				Width = 6'  			};
Magic Number,MatterHackers.Agg.UI,Splitter,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The following statement contains a magic number: SplitterDistance = 120;
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,ToolTipManager,The following statement contains a magic number: runningInterval = UiThread.SetInterval(CheckIfNeedToDisplayToolTip' .05);
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = Color.White'  						OriginRelativeParent = new Vector2((int)mousePosition.X' (int)mousePosition.Y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)  					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.Fit'  					});
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: offset.X = systemWindowBounds.Right - toolTipBoundsRelativeToParent.Right - 3;
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: toolTipBoundsRelativeToParent.Right > systemWindowBounds.Right - 3
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: offset.Y = screenBoundsShowingTT.Top - toolTipBoundsRelativeToParent.Bottom + 3;
Magic Number,MatterHackers.Agg.UI,ToolTipManager,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: toolTipBoundsRelativeToParent.Bottom < systemWindowBounds.Bottom + 3
Magic Number,MatterHackers.Agg.UI,TextTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,TextTab,The following statement contains a magic number: normalWidget.Padding = new BorderDouble(10);
Magic Number,MatterHackers.Agg.UI,TextTab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,TextTab,The following statement contains a magic number: selectedWidget.Padding = new BorderDouble(10' 0);
Magic Number,MatterHackers.Agg.UI,Tab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: this.Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,Tab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: this.Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,Tab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: this.Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,Tab,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: this.Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,UpdateLocalBounds,The following statement contains a magic number: double width = Math.Max(internalTextWidget.Width + 2' 3);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,UpdateLocalBounds,The following statement contains a magic number: double width = Math.Max(internalTextWidget.Width + 2' 3);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnIdle,The following statement contains a magic number: timeSinceTurnOn.ElapsedMilliseconds >= (barOnTime + barOffTime) * 950
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnIdle,The following statement contains a magic number: this.Focused  				&& timeSinceTurnOn.ElapsedMilliseconds >= barOnTime * 950  				&& !HasBeenClosed
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnDraw,The following statement contains a magic number: boundsPlusPoint5.Inflate(-.5);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseDown,The following statement contains a magic number: mouseEvent.Clicks < 2
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The following statement contains a magic number: keyPressEvent.KeyChar < 32  					&& keyPressEvent.KeyChar != 13  					&& keyPressEvent.KeyChar != 9
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The following statement contains a magic number: keyPressEvent.KeyChar < 32  					&& keyPressEvent.KeyChar != 13  					&& keyPressEvent.KeyChar != 9
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The following statement contains a magic number: keyPressEvent.KeyChar < 32  					&& keyPressEvent.KeyChar != 13  					&& keyPressEvent.KeyChar != 9
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GetIndexOffset,The following statement contains a magic number: Math.Abs(offset.Y) < .01  						&& Math.Abs(lastOffset.X - DesiredPixelOffset) < Math.Abs(offset.X - DesiredPixelOffset)
Magic Number,MatterHackers.Agg.UI,TextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,internalTextEditWidget_InsertBarPositionChanged,The following statement contains a magic number: requiredOffet.X = currentOffsetInView.X - Width + 2;
Magic Number,MatterHackers.Agg.UI,TextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,internalTextEditWidget_InsertBarPositionChanged,The following statement contains a magic number: currentOffsetInView.X > Width - 2
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,TextWidget,The following statement contains a magic number: disabledColor = new Color(textColor' 50);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: switch (Printer.Justification)  			{  				case Justification.Left:  					break;    				case Justification.Center:  					xOffsetForText = (Width - Printer.LocalBounds.Width) / 2;  					break;    				case Justification.Right:  					xOffsetForText = Width - Printer.LocalBounds.Width;  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: shortTextPrinter = new TypeFacePrinter(shortTextPrinter.Text.Substring(0' shortTextPrinter.Text.Length - 4).TrimEnd(spaceTrim) + "..."' Printer);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: shortTextPrinter.LocalBounds.Width > LocalBounds.Width && shortTextPrinter.Text.Length > 4
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.FillRectangle(this.Width - 12' this.Height - 13' this.Width' this.Height' new Color(Color.White' 100));
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.FillRectangle(this.Width - 12' this.Height - 13' this.Width' this.Height' new Color(Color.White' 100));
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.FillRectangle(this.Width - 12' this.Height - 13' this.Width' this.Height' new Color(Color.White' 100));
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(this.PointSize.ToString()' this.Width - 10' this.Height - 11' 7' color: Color.Black);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(this.PointSize.ToString()' this.Width - 10' this.Height - 11' 7' color: Color.Black);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(this.PointSize.ToString()' this.Width - 10' this.Height - 11' 7' color: Color.Black);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(this.PointSize.ToString()' this.Width - 11' this.Height - 12' 7' color: Color.Red);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(this.PointSize.ToString()' this.Width - 11' this.Height - 12' 7' color: Color.Red);
Magic Number,MatterHackers.Agg.UI,TextWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.DrawString(this.PointSize.ToString()' this.Width - 11' this.Height - 12' 7' color: Color.Red);
Magic Number,MatterHackers.Agg.UI,ToggleSwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The following statement contains a magic number: switchNormalToPressed.AddChild(new TextWidget(word' pointSize: 10' textColor: textColor)  				{  					VAnchor = VAnchor.Center'  					Margin = new BorderDouble(right: 5)  				});
Magic Number,MatterHackers.Agg.UI,ToggleSwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The following statement contains a magic number: switchNormalToPressed.AddChild(new TextWidget(word' pointSize: 10' textColor: textColor)  				{  					VAnchor = VAnchor.Center'  					Margin = new BorderDouble(right: 5)  				});
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The following statement contains a magic number: var thumbWidth = 14;
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The following statement contains a magic number: disabledBorderColor = new Color(borderColor' 50);
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The following statement contains a magic number: innerRect.Inflate(new BorderDouble(-3' -6));
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The following statement contains a magic number: innerRect.Inflate(new BorderDouble(-3' -6));
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The following statement contains a magic number: borderRect.Inflate(new BorderDouble(0' -3));
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(thumbBounds' new Color(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(thumbBounds' new Color(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(thumbBounds' new Color(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,SwitchView,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(thumbBounds' new Color(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,UiThread,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\UiThread.cs,RunOnIdle,The following statement contains a magic number: deferredActions.Add(new DeferredAction(action' timer.ElapsedMilliseconds + (int)(delayInSeconds * 1000)));
Magic Number,MatterHackers.Agg.UI,TitleBarWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\TitleBarWidget.cs,OnMouseMove,The following statement contains a magic number: dragPosition.X = agg_basics.Clamp(dragPosition.X' -windowToDrag.Width + 10' windowToDragParent.Width - 10);
Magic Number,MatterHackers.Agg.UI,TitleBarWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\TitleBarWidget.cs,OnMouseMove,The following statement contains a magic number: dragPosition.X = agg_basics.Clamp(dragPosition.X' -windowToDrag.Width + 10' windowToDragParent.Width - 10);
Magic Number,MatterHackers.Agg.UI,TitleBarWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\TitleBarWidget.cs,OnMouseMove,The following statement contains a magic number: dragPosition.Y = agg_basics.Clamp(dragPosition.Y' -windowToDrag.Height + 10' windowToDragParent.Height - windowToDrag.Height);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: TitleBar = new TitleBarWidget(this)  			{  				Size = new Vector2(0' 30 * GuiWidget.DeviceScale)'  				HAnchor = HAnchor.Stretch'  			};
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: MinimumSize = new Vector2(grabWidth * 8' grabWidth * 4 + TitleBar.Height * 2);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: MinimumSize = new Vector2(grabWidth * 8' grabWidth * 4 + TitleBar.Height * 2);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: MinimumSize = new Vector2(grabWidth * 8' grabWidth * 4 + TitleBar.Height * 2);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: Size = clientArea.Size + new Vector2(grabWidth * 2' grabWidth * 2 + TitleBar.Height);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: Size = clientArea.Size + new Vector2(grabWidth * 2' grabWidth * 2 + TitleBar.Height);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: var color = new Color(Color.Black' 100 * i / grabWidth);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					i + .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					i + .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					i + .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					i + .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(Width - i - .5'  					i + .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(Width - i - .5'  					i + .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(Width - i - .5'  					i + .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(Width - i - .5'  					i + .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					Width - i - .5'  					i + .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					Width - i - .5'  					i + .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					Width - i - .5'  					i + .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					i + .5'  					Width - i - .5'  					i + .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					Height - i - .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					Height - i - .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					Height - i - .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg.UI,WindowWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,OnDrawBackground,The following statement contains a magic number: graphics2D.Line(i + .5'  					Height - i - .5'  					Width - i - .5'  					Height - i - .5'  					color);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(objectCenterScreenSpace' 5' Color.Magenta);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(worldView.GetScreenPosition(bounds.GetTopCorner(i))' 5' Color.Magenta);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(worldView.GetScreenPosition(bounds.GetBottomCorner(i))' 5' Color.Magenta);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: i < 4
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(screenBoundsOfObject3D.Left' screenBoundsOfObject3D.Bottom' 5' Color.Cyan);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(screenBoundsOfObject3D.Left' screenBoundsOfObject3D.Top' 5' Color.Cyan);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(screenBoundsOfObject3D.Right' screenBoundsOfObject3D.Bottom' 5' Color.Cyan);
Magic Number,MatterHackers.Agg,ExtensionMethods,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RenderDebugAABB,The following statement contains a magic number: graphics2D.Circle(screenBoundsOfObject3D.Right' screenBoundsOfObject3D.Top' 5' Color.Cyan);
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RecalculateProjection,The following statement contains a magic number: double trackingRadius = Math.Min(Width * .45' Height * .45);
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RecalculateProjection,The following statement contains a magic number: double trackingRadius = Math.Min(Width * .45' Height * .45);
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RecalculateProjection,The following statement contains a magic number: TrackBallController.ScreenCenter = new Vector2(Width / 2 - CenterOffsetX' Height / 2);
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RecalculateProjection,The following statement contains a magic number: TrackBallController.ScreenCenter = new Vector2(Width / 2 - CenterOffsetX' Height / 2);
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RecalculateProjection,The following statement contains a magic number: var zNear = .1;
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,RecalculateProjection,The following statement contains a magic number: var zFar = 100.0;
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,ApplyVelocity,The following statement contains a magic number: double msPerUpdate = 1000.0 / updatesPerSecond;
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,ApplyVelocity,The following statement contains a magic number: currentVelocityPerMs *= .85;
Magic Number,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,ApplyVelocity,The following statement contains a magic number: currentVelocityPerMs.LengthSquared < .01 / msPerUpdate
Magic Number,MatterHackers.Agg,MotionQueue,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,AddMoveToMotionQueue,The following statement contains a magic number: motionQueue.Count > 4
Magic Number,MatterHackers.Agg,MotionQueue,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,GetVelocityPixelsPerMs,The following statement contains a magic number: firstTimeIndex > 0 && motionQueue[firstTimeIndex - 1].timeMs + 100 > lastTime.timeMs
Missing Default,MatterHackers.Agg.UI,bezier_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following switch statement is missing a default case: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Missing Default,MatterHackers.Agg.UI,curve3_ctrl_impl,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following switch statement is missing a default case: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Missing Default,MatterHackers.Agg.UI,Keyboard,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Keyboard.cs,SetKeyDownState,The following switch statement is missing a default case: switch(key)  			{  				case Keys.LControlKey:  				case Keys.RControlKey:  				case Keys.ControlKey:  					SetKeyDownState(Keys.Control' down);  					break;    				case Keys.LShiftKey:  				case Keys.RShiftKey:  				case Keys.ShiftKey:  					SetKeyDownState(Keys.Shift' down);  					break;    				case Keys.Menu:  					SetKeyDownState(Keys.Alt' down);  					break;  			}
Missing Default,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,ShowMenu,The following switch statement is missing a default case: switch (e.KeyCode)  				{  					case Keys.Up:  						if (highLightedIndex > 0)  						{  							highLightedIndex--;  						}  						e.Handled = true;  						break;    					case Keys.Down:  						if (highLightedIndex < this.MenuItems.Count - 1)  						{  							highLightedIndex++;  						}  						e.Handled = true;  						break;  				}
Missing Default,MatterHackers.Agg.UI,DropDownList,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,ShowMenu,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  				{  					case Keys.Escape:  						listFilterText = new StringBuilder();  						DropDownContainer.CloseMenu();  						break;    					case Keys.Enter:    						if (highlightedItem != null)  						{  							SelectedIndex = MenuItems.IndexOf(highlightedItem);  							DropDownContainer.CloseMenu();  							listFilterText = null;  						}    						break;    					case Keys.Back:  						if (listFilterText != null && listFilterText.Length > 0)  						{  							listFilterText.Length -= 1;  						}    						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;    						ApplyFilter();    						break;  				}
Missing Default,MatterHackers.Agg.UI,ScrollableWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnKeyDown,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  				{  					case Keys.Down:  						ScrollPosition += new Vector2(0' 16);  						break;    					case Keys.PageDown:  						ScrollPosition += new Vector2(0' Height - 20);  						break;    					case Keys.Up:  						ScrollPosition -= new Vector2(0' 16);  						break;    					case Keys.PageUp:  						ScrollPosition -= new Vector2(0' Height - 20);  						break;  				}
Missing Default,MatterHackers.Agg.UI,ScrollBar,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,UpdateScrollBar,The following switch statement is missing a default case: switch (Show)  			{  				case ShowState.WhenRequired:  					if (ParentScrollWidget.ScrollArea.Height > ParentScrollWidget.Height)  					{  						goto case ShowState.Always;  					}  					else  					{  						goto case ShowState.Never;  					}    				case ShowState.Always:  					// make sure we can see it  					Visible = true;  					// fix the bounds of the scroll bar background  					LocalBounds = new RectangleDouble(0' 0' ScrollBarWidth' ParentScrollWidget.Height);  					background.LocalBounds = LocalBounds;    					// On hover' grow the thumb bounds by the given value  					int growAmount = (mouseInBounds) ? 0 : ScrollBar.GrowThumbBy;  					thumb.LocalBounds = new RectangleDouble(growAmount' 0' ScrollBarWidth - growAmount' ThumbHeight);    					Vector2 scrollRatioFromTop0To1 = ParentScrollWidget.ScrollRatioFromTop0To1;  					double notThumbHeight = ParentScrollWidget.Height - ThumbHeight;  					thumb.OriginRelativeParent = new Vector2(0' notThumbHeight * scrollRatioFromTop0To1.Y);  					break;    				case ShowState.Never:  					Visible = false;  					break;  			}
Missing Default,MatterHackers.Agg.UI,TabBar,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TabControl\TabBar.cs,OnDraw,The following switch statement is missing a default case: switch (FlowDirection)  			{  				case UI.FlowDirection.LeftToRight:  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Bottom' this.BorderColor);  					break;    				case UI.FlowDirection.TopToBottom:  					graphics2D.Line(LocalBounds.Right' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' this.BorderColor);  					break;  			}
Missing Default,MatterHackers.Agg.UI,InternalNumberEdit,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,OnKeyDown,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  				{  					case Keys.Up:  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						Value = Value + increment;  						OnEditComplete(keyEvent);  						break;    					case Keys.Down:  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						Value = Value - increment;  						OnEditComplete(keyEvent);  						break;  				}
Missing Default,MatterHackers.Agg.UI,InternalTextEditWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyDown,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  				{  					case Keys.Escape:  						if (Selecting)  						{  							turnOffSelection = true;  							keyEvent.SuppressKeyPress = true;  							keyEvent.Handled = true;  						}  						break;    					case Keys.Left:  						StartSelectionIfRequired(keyEvent);  						if (keyEvent.Control)  						{  							GotoBeginingOfPreviousToken();  						}  						else if (CharIndexToInsertBefore > 0)  						{  							if (turnOffSelection)  							{  								CharIndexToInsertBefore = Math.Min(CharIndexToInsertBefore' SelectionIndexToStartBefore);  							}  							else  							{  								CharIndexToInsertBefore--;  							}  						}  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						break;    					case Keys.Right:  						StartSelectionIfRequired(keyEvent);  						if (keyEvent.Control)  						{  							GotoBeginingOfNextToken();  						}  						else if (CharIndexToInsertBefore < internalTextWidget.Text.Length)  						{  							if (turnOffSelection)  							{  								CharIndexToInsertBefore = Math.Max(CharIndexToInsertBefore' SelectionIndexToStartBefore);  							}  							else  							{  								CharIndexToInsertBefore++;  							}  						}  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						break;    					case Keys.Up:  						StartSelectionIfRequired(keyEvent);  						if (turnOffSelection)  						{  							CharIndexToInsertBefore = Math.Min(CharIndexToInsertBefore' SelectionIndexToStartBefore);  						}  						GotoLineAbove();  						SetDesiredBarPosition = false;  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						break;    					case Keys.Down:  						StartSelectionIfRequired(keyEvent);  						if (turnOffSelection)  						{  							CharIndexToInsertBefore = Math.Max(CharIndexToInsertBefore' SelectionIndexToStartBefore);  						}  						GotoLineBelow();  						SetDesiredBarPosition = false;  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						break;    					case Keys.Space:  						keyEvent.Handled = true;  						break;    					case Keys.End:  						StartSelectionIfRequired(keyEvent);  						if (keyEvent.Control)  						{  							CharIndexToInsertBefore = internalTextWidget.Text.Length;  						}  						else  						{  							GotoEndOfCurrentLine();  						}    						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						break;    					case Keys.Home:  						StartSelectionIfRequired(keyEvent);  						if (keyEvent.Control)  						{  							CharIndexToInsertBefore = 0;  						}  						else  						{  							GotoStartOfCurrentLine();  						}    						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  						break;    					case Keys.Back:  						if (!Selecting  							&& CharIndexToInsertBefore > 0)  						{  							SelectionIndexToStartBefore = CharIndexToInsertBefore - 1;  							Selecting = true;  						}    						DeleteSelection();    						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  						break;    					case Keys.Delete:  						if (ShiftKeyIsDown(keyEvent))  						{  							CopySelection();  							DeleteSelection();  							keyEvent.SuppressKeyPress = true;  						}  						else  						{  							if (!Selecting  							&& CharIndexToInsertBefore < internalTextWidget.Text.Length)  							{  								SelectionIndexToStartBefore = CharIndexToInsertBefore + 1;  								Selecting = true;  							}    							DeleteSelection();  						}    						turnOffSelection = true;  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  						break;    					case Keys.Enter:  						if (!Multiline)  						{  							// TODO: do the right thing.  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;    							if (EnterPressed != null)  							{  								EnterPressed(this' keyEvent);  							}    							if (TextHasChanged())  							{  								OnEditComplete(keyEvent);  							}  						}  						break;    					case Keys.Insert:  						if (ShiftKeyIsDown(keyEvent))  						{  							turnOffSelection = true;  							PasteFromClipboard();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						if (keyEvent.Control)  						{  							turnOffSelection = false;  							CopySelection();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;    					case Keys.A:  						if (keyEvent.Control)  						{  							SelectAll();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;    					case Keys.X:  						if (keyEvent.Control)  						{  							CopySelection();  							DeleteSelection();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;    					case Keys.C:  						if (keyEvent.Control)  						{  							turnOffSelection = false;  							CopySelection();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;    					case Keys.V:  						if (keyEvent.Control)  						{  							PasteFromClipboard();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;    					case Keys.Z:  						if (keyEvent.Control)  						{  							Undo();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;    					case Keys.Y:  						if (keyEvent.Control)  						{  							undoBuffer.Redo();  							keyEvent.Handled = true;  							keyEvent.SuppressKeyPress = true;  						}  						break;  				}
Missing Default,MatterHackers.Agg,TrackballTumbleWidget,D:\research\architectureSmells\repos\MatterHackers_agg-sharp\Gui\TrackballTumble\TrackballTumbleWidget.cs,OnMouseDown,The following switch statement is missing a default case: switch (TransformState)  						{  							case TrackBallTransformType.Rotation:  								TrackBallController.OnMouseDown(currentMousePosition' Matrix4X4.Identity' TrackBallTransformType.Rotation);  								break;    							case TrackBallTransformType.Translation:  								TrackBallController.OnMouseDown(currentMousePosition' Matrix4X4.Identity' TrackBallTransformType.Translation);  								break;    							case TrackBallTransformType.Scale:  								TrackBallController.OnMouseDown(currentMousePosition' Matrix4X4.Identity' TrackBallTransformType.Scale);  								break;  						}
