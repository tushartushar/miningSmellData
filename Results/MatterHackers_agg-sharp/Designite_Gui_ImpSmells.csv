Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The method has 158 lines of code.
Long Method,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyDown,The method has 249 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The method has 102 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseDown,The method has 126 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveNotCaptured,The method has 104 lines of code.
Long Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseUp,The method has 136 lines of code.
Complex Method,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,Layout,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,widgetRelativeTo_PositionChanged,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,OnMouseDown,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Focus,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseDown,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveNotCaptured,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseUp,Cyclomatic complexity of the method is 9
Long Parameter List,MatterHackers.Agg.UI,AppWidgetInfo,C:\repos\MatterHackers_agg-sharp\Gui\AppWidgetFactory.cs,AppWidgetInfo,The method has 5 parameters. Parameters: category' caption' description' width' height
Long Parameter List,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,MatterHackers.Agg.UI,CheckBoxViewStates,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewSates.cs,CheckBoxViewStates,The method has 7 parameters. Parameters: normal' normalHover' switchNormalToPressed' pressed' pressedHover' switchPressedToNormal' disabled
Long Parameter List,MatterHackers.Agg.UI,CheckBoxViewStates,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewSates.cs,SetViewStates,The method has 7 parameters. Parameters: normal' normalHover' switchNormalToPressed' pressed' pressedHover' switchPressedToNormal' disabled
Long Parameter List,MatterHackers.Agg.UI,OpenFileDialogParams,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\OpenFileDialogPrams.cs,OpenFileDialogParams,The method has 5 parameters. Parameters: fileTypeFilter' initialDirectory' multiSelect' title' actionButtonLabel
Long Parameter List,MatterHackers.Agg.UI,SelectFolderDialogParams,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\SelectFolderDialogParams.cs,SelectFolderDialogParams,The method has 5 parameters. Parameters: description' rootFolder' showNewFolderButton' title' actionButtonLabel
Long Parameter List,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The method has 6 parameters. Parameters: message' textColor' fillColor' barWidgth' barHeight' leftMargin
Long Parameter List,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The method has 6 parameters. Parameters: noSelectionString' normalColor' hoverColor' direction' maxHeight' useLeftIcons
Long Parameter List,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,OpenMenuContents,The method has 9 parameters. Parameters: MenuItems' widgetRelativeTo' openOffset' direction' backgroundColor' borderColor' borderWidth' maxHeight' alignToRightEdge
Long Parameter List,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The method has 5 parameters. Parameters: message' windowTitle' messageType' width' height
Long Parameter List,MatterHackers.Agg.UI,MouseEventArgs,C:\repos\MatterHackers_agg-sharp\Gui\MouseEventArgs.cs,MouseEventArgs,The method has 5 parameters. Parameters: button' clicks' x' y' wheelDelta
Long Parameter List,MatterHackers.Agg.UI,RadioButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The method has 5 parameters. Parameters: uncheckedWidget' uncheckedHoverWidget' checkingWidget' checkedWidget' disabledWidget
Long Parameter List,MatterHackers.Agg.UI,InternalNumberEdit,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,InternalNumberEdit,The method has 10 parameters. Parameters: startingValue' pointSize' pixelWidth' pixelHeight' allowNegatives' allowDecimals' minValue' maxValue' increment' tabIndex
Long Parameter List,MatterHackers.Agg.UI,NumberEdit,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\NumberEdit.cs,NumberEdit,The method has 12 parameters. Parameters: startingValue' x' y' pointSize' pixelWidth' pixelHeight' allowNegatives' allowDecimals' minValue' maxValue' increment' tabIndex
Long Parameter List,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The method has 5 parameters. Parameters: positionOfTrackFirstValue' widthInPixels' minimum' maximum' orientation
Long Parameter List,MatterHackers.Agg.UI,SimpleTextTabWidget,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,SimpleTextTabWidget,The method has 7 parameters. Parameters: tabPageControledByTab' internalTabName' pointSize' selectedTextColor' selectedBackgroundColor' normalTextColor' normalBackgroundColor
Long Parameter List,MatterHackers.Agg.UI,SimpleTextTabWidget,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,AddText,The method has 5 parameters. Parameters: tabText' widgetState' textColor' backgroundColor' pointSize
Long Parameter List,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The method has 5 parameters. Parameters: tabName' normalWidget' hoverWidget' pressedWidget' tabPage
Long Parameter List,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,InternalTextEditWidget,The method has 5 parameters. Parameters: text' pointSize' multiLine' tabIndex' typeFace
Long Parameter List,MatterHackers.Agg.UI,WrappedTextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\WrappedTextWidget.cs,WrappedTextWidget,The method has 8 parameters. Parameters: text' pointSize' justification' textColor' ellipsisIfClipped' underline' backgroundColor' doubleBufferText
Long Parameter List,MatterHackers.Agg.UI,TextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,TextEditWidget,The method has 9 parameters. Parameters: text' x' y' pointSize' pixelWidth' pixelHeight' multiLine' tabIndex' typeFace
Long Parameter List,MatterHackers.Agg.UI,TextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,TextWidget,The method has 10 parameters. Parameters: text' x' y' pointSize' justification' textColor' ellipsisIfClipped' underline' backgroundColor' typeFace
Long Parameter List,MatterHackers.Agg.UI,ToggleSwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,ToggleSwitchView,The method has 8 parameters. Parameters: onText' offText' width' height' backgroundColor' interiorColor' thumbColor' textColor
Long Parameter List,MatterHackers.Agg.UI,ToggleSwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The method has 7 parameters. Parameters: word' width' height' backgroundColor' interiorColor' thumbColor' textColor
Long Parameter List,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The method has 7 parameters. Parameters: width' height' startValue' backgroundColor' interiorColor' thumbColor' exteriorColor
Long Identifier,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the parameter boundsOfAllChildrenIncludingMargin is 34.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeCurrentToolTipHasBeenShowing is 32.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeCurrentToolTipHasBeenShowingWasRunning is 42.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeSinceLastMouseMoveWasRunning is 32.
Long Identifier,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,,The length of the parameter timeSinceLastToolTipCloseWasRunning is 35.
Long Identifier,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,,The length of the parameter mouseDownOffsetFromThumbCenter is 30.
Long Identifier,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,,The length of the parameter selectAllOnMouseUpIfNoSelection is 31.
Long Identifier,MatterHackers.Agg.UI,TitleBarWidget,C:\repos\MatterHackers_agg-sharp\Gui\WindowWidget\TitleBarWidget.cs,OnMouseMove,The length of the parameter parentOriginRelativeToItsParent is 31.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the parameter boundsOfAllChildrenIncludingMargin is 34.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Focus,The length of the parameter allWidgetsThatWillContainFocus is 30.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Focus,The length of the parameter allWidgetsThatCurrentlyHaveFocus is 32.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,ValidateMouseCaptureRecursive,The length of the parameter countOfChildernThatThinkTheyHaveTheMouseCaptured is 48.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveWhenCaptured,The length of the parameter countOfChildernThatThinkTheyHaveTheMouseCaptured is 48.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseUp,The length of the parameter countOfChildernThatThinkTheyHaveTheMouseCaptured is 48.
Long Identifier,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,,The length of the parameter mouseMoveEventHasBeenAcceptedByOther is 36.
Long Statement,MatterHackers.Agg.UI,AverageMillisecondTimer,C:\repos\MatterHackers_agg-sharp\Gui\AverageMillisecondTimer.cs,Draw,The length of the statement  "			graphics2D.DrawString("{0}ms {1:0.0}mb".FormatWith(GetAverage()' GC.GetTotalMemory(false) / 1000000)' x' y' 16' color: RGBA_Bytes.White' drawFromHintedCach: true); " is 163.
Long Statement,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,OnDraw,The length of the statement  "			RectangleDouble clampedRect = new RectangleDouble(1' Math.Floor(0 + bottom)' 1 + Math.Ceiling(CheckBoxWidth)' Math.Ceiling(CheckBoxWidth + bottom)); " is 148.
Long Statement,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The length of the statement  "			var warningLabel = new TextWidget("This dialog should not appear outside of automation tests.\nNotify technical support if visible"' pointSize: 15' textColor: RGBA_Bytes.Pink) " is 175.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The length of the statement  "			TextWidget sizeAndPositon = new TextWidget(string.Format("  Size {0}' Position {1}"' widgetToAddInfoAbout.LocalBounds' widgetToAddInfoAbout.OriginRelativeParent)' pointSize: 8' textColor: RGBA_Bytes.Red); " is 204.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The length of the statement  "			TextWidget boundsText = new TextWidget(string.Format("  Bounds {0}"' widgetToAddInfoAbout.BoundsRelativeToParent)' pointSize: 8' textColor: RGBA_Bytes.Red); " is 156.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,updateWidgetInfo,The length of the statement  "				widgetRefList[widgetToAddInfoAbout].sizeLabel.Text = string.Format("  Size {0}' Position {1}"' widgetToAddInfoAbout.LocalBounds' widgetToAddInfoAbout.OriginRelativeParent); " is 172.
Long Statement,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,updateWidgetInfo,The length of the statement  "				widgetRefList[widgetToAddInfoAbout].boundsLabel.Text = string.Format("  Bounds {0}"' widgetToAddInfoAbout.BoundsRelativeToParent); " is 130.
Long Statement,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + lineInset' this.borderColor); " is 166.
Long Statement,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + lineInset' localBounds.Left + lineInset' localBounds.Bottom + Height - lineInset' this.borderColor); " is 167.
Long Statement,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + Width - lineInset' localBounds.Bottom + lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + Height - lineInset' this.borderColor); " is 183.
Long Statement,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + Height - lineInset' groupBoxLabel.BoundsRelativeToParent.Left - 2' localBounds.Bottom + Height - lineInset' this.borderColor); " is 193.
Long Statement,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The length of the statement  "			graphics2D.Line(groupBoxLabel.BoundsRelativeToParent.Right + 2' localBounds.Bottom + Height - lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + Height - lineInset' this.borderColor); " is 202.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,FixOriginXIfRightToLeft,The length of the statement  "					child.OriginRelativeParent = new Vector2(child.OriginRelativeParent.x - encloseChildrenRect.Left' child.OriginRelativeParent.y); " is 128.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,FixOriginYIfTopToBottom,The length of the statement  "					child.OriginRelativeParent = new Vector2(child.OriginRelativeParent.x' child.OriginRelativeParent.y - encloseChildrenRect.Bottom); " is 130.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newWidth = (parent.LocalBounds.Width - parent.DevicePadding.Width - totalWidthOfStaticItems) / numItemsNeedingExpanding; " is 127.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newWidth = (parent.LocalBounds.Width - parent.DevicePadding.Width - totalWidthOfStaticItems) / numItemsNeedingExpanding; " is 127.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newHeight = (parent.LocalBounds.Height - parent.DevicePadding.Height - totalHeightOfStaticItems) / numItemsNeedingExpanding; " is 131.
Long Statement,MatterHackers.Agg.UI,LayoutEngineFlow,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineFlow.cs,DoLayoutChildren,The length of the statement  "									double newHeight = (parent.LocalBounds.Height - parent.DevicePadding.Height - totalHeightOfStaticItems) / numItemsNeedingExpanding; " is 131.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenVertical,The length of the statement  "					if (!GetOriginAndHeightForChild(widgetToAdjustBounds.Parent' widgetToAdjustBounds' out newOriginRelParent' out heightToMatchParent)) " is 132.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Bottom + child.DeviceMargin.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom); " is 175.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "						parent.DevicePadding.Bottom + child.DeviceMargin.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2); " is 136.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2; " is 158.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMargin.Bottom + child.DeviceMargin.Top) / 2 + child.DeviceMargin.Bottom; " is 160.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The length of the statement  "				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Top - child.DeviceMargin.Top - parent.DevicePadding.Top - child.LocalBounds.Top); " is 163.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "							// We make the assumption that the parent has set the size correctly assuming flow layout and this can only be made bigger if fit needs to. " is 139.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "							widgetToAdjustBounds.Right = Math.Max(childrenEnclosingBounds.Left + widthToMatchParent' childrenEnclosingBounds.Right); " is 120.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "						widgetToAdjustBounds.Right = Math.Max(childrenEnclosingBounds.Left + widthToMatchParent' childrenEnclosingBounds.Right); " is 120.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,DoFitToChildrenHorizontal,The length of the statement  "					widgetToAdjustBounds.Right = Math.Max(childrenEnclosingBounds.Left + widthToMatchParent' childrenEnclosingBounds.Right); " is 120.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMargin.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.y); " is 167.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "						parent.DevicePadding.Left + child.DeviceMargin.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2' " is 130.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2; " is 155.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMargin.Left + child.DeviceMargin.Right) / 2 + child.DeviceMargin.Left; " is 155.
Long Statement,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The length of the statement  "				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMargin.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.y); " is 171.
Long Statement,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,ApplyFilter,The length of the statement  "			var firstMatchedItem = MenuItems.Where(m => m.Text.IndexOf(text' StringComparison.OrdinalIgnoreCase) == 0).FirstOrDefault(); " is 124.
Long Statement,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The length of the statement  "				currentPadding = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top); " is 137.
Long Statement,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The length of the statement  "					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top); " is 140.
Long Statement,MatterHackers.Agg.UI,Menu,C:\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,ShowMenu,The length of the statement  "			DropDownContainer = new OpenMenuContents(MenuItems' this' OpenOffset' MenuDirection' MenuItemsBackgroundColor' MenuItemsBorderColor' MenuItemsBorderWidth' maxHeight' AlignToRightEdge); " is 184.
Long Statement,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,GetLocalBounds,The length of the statement  "			labelTextWidget.OriginRelativeParent = new Vector2(boxWidth * 2' -labelTextWidget.Printer.TypeFaceStyle.DescentInPixels); " is 121.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The length of the statement  "				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds); " is 125.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The length of the statement  "					RectangleDouble screenBounds = widgetThatIsShowingToolTip.TransformToScreenSpace(widgetThatIsShowingToolTip.LocalBounds); " is 121.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The length of the statement  "				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds); " is 125.
Long Statement,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The length of the statement  "					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23); " is 140.
Long Statement,MatterHackers.Agg.UI,ScrollingArea,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollingArea.cs,CalculateChildrenBounds,The length of the statement  "				RectangleDouble boundsOfChildren = new RectangleDouble(double.MaxValue' double.MaxValue' double.MinValue' double.MinValue); " is 123.
Long Statement,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The length of the statement  "			graphics2D.Render(thumbOutside' RGBA_Floats.GetTweenColor(ThumbColor.GetAsRGBA_Floats()' RGBA_Floats.Black.GetAsRGBA_Floats()' .2).GetAsRGBA_Bytes()); " is 150.
Long Statement,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnBoundsChanged,The length of the statement  "			Panel2.LocalBounds = new RectangleDouble(0' 0' LocalBounds.Width - SplitterDistance - SplitterWidth / 2' LocalBounds.Height); " is 125.
Long Statement,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The length of the statement  "				RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2); " is 168.
Long Statement,MatterHackers.Agg.UI,TabControl,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,AddChild,The length of the statement  "			throw new Exception("You cannot add controls directly to a TabControl. Add the controls to a TabPage and then add that to the TabControl."); " is 140.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,UpdateLocalBounds,The length of the statement  "			//LocalBounds = new RectangleDouble(this.BorderWidth - padding' this.BorderWidth - padding' width + this.BorderWidth + padding' height + this.BorderWidth + padding); " is 165.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseDown,The length of the statement  "			CharIndexToInsertBefore = internalTextWidget.Printer.GetCharacterIndexToStartBefore(new Vector2(mouseEvent.X' mouseEvent.Y)); " is 125.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseDown,The length of the statement  "				while (CharIndexToInsertBefore >= Text.Length || (CharIndexToInsertBefore > -1 && !WordBreakChars.Contains(Text[CharIndexToInsertBefore]))) " is 139.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseMove,The length of the statement  "				CharIndexToInsertBefore = internalTextWidget.Printer.GetCharacterIndexToStartBefore(new Vector2(mouseEvent.X' mouseEvent.Y)); " is 125.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,CopySelection,The length of the statement  "					Clipboard.SetText(internalTextWidget.Text.Substring(CharIndexToInsertBefore' SelectionIndexToStartBefore - CharIndexToInsertBefore)); " is 133.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,CopySelection,The length of the statement  "					Clipboard.SetText(internalTextWidget.Text.Substring(SelectionIndexToStartBefore' CharIndexToInsertBefore - SelectionIndexToStartBefore)); " is 137.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GetIndexOffset,The length of the statement  "				internalTextWidget.Printer.GetOffset(CharacterStartIndexInclusive' CharacterStartIndexInclusive + OffsetIndex' out offset); " is 123.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GotoLineAbove,The length of the statement  "			GetStartAndEndIndexForLineContainingChar(startIndexInclusive - 1' out prevStartIndexInclusive' out prevEndIndexInclusive); " is 122.
Long Statement,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GotoLineBelow,The length of the statement  "			GetStartAndEndIndexForLineContainingChar(endIndexInclusive + 1' out nextStartIndexInclusive' out nextEndIndexInclusive); " is 120.
Long Statement,MatterHackers.Agg.UI,TextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,Focus,The length of the statement  "				throw new Exception("Don't call Focus() until you have a Parent.\nCalling focus without a parent will not result in the focus chain pointing to the widget' so it will not work."); " is 179.
Long Statement,MatterHackers.Agg.UI,TextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The length of the statement  "					shortTextPrinter = new TypeFacePrinter(shortTextPrinter.Text.Substring(0' shortTextPrinter.Text.Length - 4).TrimEnd(spaceTrim) + "..."' Printer); " is 145.
Long Statement,MatterHackers.Agg.UI,UiThread,C:\repos\MatterHackers_agg-sharp\Gui\UiThread.cs,RunOnIdle,The length of the statement  "				functionsToCheckIfTimeToCall.Add(new CallBackAndState(callBack' state' timer.ElapsedMilliseconds + (int)(delayInSeconds * 1000))); " is 130.
Long Statement,MatterHackers.Agg.UI,UiThread,C:\repos\MatterHackers_agg-sharp\Gui\UiThread.cs,InvokePendingActions,The length of the statement  "			// now call all the functions (we put them in backwards to make it easier to remove them as we went so run them backwards " is 121.
Long Statement,MatterHackers.Agg.UI,ToggleSwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The length of the statement  "			SwitchView switchGraphics = new SwitchView(width' height' word == onText' backgroundColor' interiorColor' thumbColor' textColor); " is 129.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the statement  "						boundsOfAllChildrenIncludingMargin.Right = boundsOfAllChildrenIncludingMargin.Left + Max(boundsOfAllChildrenIncludingMargin.Width' minSize.x); " is 142.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,GetChildrenBoundsIncludingMargins,The length of the statement  "						boundsOfAllChildrenIncludingMargin.Top = boundsOfAllChildrenIncludingMargin.Bottom + Max(boundsOfAllChildrenIncludingMargin.Height' minSize.y); " is 143.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,AddChild,The length of the statement  "					throw new Exception("You are adding a child that has previously been remove. You should probably be creating a new widget' or calling ClearRemovedFlag() before adding."); " is 170.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDragDrop,The length of the statement  "			// to do this we would need to implement OnDragOver (and debug it' it was a mess when I started it and don't care right now). // LBB 2013 04 30 " is 143.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The length of the statement  "								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom) " is 121.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The length of the statement  "					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)' " is 158.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The length of the statement  "						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center); " is 137.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Close,The length of the statement  "				BreakInDebugger("You should put this close onto the UiThread.RunOnIdle so it can happen after the child list is unlocked."); " is 124.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,Close,The length of the statement  "					// This code will only execute if this is the actual widget we called close on (not a child of the widget we called close on). " is 126.
Long Statement,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,TransformToParentSpace,The length of the statement  "				position += new Vector2(widgetToTransformBy.BoundsRelativeToParent.Left' widgetToTransformBy.BoundsRelativeToParent.Bottom); " is 124.
Complex Conditional,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The conditional expression  "m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14"  is complex.
Complex Conditional,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The conditional expression  "(timeSinceLastToolTipClose.IsRunning || timeSinceLastToolTipCloseWasRunning)  				&& timeSinceLastToolTipClose.Elapsed.TotalSeconds < InitialDelay  				&& widgetThatWantsToShowToolTip != null  				&& widgetThatIsShowingToolTip == null"  is complex.
Complex Conditional,MatterHackers.Agg.UI,InternalNumberEdit,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,InternalNumberEdit,The conditional expression  "startingValue < 0 || increment < 0 || minValue < 0 || maxValue < 0"  is complex.
Complex Conditional,MatterHackers.Agg.UI,InternalNumberEdit,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,InternalNumberEdit,The conditional expression  "startingValue != (int)startingValue || increment != (int)increment || minValue != (int)minValue || maxValue != (int)maxValue"  is complex.
Complex Conditional,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The conditional expression  "MergeTypingDuringUndo  				&& charIndexToAcceptAsMerging == CharIndexToInsertBefore - 1  				&& keyPressEvent.KeyChar != '\n' && keyPressEvent.KeyChar != '\r'"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,AllParentsVisibleAndEnabled,The conditional expression  "!curGUIWidget.Visible || !curGUIWidget.Enabled  					|| visibleBounds.Width <= 0  					|| visibleBounds.Height <= 0"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseDown,The conditional expression  "child.Visible  						&& child.Enabled  						&& child.CanSelect  						&& child.PositionWithinLocalBounds(childX' childY)"  is complex.
Complex Conditional,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnMouseMoveNotCaptured,The conditional expression  "child.Visible  							&& child.Enabled  							&& child.CanSelect  							&& child.PositionWithinLocalBounds(childX' childY)"  is complex.
Virtual Method Call from Constructor,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The constructor "gamma_ctrl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewText.cs,ButtonViewText,The constructor "ButtonViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Button,C:\repos\MatterHackers_agg-sharp\Gui\Button\Button.cs,Button,The constructor "Button" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBox,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBox.cs,CheckBox,The constructor "CheckBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The constructor "CheckBoxViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The constructor "CheckBoxViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The constructor "CheckBoxViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The constructor "GroupBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The constructor "GroupBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The constructor "PerformancePanel" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The constructor "PerformancePanel" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The constructor "PerformancePanel" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The constructor "ProgressControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The constructor "ProgressControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The constructor "ProgressControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The constructor "SoftKeyboardDisplayStateManager" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The constructor "SoftKeyboardDisplayStateManager" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardContentOffset,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardContentOffset,The constructor "SoftKeyboardContentOffset" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,SoftKeyboardContentOffset,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardContentOffset,The constructor "SoftKeyboardContentOffset" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The constructor "DropDownList" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Menu,C:\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,Menu,The constructor "Menu" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItem,C:\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItem.cs,MenuItem,The constructor "MenuItem" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemStatesView,C:\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemStatesView,The constructor "MenuItemStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemStatesView,C:\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemStatesView,The constructor "MenuItemStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemColorStatesView,C:\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemColorStatesView,The constructor "MenuItemColorStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MenuItemColorStatesView,C:\repos\MatterHackers_agg-sharp\Gui\Menu\MenuItemStatesView.cs,MenuItemColorStatesView,The constructor "MenuItemColorStatesView" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,OpenMenuContents,The constructor "OpenMenuContents" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,OpenMenuContents,The constructor "OpenMenuContents" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,OpenMenuContents,The constructor "OpenMenuContents" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The constructor "MessageBox" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewStates.cs,RadioButtonViewStates,The constructor "RadioButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,RadioButtonViewText,The constructor "RadioButtonViewText" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,RadioButton,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButton.cs,RadioButton,The constructor "RadioButton" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,ScrollableWidget,The constructor "ScrollableWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,ScrollableWidget,The constructor "ScrollableWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollBar,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,ScrollBar,The constructor "ScrollBar" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollBar,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,ScrollBar,The constructor "ScrollBar" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ScrollBar,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,ScrollBar,The constructor "ScrollBar" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The constructor "Slider" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The constructor "Splitter" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The constructor "Splitter" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The constructor "Splitter" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The constructor "Tab" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The constructor "Tab" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The constructor "Tab" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabControl,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,TabControl,The constructor "TabControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabControl,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,TabControl,The constructor "TabControl" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,TabPage,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\TabPage.cs,TabPage,The constructor "TabPage" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,InternalTextEditWidget,The constructor "InternalTextEditWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WrappedTextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\WrappedTextWidget.cs,WrappedTextWidget,The constructor "WrappedTextWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WindowWidget,C:\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The constructor "WindowWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,WindowWidget,C:\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The constructor "WindowWidget" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.Agg.UI,ButtonViewStates,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewStates.cs,ButtonViewStates,The constructor "ButtonViewStates" calls a virtual method "AddChild".
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(4' 5.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(4' 5.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(0' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(1' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(1' 50.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(3' 0.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(3' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,bezier_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(3' 100.0);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetXN(2' x3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetYN(2' y3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetXN(3' x4);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetYN(3' y4);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2)'  						 m_poly.GetXN(3)' m_poly.GetYN(3));
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: return m_poly.GetXN(2);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: return m_poly.GetYN(2);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x4,The following statement contains a magic number: return m_poly.GetXN(3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y4,The following statement contains a magic number: return m_poly.GetYN(3);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: m_poly.SetXN(2' x);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: m_poly.SetYN(2' y);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x4,The following statement contains a magic number: m_poly.SetXN(3' x);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y4,The following statement contains a magic number: m_poly.SetYN(3' y);
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,num_paths,The following statement contains a magic number: return 7;
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line 1  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(2)' m_poly.GetYN(2)'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								(m_poly.GetXN(2) + m_poly.GetXN(3)) * 0.5'  								(m_poly.GetYN(2) + m_poly.GetYN(3)) * 0.5'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2)'  								 m_poly.GetXN(3)' m_poly.GetYN(3));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 6:                 // Point 4  					m_ellipse.init(m_poly.GetXN(3)' m_poly.GetYN(3)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(3' 5.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly = new polygon_ctrl_impl(3' 5.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(0' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(1' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(1' 50.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetXN(2' 50.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve3_ctrl_impl,The following statement contains a magic number: m_poly.SetYN(2' 100.0);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetXN(2' x3);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_poly.SetYN(2' y3);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2));
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,curve,The following statement contains a magic number: m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  						 m_poly.GetXN(1)' m_poly.GetYN(1)'  						 m_poly.GetXN(2)' m_poly.GetYN(2));
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: return m_poly.GetXN(2);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: return m_poly.GetYN(2);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,x3,The following statement contains a magic number: m_poly.SetXN(2' x);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,y3,The following statement contains a magic number: m_poly.SetYN(2' y);
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,num_paths,The following statement contains a magic number: return 6;
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:  				case 0:                 // Control line  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								(m_poly.GetXN(0) + m_poly.GetXN(1)) * 0.5'  								(m_poly.GetYN(0) + m_poly.GetYN(1)) * 0.5'  								 m_poly.GetXN(1)' m_poly.GetYN(1));  					m_stroke.rewind(0);  					break;    				case 1:                 // Control line 2  					m_curve.init(m_poly.GetXN(1)' m_poly.GetYN(1)'  								(m_poly.GetXN(1) + m_poly.GetXN(2)) * 0.5'  								(m_poly.GetYN(1) + m_poly.GetYN(2)) * 0.5'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 2:                 // Curve itself  					m_curve.init(m_poly.GetXN(0)' m_poly.GetYN(0)'  								 m_poly.GetXN(1)' m_poly.GetYN(1)'  								 m_poly.GetXN(2)' m_poly.GetYN(2));  					m_stroke.rewind(0);  					break;    				case 3:                 // Point 1  					m_ellipse.init(m_poly.GetXN(0)' m_poly.GetYN(0)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 4:                 // Point 2  					m_ellipse.init(m_poly.GetXN(1)' m_poly.GetYN(1)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;    				case 5:                 // Point 3  					m_ellipse.init(m_poly.GetXN(2)' m_poly.GetYN(2)' point_radius()' point_radius()' 20);  					m_ellipse.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_border_width = (2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_curve_width = (2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_grid_width = (0.2);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_text_thickness = (1.5);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_point_size = (5.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_text_height = (9.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_yc2 = (y2 - m_text_height * 2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_yt1 = (y2 - m_text_height * 2.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: gammaText = new TextWidget(""' pointSize: 11)  			{  				VAnchor = VAnchor.ParentTop'  				HAnchor = HAnchor.ParentLeftRight'  				Margin = new BorderDouble(8' 4)  			};
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: gammaText = new TextWidget(""' pointSize: 11)  			{  				VAnchor = VAnchor.ParentTop'  				HAnchor = HAnchor.ParentLeftRight'  				Margin = new BorderDouble(8' 4)  			};
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: gammaText = new TextWidget(""' pointSize: 11)  			{  				VAnchor = VAnchor.ParentTop'  				HAnchor = HAnchor.ParentLeftRight'  				Margin = new BorderDouble(8' 4)  			};
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_background_color = new RGBA_Bytes(1.0' 1.0' 0.9);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_grid_color = new RGBA_Bytes(0.2' 0.2' 0.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_grid_color = new RGBA_Bytes(0.2' 0.2' 0.0);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_colors[2] = m_inactive_pnt_color;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_colors[3] = m_active_pnt_color;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,gamma_ctrl,The following statement contains a magic number: m_colors[4] = m_text_color;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,text_size,The following statement contains a magic number: m_yc2 = BoundsRelativeToParent.Top - m_text_height * 2.0;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,text_size,The following statement contains a magic number: m_yt1 = BoundsRelativeToParent.Top - m_text_height * 2.0;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnMouseDown,The following statement contains a magic number: if (agg_math.calc_distance(x' y' m_xp2' m_yp2) <= m_point_size + 1)  			{  				m_mouse_point = 2;  				m_pdx = m_xp2 - x;  				m_pdy = m_yp2 - y;  				m_p1_active = false;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnMouseMove,The following statement contains a magic number: if (m_mouse_point == 2)  			{  				m_xp2 = x + m_pdx;  				m_yp2 = y + m_pdy;  				calc_values();  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_p1_active)  			{  				if (keyEvent.KeyCode == Keys.Left) { kx1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx1 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky1 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky1 += 0.005; ret = true; }  			}  			else  			{  				if (keyEvent.KeyCode == Keys.Left) { kx2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx2 -= 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky2 += 0.005; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky2 -= 0.005; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,num_paths,The following statement contains a magic number: return 5;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnDraw,The following statement contains a magic number: rewind(2);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,OnDraw,The following statement contains a magic number: rewind(3);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Curve  					m_gamma_spline.box(m_xs1' m_ys1' m_xs2' m_ys2);  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 1:                 // Grid  					m_vertex = 0;  					gridVertexX[0] = m_xs1;  					gridVertexY[0] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[1] = m_xs2;  					gridVertexY[1] = (m_ys1 + m_ys2) * 0.5 - m_grid_width * 0.5;  					gridVertexX[2] = m_xs2;  					gridVertexY[2] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[3] = m_xs1;  					gridVertexY[3] = (m_ys1 + m_ys2) * 0.5 + m_grid_width * 0.5;  					gridVertexX[4] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[4] = m_ys1;  					gridVertexX[5] = (m_xs1 + m_xs2) * 0.5 - m_grid_width * 0.5;  					gridVertexY[5] = m_ys2;  					gridVertexX[6] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[6] = m_ys2;  					gridVertexX[7] = (m_xs1 + m_xs2) * 0.5 + m_grid_width * 0.5;  					gridVertexY[7] = m_ys1;  					calc_points();  					gridVertexX[8] = m_xs1;  					gridVertexY[8] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[9] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[9] = m_yp1 - m_grid_width * 0.5;  					gridVertexX[10] = m_xp1 - m_grid_width * 0.5;  					gridVertexY[10] = m_ys1;  					gridVertexX[11] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[11] = m_ys1;  					gridVertexX[12] = m_xp1 + m_grid_width * 0.5;  					gridVertexY[12] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[13] = m_xs1;  					gridVertexY[13] = m_yp1 + m_grid_width * 0.5;  					gridVertexX[14] = m_xs2;  					gridVertexY[14] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[15] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[15] = m_yp2 + m_grid_width * 0.5;  					gridVertexX[16] = m_xp2 + m_grid_width * 0.5;  					gridVertexY[16] = m_ys2;  					gridVertexX[17] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[17] = m_ys2;  					gridVertexX[18] = m_xp2 - m_grid_width * 0.5;  					gridVertexY[18] = m_yp2 - m_grid_width * 0.5;  					gridVertexX[19] = m_xs2;  					gridVertexY[19] = m_yp2 - m_grid_width * 0.5;  					break;    				case 2:                 // Point1  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					break;    				case 3:                 // Point2  					calc_points();  					if (m_p1_active) m_ellipse.init(m_xp1' m_yp1' m_point_size' m_point_size' 32);  					else m_ellipse.init(m_xp2' m_yp2' m_point_size' m_point_size' 32);  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 1:  					if (m_vertex == 0 ||  					   m_vertex == 4 ||  					   m_vertex == 8 ||  					   m_vertex == 14) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;    					if (m_vertex >= 20) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = gridVertexX[m_vertex];  					y = gridVertexY[m_vertex];  					m_vertex++;  					break;    				case 2:                 // Point1  				case 3:                 // Point2  					cmd = m_ellipse.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_spline_box,The following statement contains a magic number: m_ys2 = m_yc2 - m_border_width * 0.5;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_xp1 = m_xs1 + (m_xs2 - m_xs1) * kx1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_yp1 = m_ys1 + (m_ys2 - m_ys1) * ky1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_xp2 = m_xs2 - (m_xs2 - m_xs1) * kx2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_points,The following statement contains a magic number: m_yp2 = m_ys2 - (m_ys2 - m_ys1) * ky2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: kx1 = (m_xp1 - m_xs1) * 4.0 / (m_xs2 - m_xs1);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: ky1 = (m_yp1 - m_ys1) * 4.0 / (m_ys2 - m_ys1);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: kx2 = (m_xs2 - m_xp2) * 4.0 / (m_xs2 - m_xs1);
Magic Number,MatterHackers.Agg.UI,gamma_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_ctrl.cs,calc_values,The following statement contains a magic number: ky2 = (m_ys2 - m_yp2) * 4.0 / (m_ys2 - m_ys1);
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx1 < 0.001) kx1 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx1 < 0.001) kx1 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx1 > 1.999) kx1 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx1 > 1.999) kx1 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky1 < 0.001) ky1 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky1 < 0.001) ky1 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky1 > 1.999) ky1 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky1 > 1.999) ky1 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx2 < 0.001) kx2 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx2 < 0.001) kx2 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx2 > 1.999) kx2 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (kx2 > 1.999) kx2 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky2 < 0.001) ky2 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky2 < 0.001) ky2 = 0.001;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky2 > 1.999) ky2 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: if (ky2 > 1.999) ky2 = 1.999;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[1] = kx1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[1] = ky1 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[2] = 1.0 - kx2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[2] = 1.0 - kx2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[2] = 1.0 - ky2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[2] = 1.0 - ky2 * 0.25;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_x[3] = 1.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_y[3] = 1.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: m_spline.init(4' m_x' m_y);
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: for (i = 0; i < 256; i++)  			{  				m_gamma[i] = (byte)(y((double)(i) / 255.0) * 255.0);  			}
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: for (i = 0; i < 256; i++)  			{  				m_gamma[i] = (byte)(y((double)(i) / 255.0) * 255.0);  			}
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: for (i = 0; i < 256; i++)  			{  				m_gamma[i] = (byte)(y((double)(i) / 255.0) * 255.0);  			}
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx1 = m_x[1] * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky1 = m_y[1] * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 = (1.0 - m_x[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: kx2 = (1.0 - m_x[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 = (1.0 - m_y[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,values,The following statement contains a magic number: ky2 = (1.0 - m_y[2]) * 4.0;
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,gamma_spline,C:\repos\MatterHackers_agg-sharp\Gui\agg_gamma_spline.cs,vertex,The following statement contains a magic number: RectangleDouble localBounds = new RectangleDouble(10' 10' 100' 100);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_background_color = new RGBA_Bytes(1.0' 1.0' 0.9);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: m_point_size = (3.0);
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: if (m_num_pnt < 4) m_num_pnt = 4;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: if (m_num_pnt < 4) m_num_pnt = 4;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: if (m_num_pnt > 32) m_num_pnt = 32;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: if (m_num_pnt > 32) m_num_pnt = 32;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: for (int i = 0; i < m_num_pnt; i++)  			{  				m_xp[i] = (double)(i) / (double)(m_num_pnt - 1);  				m_yp[i] = 0.5;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: {  				m_spline.init((int)m_num_pnt' m_xp' m_yp);  				for (int i = 0; i < 256; i++)  				{  					m_spline_values[i] = m_spline.get((double)(i) / 255.0);  					if (m_spline_values[i] < 0.0) m_spline_values[i] = 0.0;  					if (m_spline_values[i] > 1.0) m_spline_values[i] = 1.0;  					m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);  				}  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: {  				m_spline.init((int)m_num_pnt' m_xp' m_yp);  				for (int i = 0; i < 256; i++)  				{  					m_spline_values[i] = m_spline.get((double)(i) / 255.0);  					if (m_spline_values[i] < 0.0) m_spline_values[i] = 0.0;  					if (m_spline_values[i] > 1.0) m_spline_values[i] = 1.0;  					m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);  				}  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,spline_ctrl,The following statement contains a magic number: {  				m_spline.init((int)m_num_pnt' m_xp' m_yp);  				for (int i = 0; i < 256; i++)  				{  					m_spline_values[i] = m_spline.get((double)(i) / 255.0);  					if (m_spline_values[i] < 0.0) m_spline_values[i] = 0.0;  					if (m_spline_values[i] > 1.0) m_spline_values[i] = 1.0;  					m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);  				}  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_active_pnt >= 0)  			{  				kx = m_xp[m_active_pnt];  				ky = m_yp[m_active_pnt];  				if (keyEvent.KeyCode == Keys.Left) { kx -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx += 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky += 0.001; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_active_pnt >= 0)  			{  				kx = m_xp[m_active_pnt];  				ky = m_yp[m_active_pnt];  				if (keyEvent.KeyCode == Keys.Left) { kx -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx += 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky += 0.001; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_active_pnt >= 0)  			{  				kx = m_xp[m_active_pnt];  				ky = m_yp[m_active_pnt];  				if (keyEvent.KeyCode == Keys.Left) { kx -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx += 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky += 0.001; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,OnKeyDown,The following statement contains a magic number: if (m_active_pnt >= 0)  			{  				kx = m_xp[m_active_pnt];  				ky = m_yp[m_active_pnt];  				if (keyEvent.KeyCode == Keys.Left) { kx -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Right) { kx += 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Down) { ky -= 0.001; ret = true; }  				if (keyEvent.KeyCode == Keys.Up) { ky += 0.001; ret = true; }  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,update_spline,The following statement contains a magic number: for (int i = 0; i < 256; i++)  			{  				m_spline_values[i] = m_spline.get((double)(i) / 255.0);  				if (m_spline_values[i] < 0.0) m_spline_values[i] = 0.0;  				if (m_spline_values[i] > 1.0) m_spline_values[i] = 1.0;  				m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,update_spline,The following statement contains a magic number: for (int i = 0; i < 256; i++)  			{  				m_spline_values[i] = m_spline.get((double)(i) / 255.0);  				if (m_spline_values[i] < 0.0) m_spline_values[i] = 0.0;  				if (m_spline_values[i] > 1.0) m_spline_values[i] = 1.0;  				m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,update_spline,The following statement contains a magic number: for (int i = 0; i < 256; i++)  			{  				m_spline_values[i] = m_spline.get((double)(i) / 255.0);  				if (m_spline_values[i] < 0.0) m_spline_values[i] = 0.0;  				if (m_spline_values[i] > 1.0) m_spline_values[i] = 1.0;  				m_spline_values8[i] = (byte)(m_spline_values[i] * 255.0);  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,num_paths,The following statement contains a magic number: return 5;
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,rewind,The following statement contains a magic number: switch (idx)  			{  				default:    				case 0:                 // Background  					m_vertex = 0;  					m_vx[0] = -m_border_extra;  					m_vy[0] = -m_border_extra;  					m_vx[1] = Width + m_border_extra;  					m_vy[1] = -m_border_extra;  					m_vx[2] = Width + m_border_extra;  					m_vy[2] = Height + m_border_extra;  					m_vx[3] = -m_border_extra;  					m_vy[3] = Height + m_border_extra;  					break;    				case 1:                 // Border  					m_vertex = 0;  					m_vx[0] = 0;  					m_vy[0] = 0;  					m_vx[1] = Width - m_border_extra * 2;  					m_vy[1] = 0;  					m_vx[2] = Width - m_border_extra * 2;  					m_vy[2] = Height - m_border_extra * 2;  					m_vx[3] = 0;  					m_vy[3] = Height - m_border_extra * 2;  					m_vx[4] = +m_border_width;  					m_vy[4] = +m_border_width;  					m_vx[5] = +m_border_width;  					m_vy[5] = Height - m_border_width - m_border_extra * 2;  					m_vx[6] = Width - m_border_width - m_border_extra * 2;  					m_vy[6] = Height - m_border_width - m_border_extra * 2;  					m_vx[7] = Width - m_border_width - m_border_extra * 2;  					m_vy[7] = +m_border_width;  					break;    				case 2:                 // Curve  					calc_curve();  					m_curve_poly.width(m_curve_width);  					m_curve_poly.rewind(0);  					break;    				case 3:                 // Inactive points  					m_curve_pnt.remove_all();  					for (int i = 0; i < m_num_pnt; i++)  					{  						if (i != m_active_pnt)  						{  							m_ellipse.init(calc_xp(i)' calc_yp(i)'  										   m_point_size' m_point_size' 32);  							m_curve_pnt.concat_path(m_ellipse);  						}  					}  					m_curve_poly.rewind(0);  					break;    				case 4:                 // Active point  					m_curve_pnt.remove_all();  					if (m_active_pnt >= 0)  					{  						m_ellipse.init(calc_xp(m_active_pnt)' calc_yp(m_active_pnt)'  									   m_point_size' m_point_size' 32);    						m_curve_pnt.concat_path(m_ellipse);  					}  					m_curve_poly.rewind(0);  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,vertex,The following statement contains a magic number: switch (m_idx)  			{  				case 0:  					if (m_vertex == 0) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 4) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 1:  					if (m_vertex == 0 || m_vertex == 4) cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  					if (m_vertex >= 8) cmd = ShapePath.FlagsAndCommand.CommandStop;  					x = m_vx[m_vertex];  					y = m_vy[m_vertex];  					m_vertex++;  					break;    				case 2:  					cmd = m_curve_poly.vertex(out x' out y);  					break;    				case 3:  				case 4:  					cmd = m_curve_pnt.vertex(out x' out y);  					break;    				default:  					cmd = ShapePath.FlagsAndCommand.CommandStop;  					break;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,calc_curve,The following statement contains a magic number: for (i = 1; i < 256; i++)  			{  				m_curve_pnt.LineTo(m_xs1 + (m_xs2 - m_xs1) * (double)(i) / 255.0'  									m_ys1 + (m_ys2 - m_ys1) * m_spline_values[i]);  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,calc_curve,The following statement contains a magic number: for (i = 1; i < 256; i++)  			{  				m_curve_pnt.LineTo(m_xs1 + (m_xs2 - m_xs1) * (double)(i) / 255.0'  									m_ys1 + (m_ys2 - m_ys1) * m_spline_values[i]);  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,set_xp,The following statement contains a magic number: if (idx == 0)  			{  				val = 0.0;  			}  			else if (idx == m_num_pnt - 1)  			{  				val = 1.0;  			}  			else  			{  				if (val < m_xp[idx - 1] + 0.001) val = m_xp[idx - 1] + 0.001;  				if (val > m_xp[idx + 1] - 0.001) val = m_xp[idx + 1] - 0.001;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,set_xp,The following statement contains a magic number: if (idx == 0)  			{  				val = 0.0;  			}  			else if (idx == m_num_pnt - 1)  			{  				val = 1.0;  			}  			else  			{  				if (val < m_xp[idx - 1] + 0.001) val = m_xp[idx - 1] + 0.001;  				if (val > m_xp[idx + 1] - 0.001) val = m_xp[idx + 1] - 0.001;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,set_xp,The following statement contains a magic number: if (idx == 0)  			{  				val = 0.0;  			}  			else if (idx == m_num_pnt - 1)  			{  				val = 1.0;  			}  			else  			{  				if (val < m_xp[idx - 1] + 0.001) val = m_xp[idx - 1] + 0.001;  				if (val > m_xp[idx + 1] - 0.001) val = m_xp[idx + 1] - 0.001;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,set_xp,The following statement contains a magic number: if (idx == 0)  			{  				val = 0.0;  			}  			else if (idx == m_num_pnt - 1)  			{  				val = 1.0;  			}  			else  			{  				if (val < m_xp[idx - 1] + 0.001) val = m_xp[idx - 1] + 0.001;  				if (val > m_xp[idx + 1] - 0.001) val = m_xp[idx + 1] - 0.001;  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return m_background_color;    				case 1:  					return m_border_color;    				case 2:  					return m_curve_color;    				case 3:  					return m_inactive_pnt_color;    				case 4:  					return m_active_pnt_color;    				default:  					throw new System.IndexOutOfRangeException("You asked for a color out of range.");  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return m_background_color;    				case 1:  					return m_border_color;    				case 2:  					return m_curve_color;    				case 3:  					return m_inactive_pnt_color;    				case 4:  					return m_active_pnt_color;    				default:  					throw new System.IndexOutOfRangeException("You asked for a color out of range.");  			}
Magic Number,MatterHackers.Agg.UI,spline_ctrl,C:\repos\MatterHackers_agg-sharp\Gui\agg_spline_ctrl.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return m_background_color;    				case 1:  					return m_border_color;    				case 2:  					return m_curve_color;    				case 3:  					return m_inactive_pnt_color;    				case 4:  					return m_active_pnt_color;    				default:  					throw new System.IndexOutOfRangeException("You asked for a color out of range.");  			}
Magic Number,MatterHackers.Agg.UI,AverageMillisecondTimer,C:\repos\MatterHackers_agg-sharp\Gui\AverageMillisecondTimer.cs,Draw,The following statement contains a magic number: graphics2D.DrawString("{0}ms {1:0.0}mb".FormatWith(GetAverage()' GC.GetTotalMemory(false) / 1000000)' x' y' 16' color: RGBA_Bytes.White' drawFromHintedCach: true);
Magic Number,MatterHackers.Agg.UI,AverageMillisecondTimer,C:\repos\MatterHackers_agg-sharp\Gui\AverageMillisecondTimer.cs,Draw,The following statement contains a magic number: graphics2D.DrawString("{0}ms {1:0.0}mb".FormatWith(GetAverage()' GC.GetTotalMemory(false) / 1000000)' x' y' 16' color: RGBA_Bytes.White' drawFromHintedCach: true);
Magic Number,MatterHackers.Agg.UI,ButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewText.cs,OnDraw,The following statement contains a magic number: if (parentButton.Enabled == true)  			{  				graphics2D.Render(rectBorder' new RGBA_Bytes(0' 0' 0));  			}  			else  			{  				graphics2D.Render(rectBorder' new RGBA_Bytes(128' 128' 128));  			}
Magic Number,MatterHackers.Agg.UI,ButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewText.cs,OnDraw,The following statement contains a magic number: if (parentButton.Enabled == true)  			{  				graphics2D.Render(rectBorder' new RGBA_Bytes(0' 0' 0));  			}  			else  			{  				graphics2D.Render(rectBorder' new RGBA_Bytes(128' 128' 128));  			}
Magic Number,MatterHackers.Agg.UI,ButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewText.cs,OnDraw,The following statement contains a magic number: if (parentButton.Enabled == true)  			{  				graphics2D.Render(rectBorder' new RGBA_Bytes(0' 0' 0));  			}  			else  			{  				graphics2D.Render(rectBorder' new RGBA_Bytes(128' 128' 128));  			}
Magic Number,MatterHackers.Agg.UI,ButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\Button\ButtonViewText.cs,OnDraw,The following statement contains a magic number: if (parentButton.FirstWidgetUnderMouse)  			{  				if (parentButton.MouseDownOnButton)  				{  					insideColor = DefaultViewFactory.DefaultBlue;  				}  				else  				{  					insideColor = DefaultViewFactory.DefaultBlue.GetAsRGBA_Floats().Blend(RGBA_Floats.White' .75).GetAsRGBA_Bytes();  				}  			}
Magic Number,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,CheckBoxViewText,The following statement contains a magic number: GuiWidget boxSpace = new GuiWidget(CheckBoxWidth * 2' 1)  			{   				VAnchor = VAnchor.ParentCenter'  			};
Magic Number,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,OnDraw,The following statement contains a magic number: double bottom = LocalBounds.Bottom + (Height / 2 - CheckBoxWidth / 2);
Magic Number,MatterHackers.Agg.UI,CheckBoxViewText,C:\repos\MatterHackers_agg-sharp\Gui\CheckBox\CheckBoxViewText.cs,OnDraw,The following statement contains a magic number: double bottom = LocalBounds.Bottom + (Height / 2 - CheckBoxWidth / 2);
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,OpenFileDialog,The following statement contains a magic number: ShowFileDialog((fileText) =>  			{  				if (fileText.Length > 2)  				{  					string[] files = fileText.Split(';'' ' ').Select(f => f.Trim('\"')).ToArray();  					openParams.FileName = files[0];  					openParams.FileNames = files;  				}  				UiThread.RunOnIdle(() => callback?.Invoke(openParams));  			});
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,SaveFileDialog,The following statement contains a magic number: ShowFileDialog((fileText) =>  			{  				if (fileText.Length > 2)  				{  					string[] files = fileText.Split(';'' ' ').Select(f => f.Trim('\"')).ToArray();  					saveParams.FileName = files[0];  					saveParams.FileNames = files;  				}  				UiThread.RunOnIdle(() => callback?.Invoke(saveParams));  			});
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var systemWindow = new SystemWindow(600' 200)  			{  				Title = "TestAutomation File Input"'  				BackgroundColor = RGBA_Bytes.DarkGray  			};
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var systemWindow = new SystemWindow(600' 200)  			{  				Title = "TestAutomation File Input"'  				BackgroundColor = RGBA_Bytes.DarkGray  			};
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var warningLabel = new TextWidget("This dialog should not appear outside of automation tests.\nNotify technical support if visible"' pointSize: 15' textColor: RGBA_Bytes.Pink)  			{  				Margin = new BorderDouble(20)'  				VAnchor = VAnchor.ParentTop'  				HAnchor = HAnchor.ParentLeftRight  			};
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var warningLabel = new TextWidget("This dialog should not appear outside of automation tests.\nNotify technical support if visible"' pointSize: 15' textColor: RGBA_Bytes.Pink)  			{  				Margin = new BorderDouble(20)'  				VAnchor = VAnchor.ParentTop'  				HAnchor = HAnchor.ParentLeftRight  			};
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var fileNameInput = new TextEditWidget(pixelWidth: 400)  			{  				VAnchor = VAnchor.ParentCenter'  				HAnchor = HAnchor.ParentLeftRight'  				Margin = new BorderDouble(30' 15)  			};
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var fileNameInput = new TextEditWidget(pixelWidth: 400)  			{  				VAnchor = VAnchor.ParentCenter'  				HAnchor = HAnchor.ParentLeftRight'  				Margin = new BorderDouble(30' 15)  			};
Magic Number,MatterHackers.Agg.UI,AutomationFileDialogCreator,C:\repos\MatterHackers_agg-sharp\Gui\FileDialogs\AutomationFileDialogCreator.cs,ShowFileDialog,The following statement contains a magic number: var fileNameInput = new TextEditWidget(pixelWidth: 400)  			{  				VAnchor = VAnchor.ParentCenter'  				HAnchor = HAnchor.ParentLeftRight'  				Margin = new BorderDouble(30' 15)  			};
Magic Number,MatterHackers.Agg.UI,FLowLeftRightWithWrapping,C:\repos\MatterHackers_agg-sharp\Gui\FLowLeftRightWithWrapping.cs,DoWrappingLayout,The following statement contains a magic number: FlowLayoutWidget childContairRow = new FlowLayoutWidget()  			{  				Margin = new BorderDouble(3' 0)'  				Padding = new BorderDouble(3)'  			};
Magic Number,MatterHackers.Agg.UI,FLowLeftRightWithWrapping,C:\repos\MatterHackers_agg-sharp\Gui\FLowLeftRightWithWrapping.cs,DoWrappingLayout,The following statement contains a magic number: FlowLayoutWidget childContairRow = new FlowLayoutWidget()  			{  				Margin = new BorderDouble(3' 0)'  				Padding = new BorderDouble(3)'  			};
Magic Number,MatterHackers.Agg.UI,FLowLeftRightWithWrapping,C:\repos\MatterHackers_agg-sharp\Gui\FLowLeftRightWithWrapping.cs,DoWrappingLayout,The following statement contains a magic number: foreach (var child in addedChildren)  			{  				if (childContairRow.Width + child.Width > Parent.Width)  				{  					childContairRow = new FlowLayoutWidget()  					{  						Margin = new BorderDouble(3' 0)'  						Padding = new BorderDouble(3)'  					};  					base.AddChild(childContairRow);  				}    				// add the button to the current row  				childContairRow.AddChild(child);  			}
Magic Number,MatterHackers.Agg.UI,FLowLeftRightWithWrapping,C:\repos\MatterHackers_agg-sharp\Gui\FLowLeftRightWithWrapping.cs,DoWrappingLayout,The following statement contains a magic number: foreach (var child in addedChildren)  			{  				if (childContairRow.Width + child.Width > Parent.Width)  				{  					childContairRow = new FlowLayoutWidget()  					{  						Margin = new BorderDouble(3' 0)'  						Padding = new BorderDouble(3)'  					};  					base.AddChild(childContairRow);  				}    				// add the button to the current row  				childContairRow.AddChild(child);  			}
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: indented.AddChild(new LineWidget(15' 5));
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: indented.AddChild(new LineWidget(15' 5));
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: TextWidget sizeAndPositon = new TextWidget(string.Format("  Size {0}' Position {1}"' widgetToAddInfoAbout.LocalBounds' widgetToAddInfoAbout.OriginRelativeParent)' pointSize: 8' textColor: RGBA_Bytes.Red);
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,AddInfoRecursive,The following statement contains a magic number: TextWidget boundsText = new TextWidget(string.Format("  Bounds {0}"' widgetToAddInfoAbout.BoundsRelativeToParent)' pointSize: 8' textColor: RGBA_Bytes.Red);
Magic Number,MatterHackers.Agg.UI,DiagnosticWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,topLevelWindow_MouseMove,The following statement contains a magic number: if (count == 20)  			{  				RemoveAllChildren();    				ScrollableWidget allContainer = new ScrollableWidget(true);  				topToBottomTotal = new FlowLayoutWidget(FlowDirection.TopToBottom);    				topToBottomTotal.SuspendLayout();  				GuiWidget.DefaultEnforceIntegerBounds = true;  				AddInfoRecursive(topLevelWindow' topToBottomTotal);  				GuiWidget.DefaultEnforceIntegerBounds = false;  				topToBottomTotal.ResumeLayout();  				topToBottomTotal.PerformLayout();  				allContainer.AddChild(topToBottomTotal);    				AddChild(allContainer);  				allContainer.AnchorAll();  			}
Magic Number,MatterHackers.Agg.UI,LineWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(Width / 2' 0' Width / 2' Height' RGBA_Bytes.Black);
Magic Number,MatterHackers.Agg.UI,LineWidget,C:\repos\MatterHackers_agg-sharp\Gui\DiagnosticsWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(Width / 2' 0' Width / 2' Height' RGBA_Bytes.Black);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: this.Padding = new BorderDouble(14' 14' 14' 16);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,GroupBox,The following statement contains a magic number: groupBoxLabel.Margin = new BorderDouble(20' 0' 0' -this.Padding.Top);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(localBounds.Left + lineInset' localBounds.Bottom + Height - lineInset' groupBoxLabel.BoundsRelativeToParent.Left - 2' localBounds.Bottom + Height - lineInset' this.borderColor);
Magic Number,MatterHackers.Agg.UI,GroupBox,C:\repos\MatterHackers_agg-sharp\Gui\GroupBox.cs,OnDraw,The following statement contains a magic number: graphics2D.Line(groupBoxLabel.BoundsRelativeToParent.Right + 2' localBounds.Bottom + Height - lineInset' localBounds.Left + Width - lineInset' localBounds.Bottom + Height - lineInset' this.borderColor);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: Margin = new BorderDouble(5);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: Padding = new BorderDouble(3);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: {  				TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new RGBA_Bytes()'  					TextColor = new RGBA_Bytes(20' 120' 20)'  				};  				titleWidget.Printer.DrawFromHintedCache = true;  				AddChild(titleWidget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: {  				TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new RGBA_Bytes()'  					TextColor = new RGBA_Bytes(20' 120' 20)'  				};  				titleWidget.Printer.DrawFromHintedCache = true;  				AddChild(titleWidget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: {  				TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new RGBA_Bytes()'  					TextColor = new RGBA_Bytes(20' 120' 20)'  				};  				titleWidget.Printer.DrawFromHintedCache = true;  				AddChild(titleWidget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: {  				TextWidget titleWidget = new TextWidget(name' pointSize: 14)  				{  					BackgroundColor = new RGBA_Bytes()'  					TextColor = new RGBA_Bytes(20' 120' 20)'  				};  				titleWidget.Printer.DrawFromHintedCache = true;  				AddChild(titleWidget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,PerformancePanel,The following statement contains a magic number: BackgroundColor = new RGBA_Bytes(RGBA_Bytes.White' 180);
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,Start,The following statement contains a magic number: if (!timeDisplayData.ContainsKey(timer.Name))  			{  				PerformanceTimerDisplayData newTimerData = new PerformanceTimerDisplayData(timer.Name)  				{  					widget = new TextWidget("waiting")  					{  						AutoExpandBoundsToText = true'  						TextColor = new RGBA_Bytes(120' 20' 20)'  						HAnchor = HAnchor.ParentLeft'  					}  				};    				newTimerData.widget.Printer.DrawFromHintedCache = true;  				timeDisplayData.Add(timer.Name' newTimerData);    				topToBottom.AddChild(newTimerData.widget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,Start,The following statement contains a magic number: if (!timeDisplayData.ContainsKey(timer.Name))  			{  				PerformanceTimerDisplayData newTimerData = new PerformanceTimerDisplayData(timer.Name)  				{  					widget = new TextWidget("waiting")  					{  						AutoExpandBoundsToText = true'  						TextColor = new RGBA_Bytes(120' 20' 20)'  						HAnchor = HAnchor.ParentLeft'  					}  				};    				newTimerData.widget.Printer.DrawFromHintedCache = true;  				timeDisplayData.Add(timer.Name' newTimerData);    				topToBottom.AddChild(newTimerData.widget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,Start,The following statement contains a magic number: if (!timeDisplayData.ContainsKey(timer.Name))  			{  				PerformanceTimerDisplayData newTimerData = new PerformanceTimerDisplayData(timer.Name)  				{  					widget = new TextWidget("waiting")  					{  						AutoExpandBoundsToText = true'  						TextColor = new RGBA_Bytes(120' 20' 20)'  						HAnchor = HAnchor.ParentLeft'  					}  				};    				newTimerData.widget.Printer.DrawFromHintedCache = true;  				timeDisplayData.Add(timer.Name' newTimerData);    				topToBottom.AddChild(newTimerData.widget);  			}
Magic Number,MatterHackers.Agg.UI,PerformancePanel,C:\repos\MatterHackers_agg-sharp\Gui\PerformanceTimer\PerformancePanel.cs,ParentWindow_MouseDown,The following statement contains a magic number: if (e.NumPositions == 4)  			{  				panels.Visible = !panels.Visible;  			}
Magic Number,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The following statement contains a magic number: processTextWidget.Margin = new BorderDouble(leftMargin' 0' 5' 0);
Magic Number,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The following statement contains a magic number: progressTextWidget = new TextWidget(""' textColor: textColor' pointSize: 8);
Magic Number,MatterHackers.Agg.UI,ProgressControl,C:\repos\MatterHackers_agg-sharp\Gui\ProgressControl.cs,ProgressControl,The following statement contains a magic number: progressTextWidget.Margin = new BorderDouble(5' 0);
Magic Number,MatterHackers.Agg.UI,RelativeTime,C:\repos\MatterHackers_agg-sharp\Gui\RelativeTime.cs,GetTimeBlock,The following statement contains a magic number: if (timeToDescribe < now.AddMinutes(10))  			{  				// in the past  				if (timeToDescribe.Year == now.Year)  				{  					// same year  					if (timeToDescribe.Month == now.Month)  					{  						// same month  						if (now.Date == timeToDescribe.Date)  						{  							return TimeBlock.Today;  						}  						else if(now.Date.Subtract(TimeSpan.FromDays(1)).Date == timeToDescribe.Date)  						{  							return TimeBlock.Yesterday;  						}  						else if ((now - timeToDescribe).Days < 7)  						{  							return TimeBlock.SameWeek;  						}  						else  						{  							return TimeBlock.SameMonth;  						}  					}  					else  					{  						// same year but different month  						return TimeBlock.SameYear;  					}  				}  				else  				{  					return TimeBlock.PastYear;  				}  			}  			else  			{  				// in the future  				return TimeBlock.Future;  			}
Magic Number,MatterHackers.Agg.UI,RelativeTime,C:\repos\MatterHackers_agg-sharp\Gui\RelativeTime.cs,GetTimeBlock,The following statement contains a magic number: if (timeToDescribe < now.AddMinutes(10))  			{  				// in the past  				if (timeToDescribe.Year == now.Year)  				{  					// same year  					if (timeToDescribe.Month == now.Month)  					{  						// same month  						if (now.Date == timeToDescribe.Date)  						{  							return TimeBlock.Today;  						}  						else if(now.Date.Subtract(TimeSpan.FromDays(1)).Date == timeToDescribe.Date)  						{  							return TimeBlock.Yesterday;  						}  						else if ((now - timeToDescribe).Days < 7)  						{  							return TimeBlock.SameWeek;  						}  						else  						{  							return TimeBlock.SameMonth;  						}  					}  					else  					{  						// same year but different month  						return TimeBlock.SameYear;  					}  				}  				else  				{  					return TimeBlock.PastYear;  				}  			}  			else  			{  				// in the future  				return TimeBlock.Future;  			}
Magic Number,MatterHackers.Agg.UI,SoftKeyboard,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,MakeKeyButtons,The following statement contains a magic number: int buttonHeight = (int)Height / 4;
Magic Number,MatterHackers.Agg.UI,SoftKeyboard,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,MakeKeyButtons,The following statement contains a magic number: int y = buttonHeight * 3;
Magic Number,MatterHackers.Agg.UI,SoftKeyboard,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,MakeKeyButtons,The following statement contains a magic number: buttonWidth = (int)Width / (bottonRow3.Length + 2);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The following statement contains a magic number: keyboard = new SoftKeyboard(800' 300);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardDisplayStateManager,The following statement contains a magic number: keyboard = new SoftKeyboard(800' 300);
Magic Number,MatterHackers.Agg.UI,SoftKeyboardDisplayStateManager,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,DoShowSoftwareKeyboard,The following statement contains a magic number: if (contentOffsetHolder == null  				|| contentOffsetHolder.Children.Count == 0)  			{  				content.Invalidated += content_Invalidated;  				RemoveChild(content);  				contentOffsetHolder = new GuiWidget(Width' Height);  				contentOffsetHolder.AddChild(content);    				// remember where we were  				oldVAnchor = content.VAnchor;  				oldOrigin = content.OriginRelativeParent;  				if (hadFocusWidget != null)  				{  					// test if the text widget is visible  					RectangleDouble textWidgetScreenBounds = TextWidgetScreenBounds();  					int topOfKeyboard = (int)keyboard.LocalBounds.Height;  					if (textWidgetScreenBounds.Bottom < topOfKeyboard)  					{  						// make sure the screen is not resizing vertically  						content.VAnchor = VAnchor.AbsolutePosition;  						// move the screen up so we can see the bottom of the text widget  						content.OriginRelativeParent = new Vector2(0' topOfKeyboard - textWidgetScreenBounds.Bottom + 3);  					}  				}  			}
Magic Number,MatterHackers.Agg.UI,SoftKeyboardContentOffset,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,SoftKeyboardContentOffset,The following statement contains a magic number: KeyboardHeight = 253;
Magic Number,MatterHackers.Agg.UI,SoftKeyboardContentOffset,C:\repos\MatterHackers_agg-sharp\Gui\SoftKeyboard.cs,EnsureEditControlIsVisible,The following statement contains a magic number: if (textWidgetScreenBounds.Bottom < topOfKeyboard)  			{  				IsActive = true;    				// make sure the screen is not resizing vertically  				content.VAnchor = VAnchor.AbsolutePosition;  				// move the screen up so we can see the bottom of the text widget  				content.OriginRelativeParent = new Vector2(0' topOfKeyboard - textWidgetScreenBounds.Bottom + 10);  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The following statement contains a magic number: if ((child.VAnchor & VAnchor.ParentBottom) == VAnchor.ParentBottom)  			{  				// hold it to the Bottom  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Bottom + child.DeviceMargin.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom);    				if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Bottom + parent.DevicePadding.Top);  					newHeight = parentUsableHeight - (child.DeviceMargin.Bottom + child.DeviceMargin.Top);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  			{  				if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(child.OriginRelativeParent.x'  						parent.DevicePadding.Bottom + child.DeviceMargin.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2);    					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else  				{  					// hold it centered  					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2;  					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMargin.Bottom + child.DeviceMargin.Top) / 2 + child.DeviceMargin.Bottom;  					newOriginRelParent = new Vector2(child.OriginRelativeParent.x' originY);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  			{  				// hold it to the Top  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Top - child.DeviceMargin.Top - parent.DevicePadding.Top - child.LocalBounds.Top);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The following statement contains a magic number: if ((child.VAnchor & VAnchor.ParentBottom) == VAnchor.ParentBottom)  			{  				// hold it to the Bottom  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Bottom + child.DeviceMargin.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom);    				if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Bottom + parent.DevicePadding.Top);  					newHeight = parentUsableHeight - (child.DeviceMargin.Bottom + child.DeviceMargin.Top);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  			{  				if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(child.OriginRelativeParent.x'  						parent.DevicePadding.Bottom + child.DeviceMargin.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2);    					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else  				{  					// hold it centered  					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2;  					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMargin.Bottom + child.DeviceMargin.Top) / 2 + child.DeviceMargin.Bottom;  					newOriginRelParent = new Vector2(child.OriginRelativeParent.x' originY);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  			{  				// hold it to the Top  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Top - child.DeviceMargin.Top - parent.DevicePadding.Top - child.LocalBounds.Top);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The following statement contains a magic number: if ((child.VAnchor & VAnchor.ParentBottom) == VAnchor.ParentBottom)  			{  				// hold it to the Bottom  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Bottom + child.DeviceMargin.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom);    				if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Bottom + parent.DevicePadding.Top);  					newHeight = parentUsableHeight - (child.DeviceMargin.Bottom + child.DeviceMargin.Top);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  			{  				if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(child.OriginRelativeParent.x'  						parent.DevicePadding.Bottom + child.DeviceMargin.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2);    					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else  				{  					// hold it centered  					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2;  					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMargin.Bottom + child.DeviceMargin.Top) / 2 + child.DeviceMargin.Bottom;  					newOriginRelParent = new Vector2(child.OriginRelativeParent.x' originY);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  			{  				// hold it to the Top  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Top - child.DeviceMargin.Top - parent.DevicePadding.Top - child.LocalBounds.Top);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The following statement contains a magic number: if ((child.VAnchor & VAnchor.ParentBottom) == VAnchor.ParentBottom)  			{  				// hold it to the Bottom  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Bottom + child.DeviceMargin.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom);    				if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Bottom + parent.DevicePadding.Top);  					newHeight = parentUsableHeight - (child.DeviceMargin.Bottom + child.DeviceMargin.Top);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  			{  				if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(child.OriginRelativeParent.x'  						parent.DevicePadding.Bottom + child.DeviceMargin.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2);    					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else  				{  					// hold it centered  					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2;  					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMargin.Bottom + child.DeviceMargin.Top) / 2 + child.DeviceMargin.Bottom;  					newOriginRelParent = new Vector2(child.OriginRelativeParent.x' originY);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  			{  				// hold it to the Top  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Top - child.DeviceMargin.Top - parent.DevicePadding.Top - child.LocalBounds.Top);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndHeightForChild,The following statement contains a magic number: if ((child.VAnchor & VAnchor.ParentBottom) == VAnchor.ParentBottom)  			{  				// hold it to the Bottom  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Bottom + child.DeviceMargin.Bottom + parent.DevicePadding.Bottom - child.LocalBounds.Bottom);    				if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Bottom + parent.DevicePadding.Top);  					newHeight = parentUsableHeight - (child.DeviceMargin.Bottom + child.DeviceMargin.Top);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentCenter) == VAnchor.ParentCenter)  			{  				if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(child.OriginRelativeParent.x'  						parent.DevicePadding.Bottom + child.DeviceMargin.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2);    					// bounds need to be stretched  					double parentUsableHeight = parent.LocalBounds.Height - (parent.DevicePadding.Top + parent.DevicePadding.Bottom);  					newHeight = parentUsableHeight / 2 - child.DeviceMargin.Height;  				}  				else  				{  					// hold it centered  					double parentCenterY = parent.LocalBounds.Bottom + parent.DevicePadding.Bottom + (parent.Height - parent.DevicePadding.Bottom - parent.DevicePadding.Top) / 2;  					double originY = parentCenterY - child.LocalBounds.Bottom - (child.Height + child.DeviceMargin.Bottom + child.DeviceMargin.Top) / 2 + child.DeviceMargin.Bottom;  					newOriginRelParent = new Vector2(child.OriginRelativeParent.x' originY);  				}  				needToAdjustAnything = true;  			}  			else if ((child.VAnchor & VAnchor.ParentTop) == VAnchor.ParentTop)  			{  				// hold it to the Top  				newOriginRelParent = new Vector2(child.OriginRelativeParent.x' parent.LocalBounds.Top - child.DeviceMargin.Top - parent.DevicePadding.Top - child.LocalBounds.Top);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The following statement contains a magic number: if ((child.HAnchor & HAnchor.ParentLeft) == HAnchor.ParentLeft)  			{  				// Hold it to the left  				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMargin.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.y);    				if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  			{  				if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(  						parent.DevicePadding.Left + child.DeviceMargin.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2'  						child.OriginRelativeParent.y);    					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else  				{  					// hold it centered  					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2;  					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMargin.Left + child.DeviceMargin.Right) / 2 + child.DeviceMargin.Left;  					newOriginRelParent = new Vector2(originX' child.OriginRelativeParent.y);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  			{  				// hold it to the right  				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMargin.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.y);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The following statement contains a magic number: if ((child.HAnchor & HAnchor.ParentLeft) == HAnchor.ParentLeft)  			{  				// Hold it to the left  				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMargin.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.y);    				if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  			{  				if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(  						parent.DevicePadding.Left + child.DeviceMargin.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2'  						child.OriginRelativeParent.y);    					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else  				{  					// hold it centered  					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2;  					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMargin.Left + child.DeviceMargin.Right) / 2 + child.DeviceMargin.Left;  					newOriginRelParent = new Vector2(originX' child.OriginRelativeParent.y);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  			{  				// hold it to the right  				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMargin.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.y);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The following statement contains a magic number: if ((child.HAnchor & HAnchor.ParentLeft) == HAnchor.ParentLeft)  			{  				// Hold it to the left  				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMargin.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.y);    				if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  			{  				if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(  						parent.DevicePadding.Left + child.DeviceMargin.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2'  						child.OriginRelativeParent.y);    					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else  				{  					// hold it centered  					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2;  					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMargin.Left + child.DeviceMargin.Right) / 2 + child.DeviceMargin.Left;  					newOriginRelParent = new Vector2(originX' child.OriginRelativeParent.y);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  			{  				// hold it to the right  				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMargin.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.y);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The following statement contains a magic number: if ((child.HAnchor & HAnchor.ParentLeft) == HAnchor.ParentLeft)  			{  				// Hold it to the left  				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMargin.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.y);    				if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  			{  				if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(  						parent.DevicePadding.Left + child.DeviceMargin.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2'  						child.OriginRelativeParent.y);    					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else  				{  					// hold it centered  					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2;  					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMargin.Left + child.DeviceMargin.Right) / 2 + child.DeviceMargin.Left;  					newOriginRelParent = new Vector2(originX' child.OriginRelativeParent.y);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  			{  				// hold it to the right  				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMargin.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.y);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,LayoutEngineSimpleAlign,C:\repos\MatterHackers_agg-sharp\Gui\LayoutEngines\LayoutEngineSimpleAlign.cs,GetOriginAndWidthForChild,The following statement contains a magic number: if ((child.HAnchor & HAnchor.ParentLeft) == HAnchor.ParentLeft)  			{  				// Hold it to the left  				newOriginRelParent = new Vector2(parent.LocalBounds.Left + child.DeviceMargin.Left + parent.DevicePadding.Left - child.LocalBounds.Left' child.OriginRelativeParent.y);    				if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  				{  					// widen the bounds to the center  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentCenter) == HAnchor.ParentCenter)  			{  				if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  				{  					// fix the offset  					newOriginRelParent = new VectorMath.Vector2(  						parent.DevicePadding.Left + child.DeviceMargin.Left + (parent.Width - parent.DevicePadding.Left - parent.DevicePadding.Right) / 2'  						child.OriginRelativeParent.y);    					// widen the bounds to the right  					double parentUsableWidth = parent.LocalBounds.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right);  					newWidth = parentUsableWidth / 2 - (child.DeviceMargin.Left + child.DeviceMargin.Right);  				}  				else  				{  					// hold it centered  					double parentCenterX = parent.LocalBounds.Left + parent.DevicePadding.Left + (parent.Width - (parent.DevicePadding.Left + parent.DevicePadding.Right)) / 2;  					double originX = parentCenterX - child.LocalBounds.Left - (child.Width + child.DeviceMargin.Left + child.DeviceMargin.Right) / 2 + child.DeviceMargin.Left;  					newOriginRelParent = new Vector2(originX' child.OriginRelativeParent.y);  				}  				needToAdjustAnything = true;  			}  			else if ((child.HAnchor & HAnchor.ParentRight) == HAnchor.ParentRight)  			{  				// hold it to the right  				newOriginRelParent = new Vector2(parent.LocalBounds.Right - child.DeviceMargin.Right - parent.DevicePadding.Right - child.LocalBounds.Right' child.OriginRelativeParent.y);  				needToAdjustAnything = true;  			}
Magic Number,MatterHackers.Agg.UI,ListBoxTextItem,C:\repos\MatterHackers_agg-sharp\Gui\ListBox.cs,ListBoxTextItem,The following statement contains a magic number: Padding = new BorderDouble(3);
Magic Number,MatterHackers.Agg.UI,ListBox,C:\repos\MatterHackers_agg-sharp\Gui\ListBox.cs,AddChild,The following statement contains a magic number: itemHolder.Margin = new BorderDouble(3' 0' 0' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 8' 10' 12);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 8' 10' 12);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 8' 10' 12);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.MenuItemsPadding = new BorderDouble(10' 8' 10' 12);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.BackgroundColor = new RGBA_Bytes(255' 255' 255' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.BackgroundColor = new RGBA_Bytes(255' 255' 255' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: this.BackgroundColor = new RGBA_Bytes(255' 255' 255' 0);
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: if (this.MenuDirection == Direction.Down)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' 0);  				directionArrow.LineTo(4' 0);  				directionArrow.LineTo(0' -5);  			}  			else if (this.MenuDirection == Direction.Up)  			{  				directionArrow = new PathStorage();  				directionArrow.MoveTo(-4' -5);  				directionArrow.LineTo(4' -5);  				directionArrow.LineTo(0' 0);  			}  			else  			{  				throw new NotImplementedException("Pulldown direction has not been implemented");  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,DropDownList,The following statement contains a magic number: mainControlText = new TextWidget(noSelectionString)  			{  				AutoExpandBoundsToText = true'  				VAnchor = VAnchor.ParentBottom | VAnchor.FitToChildren'  				HAnchor = HAnchor.ParentLeft | HAnchor.FitToChildren'  				Margin = new BorderDouble(right: 30)'  				TextColor = RGBA_Bytes.Black  			};
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,OnDraw,The following statement contains a magic number: if (directionArrow != null)  			{  				graphics2D.Render(directionArrow' LocalBounds.Right - 8' LocalBounds.Top - 4' BorderColor);  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,OnDraw,The following statement contains a magic number: if (directionArrow != null)  			{  				graphics2D.Render(directionArrow' LocalBounds.Right - 8' LocalBounds.Top - 4' BorderColor);  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The following statement contains a magic number: if (UseLeftIcons)  			{  				currentPadding = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,AddItem,The following statement contains a magic number: if (UseLeftIcons)  			{  				currentPadding = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: if (UseLeftIcons || leftImage != null)  			{  				if (leftImage != null)  				{  					int size = (int)(20 * GuiWidget.DeviceScale + .5);  					ImageBuffer scaledImage = ImageBuffer.CreateScaledImage(leftImage' size' size);  					rowContainer.AddChild(new ImageWidget(scaledImage)  					{  						VAnchor = VAnchor.ParentCenter'  						Margin = new BorderDouble(MenuItemsPadding.Left' MenuItemsPadding.Bottom' 3' MenuItemsPadding.Top)'  					});  					textWidget.Margin = new BorderDouble(0' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  				else  				{  					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: if (UseLeftIcons || leftImage != null)  			{  				if (leftImage != null)  				{  					int size = (int)(20 * GuiWidget.DeviceScale + .5);  					ImageBuffer scaledImage = ImageBuffer.CreateScaledImage(leftImage' size' size);  					rowContainer.AddChild(new ImageWidget(scaledImage)  					{  						VAnchor = VAnchor.ParentCenter'  						Margin = new BorderDouble(MenuItemsPadding.Left' MenuItemsPadding.Bottom' 3' MenuItemsPadding.Top)'  					});  					textWidget.Margin = new BorderDouble(0' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  				else  				{  					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: if (UseLeftIcons || leftImage != null)  			{  				if (leftImage != null)  				{  					int size = (int)(20 * GuiWidget.DeviceScale + .5);  					ImageBuffer scaledImage = ImageBuffer.CreateScaledImage(leftImage' size' size);  					rowContainer.AddChild(new ImageWidget(scaledImage)  					{  						VAnchor = VAnchor.ParentCenter'  						Margin = new BorderDouble(MenuItemsPadding.Left' MenuItemsPadding.Bottom' 3' MenuItemsPadding.Top)'  					});  					textWidget.Margin = new BorderDouble(0' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  				else  				{  					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: if (UseLeftIcons || leftImage != null)  			{  				if (leftImage != null)  				{  					int size = (int)(20 * GuiWidget.DeviceScale + .5);  					ImageBuffer scaledImage = ImageBuffer.CreateScaledImage(leftImage' size' size);  					rowContainer.AddChild(new ImageWidget(scaledImage)  					{  						VAnchor = VAnchor.ParentCenter'  						Margin = new BorderDouble(MenuItemsPadding.Left' MenuItemsPadding.Bottom' 3' MenuItemsPadding.Top)'  					});  					textWidget.Margin = new BorderDouble(0' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  				else  				{  					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  			}
Magic Number,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,GetMenuContent,The following statement contains a magic number: if (UseLeftIcons || leftImage != null)  			{  				if (leftImage != null)  				{  					int size = (int)(20 * GuiWidget.DeviceScale + .5);  					ImageBuffer scaledImage = ImageBuffer.CreateScaledImage(leftImage' size' size);  					rowContainer.AddChild(new ImageWidget(scaledImage)  					{  						VAnchor = VAnchor.ParentCenter'  						Margin = new BorderDouble(MenuItemsPadding.Left' MenuItemsPadding.Bottom' 3' MenuItemsPadding.Top)'  					});  					textWidget.Margin = new BorderDouble(0' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  				else  				{  					textWidget.Margin = new BorderDouble(MenuItemsPadding.Left + 20 + 3' MenuItemsPadding.Bottom' MenuItemsPadding.Right' MenuItemsPadding.Top);  				}  			}
Magic Number,MatterHackers.Agg.UI,Menu,C:\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,AddHorizontalLine,The following statement contains a magic number: MenuItem menuItem = new MenuItem(new GuiWidget()  			{  				HAnchor = HAnchor.ParentLeftRight'  				Height = 2'  				BackgroundColor = RGBA_Bytes.Gray'  				Margin = new BorderDouble(3' 1)'  				VAnchor = VAnchor.ParentCenter'  			}' "HorizontalLine");
Magic Number,MatterHackers.Agg.UI,Menu,C:\repos\MatterHackers_agg-sharp\Gui\Menu\Menu.cs,AddHorizontalLine,The following statement contains a magic number: MenuItem menuItem = new MenuItem(new GuiWidget()  			{  				HAnchor = HAnchor.ParentLeftRight'  				Height = 2'  				BackgroundColor = RGBA_Bytes.Gray'  				Margin = new BorderDouble(3' 1)'  				VAnchor = VAnchor.ParentCenter'  			}' "HorizontalLine");
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,ScrollIntoView,The following statement contains a magic number: if (scrollingWindow.VerticalScrollBar.Visible)  			{  				scrollingWindow.ScrollPosition = new Vector2(0' -widget.BoundsRelativeToParent.Bottom + this.Height /2);  			}
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,MakeMenuHaveScroll,The following statement contains a magic number: scrollingWindow.MinimumSize = new Vector2(Width + 15' 0);
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,OnDraw,The following statement contains a magic number: Stroke wideOutline = new Stroke(outlineRect' borderWidth * 2);
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,widgetRelativeTo_PositionChanged,The following statement contains a magic number: if (widgetRelativeTo != null)  			{  				Vector2 zero = widgetRelativeTo.OriginRelativeParent;  				if (alignToRightEdge)  				{  					zero += new Vector2(widgetRelativeTo.LocalBounds.Left' widgetRelativeTo.LocalBounds.Bottom);  				}    				GuiWidget topParent = widgetRelativeTo.Parent;  				while (topParent != null && topParent.Parent != null)  				{  					topParent.ParentToChildTransform.transform(ref zero);  					topParent = topParent.Parent;  				}    				double alignmentOffset = 0;  				if (alignToRightEdge)  				{  					alignmentOffset = -Width + widgetRelativeTo.Width;  				}    				if (firstTimeSizing)  				{  					double distanceToWindowBottom = zero.y - Height;  					if (distanceToWindowBottom < 0)  					{  						if (MenuItems.Count > 0   							&& MenuItems[0].Height > 10  							&& Height + distanceToWindowBottom > MenuItems[0].Height * 3)  						{  							MakeMenuHaveScroll(Height + distanceToWindowBottom - 5);  						}  						else  						{  							direction = Direction.Up;  						}  					}  				}    				switch (direction)  				{  					case Direction.Down:  						this.OriginRelativeParent = zero + new Vector2(alignmentOffset' -Height) + openOffset;  						break;    					case Direction.Up:  						this.OriginRelativeParent = zero + new Vector2(alignmentOffset' widgetRelativeTo.Height) + openOffset;  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,widgetRelativeTo_PositionChanged,The following statement contains a magic number: if (widgetRelativeTo != null)  			{  				Vector2 zero = widgetRelativeTo.OriginRelativeParent;  				if (alignToRightEdge)  				{  					zero += new Vector2(widgetRelativeTo.LocalBounds.Left' widgetRelativeTo.LocalBounds.Bottom);  				}    				GuiWidget topParent = widgetRelativeTo.Parent;  				while (topParent != null && topParent.Parent != null)  				{  					topParent.ParentToChildTransform.transform(ref zero);  					topParent = topParent.Parent;  				}    				double alignmentOffset = 0;  				if (alignToRightEdge)  				{  					alignmentOffset = -Width + widgetRelativeTo.Width;  				}    				if (firstTimeSizing)  				{  					double distanceToWindowBottom = zero.y - Height;  					if (distanceToWindowBottom < 0)  					{  						if (MenuItems.Count > 0   							&& MenuItems[0].Height > 10  							&& Height + distanceToWindowBottom > MenuItems[0].Height * 3)  						{  							MakeMenuHaveScroll(Height + distanceToWindowBottom - 5);  						}  						else  						{  							direction = Direction.Up;  						}  					}  				}    				switch (direction)  				{  					case Direction.Down:  						this.OriginRelativeParent = zero + new Vector2(alignmentOffset' -Height) + openOffset;  						break;    					case Direction.Up:  						this.OriginRelativeParent = zero + new Vector2(alignmentOffset' widgetRelativeTo.Height) + openOffset;  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,widgetRelativeTo_PositionChanged,The following statement contains a magic number: if (widgetRelativeTo != null)  			{  				Vector2 zero = widgetRelativeTo.OriginRelativeParent;  				if (alignToRightEdge)  				{  					zero += new Vector2(widgetRelativeTo.LocalBounds.Left' widgetRelativeTo.LocalBounds.Bottom);  				}    				GuiWidget topParent = widgetRelativeTo.Parent;  				while (topParent != null && topParent.Parent != null)  				{  					topParent.ParentToChildTransform.transform(ref zero);  					topParent = topParent.Parent;  				}    				double alignmentOffset = 0;  				if (alignToRightEdge)  				{  					alignmentOffset = -Width + widgetRelativeTo.Width;  				}    				if (firstTimeSizing)  				{  					double distanceToWindowBottom = zero.y - Height;  					if (distanceToWindowBottom < 0)  					{  						if (MenuItems.Count > 0   							&& MenuItems[0].Height > 10  							&& Height + distanceToWindowBottom > MenuItems[0].Height * 3)  						{  							MakeMenuHaveScroll(Height + distanceToWindowBottom - 5);  						}  						else  						{  							direction = Direction.Up;  						}  					}  				}    				switch (direction)  				{  					case Direction.Down:  						this.OriginRelativeParent = zero + new Vector2(alignmentOffset' -Height) + openOffset;  						break;    					case Direction.Up:  						this.OriginRelativeParent = zero + new Vector2(alignmentOffset' widgetRelativeTo.Height) + openOffset;  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg.UI,OpenMenuContents,C:\repos\MatterHackers_agg-sharp\Gui\Menu\OpenMenuContents.cs,AllowClickingItems,The following statement contains a magic number: if ((positionAtMouseDown - positionAtMouseUp).Length > 5)  			{  				return false;  			}
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,ShowMessageBox,The following statement contains a magic number: MessageBox messageBox = new MessageBox(message' caption' messageType' 400' 300);
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,ShowMessageBox,The following statement contains a magic number: MessageBox messageBox = new MessageBox(message' caption' messageType' 400' 300);
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new RGBA_Bytes(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new RGBA_Bytes(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new RGBA_Bytes(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: BackgroundColor = new RGBA_Bytes(50' 50' 50' 240);
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: topToBottomFlow.AddChild(new GuiWidget(10' 10));
Magic Number,MatterHackers.Agg.UI,MessageBox,C:\repos\MatterHackers_agg-sharp\Gui\MessageBox.cs,MessageBox,The following statement contains a magic number: topToBottomFlow.AddChild(new GuiWidget(10' 10));
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,RadioButtonViewText,The following statement contains a magic number: activeColor = new RGBA_Bytes(0.4' 0.0' 0.0);
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: Vector2 center = new Vector2(boxWidth / 2 + 1' boxWidth / 2 - labelTextWidget.Printer.TypeFaceStyle.DescentInPixels);
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: Vector2 center = new Vector2(boxWidth / 2 + 1' boxWidth / 2 - labelTextWidget.Printer.TypeFaceStyle.DescentInPixels);
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: if (radioButton.Checked)  			{  				graphics2D.Circle(center' boxWidth / 4' radioButton.TextColor);  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: if (radioButton.MouseDownOnButton && radioButton.FirstWidgetUnderMouse)  			{  				// extra frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2)' 2)' radioButton.TextColor);  			}  			else  			{  				// the frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2))' radioButton.TextColor);  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: if (radioButton.MouseDownOnButton && radioButton.FirstWidgetUnderMouse)  			{  				// extra frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2)' 2)' radioButton.TextColor);  			}  			else  			{  				// the frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2))' radioButton.TextColor);  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: if (radioButton.MouseDownOnButton && radioButton.FirstWidgetUnderMouse)  			{  				// extra frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2)' 2)' radioButton.TextColor);  			}  			else  			{  				// the frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2))' radioButton.TextColor);  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: if (radioButton.MouseDownOnButton && radioButton.FirstWidgetUnderMouse)  			{  				// extra frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2)' 2)' radioButton.TextColor);  			}  			else  			{  				// the frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2))' radioButton.TextColor);  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,DoDrawBeforeChildren,The following statement contains a magic number: if (radioButton.MouseDownOnButton && radioButton.FirstWidgetUnderMouse)  			{  				// extra frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2)' 2)' radioButton.TextColor);  			}  			else  			{  				// the frame  				graphics2D.Render(new Stroke(new Ellipse(center' boxWidth / 2' boxWidth / 2))' radioButton.TextColor);  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,GetLocalBounds,The following statement contains a magic number: labelTextWidget.OriginRelativeParent = new Vector2(boxWidth * 2' -labelTextWidget.Printer.TypeFaceStyle.DescentInPixels);
Magic Number,MatterHackers.Agg.UI,RadioButtonViewText,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonViewText.cs,GetLocalBounds,The following statement contains a magic number: localBounds.Right = localBounds.Left + boxWidth * 2 + labelTextWidget.Width;
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,ToolTipManager,The following statement contains a magic number: UiThread.RunOnIdle(CheckIfNeedToDisplayToolTip' .02);
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,CheckIfNeedToDisplayToolTip,The following statement contains a magic number: UiThread.RunOnIdle(CheckIfNeedToDisplayToolTip' .05);
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,ToolTipManager,C:\repos\MatterHackers_agg-sharp\Gui\SystemWindow\ToolTipManager.cs,DoShowToolTip,The following statement contains a magic number: if (widgetThatWantsToShowToolTip != null  				&& widgetThatWantsToShowToolTip != widgetThatIsShowingToolTip)  			{  				RectangleDouble screenBounds = widgetThatWantsToShowToolTip.TransformToScreenSpace(widgetThatWantsToShowToolTip.LocalBounds);  				if (screenBounds.Contains(mousePosition))  				{  					RemoveToolTip();  					widgetThatIsShowingToolTip = null;    					toolTipText = widgetThatWantsToShowToolTip.ToolTipText;  					toolTipWidget = new FlowLayoutWidget()  					{  						BackgroundColor = RGBA_Bytes.White'  						OriginRelativeParent = new Vector2((int)mousePosition.x' (int)mousePosition.y)'  						Padding = new BorderDouble(3)'  						Selectable = false'  					};    					toolTipWidget.Name = "ToolTipWidget";    					toolTipWidget.AfterDraw += (sender' drawEventHandler) =>  					{  						drawEventHandler.graphics2D.Rectangle(toolTipWidget.LocalBounds' RGBA_Bytes.Black);  					};    					// Make sure we wrap long text  					toolTipWidget.AddChild(new WrappedTextWidget(toolTipText)   					{  						Width = 350 * GuiWidget.DeviceScale'  						HAnchor = HAnchor.FitToChildren'  					});    					// Increase the delay to make long text stay on screen long enough to read  					double RatioOfExpectedText = Math.Max(1' (widgetThatWantsToShowToolTip.ToolTipText.Length / 50.0));  					CurrentAutoPopDelay = RatioOfExpectedText * AutoPopDelay;    					owner.AddChild(toolTipWidget);  					if (ToolTipShown != null)  					{  						ToolTipShown(this' new StringEventArgs(CurrentText));  					}    					//timeCurrentToolTipHasBeenShowing.Reset();  					//timeCurrentToolTipHasBeenShowingWasRunning = true;  					timeCurrentToolTipHasBeenShowing.Restart();    					RectangleDouble toolTipBounds = toolTipWidget.LocalBounds;    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + new Vector2(0' -toolTipBounds.Bottom - toolTipBounds.Height - 23);    					Vector2 offset = Vector2.Zero;  					RectangleDouble ownerBounds = owner.LocalBounds;  					RectangleDouble toolTipBoundsRelativeToParent = toolTipWidget.BoundsRelativeToParent;    					if (toolTipBoundsRelativeToParent.Right > ownerBounds.Right - 3)  					{  						offset.x = ownerBounds.Right - toolTipBoundsRelativeToParent.Right - 3;  					}    					if (toolTipBoundsRelativeToParent.Bottom < ownerBounds.Bottom + 3)  					{  						offset.y = ownerBounds.Bottom - toolTipBoundsRelativeToParent.Bottom + 3;  					}    					toolTipWidget.OriginRelativeParent = toolTipWidget.OriginRelativeParent + offset;    					widgetThatIsShowingToolTip = widgetThatWantsToShowToolTip;  					widgetThatWantsToShowToolTip = null;  				}  			}
Magic Number,MatterHackers.Agg.UI,OutputScroll,C:\repos\MatterHackers_agg-sharp\Gui\OutputScroll.cs,OnDraw,The following statement contains a magic number: double y = LocalBounds.Bottom + printer.TypeFaceStyle.EmSizeInPixels * (TOTOL_POW2 - 1) + 5;
Magic Number,MatterHackers.Agg.UI,OutputScroll,C:\repos\MatterHackers_agg-sharp\Gui\OutputScroll.cs,OnDraw,The following statement contains a magic number: for (int index = lineCount; index < lineCount + TOTOL_POW2; index++)  			{  				if (y > LocalBounds.Top)  				{  					y -= printer.TypeFaceStyle.EmSizeInPixels;  					continue;  				}  				int arrayIndex = (index % TOTOL_POW2);  				if (lines[arrayIndex] != null)  				{  					printer.Text = lines[arrayIndex];  					printer.Origin = new Vector2(Bounds.Left + 2' y);  					printer.Render(graphics2D' TextColor);  				}  				y -= printer.TypeFaceStyle.EmSizeInPixels;  				if (y < -printer.TypeFaceStyle.EmSizeInPixels)  				{  					break;  				}  			}
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: x = m_polygon[m_vertex * 2];
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: y = m_polygon[m_vertex * 2 + 1];
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: if (m_roundoff)  			{  				x = Math.Floor(x) + 0.5;  				y = Math.Floor(y) + 0.5;  			}
Magic Number,MatterHackers.Agg.UI,simple_polygon_vertex_source,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: if (m_roundoff)  			{  				x = Math.Floor(x) + 0.5;  				y = Math.Floor(y) + 0.5;  			}
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,polygon_ctrl_impl,The following statement contains a magic number: m_polygon = new ArrayPOD<double>(np * 2);
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,GetXN,The following statement contains a magic number: return m_polygon.Array[n * 2];
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,SetXN,The following statement contains a magic number: m_polygon.Array[n * 2] = newXN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,AddXN,The following statement contains a magic number: m_polygon.Array[n * 2] += newXN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,GetYN,The following statement contains a magic number: return m_polygon.Array[n * 2 + 1];
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,SetYN,The following statement contains a magic number: m_polygon.Array[n * 2 + 1] = newYN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,AddYN,The following statement contains a magic number: m_polygon.Array[n * 2 + 1] += newYN;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: if (m_status == 0)  			{  				cmd = m_stroke.vertex(out x' out y);  				if (!ShapePath.is_stop(cmd))  				{  					ParentToChildTransform.transform(ref x' ref y);  					return cmd;  				}  				if (m_node >= 0 && m_node == (int)(m_status)) r *= 1.2;  				m_ellipse.init(GetXN(m_status)' GetYN(m_status)' r' r' 32);  				++m_status;  			}
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: if (m_status == 0)  			{  				cmd = m_stroke.vertex(out x' out y);  				if (!ShapePath.is_stop(cmd))  				{  					ParentToChildTransform.transform(ref x' ref y);  					return cmd;  				}  				if (m_node >= 0 && m_node == (int)(m_status)) r *= 1.2;  				m_ellipse.init(GetXN(m_status)' GetYN(m_status)' r' r' 32);  				++m_status;  			}
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: if (m_node >= 0 && m_node == (int)(m_status)) r *= 1.2;
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,vertex,The following statement contains a magic number: m_ellipse.init(GetXN(m_status)' GetYN(m_status)' r' r' 32);
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,check_edge,The following statement contains a magic number: if (Math.Sqrt(dx * dx + dy * dy) > 0.0000001)  			{  				double x3 = x;  				double y3 = y;  				double x4 = x3 - dy;  				double y4 = y3 + dx;    				double den = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);  				double u1 = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / den;    				double xi = x1 + u1 * (x2 - x1);  				double yi = y1 + u1 * (y2 - y1);    				dx = xi - x;  				dy = yi - y;    				if (u1 > 0.0 && u1 < 1.0 && Math.Sqrt(dx * dx + dy * dy) <= m_point_radius)  				{  					ret = true;  				}  			}
Magic Number,MatterHackers.Agg.UI,polygon_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\PolygonWidget.cs,point_in_polygon,The following statement contains a magic number: if (m_num_points < 3) return false;
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,RadioButtonGroup,The following statement contains a magic number: Padding = new BorderDouble(5);
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,RadioButtonGroup,The following statement contains a magic number: backgroundColor = (new RGBA_Floats(1.0' 1.0' 0.9));
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,RadioButtonGroup,The following statement contains a magic number: activeColor = (new RGBA_Floats(0.4' 0.0' 0.0));
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,OnDraw,The following statement contains a magic number: RoundedRect backgroundRect = new RoundedRect(LocalBounds' 4);
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,AddRadioButton,The following statement contains a magic number: newRadioButton.Margin = new BorderDouble(5' 0);
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return backgroundColor;    				case 1:  					return borderColor;    				case 2:  					return textColor;    				case 3:  					return inactiveColor;    				case 4:  					return activeColor;    				default:  					throw new System.IndexOutOfRangeException("There is not a color for this index");  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return backgroundColor;    				case 1:  					return borderColor;    				case 2:  					return textColor;    				case 3:  					return inactiveColor;    				case 4:  					return activeColor;    				default:  					throw new System.IndexOutOfRangeException("There is not a color for this index");  			}
Magic Number,MatterHackers.Agg.UI,RadioButtonGroup,C:\repos\MatterHackers_agg-sharp\Gui\RadioButton\RadioButtonGroup.cs,color,The following statement contains a magic number: switch (i)  			{  				case 0:  					return backgroundColor;    				case 1:  					return borderColor;    				case 2:  					return textColor;    				case 3:  					return inactiveColor;    				case 4:  					return activeColor;    				default:  					throw new System.IndexOutOfRangeException("There is not a color for this index");  			}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseMove,The following statement contains a magic number: if (ScrollPosition.y < scrollOnDownY - 10  				|| ScrollPosition.y > scrollOnDownY + 10)  			{  				// If we have ever scrolled too far remember not to pass a valid up click  				haveScrolledTooFar = true;  			}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseMove,The following statement contains a magic number: if (ScrollPosition.y < scrollOnDownY - 10  				|| ScrollPosition.y > scrollOnDownY + 10)  			{  				// If we have ever scrolled too far remember not to pass a valid up click  				haveScrolledTooFar = true;  			}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseUp,The following statement contains a magic number: if (haveScrolledTooFar)  			{  				base.OnMouseUp(new MouseEventArgs(mouseEvent' -10000' -10000));  			}  			else  			{  				base.OnMouseUp(mouseEvent);  			}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseUp,The following statement contains a magic number: if (haveScrolledTooFar)  			{  				base.OnMouseUp(new MouseEventArgs(mouseEvent' -10000' -10000));  			}  			else  			{  				base.OnMouseUp(mouseEvent);  			}
Magic Number,MatterHackers.Agg.UI,ScrollableWidget,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollableWidget.cs,OnMouseWheel,The following statement contains a magic number: if (AutoScroll)  			{  				Vector2 oldScrollPosition = ScrollPosition;  				ScrollPosition += new Vector2(0' -mouseEvent.WheelDelta / 10);  				if (oldScrollPosition != ScrollPosition)  				{  					mouseEvent.WheelDelta = 0;  				}  				Invalidate();  			}
Magic Number,MatterHackers.Agg.UI,ScrollingArea,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollingArea.cs,ValidateScrollPosition,The following statement contains a magic number: if (boundsWithMargin.Height < parentScrollableWidget.LocalBounds.Height)  			{  				debugRecursionCount++;  				if (debugRecursionCount < 20)  				{  					parentScrollableWidget.TopLeftOffset = new Vector2(parentScrollableWidget.TopLeftOffset.x' 0);  				}  				debugRecursionCount--;  				newOrigin.y = OriginRelativeParent.y;  			}  			else  			{  				if (newOrigin.y + Margin.Top + Padding.Top + LocalBounds.Top < Parent.LocalBounds.Top)  				{  					newOrigin.y = Parent.LocalBounds.Top - Margin.Top - Padding.Top - LocalBounds.Top;  				}  				else if (LocalBounds.Height + Margin.Height >= Parent.LocalBounds.Height)  				{  					if (BoundsRelativeToParent.Bottom - Margin.Bottom > Parent.LocalBounds.Bottom)  					{  						newOrigin.y = Parent.LocalBounds.Bottom - LocalBounds.Bottom + Margin.Bottom;  					}  				}  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackHeight = 3;
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackColor = new RGBA_Bytes(220' 220' 220);
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackColor = new RGBA_Bytes(220' 220' 220);
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,SlideView,The following statement contains a magic number: TrackColor = new RGBA_Bytes(220' 220' 220);
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackBounds,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				trackBounds = new RectangleDouble(0' -TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels' TrackHeight / 2);  			}  			else  			{  				trackBounds = new RectangleDouble(-TrackHeight / 2' 0' TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackBounds,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				trackBounds = new RectangleDouble(0' -TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels' TrackHeight / 2);  			}  			else  			{  				trackBounds = new RectangleDouble(-TrackHeight / 2' 0' TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackBounds,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				trackBounds = new RectangleDouble(0' -TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels' TrackHeight / 2);  			}  			else  			{  				trackBounds = new RectangleDouble(-TrackHeight / 2' 0' TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackBounds,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				trackBounds = new RectangleDouble(0' -TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels' TrackHeight / 2);  			}  			else  			{  				trackBounds = new RectangleDouble(-TrackHeight / 2' 0' TrackHeight / 2' sliderAttachedTo.TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTextPosition,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				double textHeight = 0;  				if (sliderAttachedTo.sliderTextWidget.Text != "")  				{  					textHeight = sliderAttachedTo.sliderTextWidget.Printer.TypeFaceStyle.EmSizeInPixels;  				}  				textPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' GetThumbBounds().Bottom - textHeight);  			}  			else  			{  				textPosition = new Vector2(0' -24);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTextPosition,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				double textHeight = 0;  				if (sliderAttachedTo.sliderTextWidget.Text != "")  				{  					textHeight = sliderAttachedTo.sliderTextWidget.Printer.TypeFaceStyle.EmSizeInPixels;  				}  				textPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' GetThumbBounds().Bottom - textHeight);  			}  			else  			{  				textPosition = new Vector2(0' -24);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: RoundedRect track = new RoundedRect(GetTrackBounds()' TrackHeight / 2);
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				ValuePrintPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' -sliderAttachedTo.ThumbHeight - 12);  			}  			else  			{  				ValuePrintPosition = new Vector2(0' -sliderAttachedTo.ThumbHeight - 12);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				ValuePrintPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' -sliderAttachedTo.ThumbHeight - 12);  			}  			else  			{  				ValuePrintPosition = new Vector2(0' -sliderAttachedTo.ThumbHeight - 12);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: if (sliderAttachedTo.Orientation == Orientation.Horizontal)  			{  				ValuePrintPosition = new Vector2(sliderAttachedTo.TotalWidthInPixels / 2' -sliderAttachedTo.ThumbHeight - 12);  			}  			else  			{  				ValuePrintPosition = new Vector2(0' -sliderAttachedTo.ThumbHeight - 12);  			}
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: RoundedRect thumbOutside = new RoundedRect(thumbBounds' sliderAttachedTo.ThumbWidth / 2);
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: graphics2D.Render(thumbOutside' RGBA_Floats.GetTweenColor(ThumbColor.GetAsRGBA_Floats()' RGBA_Floats.Black.GetAsRGBA_Floats()' .2).GetAsRGBA_Bytes());
Magic Number,MatterHackers.Agg.UI,SlideView,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,DoDrawAfterChildren,The following statement contains a magic number: RoundedRect thumbInside = new RoundedRect(thumbBounds' sliderAttachedTo.ThumbWidth / 2);
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The following statement contains a magic number: ThumbWidth = 10;
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,Slider,The following statement contains a magic number: ThumbHeight = 20;
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetThumbHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(-ThumbWidth / 2 + PositionPixelsFromFirstValue' -ThumbHeight / 2'  					ThumbWidth / 2 + PositionPixelsFromFirstValue' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' -ThumbWidth / 2 + PositionPixelsFromFirstValue'  					ThumbHeight / 2' ThumbWidth / 2 + PositionPixelsFromFirstValue);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetPositionPixelsFromValue,The following statement contains a magic number: return ThumbWidth / 2 + TrackWidth * GetPosition0To1FromValue(value);
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(0' -ThumbHeight / 2'  					TotalWidthInPixels' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' 0' ThumbHeight / 2' TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(0' -ThumbHeight / 2'  					TotalWidthInPixels' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' 0' ThumbHeight / 2' TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(0' -ThumbHeight / 2'  					TotalWidthInPixels' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' 0' ThumbHeight / 2' TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,Slider,C:\repos\MatterHackers_agg-sharp\Gui\Slider\Slider.cs,GetTrackHitBounds,The following statement contains a magic number: if (Orientation == Orientation.Horizontal)  			{  				return new RectangleDouble(0' -ThumbHeight / 2'  					TotalWidthInPixels' ThumbHeight / 2);  			}  			else  			{  				return new RectangleDouble(-ThumbHeight / 2' 0' ThumbHeight / 2' TotalWidthInPixels);  			}
Magic Number,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The following statement contains a magic number: splitterWidth = 6;
Magic Number,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,Splitter,The following statement contains a magic number: SplitterDistance = 120;
Magic Number,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnBoundsChanged,The following statement contains a magic number: splitterBar.LocalBounds = new RectangleDouble(0' 0' 6' Height);
Magic Number,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnBoundsChanged,The following statement contains a magic number: Panel1.LocalBounds = new RectangleDouble(0' 0' SplitterDistance - SplitterWidth / 2' LocalBounds.Height);
Magic Number,MatterHackers.Agg.UI,Splitter,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnBoundsChanged,The following statement contains a magic number: Panel2.LocalBounds = new RectangleDouble(0' 0' LocalBounds.Width - SplitterDistance - SplitterWidth / 2' LocalBounds.Height);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: RoundedRect roundRect = new RoundedRect(new RectangleDouble(Width / 2 - Width / 3 - 1' Height / 2 - Height / 8' Width / 2 + Width / 3 - 1' Height / 2 + Height / 8)' 2);
Magic Number,MatterHackers.Agg.UI,SplitterBar,C:\repos\MatterHackers_agg-sharp\Gui\Splitter.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(roundRect' new RGBA_Bytes(0' 0' 0' 60));
Magic Number,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,Tab,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\Tab.cs,Tab,The following statement contains a magic number: Padding = new BorderDouble(5' 3' 20' 3);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,UpdateLocalBounds,The following statement contains a magic number: double width = Math.Max(internalTextWidget.Width + 2' 3);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,UpdateLocalBounds,The following statement contains a magic number: double width = Math.Max(internalTextWidget.Width + 2' 3);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnIdle,The following statement contains a magic number: if (this.Focused  				&& timeSinceTurnOn.ElapsedMilliseconds >= barOnTime * 950  				&& !HasBeenClosed)  			{  				if (timeSinceTurnOn.ElapsedMilliseconds >= (barOnTime + barOffTime) * 950)  				{  					RestartBarFlash();  				}  				else  				{  					UiThread.RunOnIdle(OnIdle' barOffTime);  					Invalidate();  				}  			}  			else  			{  				timeSinceTurnOn.Stop();  			}
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnIdle,The following statement contains a magic number: if (this.Focused  				&& timeSinceTurnOn.ElapsedMilliseconds >= barOnTime * 950  				&& !HasBeenClosed)  			{  				if (timeSinceTurnOn.ElapsedMilliseconds >= (barOnTime + barOffTime) * 950)  				{  					RestartBarFlash();  				}  				else  				{  					UiThread.RunOnIdle(OnIdle' barOffTime);  					Invalidate();  				}  			}  			else  			{  				timeSinceTurnOn.Stop();  			}
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnDraw,The following statement contains a magic number: boundsPlusPoint5.Inflate(-.5);
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnMouseDown,The following statement contains a magic number: if (mouseEvent.Clicks < 2)  			{  				if (CharIndexToInsertBefore == -1)  				{  					// we could not find any characters when looking for mouse click position  					CharIndexToInsertBefore = 0;  				}  				SelectionIndexToStartBefore = CharIndexToInsertBefore;  				Selecting = false;  				mouseIsDown = true;  			}  			else if (IsDoubleClick(mouseEvent))  			{  				while (CharIndexToInsertBefore >= Text.Length || (CharIndexToInsertBefore > -1 && !WordBreakChars.Contains(Text[CharIndexToInsertBefore])))  				{  					CharIndexToInsertBefore--;  				}  				CharIndexToInsertBefore++;  				SelectionIndexToStartBefore = CharIndexToInsertBefore + 1;  				while (SelectionIndexToStartBefore < Text.Length && !WordBreakChars.Contains(Text[SelectionIndexToStartBefore]))  				{  					SelectionIndexToStartBefore++;  				}  				Selecting = true;  			}
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The following statement contains a magic number: if(keyPressEvent.KeyChar < 32  				&& keyPressEvent.KeyChar != 13  				&& keyPressEvent.KeyChar != 9)  			{  				return;  			}
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The following statement contains a magic number: if(keyPressEvent.KeyChar < 32  				&& keyPressEvent.KeyChar != 13  				&& keyPressEvent.KeyChar != 9)  			{  				return;  			}
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyPress,The following statement contains a magic number: if(keyPressEvent.KeyChar < 32  				&& keyPressEvent.KeyChar != 13  				&& keyPressEvent.KeyChar != 9)  			{  				return;  			}
Magic Number,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,GetIndexOffset,The following statement contains a magic number: while (true)  			{  				internalTextWidget.Printer.GetOffset(CharacterStartIndexInclusive' CharacterStartIndexInclusive + OffsetIndex' out offset);  				OffsetIndex++;  				if (offset.x >= DesiredPixelOffset || OffsetIndex >= EndOffsetIndex)  				{  					if (Math.Abs(offset.y) < .01  						&& Math.Abs(lastOffset.x - DesiredPixelOffset) < Math.Abs(offset.x - DesiredPixelOffset))  					{  						OffsetIndex--;  					}  					break;  				}  				lastOffset = offset;  			}
Magic Number,MatterHackers.Agg.UI,TextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,internalTextEditWidget_InsertBarPositionChanged,The following statement contains a magic number: if (currentOffsetInView.x > Width - 2)  			{  				requiredOffet.x = currentOffsetInView.x - Width + 2;  			}  			else if (currentOffsetInView.x < 0)  			{  				requiredOffet.x = currentOffsetInView.x;  			}
Magic Number,MatterHackers.Agg.UI,TextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextEditWidget.cs,internalTextEditWidget_InsertBarPositionChanged,The following statement contains a magic number: if (currentOffsetInView.x > Width - 2)  			{  				requiredOffet.x = currentOffsetInView.x - Width + 2;  			}  			else if (currentOffsetInView.x < 0)  			{  				requiredOffet.x = currentOffsetInView.x;  			}
Magic Number,MatterHackers.Agg.UI,TextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: switch (printer.Justification)  			{  				case Justification.Left:  					break;    				case Justification.Center:  					xOffsetForText = (Width - Printer.LocalBounds.Width) / 2;  					break;    				case Justification.Right:  					xOffsetForText = Width - Printer.LocalBounds.Width;  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.UI,TextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: if (EllipsisIfClipped && Printer.LocalBounds.Width > LocalBounds.Width) // only do this if it's static text  			{  				TypeFacePrinter shortTextPrinter = Printer;  				shortTextPrinter.DrawFromHintedCache = Printer.DrawFromHintedCache;  				while (shortTextPrinter.LocalBounds.Width > LocalBounds.Width && shortTextPrinter.Text.Length > 4)  				{  					shortTextPrinter = new TypeFacePrinter(shortTextPrinter.Text.Substring(0' shortTextPrinter.Text.Length - 4).TrimEnd(spaceTrim) + "..."' Printer);  				}  				shortTextPrinter.Render(graphics2D' currentColor);  			}  			else  			{  				// it all fits or it's editable (if editable it will need to be offset/scrolled sometimes).  				Printer.Render(graphics2D' currentColor);  			}
Magic Number,MatterHackers.Agg.UI,TextWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\TextWidget.cs,OnDraw,The following statement contains a magic number: if (EllipsisIfClipped && Printer.LocalBounds.Width > LocalBounds.Width) // only do this if it's static text  			{  				TypeFacePrinter shortTextPrinter = Printer;  				shortTextPrinter.DrawFromHintedCache = Printer.DrawFromHintedCache;  				while (shortTextPrinter.LocalBounds.Width > LocalBounds.Width && shortTextPrinter.Text.Length > 4)  				{  					shortTextPrinter = new TypeFacePrinter(shortTextPrinter.Text.Substring(0' shortTextPrinter.Text.Length - 4).TrimEnd(spaceTrim) + "..."' Printer);  				}  				shortTextPrinter.Render(graphics2D' currentColor);  			}  			else  			{  				// it all fits or it's editable (if editable it will need to be offset/scrolled sometimes).  				Printer.Render(graphics2D' currentColor);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,ThemeColors,C:\repos\MatterHackers_agg-sharp\Gui\Themes\ThemeColors.cs,Create,The following statement contains a magic number: if (darkTheme)  			{  				colors.PrimaryAccentColor = primary;  				colors.SecondaryAccentColor = secondary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(68' 68' 68);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(51' 51' 51);    				colors.TabLabelSelected = new RGBA_Bytes(255' 255' 255);  				colors.TabLabelUnselected = new RGBA_Bytes(180' 180' 180);  				colors.PrimaryTextColor = new RGBA_Bytes(255' 255' 255);  				colors.SecondaryTextColor = new RGBA_Bytes(200' 200' 200);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(62' 62' 62);  			}  			else  			{  				colors.PrimaryAccentColor = secondary;  				colors.SecondaryAccentColor = primary;    				colors.PrimaryBackgroundColor = new RGBA_Bytes(208' 208' 208);  				colors.SecondaryBackgroundColor = new RGBA_Bytes(185' 185' 185);  				colors.TabLabelSelected = new RGBA_Bytes(51' 51' 51);  				colors.TabLabelUnselected = new RGBA_Bytes(102' 102' 102);  				colors.PrimaryTextColor = new RGBA_Bytes(34' 34' 34);  				colors.SecondaryTextColor = new RGBA_Bytes(51' 51' 51);    				colors.TertiaryBackgroundColor = new RGBA_Bytes(190' 190' 190);  			}
Magic Number,MatterHackers.Agg.UI,UiThread,C:\repos\MatterHackers_agg-sharp\Gui\UiThread.cs,RunOnIdle,The following statement contains a magic number: lock(functionsToCheckIfTimeToCall)  			{  				functionsToCheckIfTimeToCall.Add(new CallBackAndState(callBack' state' timer.ElapsedMilliseconds + (int)(delayInSeconds * 1000)));  			}
Magic Number,MatterHackers.Agg.UI,TitleBarWidget,C:\repos\MatterHackers_agg-sharp\Gui\WindowWidget\TitleBarWidget.cs,OnDraw,The following statement contains a magic number: graphics2D.Render(roundRect' new RGBA_Bytes(0' 0' 0' 30));
Magic Number,MatterHackers.Agg.UI,WindowWidget,C:\repos\MatterHackers_agg-sharp\Gui\WindowWidget\WindowWidget.cs,WindowWidget,The following statement contains a magic number: int sizeOfDragBar = 20;
Magic Number,MatterHackers.Agg.UI,ToggleSwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The following statement contains a magic number: TextWidget text = new TextWidget(word' pointSize: 10' textColor: textColor);
Magic Number,MatterHackers.Agg.UI,ToggleSwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,createState,The following statement contains a magic number: switchGraphics.Margin = new BorderDouble(5' 0' 0' 0);
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,SwitchView,The following statement contains a magic number: thumbWidth = width / 4;
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: if (startValue)  				{  					RectangleDouble interior = GetSwitchBounds();  					interior.Inflate(-6);  					graphics2D.FillRectangle(interior' InteriorColor);  				}
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: border.Inflate(-3);
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(GetThumbBounds()' new RGBA_Bytes(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(GetThumbBounds()' new RGBA_Bytes(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(GetThumbBounds()' new RGBA_Bytes(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,SwitchView,C:\repos\MatterHackers_agg-sharp\Gui\ToggleSwitch\ToggleSwitch.cs,OnDraw,The following statement contains a magic number: graphics2D.Rectangle(GetThumbBounds()' new RGBA_Bytes(255' 255' 255' 90)' 1);
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,AllocateBackBuffer,The following statement contains a magic number: if (backBuffer == null || backBuffer.Width != intWidth || backBuffer.Height != intHeight)  			{  				backBuffer = new ImageBuffer(intWidth' intHeight' 32' new BlenderPreMultBGRA());  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: {  				if (!formHasLoaded)  				{  					OnLoad(null);  					formHasLoaded = true;  				}    				DrawCount++;    				BeforeDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				for (int i = 0; i < Children.Count; i++)  				{  					GuiWidget child = Children[i];  					if (child.Visible)  					{  						if (child.DebugShowBounds)  						{  							// draw the margin  							BorderDouble invertedMargin = child.DeviceMargin;  							invertedMargin.Left = -invertedMargin.Left;  							invertedMargin.Bottom = -invertedMargin.Bottom;  							invertedMargin.Right = -invertedMargin.Right;  							invertedMargin.Top = -invertedMargin.Top;  							DrawBorderBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new RGBA_Bytes(Red' 128));  						}    						RectangleDouble oldClippingRect = graphics2D.GetClippingRect();  						graphics2D.PushTransform();  						{  							Affine currentGraphics2DTransform = graphics2D.GetTransform();  							Affine accumulatedTransform = currentGraphics2DTransform * child.ParentToChildTransform;  							graphics2D.SetTransform(accumulatedTransform);    							RectangleDouble currentScreenClipping;  							if (child.CurrentScreenClipping(out currentScreenClipping))  							{  								currentScreenClipping.Left = Floor(currentScreenClipping.Left);  								currentScreenClipping.Right = Ceiling(currentScreenClipping.Right);  								currentScreenClipping.Bottom = Floor(currentScreenClipping.Bottom);  								currentScreenClipping.Top = Ceiling(currentScreenClipping.Top);  								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom)  								{  									BreakInDebugger("Right is less than Left or Top is less than Bottom");  								}    								graphics2D.SetClippingRect(currentScreenClipping);    								if (child.DoubleBuffer)  								{  									Vector2 offsetToRenderSurface = new Vector2(currentGraphics2DTransform.tx' currentGraphics2DTransform.ty);  									offsetToRenderSurface += child.OriginRelativeParent;    									double yFraction = offsetToRenderSurface.y - (int)offsetToRenderSurface.y;  									double xFraction = offsetToRenderSurface.x - (int)offsetToRenderSurface.x;  									int xOffset = (int)Floor(child.LocalBounds.Left);  									int yOffset = (int)Floor(child.LocalBounds.Bottom);  									if (child.isCurrentlyInvalid)  									{  										Graphics2D childBackBufferGraphics2D = child.backBuffer.NewGraphics2D();  										childBackBufferGraphics2D.Clear(new RGBA_Bytes(0' 0' 0' 0));  										Affine transformToBuffer = Affine.NewTranslation(-xOffset + xFraction' -yOffset + yFraction);  										childBackBufferGraphics2D.SetTransform(transformToBuffer);  										child.OnDrawBackground(childBackBufferGraphics2D);  										child.OnDraw(childBackBufferGraphics2D);    										child.backBuffer.MarkImageChanged();  										child.isCurrentlyInvalid = false;  									}    									offsetToRenderSurface.x = (int)offsetToRenderSurface.x + xOffset;  									offsetToRenderSurface.y = (int)offsetToRenderSurface.y + yOffset;  									// The transform to draw the backbuffer to the graphics2D must not have a factional amount  									// or we will get aliasing in the image and we want our back buffer pixels to map 1:1 to the next buffer  									if (offsetToRenderSurface.x - (int)offsetToRenderSurface.x != 0  										|| offsetToRenderSurface.y - (int)offsetToRenderSurface.y != 0)  									{  										BreakInDebugger("The transform for a back buffer must be integer to avoid aliasing.");  									}  									graphics2D.SetTransform(Affine.NewTranslation(offsetToRenderSurface));    									graphics2D.Render(child.backBuffer' 0' 0);  								}  								else  								{  									child.OnDrawBackground(graphics2D);  									child.OnDraw(graphics2D);  								}  							}  						}  						graphics2D.PopTransform();  						graphics2D.SetClippingRect(oldClippingRect);  					}  				}    				AfterDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				if (DebugShowBounds)  				{  					// draw the padding  					DrawBorderBounds(graphics2D' LocalBounds' DevicePadding' new RGBA_Bytes(Cyan' 128));    					// show the bounds and inside with an x  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' Green);  					graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' Green);  					graphics2D.Rectangle(LocalBounds' Red);  				}  				if (debugShowSize)  				{  					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);  				}  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: {  				if (!formHasLoaded)  				{  					OnLoad(null);  					formHasLoaded = true;  				}    				DrawCount++;    				BeforeDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				for (int i = 0; i < Children.Count; i++)  				{  					GuiWidget child = Children[i];  					if (child.Visible)  					{  						if (child.DebugShowBounds)  						{  							// draw the margin  							BorderDouble invertedMargin = child.DeviceMargin;  							invertedMargin.Left = -invertedMargin.Left;  							invertedMargin.Bottom = -invertedMargin.Bottom;  							invertedMargin.Right = -invertedMargin.Right;  							invertedMargin.Top = -invertedMargin.Top;  							DrawBorderBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new RGBA_Bytes(Red' 128));  						}    						RectangleDouble oldClippingRect = graphics2D.GetClippingRect();  						graphics2D.PushTransform();  						{  							Affine currentGraphics2DTransform = graphics2D.GetTransform();  							Affine accumulatedTransform = currentGraphics2DTransform * child.ParentToChildTransform;  							graphics2D.SetTransform(accumulatedTransform);    							RectangleDouble currentScreenClipping;  							if (child.CurrentScreenClipping(out currentScreenClipping))  							{  								currentScreenClipping.Left = Floor(currentScreenClipping.Left);  								currentScreenClipping.Right = Ceiling(currentScreenClipping.Right);  								currentScreenClipping.Bottom = Floor(currentScreenClipping.Bottom);  								currentScreenClipping.Top = Ceiling(currentScreenClipping.Top);  								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom)  								{  									BreakInDebugger("Right is less than Left or Top is less than Bottom");  								}    								graphics2D.SetClippingRect(currentScreenClipping);    								if (child.DoubleBuffer)  								{  									Vector2 offsetToRenderSurface = new Vector2(currentGraphics2DTransform.tx' currentGraphics2DTransform.ty);  									offsetToRenderSurface += child.OriginRelativeParent;    									double yFraction = offsetToRenderSurface.y - (int)offsetToRenderSurface.y;  									double xFraction = offsetToRenderSurface.x - (int)offsetToRenderSurface.x;  									int xOffset = (int)Floor(child.LocalBounds.Left);  									int yOffset = (int)Floor(child.LocalBounds.Bottom);  									if (child.isCurrentlyInvalid)  									{  										Graphics2D childBackBufferGraphics2D = child.backBuffer.NewGraphics2D();  										childBackBufferGraphics2D.Clear(new RGBA_Bytes(0' 0' 0' 0));  										Affine transformToBuffer = Affine.NewTranslation(-xOffset + xFraction' -yOffset + yFraction);  										childBackBufferGraphics2D.SetTransform(transformToBuffer);  										child.OnDrawBackground(childBackBufferGraphics2D);  										child.OnDraw(childBackBufferGraphics2D);    										child.backBuffer.MarkImageChanged();  										child.isCurrentlyInvalid = false;  									}    									offsetToRenderSurface.x = (int)offsetToRenderSurface.x + xOffset;  									offsetToRenderSurface.y = (int)offsetToRenderSurface.y + yOffset;  									// The transform to draw the backbuffer to the graphics2D must not have a factional amount  									// or we will get aliasing in the image and we want our back buffer pixels to map 1:1 to the next buffer  									if (offsetToRenderSurface.x - (int)offsetToRenderSurface.x != 0  										|| offsetToRenderSurface.y - (int)offsetToRenderSurface.y != 0)  									{  										BreakInDebugger("The transform for a back buffer must be integer to avoid aliasing.");  									}  									graphics2D.SetTransform(Affine.NewTranslation(offsetToRenderSurface));    									graphics2D.Render(child.backBuffer' 0' 0);  								}  								else  								{  									child.OnDrawBackground(graphics2D);  									child.OnDraw(graphics2D);  								}  							}  						}  						graphics2D.PopTransform();  						graphics2D.SetClippingRect(oldClippingRect);  					}  				}    				AfterDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				if (DebugShowBounds)  				{  					// draw the padding  					DrawBorderBounds(graphics2D' LocalBounds' DevicePadding' new RGBA_Bytes(Cyan' 128));    					// show the bounds and inside with an x  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' Green);  					graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' Green);  					graphics2D.Rectangle(LocalBounds' Red);  				}  				if (debugShowSize)  				{  					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);  				}  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: {  				if (!formHasLoaded)  				{  					OnLoad(null);  					formHasLoaded = true;  				}    				DrawCount++;    				BeforeDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				for (int i = 0; i < Children.Count; i++)  				{  					GuiWidget child = Children[i];  					if (child.Visible)  					{  						if (child.DebugShowBounds)  						{  							// draw the margin  							BorderDouble invertedMargin = child.DeviceMargin;  							invertedMargin.Left = -invertedMargin.Left;  							invertedMargin.Bottom = -invertedMargin.Bottom;  							invertedMargin.Right = -invertedMargin.Right;  							invertedMargin.Top = -invertedMargin.Top;  							DrawBorderBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new RGBA_Bytes(Red' 128));  						}    						RectangleDouble oldClippingRect = graphics2D.GetClippingRect();  						graphics2D.PushTransform();  						{  							Affine currentGraphics2DTransform = graphics2D.GetTransform();  							Affine accumulatedTransform = currentGraphics2DTransform * child.ParentToChildTransform;  							graphics2D.SetTransform(accumulatedTransform);    							RectangleDouble currentScreenClipping;  							if (child.CurrentScreenClipping(out currentScreenClipping))  							{  								currentScreenClipping.Left = Floor(currentScreenClipping.Left);  								currentScreenClipping.Right = Ceiling(currentScreenClipping.Right);  								currentScreenClipping.Bottom = Floor(currentScreenClipping.Bottom);  								currentScreenClipping.Top = Ceiling(currentScreenClipping.Top);  								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom)  								{  									BreakInDebugger("Right is less than Left or Top is less than Bottom");  								}    								graphics2D.SetClippingRect(currentScreenClipping);    								if (child.DoubleBuffer)  								{  									Vector2 offsetToRenderSurface = new Vector2(currentGraphics2DTransform.tx' currentGraphics2DTransform.ty);  									offsetToRenderSurface += child.OriginRelativeParent;    									double yFraction = offsetToRenderSurface.y - (int)offsetToRenderSurface.y;  									double xFraction = offsetToRenderSurface.x - (int)offsetToRenderSurface.x;  									int xOffset = (int)Floor(child.LocalBounds.Left);  									int yOffset = (int)Floor(child.LocalBounds.Bottom);  									if (child.isCurrentlyInvalid)  									{  										Graphics2D childBackBufferGraphics2D = child.backBuffer.NewGraphics2D();  										childBackBufferGraphics2D.Clear(new RGBA_Bytes(0' 0' 0' 0));  										Affine transformToBuffer = Affine.NewTranslation(-xOffset + xFraction' -yOffset + yFraction);  										childBackBufferGraphics2D.SetTransform(transformToBuffer);  										child.OnDrawBackground(childBackBufferGraphics2D);  										child.OnDraw(childBackBufferGraphics2D);    										child.backBuffer.MarkImageChanged();  										child.isCurrentlyInvalid = false;  									}    									offsetToRenderSurface.x = (int)offsetToRenderSurface.x + xOffset;  									offsetToRenderSurface.y = (int)offsetToRenderSurface.y + yOffset;  									// The transform to draw the backbuffer to the graphics2D must not have a factional amount  									// or we will get aliasing in the image and we want our back buffer pixels to map 1:1 to the next buffer  									if (offsetToRenderSurface.x - (int)offsetToRenderSurface.x != 0  										|| offsetToRenderSurface.y - (int)offsetToRenderSurface.y != 0)  									{  										BreakInDebugger("The transform for a back buffer must be integer to avoid aliasing.");  									}  									graphics2D.SetTransform(Affine.NewTranslation(offsetToRenderSurface));    									graphics2D.Render(child.backBuffer' 0' 0);  								}  								else  								{  									child.OnDrawBackground(graphics2D);  									child.OnDraw(graphics2D);  								}  							}  						}  						graphics2D.PopTransform();  						graphics2D.SetClippingRect(oldClippingRect);  					}  				}    				AfterDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				if (DebugShowBounds)  				{  					// draw the padding  					DrawBorderBounds(graphics2D' LocalBounds' DevicePadding' new RGBA_Bytes(Cyan' 128));    					// show the bounds and inside with an x  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' Green);  					graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' Green);  					graphics2D.Rectangle(LocalBounds' Red);  				}  				if (debugShowSize)  				{  					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);  				}  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: {  				if (!formHasLoaded)  				{  					OnLoad(null);  					formHasLoaded = true;  				}    				DrawCount++;    				BeforeDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				for (int i = 0; i < Children.Count; i++)  				{  					GuiWidget child = Children[i];  					if (child.Visible)  					{  						if (child.DebugShowBounds)  						{  							// draw the margin  							BorderDouble invertedMargin = child.DeviceMargin;  							invertedMargin.Left = -invertedMargin.Left;  							invertedMargin.Bottom = -invertedMargin.Bottom;  							invertedMargin.Right = -invertedMargin.Right;  							invertedMargin.Top = -invertedMargin.Top;  							DrawBorderBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new RGBA_Bytes(Red' 128));  						}    						RectangleDouble oldClippingRect = graphics2D.GetClippingRect();  						graphics2D.PushTransform();  						{  							Affine currentGraphics2DTransform = graphics2D.GetTransform();  							Affine accumulatedTransform = currentGraphics2DTransform * child.ParentToChildTransform;  							graphics2D.SetTransform(accumulatedTransform);    							RectangleDouble currentScreenClipping;  							if (child.CurrentScreenClipping(out currentScreenClipping))  							{  								currentScreenClipping.Left = Floor(currentScreenClipping.Left);  								currentScreenClipping.Right = Ceiling(currentScreenClipping.Right);  								currentScreenClipping.Bottom = Floor(currentScreenClipping.Bottom);  								currentScreenClipping.Top = Ceiling(currentScreenClipping.Top);  								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom)  								{  									BreakInDebugger("Right is less than Left or Top is less than Bottom");  								}    								graphics2D.SetClippingRect(currentScreenClipping);    								if (child.DoubleBuffer)  								{  									Vector2 offsetToRenderSurface = new Vector2(currentGraphics2DTransform.tx' currentGraphics2DTransform.ty);  									offsetToRenderSurface += child.OriginRelativeParent;    									double yFraction = offsetToRenderSurface.y - (int)offsetToRenderSurface.y;  									double xFraction = offsetToRenderSurface.x - (int)offsetToRenderSurface.x;  									int xOffset = (int)Floor(child.LocalBounds.Left);  									int yOffset = (int)Floor(child.LocalBounds.Bottom);  									if (child.isCurrentlyInvalid)  									{  										Graphics2D childBackBufferGraphics2D = child.backBuffer.NewGraphics2D();  										childBackBufferGraphics2D.Clear(new RGBA_Bytes(0' 0' 0' 0));  										Affine transformToBuffer = Affine.NewTranslation(-xOffset + xFraction' -yOffset + yFraction);  										childBackBufferGraphics2D.SetTransform(transformToBuffer);  										child.OnDrawBackground(childBackBufferGraphics2D);  										child.OnDraw(childBackBufferGraphics2D);    										child.backBuffer.MarkImageChanged();  										child.isCurrentlyInvalid = false;  									}    									offsetToRenderSurface.x = (int)offsetToRenderSurface.x + xOffset;  									offsetToRenderSurface.y = (int)offsetToRenderSurface.y + yOffset;  									// The transform to draw the backbuffer to the graphics2D must not have a factional amount  									// or we will get aliasing in the image and we want our back buffer pixels to map 1:1 to the next buffer  									if (offsetToRenderSurface.x - (int)offsetToRenderSurface.x != 0  										|| offsetToRenderSurface.y - (int)offsetToRenderSurface.y != 0)  									{  										BreakInDebugger("The transform for a back buffer must be integer to avoid aliasing.");  									}  									graphics2D.SetTransform(Affine.NewTranslation(offsetToRenderSurface));    									graphics2D.Render(child.backBuffer' 0' 0);  								}  								else  								{  									child.OnDrawBackground(graphics2D);  									child.OnDraw(graphics2D);  								}  							}  						}  						graphics2D.PopTransform();  						graphics2D.SetClippingRect(oldClippingRect);  					}  				}    				AfterDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				if (DebugShowBounds)  				{  					// draw the padding  					DrawBorderBounds(graphics2D' LocalBounds' DevicePadding' new RGBA_Bytes(Cyan' 128));    					// show the bounds and inside with an x  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' Green);  					graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' Green);  					graphics2D.Rectangle(LocalBounds' Red);  				}  				if (debugShowSize)  				{  					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);  				}  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: {  				if (!formHasLoaded)  				{  					OnLoad(null);  					formHasLoaded = true;  				}    				DrawCount++;    				BeforeDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				for (int i = 0; i < Children.Count; i++)  				{  					GuiWidget child = Children[i];  					if (child.Visible)  					{  						if (child.DebugShowBounds)  						{  							// draw the margin  							BorderDouble invertedMargin = child.DeviceMargin;  							invertedMargin.Left = -invertedMargin.Left;  							invertedMargin.Bottom = -invertedMargin.Bottom;  							invertedMargin.Right = -invertedMargin.Right;  							invertedMargin.Top = -invertedMargin.Top;  							DrawBorderBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new RGBA_Bytes(Red' 128));  						}    						RectangleDouble oldClippingRect = graphics2D.GetClippingRect();  						graphics2D.PushTransform();  						{  							Affine currentGraphics2DTransform = graphics2D.GetTransform();  							Affine accumulatedTransform = currentGraphics2DTransform * child.ParentToChildTransform;  							graphics2D.SetTransform(accumulatedTransform);    							RectangleDouble currentScreenClipping;  							if (child.CurrentScreenClipping(out currentScreenClipping))  							{  								currentScreenClipping.Left = Floor(currentScreenClipping.Left);  								currentScreenClipping.Right = Ceiling(currentScreenClipping.Right);  								currentScreenClipping.Bottom = Floor(currentScreenClipping.Bottom);  								currentScreenClipping.Top = Ceiling(currentScreenClipping.Top);  								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom)  								{  									BreakInDebugger("Right is less than Left or Top is less than Bottom");  								}    								graphics2D.SetClippingRect(currentScreenClipping);    								if (child.DoubleBuffer)  								{  									Vector2 offsetToRenderSurface = new Vector2(currentGraphics2DTransform.tx' currentGraphics2DTransform.ty);  									offsetToRenderSurface += child.OriginRelativeParent;    									double yFraction = offsetToRenderSurface.y - (int)offsetToRenderSurface.y;  									double xFraction = offsetToRenderSurface.x - (int)offsetToRenderSurface.x;  									int xOffset = (int)Floor(child.LocalBounds.Left);  									int yOffset = (int)Floor(child.LocalBounds.Bottom);  									if (child.isCurrentlyInvalid)  									{  										Graphics2D childBackBufferGraphics2D = child.backBuffer.NewGraphics2D();  										childBackBufferGraphics2D.Clear(new RGBA_Bytes(0' 0' 0' 0));  										Affine transformToBuffer = Affine.NewTranslation(-xOffset + xFraction' -yOffset + yFraction);  										childBackBufferGraphics2D.SetTransform(transformToBuffer);  										child.OnDrawBackground(childBackBufferGraphics2D);  										child.OnDraw(childBackBufferGraphics2D);    										child.backBuffer.MarkImageChanged();  										child.isCurrentlyInvalid = false;  									}    									offsetToRenderSurface.x = (int)offsetToRenderSurface.x + xOffset;  									offsetToRenderSurface.y = (int)offsetToRenderSurface.y + yOffset;  									// The transform to draw the backbuffer to the graphics2D must not have a factional amount  									// or we will get aliasing in the image and we want our back buffer pixels to map 1:1 to the next buffer  									if (offsetToRenderSurface.x - (int)offsetToRenderSurface.x != 0  										|| offsetToRenderSurface.y - (int)offsetToRenderSurface.y != 0)  									{  										BreakInDebugger("The transform for a back buffer must be integer to avoid aliasing.");  									}  									graphics2D.SetTransform(Affine.NewTranslation(offsetToRenderSurface));    									graphics2D.Render(child.backBuffer' 0' 0);  								}  								else  								{  									child.OnDrawBackground(graphics2D);  									child.OnDraw(graphics2D);  								}  							}  						}  						graphics2D.PopTransform();  						graphics2D.SetClippingRect(oldClippingRect);  					}  				}    				AfterDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				if (DebugShowBounds)  				{  					// draw the padding  					DrawBorderBounds(graphics2D' LocalBounds' DevicePadding' new RGBA_Bytes(Cyan' 128));    					// show the bounds and inside with an x  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' Green);  					graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' Green);  					graphics2D.Rectangle(LocalBounds' Red);  				}  				if (debugShowSize)  				{  					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);  				}  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,OnDraw,The following statement contains a magic number: {  				if (!formHasLoaded)  				{  					OnLoad(null);  					formHasLoaded = true;  				}    				DrawCount++;    				BeforeDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				for (int i = 0; i < Children.Count; i++)  				{  					GuiWidget child = Children[i];  					if (child.Visible)  					{  						if (child.DebugShowBounds)  						{  							// draw the margin  							BorderDouble invertedMargin = child.DeviceMargin;  							invertedMargin.Left = -invertedMargin.Left;  							invertedMargin.Bottom = -invertedMargin.Bottom;  							invertedMargin.Right = -invertedMargin.Right;  							invertedMargin.Top = -invertedMargin.Top;  							DrawBorderBounds(graphics2D' child.BoundsRelativeToParent' invertedMargin' new RGBA_Bytes(Red' 128));  						}    						RectangleDouble oldClippingRect = graphics2D.GetClippingRect();  						graphics2D.PushTransform();  						{  							Affine currentGraphics2DTransform = graphics2D.GetTransform();  							Affine accumulatedTransform = currentGraphics2DTransform * child.ParentToChildTransform;  							graphics2D.SetTransform(accumulatedTransform);    							RectangleDouble currentScreenClipping;  							if (child.CurrentScreenClipping(out currentScreenClipping))  							{  								currentScreenClipping.Left = Floor(currentScreenClipping.Left);  								currentScreenClipping.Right = Ceiling(currentScreenClipping.Right);  								currentScreenClipping.Bottom = Floor(currentScreenClipping.Bottom);  								currentScreenClipping.Top = Ceiling(currentScreenClipping.Top);  								if (currentScreenClipping.Right < currentScreenClipping.Left || currentScreenClipping.Top < currentScreenClipping.Bottom)  								{  									BreakInDebugger("Right is less than Left or Top is less than Bottom");  								}    								graphics2D.SetClippingRect(currentScreenClipping);    								if (child.DoubleBuffer)  								{  									Vector2 offsetToRenderSurface = new Vector2(currentGraphics2DTransform.tx' currentGraphics2DTransform.ty);  									offsetToRenderSurface += child.OriginRelativeParent;    									double yFraction = offsetToRenderSurface.y - (int)offsetToRenderSurface.y;  									double xFraction = offsetToRenderSurface.x - (int)offsetToRenderSurface.x;  									int xOffset = (int)Floor(child.LocalBounds.Left);  									int yOffset = (int)Floor(child.LocalBounds.Bottom);  									if (child.isCurrentlyInvalid)  									{  										Graphics2D childBackBufferGraphics2D = child.backBuffer.NewGraphics2D();  										childBackBufferGraphics2D.Clear(new RGBA_Bytes(0' 0' 0' 0));  										Affine transformToBuffer = Affine.NewTranslation(-xOffset + xFraction' -yOffset + yFraction);  										childBackBufferGraphics2D.SetTransform(transformToBuffer);  										child.OnDrawBackground(childBackBufferGraphics2D);  										child.OnDraw(childBackBufferGraphics2D);    										child.backBuffer.MarkImageChanged();  										child.isCurrentlyInvalid = false;  									}    									offsetToRenderSurface.x = (int)offsetToRenderSurface.x + xOffset;  									offsetToRenderSurface.y = (int)offsetToRenderSurface.y + yOffset;  									// The transform to draw the backbuffer to the graphics2D must not have a factional amount  									// or we will get aliasing in the image and we want our back buffer pixels to map 1:1 to the next buffer  									if (offsetToRenderSurface.x - (int)offsetToRenderSurface.x != 0  										|| offsetToRenderSurface.y - (int)offsetToRenderSurface.y != 0)  									{  										BreakInDebugger("The transform for a back buffer must be integer to avoid aliasing.");  									}  									graphics2D.SetTransform(Affine.NewTranslation(offsetToRenderSurface));    									graphics2D.Render(child.backBuffer' 0' 0);  								}  								else  								{  									child.OnDrawBackground(graphics2D);  									child.OnDraw(graphics2D);  								}  							}  						}  						graphics2D.PopTransform();  						graphics2D.SetClippingRect(oldClippingRect);  					}  				}    				AfterDraw?.Invoke(this' new DrawEventArgs(graphics2D));    				if (DebugShowBounds)  				{  					// draw the padding  					DrawBorderBounds(graphics2D' LocalBounds' DevicePadding' new RGBA_Bytes(Cyan' 128));    					// show the bounds and inside with an x  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' Green);  					graphics2D.Line(LocalBounds.Left' LocalBounds.Top' LocalBounds.Right' LocalBounds.Bottom' Green);  					graphics2D.Rectangle(LocalBounds' Red);  				}  				if (debugShowSize)  				{  					graphics2D.DrawString(string.Format("{4} {0}' {1} : {2}' {3}"' (int)MinimumSize.x' (int)MinimumSize.y' (int)LocalBounds.Width' (int)LocalBounds.Height' Name)'  						Width / 2' Max(Height - 16' Height / 2 - 16 * graphics2D.TransformStackCount)' color: Magenta' justification: Font.Justification.Center);  				}  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,IsDoubleClick,The following statement contains a magic number: if (mouseEvent.Clicks == 2  				&& LastMouseDownMs > UiThread.CurrentTimerMs - 550)  			{  				return true;  			}
Magic Number,MatterHackers.Agg.UI,GuiWidget,C:\repos\MatterHackers_agg-sharp\Gui\GUIWidget.cs,IsDoubleClick,The following statement contains a magic number: if (mouseEvent.Clicks == 2  				&& LastMouseDownMs > UiThread.CurrentTimerMs - 550)  			{  				return true;  			}
Missing Default,MatterHackers.Agg.UI,bezier_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following switch statement is missing a default case: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  				case 7:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Missing Default,MatterHackers.Agg.UI,curve3_ctrl_impl,C:\repos\MatterHackers_agg-sharp\Gui\agg_bezier_ctrl.cs,vertex,The following switch statement is missing a default case: switch (m_idx)  			{  				case 0:  				case 1:  				case 2:  					cmd = m_stroke.vertex(out x' out y);  					break;    				case 3:  				case 4:  				case 5:  				case 6:  					cmd = m_ellipse.vertex(out x' out y);  					break;  			}
Missing Default,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,ShowMenu,The following switch statement is missing a default case: switch (e.KeyCode)  				{  					case Keys.Up:  						if (highLightedIndex > 0)  						{  							highLightedIndex--;  						}    						break;    					case Keys.Down:  						if (highLightedIndex < this.MenuItems.Count - 1)  						{  							highLightedIndex++;  						}    						break;  				}
Missing Default,MatterHackers.Agg.UI,DropDownList,C:\repos\MatterHackers_agg-sharp\Gui\Menu\DropDownList.cs,ShowMenu,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  				{  					case Keys.Escape:  						listFilterText = new StringBuilder();  						DropDownContainer.CloseMenu();  						break;    					case Keys.Enter:    						if (highlightedItem != null)  						{  							SelectedIndex = MenuItems.IndexOf(highlightedItem);  							DropDownContainer.CloseMenu();  							listFilterText = null;  						}    						break;    					case Keys.Back:  						if (listFilterText != null && listFilterText.Length > 0)  						{  							listFilterText.Length -= 1;  						}    						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;    						ApplyFilter();    						break;  				}
Missing Default,MatterHackers.Agg.UI,InternalNumberEdit,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalNumberEdit.cs,OnKeyDown,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  			{  				case Keys.Up:  					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					Value = Value + increment;  					OnEditComplete(keyEvent);  					break;    				case Keys.Down:  					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					Value = Value - increment;  					OnEditComplete(keyEvent);  					break;  			}
Missing Default,MatterHackers.Agg.UI,ScrollBar,C:\repos\MatterHackers_agg-sharp\Gui\ScrollableWidget\ScrollBar.cs,UpdateScrollBar,The following switch statement is missing a default case: switch (Show)  			{  				case ShowState.WhenRequired:  					if (ParentScrollWidget.ScrollArea.Height > ParentScrollWidget.Height)  					{  						goto case ShowState.Always;  					}  					else  					{  						goto case ShowState.Never;  					}    				case ShowState.Always:  					// make sure we can see it  					Visible = true;  					// fix the bounds of the scroll bar background  					LocalBounds = new RectangleDouble(0' 0' ScrollBarWidth' ParentScrollWidget.Height);  					background.LocalBounds = LocalBounds;    					// this is for vertical scroll bar  					thumb.LocalBounds = new RectangleDouble(0' 0' ScrollBarWidth' ThumbHeight);    					Vector2 scrollRatioFromTop0To1 = ParentScrollWidget.ScrollRatioFromTop0To1;  					double notThumbHeight = ParentScrollWidget.Height - ThumbHeight;  					thumb.OriginRelativeParent = new Vector2(0' notThumbHeight * scrollRatioFromTop0To1.y);    					ParentScrollWidget.ScrollArea.Padding = new BorderDouble(0' 0' ScrollBar.ScrollBarWidth' 0);    					break;    				case ShowState.Never:  					Visible = false;    					ParentScrollWidget.ScrollArea.Padding = new BorderDouble(0' 0' 0' 0);    					break;  			}
Missing Default,MatterHackers.Agg.UI,TabBar,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\TabBar.cs,OnDraw,The following switch statement is missing a default case: switch (FlowDirection)  			{  				case UI.FlowDirection.LeftToRight:  					graphics2D.Line(LocalBounds.Left' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Bottom' this.BorderColor);  					break;    				case UI.FlowDirection.TopToBottom:  					graphics2D.Line(LocalBounds.Right' LocalBounds.Bottom' LocalBounds.Right' LocalBounds.Top' this.BorderColor);  					break;  			}
Missing Default,MatterHackers.Agg.UI,TabControl,C:\repos\MatterHackers_agg-sharp\Gui\TabControl\TabControl.cs,AddTab,The following switch statement is missing a default case: switch (Orientation)  			{  				case Orientation.Horizontal:  					newTab.VAnchor = VAnchor.ParentCenter;  					break;    				case Orientation.Vertical:  					newTab.HAnchor = HAnchor.ParentLeft | HAnchor.ParentRight;  					break;  			}
Missing Default,MatterHackers.Agg.UI,InternalTextEditWidget,C:\repos\MatterHackers_agg-sharp\Gui\TextWidgets\InternalTextEditWidget.cs,OnKeyDown,The following switch statement is missing a default case: switch (keyEvent.KeyCode)  			{  				case Keys.Escape:  					if (Selecting)  					{  						turnOffSelection = true;  						keyEvent.SuppressKeyPress = true;  						keyEvent.Handled = true;  					}  					break;    				case Keys.Left:  					StartSelectionIfRequired(keyEvent);  					if (keyEvent.Control)  					{  						GotoBeginingOfPreviousToken();  					}  					else if (CharIndexToInsertBefore > 0)  					{  						if (turnOffSelection)  						{  							CharIndexToInsertBefore = Math.Min(CharIndexToInsertBefore' SelectionIndexToStartBefore);  						}  						else  						{  							CharIndexToInsertBefore--;  						}  					}  					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					break;    				case Keys.Right:  					StartSelectionIfRequired(keyEvent);  					if (keyEvent.Control)  					{  						GotoBeginingOfNextToken();  					}  					else if (CharIndexToInsertBefore < internalTextWidget.Text.Length)  					{  						if (turnOffSelection)  						{  							CharIndexToInsertBefore = Math.Max(CharIndexToInsertBefore' SelectionIndexToStartBefore);  						}  						else  						{  							CharIndexToInsertBefore++;  						}  					}  					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					break;    				case Keys.Up:  					StartSelectionIfRequired(keyEvent);  					if (turnOffSelection)  					{  						CharIndexToInsertBefore = Math.Min(CharIndexToInsertBefore' SelectionIndexToStartBefore);  					}  					GotoLineAbove();  					SetDesiredBarPosition = false;  					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					break;    				case Keys.Down:  					StartSelectionIfRequired(keyEvent);  					if (turnOffSelection)  					{  						CharIndexToInsertBefore = Math.Max(CharIndexToInsertBefore' SelectionIndexToStartBefore);  					}  					GotoLineBelow();  					SetDesiredBarPosition = false;  					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					break;    				case Keys.Space:  					keyEvent.Handled = true;  					break;    				case Keys.End:  					StartSelectionIfRequired(keyEvent);  					if (keyEvent.Control)  					{  						CharIndexToInsertBefore = internalTextWidget.Text.Length;  					}  					else  					{  						GotoEndOfCurrentLine();  					}    					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					break;    				case Keys.Home:  					StartSelectionIfRequired(keyEvent);  					if (keyEvent.Control)  					{  						CharIndexToInsertBefore = 0;  					}  					else  					{  						GotoStartOfCurrentLine();  					}    					keyEvent.SuppressKeyPress = true;  					keyEvent.Handled = true;  					break;    				case Keys.Back:  					if (!Selecting  						&& CharIndexToInsertBefore > 0)  					{  						SelectionIndexToStartBefore = CharIndexToInsertBefore - 1;  						Selecting = true;  					}    					DeleteSelection();    					keyEvent.Handled = true;  					keyEvent.SuppressKeyPress = true;  					break;    				case Keys.Delete:  					if (ShiftKeyIsDown(keyEvent))  					{  						CopySelection();  						DeleteSelection();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					else  					{  						if (!Selecting  						&& CharIndexToInsertBefore < internalTextWidget.Text.Length)  						{  							SelectionIndexToStartBefore = CharIndexToInsertBefore + 1;  							Selecting = true;  						}    						DeleteSelection();  					}    					turnOffSelection = true;  					keyEvent.Handled = true;  					keyEvent.SuppressKeyPress = true;  					break;    				case Keys.Enter:  					if (!Multiline)  					{  						// TODO: do the right thing.  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;    						if (EnterPressed != null)  						{  							EnterPressed(this' keyEvent);  						}    						if (TextHasChanged())  						{  							OnEditComplete(keyEvent);  						}  					}  					break;    				case Keys.Insert:  					if (ShiftKeyIsDown(keyEvent))  					{  						turnOffSelection = true;  						PasteFromClipboard();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					if (keyEvent.Control)  					{  						turnOffSelection = false;  						CopySelection();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;    				case Keys.A:  					if (keyEvent.Control)  					{  						SelectAll();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;    				case Keys.X:  					if (keyEvent.Control)  					{  						CopySelection();  						DeleteSelection();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;    				case Keys.C:  					if (keyEvent.Control)  					{  						turnOffSelection = false;  						CopySelection();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;    				case Keys.V:  					if (keyEvent.Control)  					{  						PasteFromClipboard();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;    				case Keys.Z:  					if (keyEvent.Control)  					{  						Undo();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;    				case Keys.Y:  					if (keyEvent.Control)  					{  						undoBuffer.Redo();  						keyEvent.Handled = true;  						keyEvent.SuppressKeyPress = true;  					}  					break;  			}
