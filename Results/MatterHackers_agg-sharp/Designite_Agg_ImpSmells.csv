Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_liang_barsky,The method has 134 lines of code.
Long Method,MatterHackers.Agg,rasterizer_cells_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_cells_aa.cs,line,The method has 122 lines of code.
Long Method,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The method has 116 lines of code.
Long Method,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The method has 246 lines of code.
Long Method,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,RenderCompound,The method has 176 lines of code.
Long Method,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 107 lines of code.
Long Method,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 169 lines of code.
Long Method,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The method has 141 lines of code.
Long Method,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The method has 136 lines of code.
Long Method,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The method has 2757 lines of code.
Long Method,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The method has 116 lines of code.
Long Method,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The method has 107 lines of code.
Long Method,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,stack_blur_gray8,The method has 136 lines of code.
Long Method,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,stack_blur_bgr24,The method has 215 lines of code.
Long Method,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,stack_blur_bgra32,The method has 252 lines of code.
Long Method,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The method has 193 lines of code.
Long Method,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The method has 121 lines of code.
Long Method,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,ParseSvgDString,The method has 180 lines of code.
Long Method,MatterHackers.Agg.VertexSource,StrokeGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeGenerator.cs,Vertex,The method has 118 lines of code.
Long Method,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_join,The method has 125 lines of code.
Complex Method,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ParseDoubleFast,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_liang_barsky,Cyclomatic complexity of the method is 15
Complex Method,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,Cyclomatic complexity of the method is 10
Complex Method,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,normalize,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.Agg,rasterizer_cells_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_cells_aa.cs,line,Cyclomatic complexity of the method is 20
Complex Method,MatterHackers.Agg,rasterizer_cells_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_cells_aa.cs,sort_cells,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg,rasterizer_cells_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_cells_aa.cs,render_hline,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_scanline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg,RectangleInt,C:\repos\MatterHackers_agg-sharp\agg\RectangleInt.cs,ClipRects,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.Agg,RectangleInt,C:\repos\MatterHackers_agg-sharp\agg\RectangleInt.cs,ClipRect,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg,ScanlineRasterizer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRasterizer.cs,sweep_scanline,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,set,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,Cyclomatic complexity of the method is 13
Complex Method,MatterHackers.Agg,FloodFill,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,Fill,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.Font,EnglishTextWrapping,C:\repos\MatterHackers_agg-sharp\agg\Font\TextWrapping.cs,WrapSingleLineOnWidth,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,GetVisibleBounds,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Contains,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,FindLeastSquaresMatch,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,GetVisibleBounds,Cyclomatic complexity of the method is 14
Complex Method,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_hline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_vline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_hline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_vline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_hspan,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,clip_rect_area,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_vspan,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_hline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_vline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_hline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_vline,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_hspan,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,clip_rect_area,Cyclomatic complexity of the method is 11
Complex Method,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_vspan,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,Cyclomatic complexity of the method is 23
Complex Method,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,arrange_polygon_orientation,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,Cyclomatic complexity of the method is 12
Long Parameter List,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,memcpy,The method has 5 parameters. Parameters: dest' destIndex' source' sourceIndex' Count
Long Parameter List,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,memcpy,The method has 5 parameters. Parameters: dest' destIndex' source' sourceIndex' Count
Long Parameter List,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,memcpy,The method has 5 parameters. Parameters: dest' destIndex' source' sourceIndex' count
Long Parameter List,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,memmove,The method has 5 parameters. Parameters: dest' destIndex' source' sourceIndex' Count
Long Parameter List,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,memmove,The method has 5 parameters. Parameters: dest' destIndex' source' sourceIndex' Count
Long Parameter List,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,memmove,The method has 5 parameters. Parameters: dest' destIndex' source' sourceIndex' Count
Long Parameter List,MatterHackers.Agg,bounding_rect,C:\repos\MatterHackers_agg-sharp\agg\agg_bounding_rect.cs,get_bounding_rect,The method has 8 parameters. Parameters: vs' gi' start' num' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,bounding_rect,C:\repos\MatterHackers_agg-sharp\agg\agg_bounding_rect.cs,get_bounding_rect,The method has 5 parameters. Parameters: vs' gi' start' num' boundingRect
Long Parameter List,MatterHackers.Agg,bounding_rect,C:\repos\MatterHackers_agg-sharp\agg\agg_bounding_rect.cs,bounding_rect_single,The method has 6 parameters. Parameters: vs' path_id' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_liang_barsky,The method has 7 parameters. Parameters: x1' y1' x2' y2' clip_box' x' y
Long Parameter List,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_move_point,The method has 8 parameters. Parameters: x1' y1' x2' y2' clip_box' x' y' flags
Long Parameter List,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The method has 5 parameters. Parameters: x1' y1' x2' y2' clip_box
Long Parameter List,MatterHackers.Agg,line_parameters,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,line_parameters,The method has 5 parameters. Parameters: x1_' y1_' x2_' y2_' len_
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,cross_product,The method has 6 parameters. Parameters: x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,point_in_triangle,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_line_point_distance,The method has 6 parameters. Parameters: x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_segment_point_u,The method has 6 parameters. Parameters: x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_segment_point_sq_distance,The method has 7 parameters. Parameters: x1' y1' x2' y2' x' y' u
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_segment_point_sq_distance,The method has 6 parameters. Parameters: x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_intersection,The method has 10 parameters. Parameters: aX1' aY1' aX2' aY2' bX1' bY1' bX2' bY2' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,intersection_exists,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_orthogonal,The method has 7 parameters. Parameters: thickness' x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The method has 9 parameters. Parameters: x1' y1' x2' y2' x3' y3' x' y' d
Long Parameter List,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_triangle_area,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,MatterHackers.Agg,IPatternFilter,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The method has 5 parameters. Parameters: sourceImage' destBuffer' destBufferOffset' x' y
Long Parameter List,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_low_res,The method has 5 parameters. Parameters: buf' p' offset' x' y
Long Parameter List,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The method has 5 parameters. Parameters: sourceImage' destBuffer' destBufferOffset' x' y
Long Parameter List,MatterHackers.Agg,rasterizer_cells_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_cells_aa.cs,render_hline,The method has 5 parameters. Parameters: ey' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The method has 7 parameters. Parameters: ras' x1' y1' x2' y2' f1' f2
Long Parameter List,MatterHackers.Agg,distance_interpolator0,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator0,The method has 6 parameters. Parameters: x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,distance_interpolator00,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator00,The method has 8 parameters. Parameters: xc' yc' x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,distance_interpolator1,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator1,The method has 6 parameters. Parameters: x1' y1' x2' y2' x' y
Long Parameter List,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The method has 8 parameters. Parameters: x1' y1' x2' y2' sx' sy' x' y
Long Parameter List,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The method has 9 parameters. Parameters: x1' y1' x2' y2' ex' ey' x' y' none
Long Parameter List,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The method has 10 parameters. Parameters: x1' y1' x2' y2' sx' sy' ex' ey' x' y
Long Parameter List,MatterHackers.Agg,line_interpolator_aa3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line_interpolator_aa3,The method has 6 parameters. Parameters: ren' lp' sx' sy' ex' ey
Long Parameter List,MatterHackers.Agg,LineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot,The method has 5 parameters. Parameters: cmp' xc1' yc1' xc2' yc2
Long Parameter List,MatterHackers.Agg,LineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot_hline,The method has 8 parameters. Parameters: cmp' xc1' yc1' xc2' yc2' x1' y1' x2
Long Parameter List,MatterHackers.Agg,LineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie,The method has 6 parameters. Parameters: xc' yc' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,LineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line3,The method has 5 parameters. Parameters: lp' sx' sy' ex' ey
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,blend_solid_hspan,The method has 5 parameters. Parameters: x' y' len' covers' coversOffset
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,blend_solid_vspan,The method has 5 parameters. Parameters: x' y' len' covers' coversOffset
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot_hline,The method has 8 parameters. Parameters: cmp' xc1' yc1' xc2' yc2' x1' y1' x2
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot,The method has 5 parameters. Parameters: cmp' xc1' yc1' xc2' yc2
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie_hline,The method has 9 parameters. Parameters: xc' yc' xp1' yp1' xp2' yp2' xh1' yh1' xh2
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie,The method has 6 parameters. Parameters: xc' yc' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line3_no_clip,The method has 5 parameters. Parameters: lp' sx' sy' ex' ey
Long Parameter List,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line3,The method has 5 parameters. Parameters: lp' sx' sy' ex' ey
Long Parameter List,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The method has 12 parameters. Parameters: x1' y1' x2' y2' sx' sy' ex' ey' len' scale' x' y
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,blend_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsOffset
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,blend_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsOffset
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,semidot,The method has 5 parameters. Parameters: cmp' xc1' yc1' xc2' yc2
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,semidot_hline,The method has 8 parameters. Parameters: cmp' xc1' yc1' xc2' yc2' x1' y1' x2
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,pie,The method has 6 parameters. Parameters: xc' yc' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,line3_no_clip,The method has 5 parameters. Parameters: lp' sx' sy' ex' ey
Long Parameter List,MatterHackers.Agg,ImageLineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,line3,The method has 5 parameters. Parameters: lp' sx' sy' ex' ey
Long Parameter List,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,RenderSolidAllPaths,The method has 7 parameters. Parameters: destImage' ras' sl' vs' color_storage' path_id' num_paths
Long Parameter List,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,GenerateAndRender,The method has 5 parameters. Parameters: rasterizer' scanlineCache' destImage' spanAllocator' spanGenerator
Long Parameter List,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,GenerateAndRender,The method has 5 parameters. Parameters: rasterizer' scanlineCache' destImage' spanAllocator' spanGenerator
Long Parameter List,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,RenderCompound,The method has 6 parameters. Parameters: ras' sl_aa' sl_bin' imageFormat' alloc' sh
Long Parameter List,MatterHackers.Agg,span_gradient,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,span_gradient,The method has 5 parameters. Parameters: inter' gradient_function' color_function' d1' d2
Long Parameter List,MatterHackers.Agg,span_gradient,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,ISpanGenerator,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,ISpanGeneratorFloat,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_gray_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_gray.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_nn,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,BlendInFilterPixel,The method has 12 parameters. Parameters: fg' src_alpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,BlendInFilterPixel,The method has 12 parameters. Parameters: accumulatedColor' sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgb_2x2,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_nn,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_bilinear_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,BlendInFilterPixel,The method has 11 parameters. Parameters: accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_image_filter_rgba_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' xInt' yInt' len
Long Parameter List,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,span_interpolator_persp_lerp,The method has 5 parameters. Parameters: x1' y1' x2' y2' quad
Long Parameter List,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,span_interpolator_persp_lerp,The method has 5 parameters. Parameters: quad' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The method has 5 parameters. Parameters: x1' y1' x2' y2' quad
Long Parameter List,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The method has 5 parameters. Parameters: quad' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg,span_subdiv_adaptor,C:\repos\MatterHackers_agg-sharp\agg\agg_span_subdiv_adaptor.cs,span_subdiv_adaptor,The method has 5 parameters. Parameters: interpolator' x' y' len' subdiv_shift
Long Parameter List,MatterHackers.Agg,IStyleHandler,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,generate_span,The method has 6 parameters. Parameters: span' spanIndex' x' y' len' style
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,Render,The method has 5 parameters. Parameters: imageSource' x' y' width' height
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,Render,The method has 6 parameters. Parameters: imageSource' x' y' angleRadians' scaleX' ScaleY
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,Render,The method has 6 parameters. Parameters: imageSource' x' y' angleRadians' scaleX' ScaleY
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,DrawString,The method has 9 parameters. Parameters: Text' x' y' pointSize' justification' baseline' color' drawFromHintedCach' backgroundColor
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,Line,The method has 6 parameters. Parameters: x1' y1' x2' y2' color' strokeWidth
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,Rectangle,The method has 6 parameters. Parameters: left' bottom' right' top' color' strokeWidth
Long Parameter List,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,FillRectangle,The method has 5 parameters. Parameters: left' bottom' right' top' fillColor
Long Parameter List,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,DrawImageGetDestBounds,The method has 9 parameters. Parameters: sourceImage' DestX' DestY' HotspotOffsetX' HotspotOffsetY' ScaleX' ScaleY' AngleRad' destRectTransform
Long Parameter List,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The method has 6 parameters. Parameters: source' destX' destY' angleRadians' inScaleX' inScaleY
Long Parameter List,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Rectangle,The method has 6 parameters. Parameters: left' bottom' right' top' color' strokeWidth
Long Parameter List,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,FillRectangle,The method has 5 parameters. Parameters: left' bottom' right' top' fillColor
Long Parameter List,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The method has 6 parameters. Parameters: source' x' y' angleDegrees' inScaleX' inScaleY
Long Parameter List,MatterHackers.Agg,IAlphaMask,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,fill_hspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,IAlphaMask,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,fill_vspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,IAlphaMask,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspanFullCover,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,IAlphaMask,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,IAlphaMask,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_vspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,fill_hspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspanFullCover,The method has 5 parameters. Parameters: x' y' covers' coversIndex' count
Long Parameter List,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The method has 5 parameters. Parameters: x' y' covers' coversIndex' count
Long Parameter List,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,fill_vspan,The method has 5 parameters. Parameters: x' y' buffer' bufferIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_vspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,fill_hspan,The method has 5 parameters. Parameters: x' y' dst' dstIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspanFullCover,The method has 5 parameters. Parameters: x' y' covers' coversIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The method has 5 parameters. Parameters: x' y' buffer' bufferIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,fill_vspan,The method has 5 parameters. Parameters: x' y' buffer' bufferIndex' num_pix
Long Parameter List,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_vspan,The method has 5 parameters. Parameters: x' y' buffer' bufferIndex' num_pix
Long Parameter List,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,TypeFacePrinter,The method has 5 parameters. Parameters: text' pointSize' origin' justification' baseline
Long Parameter List,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,TypeFacePrinter,The method has 5 parameters. Parameters: text' typeFaceStyle' origin' justification' baseline
Long Parameter List,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,CheckForBetterClickPosition,The method has 6 parameters. Parameters: position' clostestIndex' clostestXDistSquared' clostestYDistSquared' offset' i
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_hline,The method has 5 parameters. Parameters: x' y' x2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,IImageByte,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_hline,The method has 5 parameters. Parameters: x' y' x2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,IImageFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\IImage.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,ImageBuffer,The method has 5 parameters. Parameters: sourceImageToCopy' blender' distanceBetweenPixelsInclusive' bufferOffset' bitsPerPixel
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,AttachBuffer,The method has 7 parameters. Parameters: buffer' bufferOffset' width' height' strideInBytes' bitDepth' distanceInBytesBetweenPixelsInclusive
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Attach,The method has 5 parameters. Parameters: sourceImage' recieveBlender' distanceBetweenPixelsInclusive' bufferOffset' bitsPerPixel
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Attach,The method has 5 parameters. Parameters: sourceImage' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,DeallocateOrClearBuffer,The method has 5 parameters. Parameters: width' height' strideInBytes' bitDepth' distanceInBytesBetweenPixelsInclusive
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetDimmensionAndFormat,The method has 6 parameters. Parameters: width' height' strideInBytes' bitDepth' distanceInBytesBetweenPixelsInclusive' doDeallocateOrClearBuffer
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,DoCopyOrBlend,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,BasedOnAlphaAndCover,The method has 5 parameters. Parameters: recieveBlender' destBuffer' bufferOffset' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,ImageBufferFloat,The method has 5 parameters. Parameters: sourceImageToCopy' blender' distanceBetweenPixelsInclusive' bufferOffset' bitsPerPixel
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,AttachBuffer,The method has 7 parameters. Parameters: buffer' bufferOffset' width' height' strideInBytes' bitDepth' distanceInBytesBetweenPixelsInclusive
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Attach,The method has 5 parameters. Parameters: sourceImage' blender' distanceBetweenPixelsInclusive' bufferOffset' bitsPerPixel
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Attach,The method has 5 parameters. Parameters: sourceImage' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetDimmensionAndFormat,The method has 5 parameters. Parameters: width' height' strideInFloats' bitDepth' distanceInFloatsBetweenPixelsInclusive
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' sourceColor' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,DoCopyOrBlendFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,BasedOnAlphaAndCover,The method has 5 parameters. Parameters: Blender' destBuffer' bufferOffset' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' sourceColor' cover
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageProxy.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To8Bit,The method has 5 parameters. Parameters: Dest' Source' SourceOffset' Width' Height
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To8Bit,The method has 5 parameters. Parameters: Dest' Source' SourceOffset' Width' Height
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To24Bit,The method has 5 parameters. Parameters: Dest' Source' SourceOffset' Width' Height
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To24Bit,The method has 5 parameters. Parameters: Dest' Source' SourceOffset' Width' Height
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The method has 5 parameters. Parameters: Dest' Source' SourceOffset' Width' Height
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To32Bit,The method has 5 parameters. Parameters: Dest' Source' SourceOffset' Width' Height
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The method has 6 parameters. Parameters: pDecompressBits' pBitsToPars' ParsOffset' Width' Depth' LineBeingRead
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,memcmp,The method has 5 parameters. Parameters: pCheck' CheckOffset' pSource' SourceOffset' Width
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,GetSameLength,The method has 6 parameters. Parameters: checkBufer' checkOffset' sourceBuffer' sourceOffsetToNextPixel' numBytesInPixel' maxSameLengthWidth
Long Parameter List,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,GetDifLength,The method has 5 parameters. Parameters: pCheck' pSource' SourceOffset' numBytesInPixel' Max
Long Parameter List,MatterHackers.Agg.Image,RecursizeBlurCalculator,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,calc,The method has 8 parameters. Parameters: b1' b2' b3' b4' c1' c2' c3' c4
Long Parameter List,MatterHackers.Agg.Image,recursive_blur_calc_rgb,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,calc,The method has 8 parameters. Parameters: b1' b2' b3' b4' c1' c2' c3' c4
Long Parameter List,MatterHackers.Agg.Image,recursive_blur_calc_rgba,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,calc,The method has 8 parameters. Parameters: b1' b2' b3' b4' c1' c2' c3' c4
Long Parameter List,MatterHackers.Agg.Image,recursive_blur_calc_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,calc,The method has 8 parameters. Parameters: b1' b2' b3' b4' c1' c2' c3' c4
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' c' cover
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' c' cover
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' color' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' c' cover
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' c' cover
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' in_len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxy,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' c' cover
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' c' cover
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' in_len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' in_len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,ImageClippingProxyFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ClippingProxy.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderGammaBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The method has 8 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,goodInterfaceThinking,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,SetPixels,The method has 5 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' count
Long Parameter List,MatterHackers.Agg.Image,goodInterfaceThinking,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 5 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' count
Long Parameter List,MatterHackers.Agg.Image,goodInterfaceThinking,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 6 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCover' count
Long Parameter List,MatterHackers.Agg.Image,goodInterfaceThinking,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 7 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' count
Long Parameter List,MatterHackers.Agg.Image,IRecieveBlenderByte,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,IRecieveBlenderFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: destBuffer' bufferOffset' sourceColors' sourceColorsOffset' covers' coversIndex' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: pDestBuffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: pDestBuffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The method has 5 parameters. Parameters: buffer' bufferOffset' sourceColors' sourceColorsOffset' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 5 parameters. Parameters: pDestBuffer' bufferOffset' sourceColors' sourceColorsOffset' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 6 parameters. Parameters: pDestBuffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 7 parameters. Parameters: pDestBuffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' count
Long Parameter List,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The method has 8 parameters. Parameters: pDestBuffer' bufferOffset' sourceColors' sourceColorsOffset' sourceCovers' sourceCoversOffset' firstCoverForAll' count
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,blend_hline,The method has 5 parameters. Parameters: x1' y' x2' c' cover
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,blend_vline,The method has 5 parameters. Parameters: x' y1' y2' c' cover
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,blend_solid_hspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,blend_solid_vspan,The method has 6 parameters. Parameters: x' y' len' c' covers' coversIndex
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,copy_color_hspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,copy_color_vspan,The method has 5 parameters. Parameters: x' y' len' colors' colorsIndex
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,blend_color_hspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Image,FormatTransposer,C:\repos\MatterHackers_agg-sharp\agg\Image\Transposer.cs,blend_color_vspan,The method has 8 parameters. Parameters: x' y' len' colors' colorsIndex' covers' coversIndex' firstCoverForAll
Long Parameter List,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,Affine,The method has 6 parameters. Parameters: v0' v1' v2' v3' v4' v5
Long Parameter List,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,Bilinear,The method has 5 parameters. Parameters: x1' y1' x2' y2' quad
Long Parameter List,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,Bilinear,The method has 5 parameters. Parameters: quad' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The method has 5 parameters. Parameters: x1' y1' x2' y2' quad
Long Parameter List,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The method has 5 parameters. Parameters: quad' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The method has 9 parameters. Parameters: v0' v1' v2' v3' v4' v5' v6' v7' v8
Long Parameter List,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The method has 5 parameters. Parameters: x1' y1' x2' y2' quad
Long Parameter List,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The method has 5 parameters. Parameters: quad' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The method has 5 parameters. Parameters: x1' y1' x2' y2' q
Long Parameter List,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The method has 5 parameters. Parameters: q' x1' y1' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve3_inc,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 6 parameters. Parameters: x1' y1' cx' cy' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve3_div,The method has 6 parameters. Parameters: x1' y1' cx' cy' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 6 parameters. Parameters: x1' y1' cx' cy' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,bezier,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The method has 7 parameters. Parameters: x1' y1' x2' y2' x3' y3' level
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The method has 8 parameters. Parameters: x1' y1' cx1' cy1' cx2' cy2' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 8 parameters. Parameters: x1' y1' cx1' cy1' cx2' cy2' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,bezier,The method has 8 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4
Long Parameter List,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The method has 9 parameters. Parameters: x1' y1' x2' y2' x3' y3' x4' y4' level
Long Parameter List,MatterHackers.Agg.VertexSource,Curve3,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve3,The method has 6 parameters. Parameters: x1' y1' cx' cy' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,Curve3,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 6 parameters. Parameters: x1' y1' cx' cy' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The method has 8 parameters. Parameters: x1' y1' cx1' cy1' cx2' cy2' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The method has 8 parameters. Parameters: x1' y1' cx1' cy1' cx2' cy2' x2' y2
Long Parameter List,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,span_gouraud,The method has 10 parameters. Parameters: c1' c2' c3' x1' y1' x2' y2' x3' y3' d
Long Parameter List,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The method has 7 parameters. Parameters: x1' y1' x2' y2' x3' y3' dilation
Long Parameter List,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,span_gouraud_rgba,The method has 9 parameters. Parameters: c1' c2' c3' x1' y1' x2' y2' x3' y3
Long Parameter List,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,span_gouraud_rgba,The method has 10 parameters. Parameters: c1' c2' c3' x1' y1' x2' y2' x3' y3' d
Long Parameter List,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The method has 5 parameters. Parameters: span' spanIndex' x' y' len
Long Parameter List,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,Arc,The method has 8 parameters. Parameters: originX' originY' radiusX' radiusY' startAngle' endAngle' direction' scale
Long Parameter List,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,Arc,The method has 6 parameters. Parameters: origin' radius' startAngle' endAngle' direction' scale
Long Parameter List,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,init,The method has 8 parameters. Parameters: originX' originY' radiusX' radiusY' startAngle' endAngle' direction' scale
Long Parameter List,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,init,The method has 6 parameters. Parameters: origin' radius' startAngle' endAngle' direction' scale
Long Parameter List,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,Ellipse,The method has 5 parameters. Parameters: origin' RadiusX' RadiusY' num_steps' cw
Long Parameter List,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,Ellipse,The method has 6 parameters. Parameters: OriginX' OriginY' RadiusX' RadiusY' num_steps' cw
Long Parameter List,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,init,The method has 5 parameters. Parameters: OriginX' OriginY' RadiusX' RadiusY' num_steps
Long Parameter List,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,init,The method has 6 parameters. Parameters: OriginX' OriginY' RadiusX' RadiusY' num_steps' cw
Long Parameter List,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,curve4,The method has 6 parameters. Parameters: x_ctrl1' y_ctrl1' x_ctrl2' y_ctrl2' x_to' y_to
Long Parameter List,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,curve4_rel,The method has 6 parameters. Parameters: dx_ctrl1' dy_ctrl1' dx_ctrl2' dy_ctrl2' dx_to' dy_to
Long Parameter List,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,RoundedRect,The method has 5 parameters. Parameters: left' bottom' right' top' radius
Long Parameter List,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,radius,The method has 8 parameters. Parameters: rx1' ry1' rx2' ry2' rx3' ry3' rx4' ry4
Long Parameter List,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_join,The method has 6 parameters. Parameters: vc' v0' v1' v2' len1' len2
Long Parameter List,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_arc,The method has 7 parameters. Parameters: vc' x' y' dx1' dy1' dx2' dy2
Long Parameter List,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_miter,The method has 11 parameters. Parameters: vc' v0' v1' v2' dx1' dy1' dx2' dy2' lj' mlimit' dbevel
Long Identifier,MatterHackers.Agg,DumpCallStackIfSlow,C:\repos\MatterHackers_agg-sharp\agg\DumpCallStackIfSlow.cs,DumpCallStackIfSlow,The length of the parameter maxSecondsBeforePrintCallStack is 30.
Long Identifier,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the parameter distanceBetweenPixelsInclusive is 30.
Long Identifier,MatterHackers.Agg,ImageBufferAccessorCommon,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,,The length of the parameter m_DistanceBetweenPixelsInclusive is 32.
Long Identifier,MatterHackers.Agg,ImageBufferAccessorCommonFloat,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,,The length of the parameter m_DistanceBetweenPixelsInclusive is 32.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetSize,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetSize,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,NumLines,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,NumLines,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,NumLines,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,NumLines,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetOffset,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetOffset,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetCharacterIndexToStartBefore,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetCharacterIndexToStartBefore,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Identifier,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,ImageBuffer,The length of the parameter distanceBetweenPixelsInclusive is 30.
Long Identifier,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,AttachBuffer,The length of the parameter distanceInBytesBetweenPixelsInclusive is 37.
Long Identifier,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Attach,The length of the parameter distanceBetweenPixelsInclusive is 30.
Long Identifier,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,DeallocateOrClearBuffer,The length of the parameter distanceInBytesBetweenPixelsInclusive is 37.
Long Identifier,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetDimmensionAndFormat,The length of the parameter distanceInBytesBetweenPixelsInclusive is 37.
Long Identifier,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,,The length of the parameter m_DistanceInBytesBetweenPixelsInclusive is 39.
Long Identifier,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,ImageBufferFloat,The length of the parameter distanceBetweenPixelsInclusive is 30.
Long Identifier,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,AttachBuffer,The length of the parameter distanceInBytesBetweenPixelsInclusive is 37.
Long Identifier,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Attach,The length of the parameter distanceBetweenPixelsInclusive is 30.
Long Identifier,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetDimmensionAndFormat,The length of the parameter distanceInFloatsBetweenPixelsInclusive is 38.
Long Identifier,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,,The length of the parameter m_DistanceInFloatsBetweenPixelsInclusive is 40.
Long Identifier,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,RecursiveBlur,The length of the parameter recursizeBluerCalculatorFactory is 31.
Long Identifier,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,,The length of the parameter m_RecursizeBlurCalculatorFactory is 32.
Long Identifier,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetCharacterIndexToStartBefore,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetCharacterIndexToStartBefore,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Identifier,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetSize,The length of the parameter characterToMeasureStartIndexInclusive is 37.
Long Identifier,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetSize,The length of the parameter characterToMeasureEndIndexInclusive is 35.
Long Statement,MatterHackers.Agg,bounding_rect,C:\repos\MatterHackers_agg-sharp\agg\agg_bounding_rect.cs,get_bounding_rect,The length of the statement  "			return get_bounding_rect(vs' gi' start' num' out boundingRect.Left' out boundingRect.Bottom' out boundingRect.Right' out boundingRect.Top); " is 139.
Long Statement,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetAsRGBA_Floats,The length of the statement  "			return new RGBA_Floats((float)red / (float)base_mask' (float)green / (float)base_mask' (float)blue / (float)base_mask' (float)alpha / (float)base_mask); " is 152.
Long Statement,MatterHackers.Agg,DumpCallStackIfSlow,C:\repos\MatterHackers_agg-sharp\agg\DumpCallStackIfSlow.cs,Dispose,The length of the statement  "				Debug.Write("{0} [{1}ms]\n{2}\n".FormatWith(startMessage' timeToCallOnDrawFunction.ElapsedMilliseconds' Environment.StackTrace)); " is 129.
Long Statement,MatterHackers.Agg,ScanlineRasterizer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRasterizer.cs,gamma,The length of the statement  "				m_gamma[i] = (int)agg_basics.uround(gamma_function.GetGamma((double)(i) / (int)aa_scale_e.aa_mask) * (int)aa_scale_e.aa_mask); " is 126.
Long Statement,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,GenerateAndRenderSingleScanline,The length of the statement  "				destImage.blend_color_hspan(x' y' len' tempSpanColors.Array' 0' ManagedCoversArray' scanlineSpan.cover_index' useFirstCoverForAll); " is 131.
Long Statement,MatterHackers.Agg,ScanlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRenderer.cs,GenerateAndRenderSingleScanline,The length of the statement  "				destImageFloat.blend_color_hspan(x' y' len' tempSpanColorsFloats.Array' 0' ManagedCoversArray' scanlineSpan.cover_index' useFirstCoverForAll); " is 142.
Long Statement,MatterHackers.Agg,gradient_conic,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,calculate,The length of the statement  "			return (int)agg_basics.uround(System.Math.Abs(System.Math.Atan2((double)(y)' (double)(x))) * (double)(d) / System.Math.PI); " is 123.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2; " is 126.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2; " is 126.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 141.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 141.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 141.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 141.
Long Statement,MatterHackers.Agg,span_image_filter_rgb_2x2,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The length of the statement  "                span[spanIndex].m_ARGBData = base_mask << (int)RGBA_Bytes.Shift.A | fg[0] << (int)RGBA_Bytes.Shift.R | fg[1] << (int)RGBA_Bytes.Shift.G | fg[2] << (int)RGBA_Bytes.Shift.B; " is 171.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "				&& ((MatterHackers.Agg.span_interpolator_linear)base.m_interpolator).transformer().GetType() == typeof(MatterHackers.Agg.Transform.Affine) " is 138.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "			&& ((MatterHackers.Agg.Transform.Affine)((MatterHackers.Agg.span_interpolator_linear)base.m_interpolator).transformer()).is_identity()) " is 135.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2; " is 126.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2; " is 126.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 124.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 124.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 124.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight); " is 124.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "					float yweight = (float)m_filterFunction.calc_weight(System.Math.Sqrt((sourceSample.y - sourceOrigin.y) * (sourceSample.y - sourceOrigin.y))); " is 141.
Long Statement,MatterHackers.Agg,span_image_filter_rgba_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The length of the statement  "						float xweight = (float)m_filterFunction.calc_weight(System.Math.Sqrt((sourceSample.x - sourceOrigin.x) * (sourceSample.x - sourceOrigin.x))); " is 141.
Long Statement,MatterHackers.Agg,span_interpolator_linear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_linear.cs,resynchronize,The length of the statement  "			m_li_x = new dda2_line_interpolator(m_li_x.y()' agg_basics.iround(xe * (double)subpixel_scale_e.subpixel_scale)' (int)len); " is 123.
Long Statement,MatterHackers.Agg,span_interpolator_linear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_linear.cs,resynchronize,The length of the statement  "			m_li_y = new dda2_line_interpolator(m_li_y.y()' agg_basics.iround(ye * (double)subpixel_scale_e.subpixel_scale)' (int)len); " is 123.
Long Statement,MatterHackers.Agg,span_interpolator_linear_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_linear.cs,resynchronize,The length of the statement  "			//m_li_x = new dda2_line_interpolator(m_li_x.y()' agg_basics.iround(xe * (double)subpixel_scale_e.subpixel_scale)' (int)len); " is 125.
Long Statement,MatterHackers.Agg,span_interpolator_linear_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_linear.cs,resynchronize,The length of the statement  "			//m_li_y = new dda2_line_interpolator(m_li_y.y()' agg_basics.iround(ye * (double)subpixel_scale_e.subpixel_scale)' (int)len); " is 125.
Long Statement,MatterHackers.Agg,FloodFill,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,Fill,The length of the statement  "			fillRule.SetStartColor(new RGBA_Bytes(destImage.GetBuffer()[startColorBufferOffset + 2]' destImage.GetBuffer()[startColorBufferOffset + 1]' destImage.GetBuffer()[startColorBufferOffset])); " is 188.
Long Statement,MatterHackers.Agg,ToleranceMatch,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,CheckPixel,The length of the statement  "				return (destBuffer[bufferOffset] >= (startColor.red - tolerance0To255)) && destBuffer[bufferOffset] <= (startColor.red + tolerance0To255) && " is 140.
Long Statement,MatterHackers.Agg,ToleranceMatch,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,CheckPixel,The length of the statement  "					(destBuffer[bufferOffset + 1] >= (startColor.green - tolerance0To255)) && destBuffer[bufferOffset + 1] <= (startColor.green + tolerance0To255) && " is 145.
Long Statement,MatterHackers.Agg,ToleranceMatch,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,CheckPixel,The length of the statement  "					(destBuffer[bufferOffset + 2] >= (startColor.blue - tolerance0To255)) && destBuffer[bufferOffset + 2] <= (startColor.blue + tolerance0To255); " is 141.
Long Statement,MatterHackers.Agg,GammaLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\GammaLookUpTable.cs,SetGamma,The length of the statement  "				m_dir_gamma[i] = (byte)agg_basics.uround(Math.Pow(i / (double)gamma_scale_e.gamma_mask' m_gamma) * (double)gamma_scale_e.gamma_mask); " is 133.
Long Statement,MatterHackers.Agg,GammaLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\GammaLookUpTable.cs,SetGamma,The length of the statement  "				m_inv_gamma[i] = (byte)agg_basics.uround(Math.Pow(i / (double)gamma_scale_e.gamma_mask' inv_g) * (double)gamma_scale_e.gamma_mask); " is 131.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,DrawImage,The length of the statement  "				scanlineRenderer.GenerateAndRender(Rasterizer' drawImageScanlineCache' destImageWithClipping' destImageSpanAllocatorCache' spanImageFilter); " is 140.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "#if false // this is an optimization that eliminates the drawing of images that have their alpha set to all 0 (happens with generated images like explosions). " is 158.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform); " is 140.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes()); " is 129.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator); " is 123.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform); " is 140.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes()); " is 129.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "							//spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator); " is 125.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "				DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform); " is 140.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The length of the statement  "				ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes()); " is 129.
Long Statement,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The length of the statement  "			RectangleInt clippingRectInt = new RectangleInt((int)clippingRect.Left' (int)clippingRect.Bottom' (int)clippingRect.Right' (int)clippingRect.Top); " is 146.
Long Statement,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The length of the statement  "							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]); " is 134.
Long Statement,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The length of the statement  "									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best " is 137.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M896 885l-78 -369h260v-108h-283l-88 -408h-110l86 408h-363l-84 -408h-110l84 408h-201v108h225l78 369h-252v108h274l89 408h110l-88 -408h363l88 408h110l-88 -408h211v-108h-233zM425 885l-80 -369h362l78 369h-360z"" /> " is 213.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M518 20q-217 9 -339.5 101.5t-156.5 257.5l170 37q11 -53 34 -96.5t62 -75.5t95.5 -51.5t134.5 -24.5v496l-20 5q-77 18 -151 43t-132 66.5t-93.5 105.5t-35.5 162q0 84 32 146t89.5 103.5t136.5 63.5t174 26v131h124v-131q100 -5 172.5 -27.5t123.5 -62.5t84 -97.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t53 -132.5l-174 -33q-20 94 -81 146.5t-178 63.5v-445q59 -14 116 -29t108.5 -35.5t95.5 -48.5t76 -67.5t50 -94t18 -126.5q0 -77 -28 -142.5t-85 -115.5t-144.5 -81t-206.5 -37v-162h-124v162zM934 394q0 63 -23.5 103t-64 65.5t-93.5 41.5t-111 31v-468q65 4 119 19.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t92.5 43.5t59.5 68.5t21 95.5zM258 1048q0 -54 20 -91t55 -62t82.5 -41.5t102.5 -30.5v421q-72 -4 -122 -20.5t-80.5 -42.5t-44 -60t-13.5 -73z"" /> " is 139.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1748 434q0 -125 -25.5 -210.5t-69 -138t-101.5 -75t-124 -22.5t-123.5 22.5t-100 74.5t-67 137.5t-24.5 211.5q0 133 24 220t67 138.5t101.5 72t126.5 20.5q66 0 123.5 -20.5t100 -72t67.5 -138.5t25 -220zM527 0h-155l922 1409h157zM394 1421q64 0 121 -20.5t100 -71.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t67.5 -137t24.5 -217q0 -126 -25 -212t-67.5 -139.5t-100.5 -76.5t-124 -23q-67 0 -125 23t-100.5 76t-67 139t-24.5 213q0 131 24.5 217t67.5 137t102 71.5t127 20.5zM1600 434q0 99 -11 164.5t-32.5 104.5t-53 55t-71.5 16q-42 0 -74 -16.5t-54 -55.5t-33 -104.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-11 -163.5q0 -95 11.5 -159t33 -103.5t53 -56.5t72.5 -17q39 0 70.5 17t53.5 56.5t34 103.5t12 159zM560 975q0 98 -11 163t-32 104t-52 55t-71 16q-43 0 -75.5 -16.5t-54.5 -55.5t-33 -104t-11 -162q0 -95 11.5 -160t33 -104.5t53.5 -56.5t74 -17q38 0 69 17t53 56.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1193 -12q-96 0 -168 33t-130 94q-30 -26 -68 -50t-84.5 -43t-101 -30.5t-118.5 -11.5q-117 0 -202.5 30t-140.5 82.5t-81.5 124t-26.5 154.5q0 79 25.5 143.5t71 117t108.5 94t138 74.5q-18 34 -32.5 72.5t-25.5 77.5t-17 78t-6 74q0 66 20 123.5t62.5 100t109 67 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t159.5 24.5q73 0 134.5 -19t106.5 -55t70 -89t25 -121q0 -75 -33 -133.5t-89 -104.5t-130 -83.5t-157 -70.5q62 -114 135 -214.5t158 -197.5q61 90 101.5 189.5t69.5 220.5l145 -43q-35 -139 -88.5 -252.5t-123.5 -216.5q53 -54 106 -76t102 -22q32 0 61.5 3.5t55.5 12.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-135q-28 -11 -65.5 -16.5t-75.5 -5.5zM869 1133q0 37 -13.5 67t-37.5 51.5t-58.5 33t-76.5 11.5q-96 0 -146 -51.5t-50 -142.5q0 -59 18.5 -123.5t46.5 -120.5q65 26 123 53.5t101 60t68 72t25 89.5zM795 217q-89 105 -171 220t-148 237q-113 -48 -174.5 -122t-61.5 -179 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M127 532q0 139 21 266t66 244t115 227t167 215h174q-94 -105 -162.5 -215.5t-112.5 -228t-65.5 -244.5t-21.5 -266t21.5 -266t65.5 -245t112.5 -228t162.5 -215h-174q-97 105 -167 215t-115 227t-66 243.5t-21 266.5v4z"" /> " is 212.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M555 528q0 -140 -21 -266.5t-66 -243.5t-115 -227t-167 -215h-174q94 105 162.5 215t112.5 228t65.5 245t21.5 266t-21.5 266t-65.5 244.5t-112.5 228t-162.5 215.5h174q97 -105 167 -215t115 -227t66 -244t21 -266v-4z"" /> " is 212.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M456 1114l264 103l45 -132l-282 -73l185 -250l-119 -72l-150 258l-156 -256l-119 72l189 248l-280 73l45 134l267 -107l-12 297h136z"" /> " is 133.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1059 705q0 -203 -38.5 -341.5t-105 -224t-156.5 -122.5t-192 -37q-103 0 -192 37t-154.5 122t-103 223.5t-37.5 342.5q0 213 37.5 352.5t103.5 222.5t156 116.5t196 33.5q101 0 189.5 -33.5t154.5 -116.5t104 -222.5t38 -352.5zM876 705q0 168 -20 279.5t-59 178 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-95.5 94t-128.5 27.5q-76 0 -134 -28t-97.5 -94.5t-59.5 -178t-20 -278.5q0 -162 20.5 -273t60 -178.5t96.5 -97t130 -29.5q71 0 128 29.5t96.5 97t61 178.5t21.5 273z"" /> " is 162.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 0v127q51 117 124.5 206.5t154.5 162t160.5 134.5t143.5 124t103.5 130t39.5 154q0 60 -18 105.5t-52 76.5t-81.5 46.5t-105.5 15.5q-54 0 -101.5 -15t-84.5 -45t-60.5 -74.5t-30.5 -103.5l-184 17q9 76 42 143t91 117.5t139.5 79.5t188.5 29q105 0 187 -25 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t138.5 -74t86.5 -121t30 -166q0 -71 -25.5 -135t-68 -122t-98.5 -112t-117 -105.5t-123 -102t-116.5 -101.5t-97.5 -103.5t-67 -109.5h735v-153h-933z"" /> " is 145.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1049 389q0 -97 -31.5 -173t-92 -128.5t-150 -80t-204.5 -27.5q-131 0 -220.5 32.5t-147.5 86t-87 122t-38 141.5l186 17q8 -56 29.5 -102t58.5 -79t91 -51t128 -18q136 0 213.5 67t77.5 199q0 78 -34.5 125.5t-86 74t-112 35.5t-111.5 9h-102v156h98q51 0 106 10.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t100.5 38t75 74.5t29.5 120q0 113 -66.5 178.5t-197.5 65.5q-119 0 -192.5 -61t-85.5 -172l-181 14q11 93 51 162t101.5 114.5t140.5 68t168 22.5q118 0 203 -29.5t139 -80t79.5 -118.5t25.5 -145q0 -62 -17 -116t-53 -97t-91.5 -74t-133.5 -47v-4q85 -9 148 -38.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M881 319v-319h-170v319h-664v140l645 950h189v-948h198v-142h-198zM711 1206q-2 -5 -10 -19.5t-18 -32.5t-20.5 -36.5t-18.5 -30.5l-361 -532q-5 -8 -14.5 -21t-19.5 -26.5t-20 -26.5t-16 -20h498v745z"" /> " is 196.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 459q0 -106 -32 -194t-95 -151.5t-156.5 -98.5t-216.5 -35q-111 0 -193.5 26t-139.5 71.5t-90.5 106.5t-47.5 131l182 21q11 -40 31 -77.5t54.5 -67t85 -47t122.5 -17.5q70 0 127 21.5t97.5 63.5t62.5 103t22 140q0 65 -21 119.5t-60 94t-95.5 61.5t-128.5 22 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-45 0 -83 -8t-70.5 -22t-59 -32.5t-49.5 -38.5h-176l47 758h801v-153h-637l-27 -447q48 37 120 63.5t171 26.5q105 0 189 -32t143 -90.5t91 -139.5t32 -178z"" /> " is 152.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1049 461q0 -106 -29.5 -194.5t-87 -152t-142.5 -99t-196 -35.5q-123 0 -215 47t-153 135.5t-91.5 217t-30.5 292.5q0 188 34.5 330t99.5 237t158.5 143t211.5 48q72 0 135 -15t114.5 -48.5t90.5 -88.5t62 -135l-172 -31q-28 91 -89.5 131.5t-142.5 40.5q-74 0 -134 -35 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-102 -104.5t-64.5 -174.5t-22.5 -245q49 91 138 138.5t204 47.5q96 0 174 -31t133.5 -89.5t86 -142t30.5 -187.5zM866 453q0 73 -18 132t-54 100.5t-89 64t-123 22.5q-49 0 -99 -14.5t-90.5 -47t-66 -85.5t-25.5 -129q0 -78 20 -145.5t57.5 -117.5t90.5 -79t119 -29 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1036 1263q-106 -162 -195 -311.5t-153 -301t-99.5 -311t-35.5 -339.5h-188q0 169 40 331.5t108 319t158 307.5t191 298h-757v153h931v-146z"" /> " is 140.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1050 393q0 -90 -28.5 -165.5t-87 -130.5t-149.5 -86t-215 -31t-214.5 31t-150 85.5t-88 130t-28.5 164.5q0 77 23.5 137t63 103.5t90 70t104.5 35.5v4q-59 14 -105.5 45t-78 74.5t-48 96.5t-16.5 112q0 74 28.5 139.5t84.5 115t139 78t192 28.5q115 0 199.5 -29 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t140 -78.5t82.5 -115.5t27 -140q0 -58 -16.5 -111t-48 -96.5t-78 -74t-107.5 -42.5v-4q61 -10 113 -36.5t90 -70t60 -103.5t22 -136zM828 1057q0 53 -13.5 97t-44.5 75.5t-81 49t-123 17.5q-71 0 -120 -17.5t-80.5 -49t-45.5 -75.5t-14 -97q0 -42 11 -86t40 -80t80 -59 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t131 -23q85 0 136.5 23t79 59t36 80t8.5 86zM863 410q0 51 -14 98.5t-48 84t-91.5 59t-143.5 22.5q-79 0 -134.5 -22.5t-90 -59.5t-50.5 -85.5t-16 -100.5q0 -65 16 -118.5t51 -92t92 -59.5t138 -21q82 0 138 21t90 59.5t48.5 93t14.5 121.5z"" /> " is 229.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1042 733q0 -188 -35.5 -329.5t-101.5 -235.5t-160.5 -141t-212.5 -47q-81 0 -146 16.5t-116 51.5t-87 91t-58 135l172 27q28 -91 87.5 -133.5t150.5 -42.5q73 0 133.5 34.5t103 103.5t66.5 173t26 244q-21 -47 -57.5 -84t-83 -62.5t-100.5 -39t-109 -13.5 " is 241.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-96 0 -173.5 34.5t-131.5 96.5t-83.5 149.5t-29.5 194.5q0 109 31.5 197t91.5 149.5t147.5 94.5t198.5 33q235 0 356 -174t121 -523zM846 907q0 78 -18.5 147t-55 120t-90 80.5t-123.5 29.5q-65 0 -117 -23t-88 -65.5t-55.5 -103.5t-19.5 -136q0 -71 17.5 -132t52.5 -105.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M385 207v-156q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v207h195zM190 875v207h195v-207h-195z"" /> " is 140.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M385 207v-156q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v207h195zM190 875v207h195v-207h-195z"" /> " is 140.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1063 1032q0 -71 -18.5 -125t-49.5 -96.5t-70.5 -76t-80.5 -63.5t-80.5 -59t-71 -63t-51 -75.5t-20.5 -96.5h-175q2 69 21.5 121t50.5 92t70 71.5t79 60t78.5 57t68.5 63.5t48.5 79t18.5 103t-21 105t-59.5 77.5t-93 47.5t-121.5 16q-140 0 -222 -70t-96 -192l-184 12 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q11 84 44.5 158.5t94 130.5t150 88.5t211.5 32.5q114 0 203 -28t150.5 -79.5t93.5 -125.5t32 -165zM438 0v201h195v-201h-195z"" /> " is 123.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1902 755q0 -144 -33.5 -263.5t-92.5 -205.5t-141.5 -134t-179.5 -48q-56 0 -95.5 13.5t-64.5 37t-36 55.5t-11 70q0 15 1 36.5t2 33.5h-6q-24 -45 -58.5 -89.5t-81 -79t-105 -56t-129.5 -21.5q-84 0 -146.5 29t-103 80.5t-60.5 122t-20 153.5q0 120 35.5 230.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t101.5 195t158.5 135.5t206.5 51q60 0 108 -13.5t84.5 -37.5t63.5 -57.5t45 -73.5h6l39 160h156l-116 -506q-19 -84 -28 -144t-9 -109q0 -48 21.5 -71t59.5 -23q62 0 115.5 40.5t93 111.5t62 167t22.5 208q0 129 -41.5 240t-122 192t-199.5 127t-275 46q-134 0 -247.5 -32 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-205.5 -90t-161.5 -138.5t-116.5 -176.5t-71 -205.5t-24 -224.5q0 -141 43 -260t125.5 -204.5t204 -133.5t279.5 -48q105 0 196 16.5t167 40.5t136 52.5t104 52.5l55 -112q-50 -30 -117.5 -61.5t-150.5 -57.5t-181 -42.5t-209 -16.5q-190 0 -337.5 57.5t-249 160.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-154 245t-52.5 311q0 139 31.5 267t90.5 238t144 200t192.5 154t235 99t271.5 35q201 0 347 -59t241.5 -159t141.5 -232t46 -279zM1296 747q0 50 -17 92t-48.5 72t-76 46.5t-100.5 16.5q-86 0 -151 -42.5t-108.5 -111.5t-66 -155.5t-22.5 -173.5q0 -120 47.5 -188 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" /> " is 185.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" /> " is 158.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" /> " is 135.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1381 719q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v1409h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-1103h314q111 0 205.5 36t163.5 107t108 177t39 246z"" /> " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293z"" /> " is 168.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" /> " is 190.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" /> " is 141.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" /> " is 138.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" /> " is 209.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -149 -38.5 -272.5t-111 -216.5t-178 -151.5t-239.5 -76.5q21 -64 47.5 -109t60.5 -73.5t75.5 -42t92.5 -13.5q28 0 60 4t55 9v-134q-38 -9 -83.5 -15.5t-94.5 -6.5q-86 0 -150 25.5t-112.5 73t-83.5 116.5t-62 156q-158 8 -277.5 65.5t-199 154t-119.5 226 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-40 281.5q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5 " is 240.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" /> " is 120.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33z"" /> " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M782 0h-198l-575 1409h201l390 -992q15 -45 30 -89.5t27 -79.5q14 -41 27 -80q12 37 26 78q12 35 26.5 79t31.5 92l388 992h201z"" /> " is 129.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199z"" /> " is 125.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 546q0 -566 -398 -566q-123 0 -204.5 44.5t-132.5 143.5h-2q0 -26 -1.5 -54t-3 -52t-3 -41t-2.5 -21h-174q1 9 2 30.5t2 51.5t1.5 66t0.5 75v1261h180v-423q0 -30 -0.5 -57.5t-1.5 -48.5q-1 -25 -2 -47h4q50 104 132.5 149t204.5 45q205 0 301.5 -138t96.5 -418z " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M864 540q0 112 -14 192t-45 131.5t-79 75.5t-117 24q-71 0 -125.5 -23t-91 -74t-55.5 -134t-19 -203q0 -116 19 -195t55.5 -128.5t90.5 -71t124 -21.5q66 0 114 23t80 74t47.5 132.5t15.5 197.5z"" /> " is 186.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183z"" /> " is 136.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v419h180v-1261q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5t-3 42.5t-2.5 50.5t-1 52.5h-4z " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" /> " is 194.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211z"" /> " is 203.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191z"" /> " is 137.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M317 897q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-721h-181v686q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-638h-180v1484h180v-386q0 -33 -1 -66t-2.5 -61t-2.5 -47.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M137 1312v172h180v-172h-180zM317 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" /> " is 194.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M768 0v686q0 79 -10 132t-33.5 85.5t-61.5 46t-93 13.5q-57 0 -103 -22.5t-78.5 -65t-50 -105t-17.5 -143.5v-627h-179v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q24 47 52 85t65.5 64.5t86 41t112.5 14.5q123 0 194.5 -49 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t99.5 -156h3q24 47 54 85t70 64.5t90 41t114 14.5q82 0 141.5 -22t97.5 -68t56 -118.5t18 -172.5v-721h-178v686q0 79 -10 132t-33.5 85.5t-61.5 46t-93 13.5q-57 0 -103 -21.5t-78.5 -63.5t-50 -105t-17.5 -146v-627h-178z"" /> " is 212.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M825 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 546q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40t1 -53.5t0.5 -58.5v-423h-180v1286q0 39 -0.5 75t-1.5 65.5t-2 50.5t-2 30h174q1 -3 2.5 -21t3 -43.5t3 -54.5t1.5 -55h4q25 52 57 88.5t73 60t91.5 34 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" /> " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M484 -20q-206 0 -302 139t-96 417q0 282 98.5 424t299.5 142q67 0 118.5 -12t92 -35.5t71 -58.5t55.5 -82h2q0 25 1.5 55.5t3 57.5t3.5 46.5t4 22.5h173q-2 -17 -4.5 -89t-2.5 -206v-1226h-180v439q0 26 0.5 54t1.5 53q1 28 2 57h-2q-26 -51 -57.5 -88.5t-72.5 -62 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-92.5 -36t-116.5 -11.5zM821 554q0 118 -20.5 198t-58 128t-91 68.5t-119.5 20.5q-69 0 -118 -25.5t-79.5 -78t-45 -133t-14.5 -190.5q0 -108 13.5 -188t44 -132t79 -77.5t118.5 -25.5q60 0 113 18.5t92.5 67t62.5 133t23 216.5z"" /> " is 218.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180z"" /> " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" /> " is 169.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M613 0h-213l-393 1082h192l238 -704q7 -22 16.5 -53.5t19.5 -65.5t18.5 -65.5t14.5 -52.5q6 21 15.5 52.5t19.5 64.5t20.5 64.5t18.5 53.5l246 706h191z"" /> " is 151.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M513 -425q-65 0 -114.5 20.5t-82.5 58.5t-50 92t-17 122v361q0 63 -14.5 107t-42 72t-67.5 42t-91 16v127q51 2 91 16t67.5 42t42 72t14.5 106v362q0 141 66.5 217t197.5 76h135v-129h-63q-91 0 -129.5 -53.5t-38.5 -161.5v-356q0 -50 -15 -92t-41 -74t-61.5 -54 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M94 -296q91 0 130.5 54.5t39.5 160.5v357q0 51 14 93t39.5 74.5t61 54.5t78.5 32v2q-42 10 -77 32t-61 54t-40.5 74t-14.5 92v356q0 108 -39.5 161.5t-130.5 53.5h-60v129h132q131 0 197.5 -76t66.5 -217v-362q0 -62 14.5 -106t42 -72t68 -42t92.5 -16v-127 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M844 553q-69 0 -141.5 22t-145.5 48q-129 45 -217 45q-38 0 -70.5 -6t-62.5 -17.5t-58 -27.5t-57 -37v143q50 38 116 61t147 23q40 0 80 -6.5t78.5 -16.5t76 -23t74.5 -26q21 -8 46 -15.5t50.5 -14.5t51 -11t48.5 -4q69 0 130.5 25t113.5 67v-149q-32 -23 -61.5 -38 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M538 282v830q-166 -24 -202 -228q-13 -78 -13 -177t13 -177q38 -218 202 -248zM662 284q150 34 174 205l182 -12q-27 -211 -210 -301q-63 -31 -146 -39v-168h-124v168q-211 19 -312 177q-91 142 -91 383q0 278 121 421q102 120 282 136v155h124v-155q222 -23 311 -202 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1104 311q-9 -80 -37.5 -138.5t-73 -97t-102 -57t-124.5 -18.5h-698v154q89 46 132 126t43 201v144h-186v129h186v280q0 92 24 165.5t73.5 124.5t125.5 78.5t179 27.5q70 0 131.5 -14.5t111 -43.5t85 -72t53.5 -100l-174 -57q-10 31 -29.5 57t-46 44t-59 28t-68.5 10 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-114 0 -170 -57.5t-56 -182.5v-288h408v-129h-408v-126q0 -56 -11 -109t-33 -99t-53.5 -81.5t-71.5 -56.5h483q38 0 71.5 9.5t60 30.5t45 54.5t26.5 81.5z"" /> " is 150.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M137 684q0 71 20.5 134.5t57.5 117.5l-100 100l104 103l99 -101q54 39 117.5 60.5t136.5 21.5q71 0 134 -21t117 -59l97 97l104 -105l-96 -96q37 -54 58.5 -117.5t21.5 -134.5t-22 -135t-60 -117l100 -100l-102 -105l-101 101q-54 -37 -117 -57.5t-134 -20.5 " is 243.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-72 0 -136 21t-116 59l-105 -105l-102 105l102 102q-37 54 -57.5 117.5t-20.5 134.5zM291 686q0 -58 22 -109t60.5 -89t89.5 -60t109 -22q57 0 108 22t89.5 60t60.5 89t22 109t-22 109t-60.5 89t-89.5 60.5t-108 22.5q-58 0 -109 -22.5t-89.5 -60.5t-60.5 -89t-22 -109z " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M720 709h321v-125h-383v-154h383v-127h-383v-303h-178v303h-381v127h381l2 154h-383v125h320l-421 700h199l371 -647l375 647h199z"" /> " is 131.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M588 1484q79 0 148 -15t123 -46.5t90.5 -80.5t51.5 -118l-161 -20q-8 45 -31 74t-57 46t-76 23.5t-88 6.5q-125 0 -189.5 -39.5t-64.5 -110.5q0 -45 25 -77t66.5 -55t96 -39t113.5 -30q68 -16 137.5 -39t125.5 -59.5t91 -89.5t35 -129q0 -45 -14 -88.5t-41.5 -80 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-68.5 -64t-95 -40.5q49 -21 88.5 -46.5t67 -57.5t42.5 -72.5t15 -91.5q0 -73 -29 -131.5t-85 -100t-138 -63.5t-189 -22q-93 0 -170 13.5t-135.5 45.5t-98 84t-58.5 129l161 31q12 -55 39 -88.5t66 -52t89 -25t107 -6.5q58 0 109 9t89 29t60.5 52.5t22.5 79.5 " is 241.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 54 -28.5 90t-76 61.5t-109 43.5t-126.5 34q-65 15 -130.5 38t-117.5 59.5t-84.5 89t-32.5 126.5q0 45 16 86.5t45.5 77t71.5 62t95 41.5q-42 14 -79.5 37t-66 55t-45 72t-16.5 88q0 139 105.5 216.5t308.5 77.5zM866 663q0 48 -26.5 82.5t-70.5 60t-100.5 43t-117.5 31.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-58 -3 -102.5 -19.5t-74.5 -42.5t-45.5 -60.5t-15.5 -73.5q0 -46 24.5 -79t65.5 -57t95 -41t114 -32q54 1 100.5 13t80.5 35.5t53.5 58.5t19.5 81z"" /> " is 143.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1477 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M1385 707q0 86 -22.5 166.5t-63.5 150t-99 127t-128 98.5t-150.5 63.5t-167.5 22.5q-130 0 -244 -49.5t-199.5 -135t-135 -199.5t-49.5 -244q0 -131 49.5 -245.5t135 -200t199.5 -134.5t244 -49q87 0 167.5 22.5t150.5 63t128 98t99 127.5t63.5 150.5t22.5 167.5zM498 709 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -72 16.5 -132t50 -103t83.5 -67t117 -24q49 0 86.5 13.5t65.5 36t47.5 50t33.5 56.5l115 -35q-22 -43 -51 -83.5t-70 -72t-96.5 -50.5t-130.5 -19q-101 0 -175.5 32t-123.5 89t-73 136t-24 173q0 97 24 175.5t72.5 134t121.5 85t171 29.5q75 0 131 -18t96 -47.5t67.5 -67 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M260 651q-53 0 -96 14.5t-74 42.5t-47.5 69t-16.5 93q0 69 25.5 115t68.5 74t99.5 40t118.5 13l178 4v60q0 46 -10.5 76t-30 47.5t-47.5 24.5t-63 7q-67 0 -107.5 -29.5t-49.5 -105.5l-149 10q7 47 28.5 88t59 72t91.5 48.5t125 17.5q68 0 122.5 -14.5t93 -44.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t59.5 -77.5t21 -113.5v-308q0 -58 14 -83t49 -25q12 0 23 2.5t20 5.5v-104q-19 -5 -40 -9t-43 -4q-41 0 -69.5 11t-47.5 30.5t-29 45t-12 54.5h-4q-38 -77 -104 -112t-156 -35zM299 762q48 0 88 17t68.5 44.5t44.5 63t16 72.5v65l-138 -4q-41 -2 -78 -7.5t-64.5 -20 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M886 141l-338 365v63l338 371h168v-31l-338 -372l340 -367v-29h-170zM419 141l-336 365v63l336 371h167v-31l-335 -372l337 -367v-29h-169z"" /> " is 139.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1477 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M1385 707q0 86 -22.5 166.5t-63.5 150t-99 127t-128 98.5t-150.5 63.5t-167.5 22.5q-130 0 -244 -49.5t-199.5 -135t-135 -199.5t-49.5 -244q0 -131 49.5 -245.5t135 -200t199.5 -134.5t244 -49q87 0 167.5 22.5t150.5 63t128 98t99 127.5t63.5 150.5t22.5 167.5zM955 289 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l-199 336h-161v-336h-127v831h307q142 0 217.5 -63t75.5 -174q0 -102 -52 -163.5t-137 -80.5l221 -350h-145zM941 881q0 69 -47.5 105t-128.5 36h-170v-301h182q80 0 122 42.5t42 117.5z"" /> " is 178.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M696 1145q0 -59 -22.5 -111t-61.5 -90.5t-91.5 -61t-111.5 -22.5t-111 22.5t-91 61t-62 90.5t-23 111q0 60 23 112t62 90.5t91 60.5t111 22t111.5 -22t91.5 -60.5t61.5 -90.5t22.5 -112zM587 1145q0 37 -13.5 70t-37.5 57.5t-56.5 38.5t-70.5 14q-37 0 -69.5 -14 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M43 563l-2 103q27 61 71 109t94 88.5t101.5 76.5t92.5 72.5t67 76.5t26 89q0 62 -35.5 99.5t-109.5 37.5q-68 0 -112 -36.5t-52 -104.5l-133 8q6 51 29 94.5t61 75.5t91.5 50.5t121.5 18.5q65 0 116.5 -16.5t87 -46.5t54 -73t18.5 -97q0 -62 -27 -112t-68.5 -93 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M642 795q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-108 34.5q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" /> " is 202.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M140 -425v1507h181v-686q0 -78 16 -131t45 -85.5t71 -46.5t94 -14q128 0 201 87t73 249v627h180v-816q0 -44 5.5 -72t15.5 -44t24.5 -22.5t32.5 -6.5q11 0 27 2.5t27 5.5v-129q-26 -8 -51.5 -14t-61.5 -6q-54 0 -89.5 15t-57.5 41t-32 61.5t-12 76.5h-3 " is 238.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M884 1307v-1571h-112v1571h-217v-1571h-113v958q-80 0 -146.5 22.5t-114.5 66.5t-74.5 110.5t-26.5 155.5q0 84 25 150.5t72.5 113t116.5 71.5t156 25h563v-102h-129z"" /> " is 164.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M483 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" /> " is 231.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M723 1042q0 -188 -88 -289.5t-263 -101.5q-168 0 -256.5 100.5t-88.5 290.5q0 91 21.5 163.5t65 123t109 77t153.5 26.5q93 0 158.5 -26.5t107.5 -76.5t61.5 -122.5t19.5 -164.5zM574 1042q0 83 -12.5 138t-37.5 87.5t-61 46t-84 13.5t-85.5 -13.5t-63 -46.5t-38.5 -88 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M56 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1503 180v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM1374 715q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26z"" /> " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M56 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1053 2l-2 103q27 61 71 109t94 88.5t101.5 76.5t92.5 72.5t67 76.5t26 89q0 62 -35.5 99.5t-109.5 37.5q-68 0 -112 -36.5t-52 -104.5l-133 8q6 51 29 94.5t61 75.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t91.5 50.5t121.5 18.5q65 0 116.5 -16.5t87 -46.5t54 -73t18.5 -97q0 -62 -27 -112t-68.5 -93t-92.5 -80.5t-98.5 -74t-86.5 -73.5t-57 -79h443v-113h-600z"" /> " is 150.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M513 0h-148l881 1409h145zM1503 180v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM1374 715q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26zM688 795q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5t-108 34.5q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" /> " is 138.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M131 50q0 71 18.5 125t49.5 96.5t70.5 76t80.5 63.5t80.5 59t71 63t51 75.5t20.5 96.5h175q-2 -69 -21.5 -121t-50.5 -92t-70 -71.5t-79 -60t-78.5 -57t-68.5 -63.5t-48.5 -79t-18.5 -103t21 -105t59.5 -77.5t93 -47.5t121.5 -16q140 0 222 70t96 192l184 -12 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-11 -84 -44.5 -158.5t-94 -130.5t-150 -88.5t-211.5 -32.5q-114 0 -203 28t-150.5 79.5t-93.5 125t-32 165.5zM756 1082v-201h-195v201h195z"" /> " is 137.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM750 1530l-310 217v29h207l217 -226v-20h-114z"" /> " is 229.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM547 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 229.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM1014 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM842 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" /> " is 167.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM803 1530v184h163v-184h-163zM409 1530v184h165v-184h-165z"" /> " is 241.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM928 1546q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM820 1546q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M969 0v412h-548l-198 -412h-199l686 1409h1209v-156h-759v-452h699v-154h-699v-491h800v-156h-991zM969 1262h-151q-1 -3 -9 -20.5t-19 -42.5t-24.5 -54t-25.5 -54.5t-21 -44.5t-11 -24l-217 -461h478v701z"" /> " is 200.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM993 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM1037 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 137.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM816 1530v184h163v-184h-163zM422 1530v184h165v-184h-165z"" /> " is 131.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M14 801h154v608h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v647h-154v154zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-455h406v-154h-406v-494h314q111 0 205.5 36 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM909 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" /> " is 126.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM854 1530l-310 217v29h207l217 -226v-20h-114z"" /> " is 182.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM621 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 182.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM1131 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 200.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM941 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" /> " is 126.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM910 1530v184h163v-184h-163zM516 1530v184h165v-184h-165z"" /> " is 194.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-127 0 -230 29t-184 83l-120 -145h-190l200 241q-88 97 -131 230t-43 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q125 0 228.5 -28t185.5 -82l121 146h192l-201 -242q85 -94 128.5 -223.5 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t43.5 -289.5zM1300 711q0 112 -24.5 204t-73.5 164l-709 -853q59 -44 134 -67.5t168 -23.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM291 711q0 -113 25 -208t76 -170l707 853q-59 42 -134.5 65t-167.5 23q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM813 1530 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM565 1530v20 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM1070 1550v-20 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM853 1530v184 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 735q0 -88 -29.5 -167.5t-90 -139.5t-151.5 -95.5t-214 -35.5h-414v-297h-191v1409h191v-252h402q125 0 218 -30t155 -85.5t93 -133.5t31 -173zM1066 731q0 134 -82 208.5t-246 74.5h-379v-576h387q82 0 142.5 22t100 61.5t58.5 93t19 116.5z"" /> " is 238.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 295q0 -66 -20.5 -123.5t-64 -100t-111.5 -67t-162 -24.5q-80 0 -154 12.5t-129 36.5l-2 164q25 -14 58.5 -26.5t70.5 -22t76 -15t76 -5.5q92 0 141 43t49 122q0 56 -27 94.5t-67.5 69.5t-88 59.5t-88 65t-67.5 85.5t-27 122q0 51 16.5 87.5t41 65.5t53.5 53 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t53.5 50t41 57.5t16.5 74.5q0 37 -16.5 68t-48 53.5t-76.5 35.5t-102 13q-68 0 -121.5 -17.5t-90 -56t-56 -99.5t-19.5 -149v-1021h-180v1027q0 118 31.5 204.5t91.5 142.5t147 83t197 27q102 0 179.5 -23t130 -63t79 -94.5t26.5 -116.5q0 -61 -16.5 -106t-42 -79.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM624 1201l-330 278v29h207l217 -287v-20h-94z"" /> " is 128.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM412 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 128.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM880 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 146.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM737 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM674 1219v184h163v-184h-163zM280 1219v184h165v-184h-165z"" /> " is 141.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM799 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM691 1410q0 28 -10.5 52.5t-28.5 42.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" /> " is 177.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M968 503v-17q1 -82 18 -150t52 -117t89.5 -76.5t132.5 -27.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-321 0 -423 257q-29 -51 -66 -97.5t-88 -82t-119.5 -56.5t-161.5 -21q-167 0 -251.5 86t-84.5 236q0 71 19 125 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t52.5 93t79 64.5t99 41.5t112 22.5t118.5 7.5l240 4v59q0 67 -13 114t-41.5 76t-72.5 42.5t-105 13.5q-54 0 -98 -7.5t-76 -27t-51.5 -53t-26.5 -84.5l-188 17q10 64 39 117.5t81.5 92.5t132 60.5t191.5 21.5q128 0 214 -35t135 -104q63 74 151.5 106.5t194.5 32.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-762zM786 534l-195 -4q-40 -1 -80.5 -4t-78.5 -12t-71 -24.5t-57.5 -41t-38.5 -62t-14 -87.5q0 -87 50 -135.5t143 -48.5q90 0 154.5 31.5t106 80.5t61.5 107t20 111v89zM1544 641q-15 171 -87 249.5t-207 78.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM751 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM657 1201l-330 278v29h207l217 -287v-20h-94z"" /> " is 161.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM440 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 161.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM907 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 179.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM687 1219v184h163v-184h-163zM293 1219v184h165v-184h-165z"" /> " is 174.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M566 -20q-125 0 -215.5 36.5t-149.5 102.5t-87 158.5t-28 203.5q0 107 26 198t84 158t151 104.5t226 37.5q71 0 129.5 -16t101.5 -43q-43 86 -100.5 174t-133.5 157l-301 -133v114l218 94q-56 45 -116 84t-126 74h209q45 -20 86.5 -45.5t83.5 -56.5l306 132l-1 -112 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l-211 -92q81 -74 145.5 -162t108.5 -188t67.5 -211.5t23.5 -232.5v-6q0 -122 -28.5 -220t-88.5 -167t-154 -106t-226 -37zM874 481q0 94 -16.5 162.5t-52 113.5t-92 67t-136.5 22q-81 0 -138.5 -22.5t-94 -68.5t-53 -114.5t-16.5 -159.5q0 -190 72 -279t217 -89q81 0 140 22 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM737 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5 " is 243.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM659 1201l-330 278v29h207l217 -287v-20h-94z"" /> " is 131.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM431 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 131.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM902 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 149.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM739 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM689 1219v184h163v-184h-163zM295 1219v184h165v-184h-165z"" /> " is 144.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1112 542q0 -284 -125 -423t-363 -139q-97 0 -175 24t-138 74l-100 -116h-167l184 214q-41 68 -62 159t-21 207q0 560 485 560q103 0 181 -23t135 -68l91 105h167l-173 -201q42 -69 61.5 -161.5t19.5 -211.5zM923 542q0 68 -6 122.5t-17 98.5l-483 -562 " is 238.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q38 -49 90.5 -68.5t114.5 -19.5q69 0 125 19.5t95 68.5t60 132t21 209zM334 542q0 -130 24 -215l482 561q-37 45 -89 63t-118 18q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205z"" /> " is 179.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM355 1201 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M138 1484h180v-423q0 -30 -0.5 -57.5t-1.5 -48.5q-1 -25 -2 -47h6q25 52 57 88.5t73 60t91.5 34t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t1 -53.5t0.5 -58.5v-423h-180v1909zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" /> " is 228.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM626 1219 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM960 1570h-549v127h549v-127z"" /> " is 213.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM685 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM560 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM1379 -389q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" /> " is 144.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM1139 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM667 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 179.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM431 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 179.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM1122 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 197.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM870 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 197.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM702 1605v172h180v-172h-180z"" /> " is 163.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM456 1312v172h180v-172h-180z"" /> " is 164.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM898 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" /> " is 193.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM652 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" /> " is 194.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1381 719q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v1409h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-1103h314q111 0 205.5 36t163.5 107t108 177t39 246zM796 1530 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v419h180v-1261q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5t-3 42.5t-2.5 50.5t-1 52.5h-4z " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5zM1279 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M14 801h154v608h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v647h-154v154zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-455h406v-154h-406v-494h314q111 0 205.5 36 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v141h-300v131h300v147h180v-147h132v-131h-132v-983q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-3 42.5t-2.5 50.5t-1 52.5h-4zM275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" /> " is 224.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM845 1236h-549v127h549v-127z"" /> " is 146.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM701 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" /> " is 228.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM569 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM480 1312v172h180v-172h-180z"" /> " is 146.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM1278 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM811 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM805 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" /> " is 133.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM672 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" /> " is 176.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM1137 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 230.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM878 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 198.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM810 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM546 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM721 1605v172h180v-172h-180z"" /> " is 196.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM457 1312v172h180v-172h-180z"" /> " is 165.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM918 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM442 1317q0 87 22 145.5t62 105.5h117q-45 -48 -69.5 -96t-24.5 -94h88v-167h-195v106z"" /> " is 219.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191zM1071 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 135.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M317 897q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-721h-181v686q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-638h-180v1484h180v-386q0 -33 -1 -66t-2.5 -61t-2.5 -47.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1126 0v653h-767v-653h-191v1025h-154v154h154v230h191v-230h767v230h186v-230h153v-154h-153v-1025h-186zM1126 813v212h-767v-212h767z"" /> " is 137.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M317 857q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-681h-181v646q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180v1206h-132v131h132v147h180v-147h300v-131h-300 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M189 0v1409h191v-1409h-191zM443 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M194 0v1082h180v-1082h-180zM443 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M189 0v1409h191v-1409h-191zM286 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" /> " is 189.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M194 0v1082h180v-1082h-180zM286 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" /> " is 220.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M189 0v1409h191v-1409h-191zM442 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" /> " is 238.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180zM381 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M170 0v1409h191v-1409h-191zM938 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" /> " is 217.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180zM591 1312v172h180v-172h-180zM771 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31zM973 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M77 -425q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5zM559 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 226.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237zM805 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" /> " is 177.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M816 0l-366 494l-132 -109v-385h-180v1484h180v-927l475 525h211l-439 -465l462 -617h-211zM662 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" /> " is 176.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h191v-1253h712v-156h-903zM717 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" /> " is 126.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h191v-1253h712v-156h-903zM858 1303q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" /> " is 127.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM601 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 185.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM836 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" /> " is 222.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM675 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" /> " is 129.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM841 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" /> " is 199.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M923 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM199 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 129h-88v197h195v-145z"" /> " is 153.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M941 -20q-56 0 -104 12t-87.5 32t-71 47t-55.5 57l127 115q37 -45 87 -77.5t109 -32.5q64 0 103 29t59.5 82.5t27 130t6.5 171.5v322q0 108 -19.5 185t-60 126t-104 72t-150.5 23q-94 0 -175.5 -31t-142 -83.5t-95.5 -122t-35 -146.5v-891h-191v1092q0 37 -0.5 83t-1 91 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-1 83t-1.5 60h184q1 -22 2.5 -53.5t2.5 -66t1.5 -69t0.5 -62.5h4q34 61 85.5 111.5t116.5 85.5t141.5 54.5t162.5 19.5q124 0 212.5 -32t144.5 -98.5t82.5 -168.5t26.5 -241v-347q0 -130 -15 -234t-58 -177t-119 -112t-199 -39z"" /> " is 217.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M769 -425q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v793q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68t61.5 -118.5t19.5 -172.5v-855q0 -62 -11 -115t-38 -92t-73.5 -61.5t-118.5 -22.5z"" /> " is 178.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM1070 1570h-549v127h549v-127z"" /> " is 167.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM795 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM569 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM514 1530v20l197 227h207v-29l-310 -218h-94zM861 1530v20l197 227h207v-29l-310 -218h-94z"" /> " is 224.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM287 1201v20l217 287h207v-29l-330 -278h-94zM634 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 174.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M999 0q-20 -3 -45.5 -4.5t-54 -3t-57 -2t-53.5 -0.5q-169 0 -298.5 53t-217 148.5t-132 228t-44.5 291.5q0 165 47 296.5t136 223t218 140.5t293 49q26 0 55 -1t57.5 -2.5t54.5 -3.5t45 -4h914v-156h-803v-452h743v-154h-743v-491h844v-156h-959zM789 145q32 0 70 1t64 3 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v1111q-11 1 -27 2t-34.5 1.5t-37 0.5h-33.5q-125 0 -218.5 -37t-156 -108t-94 -174t-31.5 -234q0 -129 32 -233.5t95 -178.5t156 -114t215 -40z"" /> " is 139.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1070 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-137 0 -236 45.5t-160 137.5q-63 -93 -163.5 -138t-237.5 -45q-113 0 -203.5 34t-154 104t-97.5 175.5t-34 248.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 279 126.5 419.5t368.5 140.5q281 0 398 -177q67 94 167 135.5t219 41.5q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-772zM881 542q0 126 -21 208t-59.5 131t-93.5 68.5t-123 19.5q-69 0 -126 -20.5t-97.5 -70t-63 -131.5t-22.5 -205q0 -126 23.5 -208.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t64 -131.5t94.5 -69t116 -20q69 0 126 19.5t97.5 68.5t62.5 132t22 209zM1656 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" /> " is 167.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM254 1201 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM330 -193 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM494 1201 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM562 1530v20l217 287h207v-29l-330 -278h-94z"" /> " is 163.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM1032 1548v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 182.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM905 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t44.5 -77t16.5 -102zM701 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" /> " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM809 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" /> " is 178.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M830 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5zM720 1253v-1253h-190v1253 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M554 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5zM554 8q-41 -11 -83.5 -17.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" /> " is 139.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133zM785 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" /> " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M336 516v-248q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v287h-125v131h125v304h-125v131h132l53 242h120v-242h200v-131h-200v-304h200v-131h-200z"" /> " is 207.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM896 1530 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" /> " is 231.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM738 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM1015 1565h-549 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM738 1530 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" /> " is 149.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM564 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" /> " is 240.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM982 1613 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM874 1613q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5 " is 239.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM811 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM703 1410q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" /> " is 155.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM445 1530v20 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM283 1201v20l217 287h207v-29l-330 -278h-94zM630 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 142.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM974 -400 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" /> " is 198.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM1029 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM1295 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 187.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM1066 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" /> " is 129.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM1009 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" /> " is 128.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM844 1221 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM799 1530v184h163v-184h-163zM405 1530v184h165v-184h-165z"" /> " is 122.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM750 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" /> " is 133.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM594 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" /> " is 127.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M318 0h-180v1204q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-1179z"" /> " is 168.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M932 1312q-17 5 -48 10t-62 5t-54 -9.5t-39.5 -29.5t-28.5 -52t-21 -77l-26 -137h211l-25 -131h-213l-254 -1325h-180l254 1325h-152l27 131h151l29 152q12 59 32 110t55.5 89t90 59.5t135.5 21.5q32 0 73 -5t76 -15z"" /> " is 210.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M926 1392q0 -45 -19 -84.5t-52 -69.5q-16 -15 -34 -26l541 -1212h-195l-161 371h-642l-162 -371h-198l548 1209q-21 12 -39 29q-33 30 -52 69.5t-19 84.5t19 84.5t52 69t77 46.5t94 17t94 -17t77 -46.5t52 -69t19 -84.5zM768 923q-16 36 -30.5 73t-25.5 67t-18.5 50.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-8.5 24.5q-2 -4 -9 -24.5t-18.5 -51.5t-26 -67.5t-29.5 -72.5l-180 -417h527zM818 1392q0 25 -10.5 47t-28.5 38.5t-42.5 26t-52.5 9.5q-29 0 -53.5 -9.5t-42.5 -26t-28.5 -38.5t-10.5 -47q0 -26 10.5 -48t28.5 -39.5t42 -27.5q21 -8 45 -9h9q28 0 52.5 9.5t42.5 27 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM811 1239q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM703 1239q0 28 -10.5 52.5t-28.5 42.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5zM427 1547v20l217 287h207v-29l-330 -278h-94z"" /> " is 220.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M969 0v412h-548l-198 -412h-199l686 1409h1209v-156h-759v-452h699v-154h-699v-491h800v-156h-991zM969 1262h-151q-1 -3 -9 -20.5t-19 -42.5t-24.5 -54t-25.5 -54.5t-21 -44.5t-11 -24l-217 -461h478v701zM1068 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M968 503v-17q1 -82 18 -150t52 -117t89.5 -76.5t132.5 -27.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-321 0 -423 257q-29 -51 -66 -97.5t-88 -82t-119.5 -56.5t-161.5 -21q-167 0 -251.5 86t-84.5 236q0 71 19 125 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t52.5 93t79 64.5t99 41.5t112 22.5t118.5 7.5l240 4v59q0 67 -13 114t-41.5 76t-72.5 42.5t-105 13.5q-54 0 -98 -7.5t-76 -27t-51.5 -53t-26.5 -84.5l-188 17q10 64 39 117.5t81.5 92.5t132 60.5t191.5 21.5q128 0 214 -35t135 -104q63 74 151.5 106.5t194.5 32.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-762zM786 534l-195 -4q-40 -1 -80.5 -4t-78.5 -12t-71 -24.5t-57.5 -41t-38.5 -62t-14 -87.5q0 -87 50 -135.5t143 -48.5q90 0 154.5 31.5t106 80.5t61.5 107t20 111v89zM1544 641q-15 171 -87 249.5t-207 78.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-127 0 -230 29t-184 83l-120 -145h-190l200 241q-88 97 -131 230t-43 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q125 0 228.5 -28t185.5 -82l121 146h192l-201 -242q85 -94 128.5 -223.5 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t43.5 -289.5zM1300 711q0 112 -24.5 204t-73.5 164l-709 -853q59 -44 134 -67.5t168 -23.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM291 711q0 -113 25 -208t76 -170l707 853q-59 42 -134.5 65t-167.5 23q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231zM659 1530 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1112 542q0 -284 -125 -423t-363 -139q-97 0 -175 24t-138 74l-100 -116h-167l184 214q-41 68 -62 159t-21 207q0 560 485 560q103 0 181 -23t135 -68l91 105h167l-173 -201q42 -69 61.5 -161.5t19.5 -211.5zM923 542q0 68 -6 122.5t-17 98.5l-483 -562 " is 238.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q38 -49 90.5 -68.5t114.5 -19.5q69 0 125 19.5t95 68.5t60 132t21 209zM334 542q0 -130 24 -215l482 561q-37 45 -89 63t-118 18q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205zM506 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 222.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M801 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M625 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M723 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" /> " is 140.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M443 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" /> " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M297 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" /> " is 193.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M535 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM427 1410q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M430 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" /> " is 211.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M492 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" /> " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM57 1086v33l69 292h207v-37l-201 -288h-75z"" /> " is 226.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1491 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1296 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM-69 1086v33l69 292h207v-37l-201 -288h-75z"" /> " is 180.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M775 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43zM-69 1086 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM141 1200v33l69 368h187v-37l-181 -364h-75zM-80 1231v172h150v-172h-150zM392 1231v172h150v-172h-150z"" /> " is 211.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" /> " is 185.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" /> " is 158.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M62 141l517 1268h217l510 -1268v-141h-1245zM1106 156l-338 862q-16 40 -30.5 81t-25.5 75.5t-18.5 58.5t-8.5 32q-2 -8 -9 -32.5t-18.5 -59.5t-25.5 -76t-30 -81l-339 -860h843z"" /> " is 175.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM502 794h587v-160h-587v160z"" /> " is 165.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1358 1h-201l-388 992q-17 47 -31.5 91.5t-26.5 79.5q-14 41 -26 78q-13 -39 -27 -80q-12 -35 -27 -79.5t-30 -89.5l-390 -992h-201l575 1409h198z"" /> " is 146.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" /> " is 141.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" /> " is 138.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" /> " is 209.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1518 736q0 -105 -32 -199t-97.5 -165.5t-164 -113.5t-231.5 -42h-83v-227h-185v227h-83q-133 0 -231.5 42t-164 113.5t-97.5 165.5t-32 199q0 113 33.5 205.5t100 158t167 101.5t235.5 36h72v182h185v-182h71q135 0 236 -36t167.5 -101.5t100 -158t33.5 -205.5z " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M1326 732q0 187 -92.5 277t-275.5 90h-48v-746h56q92 0 160 26.5t112.5 75.5t66 119t21.5 158zM309 732q0 -88 21.5 -158t66 -119t112.5 -75.5t160 -26.5h56v746h-52q-182 0 -273 -90t-91 -277z"" /> " is 185.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M763 0v427h-83q-133 0 -233.5 42t-167.5 113t-100.5 165.5t-33.5 198.5v463h191v-467q0 -80 23.5 -148.5t70 -118.5t116 -78.5t161.5 -28.5h56v841h185v-841h56q95 0 165 28.5t115.5 78.5t68 118.5t22.5 148.5v467h191v-463q0 -104 -34 -198.5t-101 -165.5t-167.5 -113 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M765 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M777 584v-584h-190l2 584l-544 825h205l434 -671l432 671h205zM802 1530v184h163v-184h-163zM408 1530v184h165v-184h-165z"" /> " is 124.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M843 237q-26 -56 -58.5 -103t-76 -81.5t-99 -53.5t-125.5 -19q-205 0 -301.5 138t-96.5 418q0 284 108.5 425t317.5 141q69 0 125 -19.5t99 -54t74.5 -81t51.5 -100.5h2q4 21 11 49t16.5 59.5t21 64t24.5 62.5h188q-22 -47 -45 -111t-42.5 -133.5t-34.5 -139t-20 -127.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q3 -103 14.5 -190.5t27 -159.5t33.5 -127t36 -94h-183q-11 28 -21.5 61t-18.5 65.5t-14.5 61.5t-9.5 49h-4zM275 542q0 -112 14 -192t43.5 -131.5t76 -75.5t112.5 -24q54 0 104 26t91 79.5t71.5 133.5t44.5 188q-12 86 -34.5 163t-58 134.5t-86.5 91.5t-121 34 " is 241.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M456 114q54 0 102 15.5t87.5 39.5t71 52t52.5 54l105 -100q-32 -39 -74 -74.5t-95 -62t-118 -42.5t-143 -16q-96 0 -166.5 23t-116.5 65t-68.5 100t-22.5 127q0 58 21 105.5t57 82t84 55.5t102 26v2q-51 6 -93.5 26t-73 52t-47.5 75t-17 94q0 62 25 115t72.5 91.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t115.5 60.5t155 22q118 0 213.5 -43t162.5 -142l-128 -88q-47 71 -109.5 105t-137.5 34q-91 0 -139 -42.5t-48 -116.5q0 -57 27.5 -92t76 -53.5t114 -24.5t140.5 -6v-135q-72 0 -141.5 -5.5t-124 -25.5t-87.5 -60t-33 -109q0 -45 14.5 -79.5t40.5 -57.5t63 -35t81 -12z " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M825 -424v1110q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 68 -11 128.5t-25 102.5h170q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM158 1218v33l69 292h207v-37l-201 -288h-75z"" /> " is 155.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t36 -123.5t26.5 -141.5t10.5 -149.5zM472 1200v33l69 368h187v-37l-181 -364h-75zM251 1231v172h150v-172h-150zM723 1231v172h150v-172h-150z"" /> " is 138.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M843 237q-26 -56 -58.5 -103t-76 -81.5t-99 -53.5t-125.5 -19q-205 0 -301.5 138t-96.5 418q0 284 108.5 425t317.5 141q69 0 125 -19.5t99 -54t74.5 -81t51.5 -100.5h2q4 21 11 49t16.5 59.5t21 64t24.5 62.5h188q-22 -47 -45 -111t-42.5 -133.5t-34.5 -139t-20 -127.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q3 -103 14.5 -190.5t27 -159.5t33.5 -127t36 -94h-183q-11 28 -21.5 61t-18.5 65.5t-14.5 61.5t-9.5 49h-4zM275 542q0 -112 14 -192t43.5 -131.5t76 -75.5t112.5 -24q54 0 104 26t91 79.5t71.5 133.5t44.5 188q-12 86 -34.5 163t-58 134.5t-86.5 91.5t-121 34 " is 241.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1097 405q0 -89 -26.5 -166t-82 -135t-142 -91t-206.5 -33q-102 0 -182 27.5t-136 66.5h-6q3 -57 4.5 -103t1.5 -99v-297h-180v1452q0 237 114 347t340 110q99 0 175 -23.5t127 -68.5t77.5 -110t26.5 -147q0 -73 -17.5 -128.5t-48 -96.5t-71 -69t-86.5 -46 " is 241.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q57 -11 114 -38.5t102.5 -74t73.5 -115t28 -162.5zM322 205q28 -19 63.5 -36t76 -29.5t84 -19.5t86.5 -7q72 0 127 20.5t91.5 58.5t55.5 91t19 119q0 65 -19 120t-59.5 95.5t-104.5 63t-153 22.5v142q127 27 183.5 96.5t56.5 191.5q0 44 -13.5 82.5t-42 67t-72 44.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M7 1082h192l245 -675q7 -22 17.5 -53.5t20.5 -65t18.5 -65t12.5 -53.5q5 21 14 52t19.5 64.5t21.5 65t19 53.5l239 677h191l-390 -1029q-17 -45 -32.5 -100.5t-29 -117.5t-25 -128t-18.5 -131h-191q17 131 41 237.5t48 197.5z"" /> " is 218.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M864 471q0 85 -24.5 157.5t-59 130t-72.5 100.5t-64 70q-73 -26 -140 -66.5t-118 -97.5t-81 -130t-30 -164q0 -76 17.5 -141.5t54 -113.5t92 -75.5t132.5 -27.5q81 0 137 27t90.5 74.5t50 113t15.5 143.5zM607 1352q-13 0 -34 1t-43.5 2.5t-43 2.5t-33.5 2l316 -324 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q54 -55 105 -113t90.5 -125t64 -146.5t24.5 -176.5q0 -110 -32 -201t-93.5 -156.5t-151.5 -101.5t-205 -36q-114 0 -204 34t-152.5 97.5t-95.5 155t-33 206.5q0 112 36.5 200t100 155.5t148 116t180.5 81.5l-319 339v119h733v-132h-358z"" /> " is 224.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M456 114q54 0 102 15.5t87.5 39.5t71 52t52.5 54l105 -100q-32 -39 -74 -74.5t-95 -62t-118 -42.5t-143 -16q-96 0 -166.5 23t-116.5 65t-68.5 100t-22.5 127q0 58 21 105.5t57 82t84 55.5t102 26v2q-51 6 -93.5 26t-73 52t-47.5 75t-17 94q0 62 25 115t72.5 91.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t115.5 60.5t155 22q118 0 213.5 -43t162.5 -142l-128 -88q-47 71 -109.5 105t-137.5 34q-91 0 -139 -42.5t-48 -116.5q0 -57 27.5 -92t76 -53.5t114 -24.5t140.5 -6v-135q-72 0 -141.5 -5.5t-124 -25.5t-87.5 -60t-33 -109q0 -45 14.5 -79.5t40.5 -57.5t63 -35t81 -12z"" /> " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M277 379q0 -64 21.5 -103.5t58.5 -64t87 -40t107 -30.5q54 -15 109.5 -32t100.5 -45.5t74 -72.5t29 -112q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56q9 12 18.5 28.5t17.5 35.5t13.5 38.5t5.5 38.5q0 34 -18 56.5t-51 39t-80 29t-104 25.5q-42 10 -86.5 21.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-85.5 29.5t-77.5 43t-63.5 62t-42.5 87t-15.5 117q0 83 24.5 171t67 176t99 175.5t120 170.5t131 160.5t131.5 145.5v4q-12 -1 -29 -1.5t-35 -1t-35 -1t-28 -0.5h-345v131h642v-127q-62 -70 -127.5 -148.5t-127 -161.5t-115.5 -169t-94.5 -171.5t-64 -168.5t-23.5 -159z " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M825 -424v1110q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 68 -11 128.5t-25 102.5h170q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1033 733q0 -381 -120 -567t-348 -186q-108 0 -193.5 46t-144.5 139t-90 234.5t-31 333.5q0 373 116.5 561.5t348.5 188.5q121 0 208.5 -46.5t143.5 -140.5t83 -234.5t27 -328.5zM563 113q62 0 112 26t86.5 90t57.5 172t24 272h-547q3 -164 25 -271.5t57.5 -172 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t82.5 -90.5t102 -26zM574 1354q-62 0 -111.5 -25.5t-85.5 -88.5t-57 -169t-24 -267h547q-3 161 -23 267t-54.5 169t-83 88.5t-108.5 25.5z"" /> " is 134.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M463 965l-36 99q-27 73 -48 125.5t-43.5 86t-51 49t-68.5 15.5q-11 0 -27 -3.5t-22 -6.5l-35 130q25 9 61 16.5t68 7.5q55 0 98.5 -18t80 -58.5t70 -106t69.5 -160.5l427 -1141h-190l-207 577q-8 22 -17 50t-18 57.5t-17 57.5t-13 49q-7 -21 -18 -51t-23.5 -61 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M862 0q-1 6 -2.5 29t-3 52.5l-3 59t-1.5 49.5h-4q-26 -51 -54 -90.5t-62.5 -66t-77.5 -40t-100 -13.5q-82 0 -142 32t-92 90h-4q3 -32 3.5 -63.5t0.5 -58.5v-373h-182v1475h182v-644q0 -69 12.5 -127t42 -100.5t78.5 -66t123 -23.5q67 0 117 26t83.5 71.5t50 108.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M946 846q0 -99 -31.5 -208t-84.5 -219.5t-123 -217.5t-147 -201h-170l-390 1082h189l311 -928q142 185 204 356t62 327q0 81 -14.5 140.5t-34.5 104.5h177q24 -45 38 -101.5t14 -134.5z"" /> " is 181.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M86 354q0 76 25.5 149.5t80.5 135.5t142.5 107t212.5 64v2q-68 5 -127 24.5t-102.5 53.5t-69 82t-25.5 110q0 64 25 110.5t64.5 78.5t88 52t95.5 30v8q-12 -1 -46 -2t-74 -2.5t-78 -2.5t-56 -1h-74v131h634v-125q-77 -9 -149 -26t-128 -46.5t-90 -74.5t-34 -112 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 30 -103.5t79.5 -65t114.5 -36.5t134 -18v-131q-100 -13 -187.5 -40t-153 -71.5t-103.5 -108t-38 -147.5q0 -64 21.5 -103.5t58.5 -64t87 -40t107 -30.5q54 -15 111 -32t104 -45.5t77.5 -72.5t30.5 -112q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q9 12 18.5 28.5t17.5 35.5t13.5 38.5t5.5 38.5q0 34 -19.5 56.5t-54.5 39t-83.5 29t-105.5 25.5q-42 10 -86.5 21.5t-85.5 29.5t-77.5 43t-63.5 62t-42.5 87t-15.5 117z"" /> " is 162.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1126 -20q-59 0 -100 14t-67 43.5t-38 76.5t-12 113v724h-402v-72q0 -131 -8 -256.5t-21.5 -239.5t-31.5 -211.5t-37 -171.5h-188q19 76 38.5 174.5t35.5 211.5t26 236.5t10 248.5v80q-39 0 -78.5 -3.5t-74 -8.5t-61 -11.5t-38.5 -13.5v139q12 6 33.5 11.5t47 9.5t52.5 6 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t50 2h1061v-131h-234v-685q0 -44 6.5 -72t18.5 -44t29.5 -22.5t39.5 -6.5q7 0 18.5 1t24 2t24 2.5t19.5 2.5v-129q-31 -8 -65.5 -14t-77.5 -6z"" /> " is 138.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1083 516q0 -118 -31.5 -216.5t-89 -169.5t-138 -110.5t-178.5 -39.5q-62 0 -111 10t-89 28.5t-73 45t-61 59.5h-4q2 -30 3 -60.5t1 -62.5v-425h-180v1006q0 119 30 215.5t88 164.5t142.5 105t194.5 37q103 0 193.5 -39.5t157.5 -114.5t106 -184.5t39 -248.5zM890 524 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 104 -22 187t-63.5 140.5t-99.5 88t-130 30.5q-69 0 -119 -26.5t-82 -77t-47 -123.5t-15 -166v-317q28 -35 64 -62.5t76 -46t83.5 -28.5t87.5 -10q67 0 117 29t83.5 82.5t50 129.5t16.5 170z"" /> " is 184.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M582 961q-54 0 -98 -24.5t-77.5 -64.5t-58 -92t-40.5 -106t-23.5 -107t-7.5 -95q0 -68 16 -116t54 -84t100 -64.5t154 -58.5q53 -17 110 -35.5t104.5 -48t78 -74t30.5 -112.5q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56q9 12 18.5 28.5t17.5 35.5t13.5 38.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t5.5 38.5q0 30 -17.5 52t-51.5 40t-82.5 33.5t-111.5 32.5q-66 18 -122.5 38t-103.5 45.5t-83 59.5t-61 80.5t-38 107.5t-13 142q0 47 10 112t33 135t60.5 138t92.5 122t129 87t171 33q68 0 117.5 -10.5t86 -27.5t63.5 -39t49 -45l-116 -119q-18 19 -39 37t-45.5 32 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1072 491q0 -112 -30.5 -206t-92 -161.5t-153 -105.5t-214.5 -38t-216 37t-155 106.5t-93.5 170.5t-31.5 230q0 144 43 249t119.5 174t183 102t232.5 33h569v-131h-165q-9 0 -26.5 0.5t-39 1.5t-43.5 2t-39 2v-4q28 -42 55.5 -91.5t49 -107t34.5 -123t13 -140.5zM883 488 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 74 -10 140t-27 124t-39.5 107.5t-47.5 91.5h-89q-83 0 -154.5 -25t-125 -77.5t-84 -132.5t-30.5 -190q0 -207 75.5 -310t222.5 -103q78 0 136.5 26t96.5 74.5t57 118t19 156.5z"" /> " is 172.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M281 951q-39 0 -78.5 -3.5t-74 -8.5t-61 -11.5t-38.5 -13.5v139q12 6 33.5 11.5t47 9.5t52.5 6t50 2h580v-131h-304v-685q0 -44 6.5 -72t18.5 -44t29.5 -22.5t39.5 -6.5q7 0 18.5 1t24 2t24 2.5t19.5 2.5v-129q-31 -8 -65.5 -14t-77.5 -6q-59 0 -100 14t-67 43.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1242 565q0 -151 -37 -258.5t-103 -177.5t-158 -105.5t-202 -41.5v-407h-170v407q-114 5 -204.5 41t-153 105t-96 172.5t-33.5 244.5q0 102 24.5 196t76 169t131 126.5t188.5 69.5l21 -136q-69 -15 -117 -53.5t-78 -95.5t-43.5 -128.5t-13.5 -151.5q0 -213 73.5 -313.5 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t224.5 -108.5v580q0 193 77 299t235 106q84 0 150.5 -38t112.5 -108.5t70.5 -170t24.5 -222.5zM1053 567q0 193 -43.5 298.5t-123.5 105.5q-68 0 -106 -64.5t-38 -204.5v-583q162 7 236.5 116t74.5 332z"" /> " is 193.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M542 239l-333 -663h-188l440 825l-170 343q-27 54 -49 95t-42 68.5t-41 41.5t-46 14q-11 0 -27 -3.5t-23 -6.5l-34 131q24 9 55 14.5t63 5.5q48 0 83 -13.5t65 -44.5t59.5 -82t65.5 -126l142 -295l264 539h187l-368 -697l406 -809h-190z"" /> " is 228.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M814 119q87 1 149 16.5t102 52t58.5 97t18.5 151.5v646h182v-644q0 -122 -29.5 -208t-91.5 -141t-158.5 -81.5t-230.5 -27.5v-405h-170v405q-134 1 -230 27.5t-158 81.5t-91.5 141t-29.5 208v644h181v-646q0 -90 19 -150.5t58.5 -97t101.5 -52.5t149 -17v1221h170v-1221z " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M883 449q0 -157 57 -243.5t159 -86.5q65 0 108.5 28t70 79t37.5 123.5t11 162.5q0 82 -14.5 157t-45 135.5t-79 102.5t-115.5 57l23 139q109 -18 188.5 -74t131 -136.5t76 -177.5t24.5 -198q0 -128 -26.5 -228t-77 -168.5t-124.5 -104.5t-169 -36q-68 0 -120 18t-90.5 52 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-64.5 83.5t-42 113.5h-4q-16 -64 -42 -113.5t-64.5 -83.5t-91 -52t-119.5 -18q-95 0 -169 36t-124.5 104.5t-77 168.5t-26.5 228q0 101 24.5 198t76 177.5t131 136.5t188.5 74l23 -139q-68 -15 -116 -57t-79 -102.5t-45 -135.5t-14 -157q0 -90 11 -162.5t37 -123.5t69 -79 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM343 1219v184h163v-184h-163zM-51 1219v184h165v-184h-165z"" /> " is 169.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM502 1218v33l69 292h207v-37l-201 -288h-75z"" /> " is 130.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M883 449q0 -157 57 -243.5t159 -86.5q65 0 108.5 28t70 79t37.5 123.5t11 162.5q0 82 -14.5 157t-45 135.5t-79 102.5t-115.5 57l23 139q109 -18 188.5 -74t131 -136.5t76 -177.5t24.5 -198q0 -128 -26.5 -228t-77 -168.5t-124.5 -104.5t-169 -36q-68 0 -120 18t-90.5 52 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-64.5 83.5t-42 113.5h-4q-16 -64 -42 -113.5t-64.5 -83.5t-91 -52t-119.5 -18q-95 0 -169 36t-124.5 104.5t-77 168.5t-26.5 228q0 101 24.5 198t76 177.5t131 136.5t188.5 74l23 -139q-68 -15 -116 -57t-79 -102.5t-45 -135.5t-14 -157q0 -90 11 -162.5t37 -123.5t69 -79 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM816 1530v184h163v-184h-163zM422 1530v184h165v-184h-165z"" /> " is 131.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M720 1253v-352q33 7 87.5 17t118 19.5t128.5 16t118 6.5q226 0 334.5 -93.5t108.5 -281.5v-214q0 -93 -20.5 -165.5t-63.5 -122.5t-109.5 -76.5t-158.5 -26.5q-53 0 -97 8.5t-81.5 24.5t-69.5 39t-61 51l111 123q18 -16 38.5 -32.5t44.5 -29.5t52 -21.5t61 -8.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q84 0 124 50.5t40 161.5v219q0 119 -64.5 180t-208.5 61q-51 0 -112.5 -5t-121.5 -12.5t-112.5 -16t-85.5 -16.5v-756h-190v1253h-484v156h1158v-156h-484z"" /> " is 150.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-111 0 -197.5 -34t-148.5 -97t-98.5 -152t-46.5 -199h654v-154h-654q9 -112 47.5 -204.5t102.5 -158.5t152 -102t197 -36q90 0 160.5 25t124.5 66t93.5 93.5t66.5 107.5l156 -77q-40 -79 -94 -147t-128 -118t-169.5 -78.5t-218.5 -28.5q-171 0 -299.5 54.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-215 152t-129.5 231.5t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" /> " is 157.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" /> " is 120.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" /> " is 190.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M2059 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1249h-416l-49 -368q-22 -172 -43.5 -305.5t-46 -233t-54.5 -168t-69 -111t-90 -61t-117 -18.5q-25 0 -48.5 2.5t-37.5 7.5v152q11 -4 28.5 -5.5t27.5 -1.5q30 0 56 11.5t48.5 42.5t43.5 84.5t40.5 138 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t39.5 203.5t41 280l67 510h770v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1867 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192z"" /> " is 156.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1963 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-545v653h-574v-653h-191v1409h191v-596h574v596h191v-596h342q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1771 411q0 121 -82 185.5t-246 64.5h-319v-510h327q164 0 242 68t78 192z"" /> " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1393 0v575q0 122 -64 176.5t-197 54.5q-53 0 -111 -5t-113 -12.5t-104 -16.5t-84 -16v-756h-190v1253h-484v156h1203v-156h-529v-352q36 8 85 18t105 19t115 15.5t115 6.5q229 0 336 -93.5t107 -271.5v-595h-190z"" /> " is 207.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 1409h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v1409zM500 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M841 1470l-330 278v29h207l217 -287v-20h-94zM1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" /> " is 184.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M734 318q-47 -88 -87.5 -152t-85.5 -105t-99.5 -61t-129.5 -20q-32 0 -65 5t-65 14t-61 22t-52 29l81 144q35 -22 76.5 -40.5t89.5 -18.5q37 0 66 10.5t55.5 36.5t55 71t66.5 113l49 89l-573 954h218l449 -784l384 784h205zM690 1530q-111 0 -181.5 28.5t-111 74 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" /> " is 122.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" /> " is 185.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h926v-156h-735v-440h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192z"" /> " is 210.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" /> " is 158.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1174 160h175v-568h-180v408h-974v-408h-180v568h144q41 51 74 120t60.5 159.5t49.5 204.5t40 255l67 510h724v-1249zM988 160v1089h-375l-49 -368q-18 -134 -38 -244.5t-43 -199.5t-50 -157.5t-59 -119.5h614z"" /> " is 204.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M850 645q-17 0 -39.5 3t-46.5 8.5t-47 12t-40 14.5l-427 -683h-222l509 775q-48 35 -179 224l-283 410h200l205 -305q66 -99 111 -160.5t83 -95.5t78.5 -46t97.5 -12v619h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M621 -20q-118 0 -206 25t-153 70.5t-112 109.5t-83 143l165 77q24 -55 57 -104t78.5 -86.5t106 -59.5t140.5 -22q77 0 138 18.5t103.5 53t65 84.5t22.5 114q0 133 -96 192t-298 59h-71v148h71q181 0 267.5 59.5t86.5 182.5q0 55 -19.5 98t-55.5 72.5t-88 44.5t-117 15 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-77 0 -134 -20t-98.5 -54t-69.5 -79t-47 -94l-178 61q33 82 81 145.5t114 107t150 66t189 22.5q108 0 194 -26.5t146 -74.5t92 -116t32 -151q0 -68 -20 -121.5t-56.5 -93.5t-88.5 -67.5t-115 -42.5q67 -10 125.5 -35t102 -66t69 -98.5t25.5 -130.5q0 -95 -34.5 -173 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h172v-924q0 -51 -1 -100t-3 -88q-2 -46 -4 -86l750 1198h222v-1409h-170v936q0 39 0.5 83.5t2.5 82.5q1 44 3 88l-742 -1190h-230z"" /> " is 142.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 0v1409h172v-924q0 -51 -1 -100t-3 -88q-2 -46 -4 -86l750 1198h222v-1409h-170v936q0 39 0.5 83.5t2.5 82.5q1 44 3 88l-742 -1190h-230zM742 1530q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164 " is 238.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M168 1409h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v1409z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M991 1249h-418l-49 -368q-22 -172 -43.5 -305.5t-46 -233t-54.5 -168t-69 -111t-90 -61t-117 -18.5q-25 0 -48.5 2.5t-37.5 7.5v152q11 -4 28.5 -5.5t27.5 -1.5q30 0 56 11.5t48.5 42.5t43.5 84.5t40.5 138t39.5 203.5t41 280l67 510h767v-1409h-186v1249z"" /> " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" /> " is 138.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" /> " is 209.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" /> " is 135.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M734 318q-47 -88 -87.5 -152t-85.5 -105t-99.5 -61t-129.5 -20q-32 0 -65 5t-65 14t-61 22t-52 29l81 144q35 -22 76.5 -40.5t89.5 -18.5q37 0 66 10.5t55.5 36.5t55 71t66.5 113l49 89l-573 954h218l449 -784l384 784h205z"" /> " is 216.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1439 736q0 -105 -32 -199t-97.5 -165.5t-164 -113.5t-231.5 -42h-40v-227h-191v227h-40q-133 0 -231.5 42t-164 113.5t-97.5 165.5t-32 199q0 113 33.5 205.5t100 158t167 101.5t235.5 36h29v182h191v-182h28q135 0 236 -36t167.5 -101.5t100 -158t33.5 -205.5z " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M1247 732q0 187 -92.5 277t-275.5 90h-5v-746h13q92 0 160 26.5t112.5 75.5t66 119t21.5 158zM310 732q0 -88 21.5 -158t66 -119t112.5 -75.5t160 -26.5h13v746h-9q-182 0 -273 -90t-91 -277z"" /> " is 183.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1008 508q-36 -8 -83 -18t-100.5 -19t-111 -15t-113.5 -6q-114 0 -197 23.5t-137 69.5t-80 114.5t-26 157.5v594h190v-574q0 -123 65 -177t199 -54q53 0 108 5t107 12.5t98 16t81 15.5v756h190v-1409h-190v508z"" /> " is 204.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M696 813h322q125 0 218 -29t155 -81.5t93 -126t31 -163.5q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-525v1253h-459v156h650v-596zM1323 411q0 121 -82 185.5t-246 64.5h-299v-510h307q164 0 242 68t78 192z"" /> " is 208.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h191v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192zM1454 0v1409h191v-1409h-191z"" /> " is 228.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h191v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 407q0 121 -82 186.5t-246 65.5h-359v-508h367q165 0 242.5 65.5t77.5 190.5z"" /> " is 208.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M713 1274q-88 0 -156.5 -21t-119.5 -56t-85.5 -80.5t-53.5 -95.5l-181 60q71 173 222 261t376 88q164 0 292 -50.5t215.5 -144t133 -226.5t45.5 -298q0 -159 -43 -293t-129 -231.5t-214.5 -152t-299.5 -54.5q-118 0 -212.5 27t-169 76.5t-131 117.5t-97.5 151l156 78 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q27 -55 67.5 -107.5t95 -94t124.5 -66.5t157 -25q109 0 197 36t152 102t102.5 158.5t47.5 204.5h-654v154h654q-10 110 -46.5 199t-98.5 152t-148.5 97t-197.5 34z"" /> " is 157.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1971 711q0 -165 -45 -300t-130 -231t-207.5 -148t-277.5 -52q-156 0 -275.5 49.5t-202 139t-127.5 213t-52 271.5h-295v-653h-191v1409h191v-596h298q13 142 62.5 256.5t132.5 194.5t199 123t262 43q159 0 281.5 -51t206 -145t127 -227t43.5 -296zM1776 711 " is 243.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 127 -30 231t-88.5 178t-145 114t-199.5 40q-116 0 -203.5 -40t-146 -114t-87.5 -178t-29 -231t30 -232.5t88.5 -182t145 -119t200.5 -42.5q121 0 209 43t145 119.5t84 182.5t27 231z"" /> " is 177.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M96 0l400 607q-91 16 -156 55t-107 93t-61.5 119t-19.5 132q0 94 33 169t96 127t155.5 79.5t212.5 27.5h663v-1409h-191v585h-439l-366 -585h-220zM344 1004q0 -57 18.5 -106t57 -85t98 -56.5t142.5 -20.5h461v520h-453q-76 0 -136 -15.5t-102 -47t-64 -78.5t-22 -111z " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4 " is 236.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M898 502q0 114 -19.5 189.5t-56 121t-88.5 64t-117 18.5q-69 0 -126 -19.5t-97.5 -65.5t-62.5 -121t-22 -187q0 -114 22 -189t60.5 -119.5t91 -62.5t114.5 -18q69 0 125 18t95 62t60 119.5t21 189.5zM655 1027q222 0 327 -130.5t105 -392.5q0 -265 -125 -394.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-363 -129.5q-113 0 -202 35t-150.5 113t-94 203t-32.5 305q0 192 29 331t93 235.5t167 154t250 85.5q57 11 107 19.5t95.5 15.5t88.5 13l86 12v-161q-86 -11 -166.5 -22.5t-171.5 -28.5q-78 -14 -140 -30.5t-109 -41.5t-80.5 -61.5t-55.5 -90.5t-33.5 -128.5t-13.5 -175.5 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M564 1082q76 0 148 -12t128 -43t90 -83t34 -133q0 -53 -17.5 -93.5t-47.5 -69.5t-71 -47.5t-87 -27.5v-7q54 -7 101.5 -24.5t82 -48t54.5 -75.5t20 -106q0 -78 -30.5 -136.5t-85 -97.5t-130 -58.5t-166.5 -19.5h-445v1082h422zM322 133h236q69 0 116.5 10t77 32t43 55.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t13.5 80.5q0 50 -14 85t-45.5 57t-81.5 32t-121 10h-224v-362zM322 945v-320h216q68 0 113.5 9.5t73 29t39 50t11.5 73.5q0 82 -51 120t-172 38h-230z"" /> " is 145.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M834 951h-306q-24 -177 -48.5 -308.5t-48.5 -228.5t-48 -165t-46 -118h497v820zM1160 -408h-163v408h-814v-408h-163v539h119q30 50 59 121.5t58 181.5t57.5 267.5t56.5 380.5h644v-951h146v-539z"" /> " is 191.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M595 477q-26 0 -58.5 6t-51.5 14l-278 -497h-200l353 592q-17 14 -50 56.5t-78 108.5l-216 325h188l148 -239q48 -77 80.5 -123t58.5 -71t50 -33t54 -8v474h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M458 -20q-167 0 -265.5 62.5t-143.5 191.5l159 44q25 -78 88 -121t166 -43q96 0 152.5 47t56.5 138q0 59 -27.5 98t-73.5 61.5t-106 31.5t-124 9v137q64 0 121 7.5t100 26.5t67.5 52.5t24.5 85.5q0 74 -49.5 117t-142.5 43q-35 0 -70 -7t-65 -23.5t-51 -44t-28 -69.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l-162 20q12 68 43 117t79.5 80.5t112.5 46t142 14.5q85 0 154 -21t118 -59t75.5 -90t26.5 -115q0 -57 -22 -101t-57.5 -74.5t-79.5 -48.5t-89 -22v-2q56 -6 106 -26.5t87.5 -54t59 -80t21.5 -104.5q0 -69 -24.5 -128.5t-75 -103t-126.5 -68t-178 -24.5z"" /> " is 239.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174z"" /> " is 154.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174zM574 1200q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M138 1082h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v1082z"" /> " is 176.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M872 0v951h-375q-25 -184 -46 -327.5t-43 -251.5t-47.5 -182.5t-61 -121t-82.5 -67.5t-112 -21q-29 0 -53 4t-41 9v129q11 -4 30 -6.5t38 -2.5q35 0 60.5 21t45.5 68t36.5 121.5t33.5 182.5t36 250.5t44 325.5h718v-1082h-181z"" /> " is 219.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M787 0h-153l-324 951q1 -26 2.5 -56t2 -60.5t1 -59t0.5 -51.5v-724h-174v1082h280l220 -661q23 -63 41.5 -138.5t26.5 -147.5q10 72 27.5 147.5t40.5 138.5l220 661h269v-1082h-173v724q0 22 0.5 52t2 62t2.5 62t3 53z"" /> " is 211.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1053 546q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40t1 -53.5t0.5 -58.5v-423h-180v1286q0 39 -0.5 75t-1.5 65.5t-2 50.5t-2 30h174q1 -3 2.5 -21t3 -43.5t3 -54.5t1.5 -55h4q25 52 57 88.5t73 60t91.5 34 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" /> " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183z"" /> " is 136.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1598 546q0 -123 -19 -227t-62 -179t-113 -117.5t-171 -42.5q-105 0 -184 44t-121 144h-6q2 -35 3.5 -73.5t1.5 -96.5v-423h-170v423q0 54 1 95t4 81h-5q-46 -104 -120.5 -149t-185.5 -45q-186 0 -275.5 137.5t-89.5 418.5q0 284 92.5 425t272.5 141q112 0 186.5 -45 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t119.5 -143h5q0 10 -1 30.5t-2 43.5t-1.5 44t-0.5 33v419h170v-420q0 -11 -0.5 -32.5t-1 -45t-1 -45t-0.5 -33.5h5q46 104 118 148.5t186 44.5q101 0 171 -40t113 -112.5t62 -175t19 -227.5zM275 542q0 -112 13 -192t41 -131.5t70.5 -75.5t102.5 -24t107 21.5t79.5 70.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t49.5 127.5t19 191.5v24q0 115 -17 194.5t-49 128.5t-79 70.5t-108 21.5q-57 0 -100 -23t-71.5 -74t-43 -132.5t-14.5 -197.5zM1409 542q0 100 -11.5 178t-37.5 132t-70 82t-108 28q-53 0 -99 -17t-81 -65t-55 -132.5t-20 -219.5v-23q1 -108 18.5 -183t50 -121.5t78.5 -67 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M302 1082v-402q0 -34 8 -63.5t27.5 -51.5t51.5 -34.5t79 -12.5q70 0 136 13t140 34v517h180v-1082h-180v461q-38 -15 -78.5 -30.5t-84 -27.5t-90 -20t-97.5 -8q-66 0 -116.5 20.5t-85 58.5t-52.5 93t-18 124v411h180z"" /> " is 210.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M781 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-409v951h-328v131h508v-458h228zM553 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372z"" /> " is 208.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M550 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-409v1082h180v-458h228zM322 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372zM1150 0v1082h180v-1082h-180z"" /> " is 228.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M568 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-427v1082h180v-458h246zM322 127h220q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-221v-372z"" /> " is 200.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M55 315l182 12q16 -108 82.5 -160t166.5 -52q73 0 124.5 26.5t85.5 75t51 116t22 149.5h-413v131h413q-4 90 -21 156.5t-50.5 110.5t-85 66t-124.5 22q-109 0 -168 -52.5t-74 -143.5l-185 14q13 68 46 126t85.5 100t125 66t165.5 24q90 0 175 -26.5t152 -90.5t107.5 -172 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1450 542q0 -284 -117.5 -423t-340.5 -139q-102 0 -182.5 31t-138 95t-90 160t-37.5 227h-222v-493h-180v1082h180v-458h223q33 478 453 478q237 0 344.5 -140t107.5 -420zM1261 542q0 126 -17.5 208t-51 131t-82 68.5t-109.5 19.5q-63 0 -112.5 -20.5t-84.5 -70 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M535 458l-315 -458h-203l344 471q-131 27 -190 108.5t-59 203.5q0 149 108 224t315 75h432v-1082h-180v458h-252zM787 955h-234q-130 0 -190 -46t-60 -139q0 -94 53.5 -140.5t177.5 -46.5h253v372z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M592 1218l-330 278v29h207l217 -287v-20h-94zM276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" /> " is 164.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM687 1219v184h163v-184h-163zM293 1219v184h165v-184h-165z"" /> " is 174.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M142 0v1206h-132v131h132v147h180v-147h300v-131h-300v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-815q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38 31.5t18.5 55t5 79.5v753q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180z"" /> " is 187.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M564 -20q-130 0 -221 43t-148 118.5t-82.5 178t-25.5 222.5q0 163 40.5 271t107.5 172t152 90.5t175 26.5q93 0 165.5 -24t125 -66t85.5 -100t46 -126l-185 -14q-15 91 -74 143.5t-168 52.5q-73 0 -124.5 -22t-85 -66t-50.5 -110.5t-21 -156.5h412v-131h-413 " is 243.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q4 -82 21.5 -149.5t51.5 -116t85.5 -75t125.5 -26.5q100 0 166.5 51.5t82.5 160.5l182 -12q-9 -67 -39.5 -128t-83.5 -107t-128.5 -73t-174.5 -27z"" /> " is 142.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M137 1312v172h180v-172h-180zM317 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" /> " is 194.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1357 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-450v951h-411q-25 -184 -46 -327.5t-43 -251.5t-47.5 -182.5t-61 -121t-82.5 -67.5t-112 -21q-29 0 -53 4t-41 9v129q11 -4 30 -6.5t38 -2.5q35 0 60.5 21t45.5 68t36.5 121.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t33.5 182.5t36 250.5t44 325.5h754v-458h268zM1089 127h242q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-243v-372z"" /> " is 135.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M937 1082v-458h228q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-410v493h-434v-493h-180v1082h180v-458h434v458h181zM937 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372z"" /> " is 237.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M317 857q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-681h-181v646q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180v1206h-132v131h132v147h180v-147h300v-131h-300 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M138 1082h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v1082zM391 1201v20l217 287h207v-29l-330 -278h-94z"" /> " is 219.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M588 1201l-330 278v29h207l217 -287v-20h-94zM316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174z"" /> " is 197.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM523 1200 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" /> " is 149.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM993 1530l-310 217v29h207l217 -226v-20h-114z"" /> " is 169.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM831 1530v20l217 226h207v-29l-310 -217h-114z"" /> " is 169.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM1085 1530v184h163v-184h-163zM691 1530v184h165v-184h-165z"" /> " is 182.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM856 1219v184h163v-184h-163zM462 1219v184h165v-184h-165z"" /> " is 123.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM541 1201 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M407 952v146q0 52 5 95t14.5 80.5t24 70.5t34.5 65h122q-45 -65 -69.5 -131t-24.5 -131h88v-195h-194zM75 952v146q0 52 5 95t15 80.5t25 70.5t35 65h121q-45 -65 -70 -131t-25 -131h89v-195h-195z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M607 1264q0 -53 -5 -96t-14.5 -80.5t-24.5 -70.5t-35 -65h-121q45 65 69.5 131t24.5 131h-88v195h194v-145zM276 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-145z"" /> " is 215.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M607 51q0 -53 -5 -96.5t-14.5 -81t-24.5 -70.5t-35 -65h-121q45 65 69.5 131t24.5 131h-88v195h194v-144zM276 51q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-144z"" /> " is 211.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M497 1000l-360 -27v164l360 -29l-16 376h175l-16 -376l361 29v-164l-361 27l-26 -330l26 -327l360 27v-164l-360 29l16 -376h-175l16 376l-361 -29v164l361 -27l26 327z"" /> " is 166.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M636 682q0 -58 -22.5 -109t-60.5 -89.5t-89 -60.5t-109 -22q-57 0 -106.5 22t-87 60.5t-59 89.5t-21.5 109q0 57 21.5 107t59 87t87 58.5t106.5 21.5q58 0 109 -21.5t89 -58.5t60.5 -87t22.5 -107z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M304 0h-155l922 1409h157zM356 1421q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM502 1060q0 73 -9.5 122t-28 78t-46 41 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5zM1044 716q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM1190 355q0 73 -9.5 122t-28 78t-46 41t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5zM1699 716 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM1845 355q0 73 -9.5 122t-28 78t-46 41t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M514 519v398q0 46 -6.5 76.5t-21 49t-38 26.5t-58.5 8q-72 0 -114.5 -50t-42.5 -144v-364h-128v511q0 20 -0.5 43t-1 43t-1.5 34.5t-1 18.5h119q0 -3 1 -16.5t2 -30.5t2 -34.5t1 -29.5h2q15 28 34 51t43.5 39t56.5 24.5t74 8.5q110 0 158.5 -54t48.5 -175v-433h-129z"" /> " is 256.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1104 311q-9 -80 -37.5 -138.5t-73 -97t-102 -57t-124.5 -18.5h-698v154q89 46 132 126t43 201v25h-186v129h186v140h-186v129h186v130q0 92 24 165.5t73.5 124.5t125.5 78.5t179 27.5q70 0 131.5 -14.5t111 -43.5t85 -72t53.5 -100l-174 -57q-10 31 -29.5 57t-46 44 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-59 28t-68.5 10q-114 0 -170 -57.5t-56 -182.5v-138h408v-129h-408v-140h408v-129h-408v-7q0 -56 -11 -109t-33 -99t-53.5 -81.5t-71.5 -56.5h483q38 0 71.5 9.5t60 30.5t45 54.5t26.5 81.5z"" /> " is 183.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M954 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-130v-549h-181v1409h299q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM772 983q0 134 -82 203.5t-246 69.5h-105v-556h113q165 0 242.5 73t77.5 210zM1407 8q-35 -11 -72 -17.5t-85 -6.5q-105 0 -151.5 61.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-46.5 183.5v453h-104v131h111l53 242h110v-242h157v-131h-157v-414q0 -78 20.5 -114.5t75.5 -36.5q23 0 43 4t46 10v-123zM2151 229q0 -120 -91.5 -184.5t-261.5 -64.5q-75 0 -135.5 12t-106.5 39t-76.5 71t-45.5 108l159 26q17 -61 66.5 -90t137.5 -29q40 0 74 5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t58.5 17.5t38 32.5t13.5 50t-17 50.5t-48 35t-74.5 26t-95.5 24.5q-49 12 -97 28t-86.5 42.5t-62 66t-23.5 98.5q0 112 84 171.5t245 59.5q141 0 223.5 -52.5t104.5 -168.5l-161 -17q-6 28 -21.5 47t-38 31t-49.5 17t-57 5q-155 0 -155 -85q0 -25 16 -43t44.5 -32t68.5 -25 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M691 126q100 0 160 50t74 141l185 -14q-13 -68 -44.5 -127t-83 -102.5t-125 -68.5t-170.5 -25q-120 0 -208.5 38.5t-149 108t-95 165.5t-47.5 210h-171l40 129h120q-1 8 -2 31t-1 47q0 27 1 53.5t2 32.5h-160l40 127h129q15 122 51.5 216.5t98 159.5t148 98.5t201.5 33.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q97 0 170.5 -25t125 -68.5t83 -102.5t44.5 -127l-185 -14q-14 91 -74.5 141t-166.5 50q-68 0 -121 -19.5t-92.5 -63t-64.5 -112t-36 -167.5h446l-40 -127h-413q-2 -16 -2.5 -39.5t-0.5 -46.5q0 -22 1 -40.5t3 -37.5h452l-40 -129h-404q9 -81 30 -150t59.5 -119t95.5 -78.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1744 434q0 -125 -25.5 -210.5t-69 -138t-101.5 -75t-124 -22.5t-123.5 22.5t-100 74.5t-67 137.5t-24.5 211.5q0 133 24 220t67 138.5t101.5 72t126.5 20.5q66 0 123.5 -20.5t100 -72t67.5 -138.5t25 -220zM523 0h-155l922 1409h157zM1596 434q0 99 -11 164.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-32.5 104.5t-53 55t-71.5 16q-42 0 -74 -16.5t-54 -55.5t-33 -104.5t-11 -163.5q0 -95 11.5 -159t33 -103.5t53 -56.5t72.5 -17q39 0 70.5 17t53.5 56.5t34 103.5t12 159zM215 975q0 -75 10 -137t33.5 -107t61 -70t91.5 -25q69 0 116 41t58 128l141 -9q-6 -54 -28.5 -103.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-61 -87.5t-94 -60.5t-127.5 -22.5q-94 0 -160 34.5t-107 95t-60 142.5t-19 178q0 130 29.5 216.5t78 138t110.5 72.5t127 21q68 0 121 -20t91 -55t62 -82t33 -102l-143 -11q-10 72 -51.5 114.5t-116.5 42.5q-108 0 -151.5 -82t-43.5 -250z"" /> " is 227.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M433 78q51 0 85 52t51 161h69q-20 -154 -80 -232.5t-169 -78.5q-111 0 -174.5 79.5t-63.5 234.5v175q-32 -17 -65 -31t-67 -27v73q35 14 68 28.5t64 30.5v587q0 59 12.5 113t42 95.5t78.5 66t121 24.5q52 0 91.5 -21t66 -60t40 -94.5t13.5 -124.5q0 -99 -22 -189 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-61.5 -166t-94.5 -135t-121 -97v-244q0 -57 9.5 -98.5t25.5 -68.5t37 -40t44 -13zM525 1122q0 52 -7 94.5t-20.5 73t-33.5 47t-46 16.5q-32 0 -51.5 -18t-30.5 -48.5t-15 -71t-4 -86.5v-507q49 33 87.5 85t65.5 117.5t41 141t14 156.5z"" /> " is 224.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1062 0l-720 1190q1 -44 3 -88q1 -38 2 -82.5t1 -83.5v-936h-160v1409h202l728 -1198q-2 40 -4 86q-2 39 -3 88t-1 100v924h162v-1409h-210zM2094 690q0 -188 -88 -289.5t-263 -101.5q-168 0 -256.5 100.5t-88.5 290.5q0 91 21.5 163.5t65 123t109 77t153.5 26.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q93 0 158.5 -26.5t107.5 -76.5t61.5 -122.5t19.5 -164.5zM1935 690q0 81 -12 134.5t-35.5 85.5t-58 45t-79.5 13q-46 0 -81.5 -13.5t-59.5 -45.5t-36.5 -85.5t-12.5 -133.5q0 -82 13 -136t37 -85.5t57.5 -44.5t74.5 -13q46 0 82 13t61 44.5t37.5 85.5t12.5 136zM1439 0v146 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1691 634v425v194q-5 -11 -9 -22q-4 -9 -6.5 -18t-4.5 -14l-230 -565h-108l-163 413q-2 5 -14 37t-26 70q-17 44 -37 99q-1 -10 -1 -20q-1 -8 -1 -17v-15v-567h-128v775h190l223 -563q2 -4 4.5 -10.5t4.5 -13.5l6 -18q20 51 36 92q7 18 13.5 35t12 31t9 23t3.5 11 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M786 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43z"" /> " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M619 -34q-130 0 -229 46.5t-166 125t-101.5 180.5t-34.5 213q0 147 47.5 253.5t123.5 176t170.5 102.5t189.5 33q112 0 209 -39.5t168 -112.5t111.5 -178t40.5 -235h-827v-356q22 -24 54 -46.5t71 -40t83 -27.5t90 -10q75 0 133 15.5t104.5 45.5t84.5 73.5t73 99.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "l72 -42q-36 -57 -78 -107t-96.5 -88t-126 -60t-166.5 -22zM917 616v277q-19 20 -48.5 41t-68 38t-84.5 28t-99 11q-51 0 -94.5 -9.5t-80.5 -25.5t-67 -37t-54 -45v-278h596z"" /> " is 166.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M80 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM676 795 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5t-108 34.5 " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM676 835 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 -65 -19 -117t-55.5 -89t-90.5 -57t-124 -20q-66 0 -116.5 16.5t-87.5 46t-59 70t-31 88.5l133 15q5 -27 17 -50.5t31.5 -41.5t46.5 -28.5t63 -10.5q71 0 114 42.5t43 135.5q0 81 -40.5 123.5t-115.5 42.5q-51 0 -89.5 -18.5t-61.5 -41.5h-129l33 468h506v-113h-398 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M433 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM734 1308 " is 243.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-64 -97 -117 -185t-91.5 -176t-60 -181.5t-21.5 -201.5h-133q0 102 23.5 196t63.5 183.5t93.5 177t113.5 175.5h-460v113h589v-101z"" /> " is 129.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h989v-86h-989z"" /> " is 141.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-989h-86v989z"" /> " is 141.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1407 637q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-989v86h989z"" /> " is 142.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M555 162q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v989h86v-989z"" /> " is 141.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h766q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-766z"" /> " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v766z"" /> " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M272 -104h480v-80h-480v80zM469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M954 938q0 -46 -3.5 -98t-10 -105t-15.5 -106t-20 -101q-31 -128 -79 -231t-113 -175t-146 -110.5t-178 -38.5q-93 0 -156.5 31.5t-102.5 85t-56.5 122.5t-17.5 144q0 60 11 131.5t34.5 143.5t60 139t87.5 119t117 83.5t149 31.5q42 0 80.5 -13t70.5 -37t57 -57.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t41 -75.5h4q1 25 2.5 54t1.5 63q0 196 -65 300.5t-194 104.5q-28 0 -57.5 -5.5t-58.5 -15t-56.5 -23.5t-49.5 -31l36 147q42 23 100 42.5t125 19.5q113 0 190 -44t124 -118.5t67.5 -172t20.5 -204.5zM743 680q-8 42 -26 79t-43.5 64.5t-57.5 43.5t-68 16q-53 0 -96 -25.5 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-76.5 -67.5t-58 -97t-40.5 -113t-23.5 -116t-7.5 -106q0 -53 10.5 -98.5t31.5 -79t53.5 -52.5t76.5 -19q66 0 120 49.5t95.5 130t69.5 183t40 208.5z"" /> " is 145.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M5 141l517 1268h217l510 -1268v-141h-1245zM1049 156l-338 862q-16 40 -30.5 81t-25.5 75.5t-18.5 58.5t-8.5 32q-2 -8 -9 -32.5t-18.5 -59.5t-25.5 -76t-30 -81l-339 -860h843z"" /> " is 174.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1373 590q0 -78 -22 -148.5t-63 -123.5t-98.5 -84t-127.5 -31q-97 0 -181 66.5t-154 215.5q-32 -63 -69.5 -114t-79.5 -87t-87 -55.5t-91 -19.5q-69 0 -126.5 27.5t-99 77.5t-64.5 121.5t-23 160.5q0 81 22 152t63 123t99 82t129 30q94 0 178 -67.5t151 -215.5 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q31 62 68.5 113t79.5 87.5t89 56.5t98 20q69 0 126 -27.5t97.5 -78t63 -122t22.5 -159.5zM1040 846q-70 0 -129.5 -63t-115.5 -193q51 -128 110.5 -192t136.5 -64q43 0 78.5 20t61 55t39 82t13.5 101t-14.5 100t-40 80.5t-61 54t-78.5 19.5zM664 596q-51 128 -110.5 192 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-137.5 64q-43 0 -78 -20t-59.5 -55t-38 -82t-13.5 -101q0 -51 12.5 -97.5t36.5 -81t59.5 -55t82.5 -20.5q70 0 130 63t116 193z"" /> " is 125.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M278 -2v512q0 116 34 212t95 165t144.5 107t181.5 38q99 0 183.5 -38t146 -107t96.5 -165t35 -212v-512h-103v514q0 98 -26.5 175.5t-74 131.5t-112.5 82.5t-143 28.5t-143 -28t-112 -82t-73 -132t-26 -178v-512h-103z"" /> " is 211.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M36 -434q-36 0 -73.5 5.5t-60.5 13.5v147q20 -8 51 -16t66 -8q51 0 84 18.5t52.5 50.5t27.5 74t8 90l-2 1212q0 94 25 161t70 110t107.5 63t137.5 20q34 0 71.5 -4.5t59.5 -13.5v-148q-18 10 -48.5 18.5t-66.5 8.5q-51 0 -84 -20t-52.5 -52.5t-27.5 -74.5t-8 -86v-1214 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M808 758q-69 0 -141.5 21.5t-145.5 47.5q-65 22 -118.5 33.5t-98.5 11.5q-38 0 -70.5 -6t-62.5 -17t-58 -27.5t-57 -37.5v144q50 37 116 60.5t147 23.5q40 0 80 -6.5t78.5 -17t76 -24t74.5 -26.5q21 -8 46 -15.5t50.5 -14.5t51 -11t48.5 -4q69 0 130.5 25.5t113.5 68.5 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-149q-32 -23 -61.5 -38t-60 -24.5t-64.5 -13.5t-74 -4zM808 336q-69 0 -141.5 22t-145.5 48q-65 23 -118.5 35t-98.5 12q-38 0 -70.5 -6t-62.5 -17.5t-58 -27.5t-57 -37v141q50 38 116 61t147 23q40 0 80 -6.5t78.5 -16.5t76 -23t74.5 -26q21 -8 46 -15.5t50.5 -14.5 " is 248.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M448 344l-152 -289h-145l151 289h-237v148h311l190 364h-501v148h573l154 292h143l-152 -292h277v-148h-350l-191 -364h541v-148h-612z"" /> " is 135.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M693 -614h-147v1878q0 196 84 319q82 123 210 123q63 0 100.5 -31.5t37.5 -79.5q0 -40 -25.5 -66t-62.5 -26q-30 0 -43 10q-8 4 -21 16t-33 34q-33 39 -49 39q-36 0 -45 -39q-6 -35 -6 -140v-2037z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M546 1706h147v-1880q0 -205 -90 -330q-40 -56 -91.5 -83t-113.5 -27q-30 0 -55 8t-43.5 22.5t-28.5 34t-10 43.5q0 20 7 37t18.5 29t27 19t33.5 7q33 0 59 -16q5 -2 15.5 -13.5t25.5 -31.5q31 -37 47 -37q37 0 45 41q7 31 7 137v2040z"" /> " is 226.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M833 1864h145v-990h483v-145h-628v1135zM618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM473 1864h145v-1135h-628v145h483v990z"" /> " is 160.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM933 1314h103v-98h-103v98zM310 1119h104v-96h-104v96zM725 1119h104v-96h-104v96zM1140 1119h104v-96h-104v96zM933 927h103v-96h-103v96zM517 927h104v-96h-104v96zM103 927h104v-96h-104v96zM1140 732h104v-96 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v96zM725 732h104v-96h-104v96zM310 732h104v-96h-104v96zM103 540h104v-96h-104v96zM517 540h104v-96h-104v96zM933 540h103v-96h-103v96zM1140 345h104v-96h-104v96zM725 345h104v-96h-104v96zM310 345h104v-96h-104v96zM103 153h104v-97h-104v97zM517 153h104v-97 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v97zM933 153h103v-97h-103v97zM310 -42h104v-94h-104v94zM725 -42h104v-94h-104v94zM1140 -42h104v-94h-104v94zM933 -234h103v-97h-103v97zM517 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM310 -427h104v-96h-104v96zM725 -427h104v-96h-104v96zM1140 -427h104 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-96h-104v96zM310 1506h104v-98h-104v98zM725 1506h104v-98h-104v98zM1140 1506h104v-98h-104v98zM103 1699h104v-96h-104v96zM517 1699h104v-96h-104v96zM933 1699h103v-96h-103v96zM1347 1314h104v-98h-104v98zM1347 927h104v-96h-104v96zM1347 540h104v-96h-104v96z " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M103 1314h104v-98h-104v98zM310 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM725 1314h104v-98h-104v98zM933 1314h104v-98h-104v98zM1140 1314h104v-98h-104v98zM0 1119h103v-96h-103v96zM207 1119h103v-96h-103v96zM414 1119h103v-96h-103v96zM621 1119h104v-96 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v96zM829 1119h104v-96h-104v96zM1037 1119h103v-96h-103v96zM103 927h104v-96h-104v96zM310 927h104v-96h-104v96zM517 927h104v-96h-104v96zM725 927h104v-96h-104v96zM933 927h104v-96h-104v96zM1140 927h104v-96h-104v96zM0 732h103v-96h-103v96zM207 732h103v-96 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-103v96zM414 732h103v-96h-103v96zM621 732h104v-96h-104v96zM829 732h104v-96h-104v96zM1037 732h103v-96h-103v96zM103 540h104v-96h-104v96zM310 540h104v-96h-104v96zM517 540h104v-96h-104v96zM725 540h104v-96h-104v96zM933 540h104v-96h-104v96zM1140 540h104v-96 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v96zM0 345h103v-96h-103v96zM414 345h103v-96h-103v96zM621 345h104v-96h-104v96zM829 345h104v-96h-104v96zM1037 345h103v-96h-103v96zM207 345h103v-96h-103v96zM1140 153h104v-97h-104v97zM933 153h104v-97h-104v97zM725 153h104v-97h-104v97zM517 153h104v-97 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v97zM310 153h104v-97h-104v97zM103 153h104v-97h-104v97zM0 -42h103v-94h-103v94zM207 -42h103v-94h-103v94zM414 -42h103v-94h-103v94zM621 -42h104v-94h-104v94zM829 -42h104v-94h-104v94zM1037 -42h103v-94h-103v94zM1140 -234h104v-97h-104v97zM933 -234h104v-97 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v97zM725 -234h104v-97h-104v97zM517 -234h104v-97h-104v97zM310 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM0 -427h103v-96h-103v96zM207 -427h103v-96h-103v96zM414 -427h103v-96h-103v96zM621 -427h104v-96h-104v96zM829 -427h104v-96h-104v96zM1037 -427 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h103v-96h-103v96zM0 1506h103v-98h-103v98zM207 1506h103v-98h-103v98zM414 1506h103v-98h-103v98zM621 1506h104v-98h-104v98zM829 1506h104v-98h-104v98zM1037 1506h103v-98h-103v98zM103 1699h104v-96h-104v96zM310 1699h104v-96h-104v96zM517 1699h104v-96h-104v96z " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M725 1699h104v-96h-104v96zM933 1699h104v-96h-104v96zM1140 1699h104v-96h-104v96zM1347 1314h104v-98h-104v98zM1244 1119h103v-96h-103v96zM1347 927h104v-96h-104v96zM1244 732h103v-96h-103v96zM1347 540h104v-96h-104v96zM1244 345h103v-96h-103v96zM1347 153h104v-97 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-104v97zM1244 -42h103v-94h-103v94zM1347 -234h104v-97h-104v97zM1244 -427h103v-96h-103v96zM1244 1506h103v-98h-103v98zM1347 1699h104v-96h-104v96z"" /> " is 148.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1493 -621h-1493v290h106v97h-106v290h106v97h-106v291h106v96h-106v289h106v98h-106v289h106v98h-106v289h106v96h107v-96h106v96h107v-96h106v96h107v-96h107v96h107v-96h107v96h107v-96h106v96h107v-96h106v96h107v-193h-107v-98h107v-289h-107v-96h107v-291h-107v-96 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h107v-291h-107v-96h107v-291h-107v-94h107v-291h-107v-96h107v-98zM106 1119v-96h107v96h-107zM319 1119v-96h107v96h-107zM532 1119v-96h107v96h-107zM746 1119v-96h107v96h-107zM960 927h-107v-98h107v98zM746 927h-107v-98h107v98zM532 927h-106v-98h106v98zM319 927 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-106v-98h106v98zM106 732v-96h107v96h-107zM319 732v-96h107v96h-107zM532 732v-96h107v96h-107zM746 732v-96h107v96h-107zM319 540h-106v-96h106v96zM426 540v-96h106v96h-106zM639 540v-96h107v96h-107zM853 540v-96h107v96h-107zM106 345v-96h107v96h-107zM532 345v-96 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h107v96h-107zM426 249v96h-107v-96h107zM746 345v-96h107v96h-107zM960 56v97h-107v-97h107zM746 56v97h-107v-97h107zM532 56v97h-106v-97h106zM319 56v97h-106v-97h106zM106 -42v-94h107v94h-107zM319 -42v-94h107v94h-107zM532 -42v-94h107v94h-107zM746 -42v-94h107v94 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "h-107zM960 -331v97h-107v-97h107zM746 -331v97h-107v-97h107zM532 -331v97h-106v-97h106zM319 -331v97h-106v-97h106zM106 -427v-96h107v96h-107zM319 -427v-96h107v96h-107zM532 -427v-96h107v96h-107zM746 -427v-96h107v96h-107zM960 1314h-107v-98h107v98zM746 1314h-107 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "v-98h107v98zM532 1314h-106v-98h106v98zM319 1314h-106v-98h106v98zM853 1506h-107v-98h107v98zM639 1506h-107v-98h107v98zM426 1506h-107v-98h107v98zM213 1506h-107v-98h107v98zM960 1119v-96h107v96h-107zM1173 1119v-96h107v96h-107zM1386 927h-106v-98h106v98z " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "M1173 927h-106v-98h106v98zM960 732v-96h107v96h-107zM1173 732v-96h107v96h-107zM1173 540h-106v-96h106v96zM1280 540v-96h106v96h-106zM960 345v-96h107v96h-107zM1280 249v96h-107v-96h107zM1386 56v97h-106v-97h106zM1173 56v97h-106v-97h106zM960 -42v-94h107v94h-107 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "zM1173 -42v-94h107v94h-107zM1386 -331v97h-106v-97h106zM1173 -331v97h-106v-97h106zM960 -427v-96h107v96h-107zM1173 -427v-96h107v96h-107zM1386 1314h-106v-98h106v98zM1173 1314h-106v-98h106v98zM1280 1506h-107v-98h107v98zM1067 1506h-107v-98h107v98z"" /> " is 247.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M167 612q0 94 35 176.5t96 144t143 97t176 35.5t176.5 -35.5t144 -97t97 -144t35.5 -176.5t-35.5 -176t-97 -143t-144 -96t-176.5 -35t-176 35t-143 96t-96 143t-35 176zM253 612q0 -76 28.5 -142t77.5 -115.5t115.5 -78t142.5 -28.5t143 28.5t116.5 78t78.5 115.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M618 1018q110 0 217 -57q53 -28 94 -69t70 -93q29 -54 44.5 -109t15.5 -112q0 -183 -129 -312t-312 -129q-182 0 -311 129t-129 312q0 58 15 112.5t44 108.5q29 52 70.5 93t93.5 69q108 57 217 57z"" /> " is 192.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M41 0v1155h1155v-1155h-1155zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" /> " is 228.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M41 0v1155h1155v-1155h-1155zM253 577q0 75 29 141.5t78.5 116t116 78.5t141.5 29t141.5 -29t116 -78.5t78.5 -116t29 -141.5t-29 -141.5t-78.5 -116t-116 -78.5t-141.5 -29t-141.5 29t-116 78.5t-78.5 116t-29 141.5zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5 " is 250.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" /> " is 152.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M611 637q0 -53 -18.5 -96t-55.5 -80q-37 -35 -80 -53.5t-94 -18.5q-101 0 -176 72q-35 37 -53.5 80t-18.5 96q0 102 72 174q74 74 176 74q103 0 174 -74q74 -71 74 -174zM535 637q0 70 -51 121t-121 51t-121 -51t-51 -121q0 -69 51 -123q49 -49 121 -49t121 49 " is 245.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1657 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM1567 584q0 217 -153 370q-151 154 -369 154t-369 -154q-153 -153 -153 -370q0 -216 153 -369 " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q152 -154 369 -154t369 154q153 153 153 369zM889 711q0 -32 -23 -55t-55 -23t-54.5 23t-22.5 55t22.5 54.5t54.5 22.5t55 -22.5t23 -54.5zM1356 711q0 -32 -22 -55t-54 -23t-55.5 23t-23.5 55t23.5 54.5t55.5 22.5t54 -22.5t22 -54.5zM822 422q76 -137 223 -137 " is 243.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1689 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM921 711q0 32 -23 54.5t-55 22.5t-54.5 -22.5t-22.5 -54.5t22.5 -55t54.5 -23t55 23t23 55zM1388 711 " is 251.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q0 32 -22 54.5t-54 22.5t-55.5 -22.5t-23.5 -54.5t23.5 -55t55.5 -23t54 23t22 55zM794 387q48 -91 118.5 -138.5t164.5 -47.5q185 0 283 186l-62 35q-76 -137 -221 -137q-147 0 -223 137z"" /> " is 180.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M905 1083h66v-217q32 -3 60.5 -9t55.5 -16.5t53.5 -26.5t55.5 -38l186 182l45 -45l-184 -184q45 -59 67 -115.5t25 -113.5h215v-62h-215q-8 -60 -30 -115t-62 -106l184 -188l-49 -43l-182 182q-31 -23 -58.5 -39t-50.5 -27q-24 -9 -53 -15t-63 -11v-217h-66v217 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-63 9 -118 32t-103 58l-188 -180l-43 45l182 184q-40 51 -63 106.5t-31 118.5h-215v62h215q12 128 92 223l-180 184l40 49l189 -182q57 40 113 62t110 28v217zM936 805q-69 0 -127.5 -25t-106.5 -73q-98 -100 -98 -236q0 -137 98 -235q48 -50 106.5 -73.5t127.5 -23.5 " is 249.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M732 578q-55 8 -100 31t-80 65q-71 80 -71 188q0 122 83 205q44 43 94.5 64.5t110.5 21.5q118 0 201 -86q86 -83 86 -205q0 -109 -72 -190q-72 -82 -178 -94v-166h256v-70h-256v-262h-74v262h-258v70h258v166zM767 1069q-83 0 -145 -59q-29 -31 -44.5 -66.5t-15.5 -79.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1023 1024q-17 5 -44 14t-64 23q-28 11 -48 23t-34 26q-5 3 -6.5 8t-1.5 10q0 8 6 17q3 2 6 3t8 1t12.5 -1t20.5 -3q32 -8 63.5 -12.5t63.5 -4.5q46 0 78 3.5t51 9.5q36 12 49 12q16 0 16 -14q0 -9 -6 -27q-9 -34 -12.5 -73.5t-3.5 -84.5q0 -31 2 -63t10 -66q2 -11 3 -19 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t1 -13t-1 -8.5t-3 -6.5q-9 -6 -14 -6q-21 0 -41 39q-22 42 -37.5 83t-26.5 83l-237 -238q84 -81 84 -190q0 -125 -86 -211q-87 -88 -205 -88t-205 84q-84 84 -84 201t84 204q85 86 207 86q71 0 154 -43zM628 750q-90 0 -152 -62q-61 -61 -61 -149q0 -91 61 -152 " is 242.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M544 1231q14 -54 34 -101.5t46 -91.5q28 -43 75.5 -95.5t116.5 -115.5q141 -126 176 -192q37 -67 37 -137q0 -95 -63 -158q-66 -66 -154 -66q-157 0 -256 191q3 -147 39 -234q38 -86 119.5 -135.5t218.5 -58.5l8 -37h-792l6 37q125 0 211 49q43 25 76 59.5t55 80t32 105 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t9 134.5q-45 -96 -111 -143.5t-149 -47.5q-90 0 -156 66q-63 63 -63 154q0 74 30 133q23 42 62 84.5t96 89.5q69 59 124 115.5t93 113.5q56 83 80 201z"" /> " is 146.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1094 0h-842l8 35q84 17 138 33.5t81 33.5q41 25 73 62.5t58 87.5q52 100 52 209q0 8 -1 19t-1 28q-58 -121 -148 -180q-43 -28 -87 -43t-89 -15q-59 0 -107.5 21t-89.5 59q-79 83 -79 199q0 115 73 194q73 80 166 80q31 0 71 -12.5t91 -38.5q-20 34 -33.5 60t-21.5 45 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "q-5 17 -8 36t-3 39q0 115 78 193q40 38 88.5 58t108.5 20q116 0 196 -80q80 -78 80 -187q0 -86 -69 -184q84 40 100 43q14 5 29 6.5t32 1.5q51 0 94 -18.5t79 -59.5q73 -76 73 -192q0 -118 -80 -201q-80 -80 -192 -80q-62 0 -128 30t-116 81q-17 19 -38.5 49.5t-47.5 75.5 " is 252.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M610 -23q-14 56 -35 106.5t-47 98.5q-28 50 -79.5 123.5t-127.5 175.5q-56 76 -90.5 122.5t-48.5 68.5q-43 65 -61.5 118t-18.5 109q0 103 68 174q70 70 172 70q98 0 176 -72q28 -28 51.5 -68t40.5 -94q34 119 105 177.5t159 58.5q50 0 92.5 -18t77.5 -52q70 -70 70 -164 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M519 1223q45 -78 101.5 -160.5t125.5 -175.5t127 -163.5t105 -123.5q-39 -40 -99 -115t-143 -186q-69 -93 -122 -172.5t-93 -151.5q-13 25 -30.5 54t-39.5 61q-38 57 -87 124.5t-109 147.5q-14 20 -61 79.5t-128 158.5q50 59 114 139t144 187q59 77 107 151t88 146z"" /> " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M489 1153h76v-100l153 -193q51 -69 80 -150.5t29 -166.5q0 -78 -24 -145t-70 -126h-47q29 65 43 127t14 121q0 60 -14 109.5t-43 89.5q-57 81 -121 90v-506q0 -63 -18.5 -112t-55.5 -87q-72 -75 -180 -75q-57 0 -86 27t-29 73q0 73 60 133q63 60 143 60q44 0 90 -19v850z " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M1263 324q0 -63 -18 -113.5t-56 -85.5q-37 -37 -81 -56.5t-95 -19.5q-57 0 -85.5 27t-28.5 74q0 76 57 133q62 59 143 59q48 0 90 -18v448l-550 -149v-394q0 -62 -18.5 -111t-53.5 -87q-74 -74 -180 -74q-57 0 -86 26.5t-29 71.5q0 76 59 133q60 60 144 60q45 0 90 -19 " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM706 1312v172h180v-172h-180zM706 0v1082h180v-1082h-180z " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM706 1312v172h180v-172h-180zM706 0v1082h180v-1082h-180z " is 253.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM707 0v1484h180v-1484h-180z"" /> " is 230.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM707 0v1484h180v-1484h-180z"" /> " is 230.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M483 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l31 96h62q52 0 94 -9t72 -29.5t46 -52t16 -76.5z"" /> " is 230.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M551 741v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM422 1276q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26z"" /> " is 163.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M636 835q0 -65 -19 -117t-55.5 -89t-90.5 -57t-124 -20q-66 0 -116.5 16.5t-87.5 46t-59 70t-31 88.5l133 15q5 -27 17 -50.5t31.5 -41.5t46.5 -28.5t63 -10.5q71 0 114 42.5t43 135.5q0 81 -40.5 123.5t-115.5 42.5q-51 0 -89.5 -18.5t-61.5 -41.5h-129l33 468h506v-113 " is 255.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M632 1308q-64 -97 -117 -185t-91.5 -176t-60 -181.5t-21.5 -201.5h-133q0 102 23.5 196t63.5 183.5t93.5 177t113.5 175.5h-460v113h589v-101z"" /> " is 142.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M479 1193q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM500 814q0 28 -6.5 54t-24 46t-48 32t-79.5 12q-45 0 -74.5 -12t-47.5 -32.5 " is 246.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM642 800q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62t54 42t62.5 21v3q-36 8 -63.5 26.5 " is 254.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82z"" /> " is 206.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M340 1200q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" /> " is 162.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M492 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" /> " is 244.
Long Statement,MatterHackers.Agg.Font,LiberationSansFont,C:\repos\MatterHackers_agg-sharp\agg\Font\LiberationSansFont.cs,FontData,The length of the statement  "d=""M308 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" /> " is 162.
Long Statement,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetCharacterIndexToStartBefore,The length of the statement  "					CheckForBetterClickPosition(ref position' ref clostestIndex' ref clostestXDistSquared' ref clostestYDistSquared' ref offset' i); " is 128.
Long Statement,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetCharacterIndexToStartBefore,The length of the statement  "				CheckForBetterClickPosition(ref position' ref clostestIndex' ref clostestXDistSquared' ref clostestYDistSquared' ref offset' characterToMeasureEndIndexInclusive + 1); " is 166.
Long Statement,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,CreateGlyphFromSVGGlyphData,The length of the statement  "						throw new NotImplementedException("We do not currently support glyphs longer than one character.  You need to write the search so that it will find them if you want to support this"); " is 183.
Long Statement,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The length of the statement  "			Dictionary<char' ImageBuffer> characterImageCache = StyledTypeFaceImageCache.GetCorrectCache(this.TypeFace' color' this.emSizeInPixels); " is 136.
Long Statement,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The length of the statement  "			ImageBuffer charImage = new ImageBuffer(Math.Max((int)(bounds.Width + .5)' 1) + 1' Math.Max((int)(EmSizeInPixels + descentExtraHeight + .5)' 1) + 1' 32' new BlenderPreMultBGRA()); " is 179.
Long Statement,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetGlyphForCharacter,The length of the statement  "					sourceGlyph = new GlyphWithUnderline(sourceGlyph' TypeFace.GetAdvanceForCharacter(character)' TypeFace.Underline_position' TypeFace.Underline_thickness); " is 153.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The length of the statement  "				ImageBuffer halfImage = new ImageBuffer(unscaledSourceImage.Width / 2' unscaledSourceImage.Height / 2' 32' unscaledSourceImage.GetRecieveBlender()); " is 148.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The length of the statement  "				halfImage.NewGraphics2D().Render(unscaledSourceImage' 0' 0' 0' halfImage.Width / (double)unscaledSourceImage.Width' halfImage.Height / (double)unscaledSourceImage.Height); " is 171.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The length of the statement  "			renderGraphics.Render(unscaledSourceImage' 0' 0' 0' destImage.Width / (double)unscaledSourceImage.Width' destImage.Height / (double)unscaledSourceImage.Height); " is 160.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,NewSubImageReference,The length of the statement  "			if (subImageBounds.Left < 0 || subImageBounds.Bottom < 0 || subImageBounds.Right > imageContainingSubImage.Width || subImageBounds.Top > imageContainingSubImage.Height " is 167.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,NewSubImageReference,The length of the statement  "			subImage.AttachBuffer(imageContainingSubImage.GetBuffer()' bufferOffsetToFirstPixel' width' height' imageContainingSubImage.StrideInBytes()' imageContainingSubImage.BitDepth' imageContainingSubImage.GetBytesBetweenPixelsInclusive()); " is 233.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Attach,The length of the statement  "			SetDimmensionAndFormat(sourceImage.Width' sourceImage.Height' sourceImage.StrideInBytes()' bitsPerPixel' distanceBetweenPixelsInclusive' false); " is 144.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Attach,The length of the statement  "				SetDimmensionAndFormat(boundsRect.Width' boundsRect.Height' sourceImage.StrideInBytes()' sourceImage.BitDepth' sourceImage.GetBytesBetweenPixelsInclusive()' false); " is 164.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetAlpha,The length of the statement  "				throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + "."); " is 120.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The length of the statement  "				throw new Exception("The yTable and xTable should be allocated correctly at this point. Figure out what happened."); // LBB' don't fix this if you don't understand what it's trying to do. " is 187.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The length of the statement  "				byte[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset); " is 142.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The length of the statement  "					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion"); " is 141.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,GetBounds,The length of the statement  "			return new RectangleInt(-(int)OriginOffset.x' -(int)OriginOffset.y' Width - (int)OriginOffset.x' Height - (int)OriginOffset.y); " is 127.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_hline,The length of the statement  "						recieveBlender.BlendPixel(buffer' bufferOffset' new RGBA_Bytes(sourceColor.red' sourceColor.green' sourceColor.blue' alpha)); " is 125.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_solid_hspan,The length of the statement  "							recieveBlender.BlendPixel(buffer' bufferOffset' new RGBA_Bytes(sourceColor.red' sourceColor.green' sourceColor.blue' alpha)); " is 125.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_color_hspan,The length of the statement  "			recieveBlender.BlendPixels(m_ByteBuffer' bufferOffset' colors' colorsIndex' covers' coversIndex' firstCoverForAll' len); " is 120.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_color_vspan,The length of the statement  "					DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender' m_ByteBuffer' bufferOffset' colors[colorsIndex]' covers[coversIndex++]); " is 123.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_color_vspan,The length of the statement  "						DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender' m_ByteBuffer' bufferOffset' colors[colorsIndex]' covers[coversIndex]); " is 121.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,IsPixelVisible,The length of the statement  "			return (pixelValue.Alpha0To255 != 0 || pixelValue.Red0To255 != 0 || pixelValue.Green0To255 != 0 || pixelValue.Blue0To255 != 0); " is 127.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Initialize,The length of the statement  "				throw new Exception("We do not create a temp buffer for this to work.  You must have a source distinct from the dest."); " is 120.
Long Statement,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Initialize,The length of the statement  "			Allocate(boundsToCopyFrom.Width' boundsToCopyFrom.Height' boundsToCopyFrom.Width * sourceImage.BitDepth / 8' sourceImage.BitDepth); " is 131.
Long Statement,MatterHackers.Agg.Image,DoCopyOrBlend,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,BasedOnAlpha,The length of the statement  "#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB " is 158.
Long Statement,MatterHackers.Agg.Image,DoCopyOrBlend,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,BasedOnAlphaAndCover,The length of the statement  "#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB " is 158.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Attach,The length of the statement  "			SetDimmensionAndFormat(sourceImage.Width' sourceImage.Height' sourceImage.StrideInFloats()' bitsPerPixel' distanceBetweenPixelsInclusive); " is 138.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Attach,The length of the statement  "				SetDimmensionAndFormat(boundsRect.Width' boundsRect.Height' sourceImage.StrideInFloats()' sourceImage.BitDepth' sourceImage.GetFloatsBetweenPixelsInclusive()); " is 159.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetAlpha,The length of the statement  "				throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + "."); " is 120.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The length of the statement  "				float[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset); " is 143.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The length of the statement  "					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion"); " is 141.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,GetBounds,The length of the statement  "			return new RectangleInt(-(int)m_OriginOffset.x' -(int)m_OriginOffset.y' Width - (int)m_OriginOffset.x' Height - (int)m_OriginOffset.y); " is 135.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetDimmensionAndFormat,The length of the statement  "				throw new Exception("You already have a buffer set. You need to set dimensions before the buffer.  You may need to clear the buffer first."); " is 141.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_hline,The length of the statement  "						m_Blender.BlendPixel(buffer' bufferOffset' new RGBA_Floats(sourceColor.red' sourceColor.green' sourceColor.blue' alpha)); " is 121.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_solid_hspan,The length of the statement  "							m_Blender.BlendPixel(buffer' bufferOffset' new RGBA_Floats(sourceColor.red' sourceColor.green' sourceColor.blue' alpha)); " is 121.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_color_vspan,The length of the statement  "					DoCopyOrBlendFloat.BasedOnAlphaAndCover(m_Blender' m_FloatBuffer' bufferOffset' colors[colorsIndex]' covers[coversIndex++]); " is 124.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,blend_color_vspan,The length of the statement  "						DoCopyOrBlendFloat.BasedOnAlphaAndCover(m_Blender' m_FloatBuffer' bufferOffset' colors[colorsIndex]' covers[coversIndex]); " is 122.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,IsPixelVisible,The length of the statement  "			return (pixelValue.Alpha0To255 != 0 || pixelValue.Red0To255 != 0 || pixelValue.Green0To255 != 0 || pixelValue.Blue0To255 != 0); " is 127.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Initialize,The length of the statement  "				throw new Exception("We do not create a temp buffer for this to work.  You must have a source distinct from the dest."); " is 120.
Long Statement,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Initialize,The length of the statement  "			Allocate(boundsToCopyFrom.Width' boundsToCopyFrom.Height' boundsToCopyFrom.Width * sourceImage.BitDepth / 8' sourceImage.BitDepth); " is 131.
Long Statement,MatterHackers.Agg.Image,DoCopyOrBlendFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,BasedOnAlpha,The length of the statement  "#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB " is 158.
Long Statement,MatterHackers.Agg.Image,DoCopyOrBlendFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,BasedOnAlphaAndCover,The length of the statement  "#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB " is 158.
Long Statement,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The length of the statement  "						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine); " is 134.
Long Statement,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,GetSameLength,The length of the statement  "			while (memcmp(checkBufer' checkOffset' sourceBuffer' sourceOffsetToNextPixel' numBytesInPixel) == 0 && Count < maxSameLengthWidth) " is 130.
Long Statement,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The length of the statement  "				gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift); " is 146.
Long Statement,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The length of the statement  "				byte gray = (byte)((((sourceColor.red - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift); " is 162.
Long Statement,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The length of the statement  "				byte gray = (byte)((((clampedMax - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift); " is 157.
Long Statement,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' 255); " is 156.
Long Statement,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 162.
Long Statement,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 164.
Long Statement,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 163.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' 255); " is 156.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv((byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift)); " is 175.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv((byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift)); " is 177.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv((byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift)); " is 176.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' 255); " is 156.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red]; " is 125.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green]; " is 127.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The length of the statement  "					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue]; " is 126.
Long Statement,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 194.
Long Statement,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 162.
Long Statement,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 164.
Long Statement,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 163.
Long Statement,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift)); " is 146.
Long Statement,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 194.
Long Statement,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 194.
Long Statement,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 162.
Long Statement,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 164.
Long Statement,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift); " is 163.
Long Statement,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift)); " is 146.
Long Statement,MatterHackers.Agg.Image,BlenderBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Floats,The length of the statement  "			return new RGBA_Floats(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 195.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 194.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv((byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift)); " is 175.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv((byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift)); " is 177.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv((byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift)); " is 176.
Long Statement,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				buffer[ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift)); " is 131.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 194.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red]; " is 125.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green]; " is 127.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue]; " is 126.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]); " is 135.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Bytes,The length of the statement  "			return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 194.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR]; " is 121.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG]; " is 121.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB]; " is 121.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The length of the statement  "					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]); " is 137.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red]; " is 125.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green]; " is 127.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue]; " is 126.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]); " is 135.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                            int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red]; " is 125.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                            int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green]; " is 127.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                            int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue]; " is 126.
Long Statement,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "                            pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]); " is 135.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,PixelToColorRGBA_Floats,The length of the statement  "			//return new RGBA_(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' buffer[bufferOffset + ImageBuffer.OrderA]); " is 191.
Long Statement,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The length of the statement  "								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover " is 129.
Long Statement,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,NewRotation,The length of the statement  "			return new Affine(Math.Cos(AngleRadians)' Math.Sin(AngleRadians)' -Math.Sin(AngleRadians)' Math.Cos(AngleRadians)' 0.0' 0.0); " is 125.
Long Statement,MatterHackers.Agg.VertexSource,ContourGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\ContourGenerator.cs,Vertex,The length of the statement  "						return ShapePath.FlagsAndCommand.CommandEndPoly | ShapePath.FlagsAndCommand.FlagClose | ShapePath.FlagsAndCommand.FlagCCW; " is 122.
Long Statement,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetCharacterIndexToStartBefore,The length of the statement  "				characterToMeasureStartIndexInclusive = Math.Max(0' Math.Min(characterToMeasureStartIndexInclusive' m_Text.Length - 1)); " is 120.
Long Statement,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetSize,The length of the statement  "				characterToMeasureStartIndexInclusive = Math.Max(0' Math.Min(characterToMeasureStartIndexInclusive' m_Text.Length - 1)); " is 120.
Long Statement,MatterHackers.Agg.VertexSource,FlattenCurves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\FlattenCurve.cs,Vertices,The length of the statement  "							m_curve3.init(lastPosition.position.x' lastPosition.position.y' vertexData.position.x' vertexData.position.y' vertexDataEnd.position.x' vertexDataEnd.position.y); " is 162.
Long Statement,MatterHackers.Agg.VertexSource,FlattenCurves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\FlattenCurve.cs,Vertices,The length of the statement  "							m_curve4.init(lastPosition.position.x' lastPosition.position.y' vertexData.position.x' vertexData.position.y' vertexDataControl.position.x' vertexDataControl.position.y' vertexDataEnd.position.x' vertexDataEnd.position.y); " is 222.
Long Statement,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,OldEqualsOldStyle,The length of the statement  "			if (controlFlagsAndCommand == otherFlagsAndCommand && controlX == testX && agg_basics.is_equal_eps(controlY' testY' .000000001)) " is 128.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,radius,The length of the statement  "			leftBottomRadius.x = leftBottomRadius.y = rightBottomRadius.x = rightBottomRadius.y = rightTopRadius.x = rightTopRadius.y = leftTopRadius.x = leftTopRadius.y = r; " is 162.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The length of the statement  "			currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y' Math.PI' Math.PI + Math.PI * 0.5); " is 170.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The length of the statement  "			currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y' Math.PI + Math.PI * 0.5' 0.0); " is 171.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The length of the statement  "			currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y' 0.0' Math.PI * 0.5); " is 146.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The length of the statement  "			currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y' Math.PI * 0.5' Math.PI); " is 145.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The length of the statement  "			yield return new VertexData(ShapePath.FlagsAndCommand.CommandEndPoly | ShapePath.FlagsAndCommand.FlagClose | ShapePath.FlagsAndCommand.FlagCCW' new Vector2()); " is 159.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The length of the statement  "					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y' " is 135.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The length of the statement  "					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y' " is 140.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The length of the statement  "					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y' " is 125.
Long Statement,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The length of the statement  "					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y' " is 120.
Long Statement,MatterHackers.Agg.VertexSource,VertexSourceIO,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\VertexSourceIO.cs,Load,The length of the statement  "				ShapePath.FlagsAndCommand flagsAndCommand = (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand)' elements[2].Trim()); " is 144.
Complex Conditional,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ParseDoubleFast,The conditional expression  "next == '.' || next == '-' || next == '+' || (next >= '0' && next <= '9')"  is complex.
Complex Conditional,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The conditional expression  "left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2"  is complex.
Complex Conditional,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The conditional expression  "x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy"  is complex.
Complex Conditional,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The conditional expression  "x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy"  is complex.
Complex Conditional,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The conditional expression  "x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy"  is complex.
Complex Conditional,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The conditional expression  "x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy"  is complex.
Complex Conditional,MatterHackers.Agg.Font,EnglishTextWrapping,C:\repos\MatterHackers_agg-sharp\agg\Font\TextWrapping.cs,WrapSingleLineOnWidth,The conditional expression  "countBeforeWrap > 1 // we have more than 2 characters left  						&& textToWrap.Length > countBeforeWrap // we are longer than the remaining text  						&& textToWrap[countBeforeWrap] == ' ' // the first new character is a space  						&& textToWrap[countBeforeWrap - 1] != '\n'"  is complex.
Complex Conditional,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The conditional expression  "xFraction > 1 || xFraction < 0 || yFraction > 1 || yFraction < 0"  is complex.
Complex Conditional,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,NewSubImageReference,The conditional expression  "subImageBounds.Left < 0 || subImageBounds.Bottom < 0 || subImageBounds.Right > imageContainingSubImage.Width || subImageBounds.Top > imageContainingSubImage.Height  				|| subImageBounds.Left >= subImageBounds.Right || subImageBounds.Bottom >= subImageBounds.Top"  is complex.
Complex Conditional,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,DeallocateOrClearBuffer,The conditional expression  "this.Width == width  				&& this.Height == height  				&& this.strideInBytes == strideInBytes  				&& this.BitDepth == bitDepth  				&& m_DistanceInBytesBetweenPixelsInclusive == distanceInBytesBetweenPixelsInclusive  				&& m_ByteBuffer != null"  is complex.
Complex Conditional,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Equals,The conditional expression  "Width == b.Width  				&& Height == b.Height  				&& BitDepth == b.BitDepth  				&& StrideInBytes() == b.StrideInBytes()  				&& OriginOffset == b.OriginOffset"  is complex.
Complex Conditional,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The conditional expression  "TargaHeader.ColorMapType != 0 ||	// 0 = RGB' 1 = Palette  				// 1 = Palette' 2 = RGB' 3 = mono' 9 = RLE Palette' 10 = RLE RGB' 11 RLE mono  				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||  				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32)"  is complex.
Complex Conditional,MatterHackers.Agg.Transform,Viewport,C:\repos\MatterHackers_agg-sharp\agg\Transform\Viewport.cs,update,The conditional expression  "Math.Abs(m_world_x1 - m_world_x2) < epsilon ||  			   Math.Abs(m_world_y1 - m_world_y2) < epsilon ||  			   Math.Abs(m_device_x1 - m_device_x2) < epsilon ||  			   Math.Abs(m_device_y1 - m_device_y2) < epsilon"  is complex.
Complex Conditional,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The conditional expression  "d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1"  is complex.
Complex Conditional,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,OldEqualsNewStyle,The conditional expression  "controlFlagsAndCommand != vertexData.command  					|| controlX < vertexData.position.x - maxError || controlX > vertexData.position.x + maxError  					|| controlY < vertexData.position.y - maxError || controlY > vertexData.position.y + maxError"  is complex.
Complex Conditional,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,OldEqualsOldStyle,The conditional expression  "controlFlagsAndCommand != otherFlagsAndCommand  						|| controlX < testX - maxError || controlX > testX + maxError  						|| controlY < testY - maxError || controlY > testY + maxError"  is complex.
Empty Catch Block,MatterHackers.Agg,PluginFinder<BaseClassToFind>,C:\repos\MatterHackers_agg-sharp\agg\PluginFinder.cs,FindAndAddPlugins,The method has an empty catch block.
Empty Catch Block,MatterHackers.Agg,PluginFinder<BaseClassToFind>,C:\repos\MatterHackers_agg-sharp\agg\PluginFinder.cs,FindAndAddPlugins,The method has an empty catch block.
Empty Catch Block,MatterHackers.Agg,PluginFinder<BaseClassToFind>,C:\repos\MatterHackers_agg-sharp\agg\PluginFinder.cs,FindAndAddPlugins,The method has an empty catch block.
Magic Number,MatterHackers.Agg,VectorPOD<DataType>,C:\repos\MatterHackers_agg-sharp\agg\agg_array.cs,add,The following statement contains a magic number: if (internalArray == null || internalArray.Length < (currentSize + 1))  			{  				if (currentSize < 100000)  				{  					Resize(currentSize + (currentSize / 2) + 16);  				}  				else  				{  					Resize(currentSize + currentSize / 4);  				}  			}
Magic Number,MatterHackers.Agg,VectorPOD<DataType>,C:\repos\MatterHackers_agg-sharp\agg\agg_array.cs,add,The following statement contains a magic number: if (internalArray == null || internalArray.Length < (currentSize + 1))  			{  				if (currentSize < 100000)  				{  					Resize(currentSize + (currentSize / 2) + 16);  				}  				else  				{  					Resize(currentSize + currentSize / 4);  				}  			}
Magic Number,MatterHackers.Agg,VectorPOD<DataType>,C:\repos\MatterHackers_agg-sharp\agg\agg_array.cs,add,The following statement contains a magic number: if (internalArray == null || internalArray.Length < (currentSize + 1))  			{  				if (currentSize < 100000)  				{  					Resize(currentSize + (currentSize / 2) + 16);  				}  				else  				{  					Resize(currentSize + currentSize / 4);  				}  			}
Magic Number,MatterHackers.Agg,VectorPOD<DataType>,C:\repos\MatterHackers_agg-sharp\agg\agg_array.cs,add,The following statement contains a magic number: if (internalArray == null || internalArray.Length < (currentSize + 1))  			{  				if (currentSize < 100000)  				{  					Resize(currentSize + (currentSize / 2) + 16);  				}  				else  				{  					Resize(currentSize + currentSize / 4);  				}  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ParseDoubleFast,The following statement contains a magic number: while (startIndex < length)  			{  				char next = source[startIndex];  				if (next >= '0' && next <= '9')  				{  					currentIntPart = (currentIntPart * 10) + next - '0';  					foundNumber = true;  				}  				else if (next == '.')  				{  					foundNumber = true;  					startIndex++;  					// parse out the fractional part  					while (startIndex < length)  					{  						char nextFraction = source[startIndex];  						if (nextFraction >= '0' && nextFraction <= '9')  						{  							fractionDigits++;  							currentFractionPart = (currentFractionPart * 10) + nextFraction - '0';  						}  						else // we are done  						{  							break;  						}  						startIndex++;  					}  					break;  				}  				else if(!foundNumber && next == ' ')  				{  					// happy to skip spaces  				}  				else // we are done  				{  					break;  				}  				startIndex++;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ParseDoubleFast,The following statement contains a magic number: while (startIndex < length)  			{  				char next = source[startIndex];  				if (next >= '0' && next <= '9')  				{  					currentIntPart = (currentIntPart * 10) + next - '0';  					foundNumber = true;  				}  				else if (next == '.')  				{  					foundNumber = true;  					startIndex++;  					// parse out the fractional part  					while (startIndex < length)  					{  						char nextFraction = source[startIndex];  						if (nextFraction >= '0' && nextFraction <= '9')  						{  							fractionDigits++;  							currentFractionPart = (currentFractionPart * 10) + nextFraction - '0';  						}  						else // we are done  						{  							break;  						}  						startIndex++;  					}  					break;  				}  				else if(!foundNumber && next == ' ')  				{  					// happy to skip spaces  				}  				else // we are done  				{  					break;  				}  				startIndex++;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ParseDoubleFast,The following statement contains a magic number: if (fractionDigits > 0)  			{  				double fractionNumber = currentIntPart + (currentFractionPart / (Math.Pow(10.0' fractionDigits)));  				if (negative)  				{  					return -fractionNumber;  				}  				return fractionNumber;  			}  			else  			{  				if (negative)  				{  					return -currentIntPart;  				}  				return currentIntPart;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,ComputeHash,The following statement contains a magic number: unchecked  			{  				const long p = 1099511628211;  				long hash = (long)14695981039346656037;    				for (int i = 0; i < data.Length; i++)  				{  					hash = (hash ^ data[i]) * p;  				}    				hash += hash << 13;  				hash ^= hash >> 7;  				hash += hash << 3;  				hash ^= hash >> 17;  				hash += hash << 5;  				return hash;  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,deg2rad,The following statement contains a magic number: return deg * Math.PI / 180.0;
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,rad2deg,The following statement contains a magic number: return rad * 180.0 / Math.PI;
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,iround,The following statement contains a magic number: unchecked  			{  				return (int)((v < 0.0) ? v - 0.5 : v + 0.5);  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,iround,The following statement contains a magic number: unchecked  			{  				return (int)((v < 0.0) ? v - 0.5 : v + 0.5);  			}
Magic Number,MatterHackers.Agg,agg_basics,C:\repos\MatterHackers_agg-sharp\agg\agg_basics.cs,uround,The following statement contains a magic number: return (int)(uint)(v + 0.5);
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,init,The following statement contains a magic number: if (max > 2 && max > m_max)  			{  				m_am.Resize(max * 3);  				m_max = max;  				m_xOffset = m_max;  				m_yOffset = m_max * 2;  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,init,The following statement contains a magic number: if (max > 2 && max > m_max)  			{  				m_am.Resize(max * 3);  				m_max = max;  				m_xOffset = m_max;  				m_yOffset = m_max * 2;  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,init,The following statement contains a magic number: if (max > 2 && max > m_max)  			{  				m_am.Resize(max * 3);  				m_max = max;  				m_xOffset = m_max;  				m_yOffset = m_max * 2;  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,prepare,The following statement contains a magic number: if (m_num > 2)  			{  				int i' k;  				int r;  				int s;  				double h' p' d' f' e;    				for (k = 0; k < m_num; k++)  				{  					m_am[k] = 0.0;  				}    				int n1 = 3 * m_num;    				ArrayPOD<double> al = new ArrayPOD<double>(n1);    				for (k = 0; k < n1; k++)  				{  					al[k] = 0.0;  				}    				r = m_num;  				s = m_num * 2;    				n1 = m_num - 1;  				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];  				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;    				for (k = 1; k < n1; k++)  				{  					h = d;  					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];  					f = e;  					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;  					al[k] = d / (d + h);  					al[r + k] = 1.0 - al[k];  					al[s + k] = 6.0 * (e - f) / (h + d);  				}    				for (k = 1; k < n1; k++)  				{  					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);  					al[k] *= -p;  					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;  				}    				m_am[n1] = 0.0;  				al[n1 - 1] = al[s + n1 - 1];  				m_am[n1 - 1] = al[n1 - 1];    				for (k = n1 - 2' i = 0; i < m_num - 2; i++' k--)  				{  					al[k] = al[k] * al[k + 1] + al[s + k];  					m_am[k] = al[k];  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,init,The following statement contains a magic number: if (num > 2)  			{  				init(num);  				int i;  				for (i = 0; i < num; i++)  				{  					add_point(x[i]' y[i]);  				}  				prepare();  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,interpolation,The following statement contains a magic number: double p = d * d / 6.0;
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,interpolation,The following statement contains a magic number: return (m_am[j] * r * r * r + m_am[i] * h * h * h) / 6.0 / d +  				   ((m_am[m_yOffset + j] - m_am[j] * p) * r + (m_am[m_yOffset + i] - m_am[i] * p) * h) / d;
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,extrapolation_left,The following statement contains a magic number: return (-d * m_am[1] / 6 + (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d) *  				   (x - m_am[m_xOffset + 0]) +  				   m_am[m_yOffset + 0];
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,extrapolation_right,The following statement contains a magic number: double d = m_am[m_xOffset + m_num - 1] - m_am[m_xOffset + m_num - 2];
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,extrapolation_right,The following statement contains a magic number: return (d * m_am[m_num - 2] / 6 + (m_am[m_yOffset + m_num - 1] - m_am[m_yOffset + m_num - 2]) / d) *  				   (x - m_am[m_xOffset + m_num - 1]) +  				   m_am[m_yOffset + m_num - 1];
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,extrapolation_right,The following statement contains a magic number: return (d * m_am[m_num - 2] / 6 + (m_am[m_yOffset + m_num - 1] - m_am[m_yOffset + m_num - 2]) / d) *  				   (x - m_am[m_xOffset + m_num - 1]) +  				   m_am[m_yOffset + m_num - 1];
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,extrapolation_right,The following statement contains a magic number: return (d * m_am[m_num - 2] / 6 + (m_am[m_yOffset + m_num - 1] - m_am[m_yOffset + m_num - 2]) / d) *  				   (x - m_am[m_xOffset + m_num - 1]) +  				   m_am[m_yOffset + m_num - 1];
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,get,The following statement contains a magic number: if (m_num > 2)  			{  				int i;    				// Extrapolation on the left  				if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);    				// Extrapolation on the right  				if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);    				// Interpolation  				bsearch(m_num' m_xOffset' x' out i);  				return interpolation(x' i);  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,get_stateful,The following statement contains a magic number: if (m_num > 2)  			{  				// Extrapolation on the left  				if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);    				// Extrapolation on the right  				if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);    				if (m_last_idx >= 0)  				{  					// Check if x is not in current range  					if (x < m_am[m_xOffset + m_last_idx] || x > m_am[m_xOffset + m_last_idx + 1])  					{  						// Check if x between next points (most probably)  						if (m_last_idx < m_num - 2 &&  						   x >= m_am[m_xOffset + m_last_idx + 1] &&  						   x <= m_am[m_xOffset + m_last_idx + 2])  						{  							++m_last_idx;  						}  						else  							if (m_last_idx > 0 &&  							   x >= m_am[m_xOffset + m_last_idx - 1] &&  							   x <= m_am[m_xOffset + m_last_idx])  							{  								// x is between previous points  								--m_last_idx;  							}  							else  							{  								// Else perform full search  								bsearch(m_num' m_xOffset' x' out m_last_idx);  							}  					}  					return interpolation(x' m_last_idx);  				}  				else  				{  					// Interpolation  					bsearch(m_num' m_xOffset' x' out m_last_idx);  					return interpolation(x' m_last_idx);  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,get_stateful,The following statement contains a magic number: if (m_num > 2)  			{  				// Extrapolation on the left  				if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);    				// Extrapolation on the right  				if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);    				if (m_last_idx >= 0)  				{  					// Check if x is not in current range  					if (x < m_am[m_xOffset + m_last_idx] || x > m_am[m_xOffset + m_last_idx + 1])  					{  						// Check if x between next points (most probably)  						if (m_last_idx < m_num - 2 &&  						   x >= m_am[m_xOffset + m_last_idx + 1] &&  						   x <= m_am[m_xOffset + m_last_idx + 2])  						{  							++m_last_idx;  						}  						else  							if (m_last_idx > 0 &&  							   x >= m_am[m_xOffset + m_last_idx - 1] &&  							   x <= m_am[m_xOffset + m_last_idx])  							{  								// x is between previous points  								--m_last_idx;  							}  							else  							{  								// Else perform full search  								bsearch(m_num' m_xOffset' x' out m_last_idx);  							}  					}  					return interpolation(x' m_last_idx);  				}  				else  				{  					// Interpolation  					bsearch(m_num' m_xOffset' x' out m_last_idx);  					return interpolation(x' m_last_idx);  				}  			}
Magic Number,MatterHackers.Agg,bspline,C:\repos\MatterHackers_agg-sharp\agg\agg_bspline.cs,get_stateful,The following statement contains a magic number: if (m_num > 2)  			{  				// Extrapolation on the left  				if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);    				// Extrapolation on the right  				if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);    				if (m_last_idx >= 0)  				{  					// Check if x is not in current range  					if (x < m_am[m_xOffset + m_last_idx] || x > m_am[m_xOffset + m_last_idx + 1])  					{  						// Check if x between next points (most probably)  						if (m_last_idx < m_num - 2 &&  						   x >= m_am[m_xOffset + m_last_idx + 1] &&  						   x <= m_am[m_xOffset + m_last_idx + 2])  						{  							++m_last_idx;  						}  						else  							if (m_last_idx > 0 &&  							   x >= m_am[m_xOffset + m_last_idx - 1] &&  							   x <= m_am[m_xOffset + m_last_idx])  							{  								// x is between previous points  								--m_last_idx;  							}  							else  							{  								// Else perform full search  								bsearch(m_num' m_xOffset' x' out m_last_idx);  							}  					}  					return interpolation(x' m_last_idx);  				}  				else  				{  					// Interpolation  					bsearch(m_num' m_xOffset' x' out m_last_idx);  					return interpolation(x' m_last_idx);  				}  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clipping_flags,The following statement contains a magic number: return ((x > clip_box.Right) ? 1 : 0)  				| ((y > clip_box.Top) ? 1 << 1 : 0)  				| ((x < clip_box.Left) ? 1 << 2 : 0)  				| ((y < clip_box.Bottom) ? 1 << 3 : 0);
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clipping_flags,The following statement contains a magic number: return ((x > clip_box.Right) ? 1 : 0)  				| ((y > clip_box.Top) ? 1 << 1 : 0)  				| ((x < clip_box.Left) ? 1 << 2 : 0)  				| ((y < clip_box.Bottom) ? 1 << 3 : 0);
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clipping_flags_x,The following statement contains a magic number: return ((x > clip_box.Right ? 1 : 0) | ((x < clip_box.Left ? 1 : 0) << 2));
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clipping_flags_y,The following statement contains a magic number: return (((y > clip_box.Top ? 1 : 0) << 1) | ((y < clip_box.Bottom ? 1 : 0) << 3));
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_liang_barsky,The following statement contains a magic number: double nearzero = 1e-30;
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if ((f1 & (int)clipping_flags_e.clipping_flags_x_clipped) != 0 &&  			   (f1 & (int)clipping_flags_e.clipping_flags_x_clipped) == (f2 & (int)clipping_flags_e.clipping_flags_x_clipped))  			{  				// Fully clipped  				return 4;  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if ((f1 & (int)clipping_flags_e.clipping_flags_y_clipped) != 0 &&  			   (f1 & (int)clipping_flags_e.clipping_flags_y_clipped) == (f2 & (int)clipping_flags_e.clipping_flags_y_clipped))  			{  				// Fully clipped  				return 4;  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if (f1 != 0)  			{  				if (!clip_move_point(tx1' ty1' tx2' ty2' clip_box' ref x1' ref y1' f1))  				{  					return 4;  				}  				if (x1 == x2 && y1 == y2)  				{  					return 4;  				}  				ret |= 1;  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if (f1 != 0)  			{  				if (!clip_move_point(tx1' ty1' tx2' ty2' clip_box' ref x1' ref y1' f1))  				{  					return 4;  				}  				if (x1 == x2 && y1 == y2)  				{  					return 4;  				}  				ret |= 1;  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if (f2 != 0)  			{  				if (!clip_move_point(tx1' ty1' tx2' ty2' clip_box' ref x2' ref y2' f2))  				{  					return 4;  				}  				if (x1 == x2 && y1 == y2)  				{  					return 4;  				}  				ret |= 2;  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if (f2 != 0)  			{  				if (!clip_move_point(tx1' ty1' tx2' ty2' clip_box' ref x2' ref y2' f2))  				{  					return 4;  				}  				if (x1 == x2 && y1 == y2)  				{  					return 4;  				}  				ret |= 2;  			}
Magic Number,MatterHackers.Agg,ClipLiangBarsky,C:\repos\MatterHackers_agg-sharp\agg\agg_clip_liang_barsky.cs,clip_line_segment,The following statement contains a magic number: if (f2 != 0)  			{  				if (!clip_move_point(tx1' ty1' tx2' ty2' clip_box' ref x2' ref y2' f2))  				{  					return 4;  				}  				if (x1 == x2 && y1 == y2)  				{  					return 4;  				}  				ret |= 2;  			}
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,gray8,C:\repos\MatterHackers_agg-sharp\agg\agg_color_gray.cs,gray8,The following statement contains a magic number: v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (lightness0To1 <= 0.5)  			{  				v = lightness0To1 * (1.0 + saturation0To1);  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (v > 0)  			{  				double m;  				double sv;  				int sextant;  				double fract' vsf' mid1' mid2;    				m = lightness0To1 + lightness0To1 - v;  				sv = (v - m) / v;  				hue0To1 *= 6.0;  				sextant = (int)hue0To1;  				fract = hue0To1 - sextant;  				vsf = v * sv * fract;  				mid1 = m + vsf;  				mid2 = v - vsf;  				switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (v > 0)  			{  				double m;  				double sv;  				int sextant;  				double fract' vsf' mid1' mid2;    				m = lightness0To1 + lightness0To1 - v;  				sv = (v - m) / v;  				hue0To1 *= 6.0;  				sextant = (int)hue0To1;  				fract = hue0To1 - sextant;  				vsf = v * sv * fract;  				mid1 = m + vsf;  				mid2 = v - vsf;  				switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (v > 0)  			{  				double m;  				double sv;  				int sextant;  				double fract' vsf' mid1' mid2;    				m = lightness0To1 + lightness0To1 - v;  				sv = (v - m) / v;  				hue0To1 *= 6.0;  				sextant = (int)hue0To1;  				fract = hue0To1 - sextant;  				vsf = v * sv * fract;  				mid1 = m + vsf;  				mid2 = v - vsf;  				switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (v > 0)  			{  				double m;  				double sv;  				int sextant;  				double fract' vsf' mid1' mid2;    				m = lightness0To1 + lightness0To1 - v;  				sv = (v - m) / v;  				hue0To1 *= 6.0;  				sextant = (int)hue0To1;  				fract = hue0To1 - sextant;  				vsf = v * sv * fract;  				mid1 = m + vsf;  				mid2 = v - vsf;  				switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (v > 0)  			{  				double m;  				double sv;  				int sextant;  				double fract' vsf' mid1' mid2;    				m = lightness0To1 + lightness0To1 - v;  				sv = (v - m) / v;  				hue0To1 *= 6.0;  				sextant = (int)hue0To1;  				fract = hue0To1 - sextant;  				vsf = v * sv * fract;  				mid1 = m + vsf;  				mid2 = v - vsf;  				switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following statement contains a magic number: if (v > 0)  			{  				double m;  				double sv;  				int sextant;  				double fract' vsf' mid1' mid2;    				m = lightness0To1 + lightness0To1 - v;  				sv = (v - m) / v;  				hue0To1 *= 6.0;  				sextant = (int)hue0To1;  				fract = hue0To1 - sextant;  				vsf = v * sv * fract;  				mid1 = m + vsf;  				mid2 = v - vsf;  				switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: lightness0To1 = (minRGB + maxRGB) / 2.0;
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: if (saturation0To1 > 0.0)  			{  				saturation0To1 /= (lightness0To1 <= 0.5) ? (maxRGB + minRGB) : (2.0 - maxRGB - minRGB);  			}  			else  			{  				return;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: if (saturation0To1 > 0.0)  			{  				saturation0To1 /= (lightness0To1 <= 0.5) ? (maxRGB + minRGB) : (2.0 - maxRGB - minRGB);  			}  			else  			{  				return;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: if (red == maxRGB)  			{  				if (green == minRGB)  				{  					hue0To1 = 5.0 + b2;  				}  				else  				{  					hue0To1 = 1.0 - g2;  				}  			}  			else if (green == maxRGB)  			{  				if (blue == minRGB)  				{  					hue0To1 = 1.0 + r2;  				}  				else  				{  					hue0To1 = 3.0 - b2;  				}  			}  			else  			{  				if (red == minRGB)  				{  					hue0To1 = 3.0 + g2;  				}  				else  				{  					hue0To1 = 5.0 - r2;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: if (red == maxRGB)  			{  				if (green == minRGB)  				{  					hue0To1 = 5.0 + b2;  				}  				else  				{  					hue0To1 = 1.0 - g2;  				}  			}  			else if (green == maxRGB)  			{  				if (blue == minRGB)  				{  					hue0To1 = 1.0 + r2;  				}  				else  				{  					hue0To1 = 3.0 - b2;  				}  			}  			else  			{  				if (red == minRGB)  				{  					hue0To1 = 3.0 + g2;  				}  				else  				{  					hue0To1 = 5.0 - r2;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: if (red == maxRGB)  			{  				if (green == minRGB)  				{  					hue0To1 = 5.0 + b2;  				}  				else  				{  					hue0To1 = 1.0 - g2;  				}  			}  			else if (green == maxRGB)  			{  				if (blue == minRGB)  				{  					hue0To1 = 1.0 + r2;  				}  				else  				{  					hue0To1 = 3.0 - b2;  				}  			}  			else  			{  				if (red == minRGB)  				{  					hue0To1 = 3.0 + g2;  				}  				else  				{  					hue0To1 = 5.0 - r2;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: if (red == maxRGB)  			{  				if (green == minRGB)  				{  					hue0To1 = 5.0 + b2;  				}  				else  				{  					hue0To1 = 1.0 - g2;  				}  			}  			else if (green == maxRGB)  			{  				if (blue == minRGB)  				{  					hue0To1 = 1.0 + r2;  				}  				else  				{  					hue0To1 = 3.0 - b2;  				}  			}  			else  			{  				if (red == minRGB)  				{  					hue0To1 = 3.0 + g2;  				}  				else  				{  					hue0To1 = 5.0 - r2;  				}  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetHSL,The following statement contains a magic number: hue0To1 /= 6.0;
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl >= 380.0 && wl <= 440.0)  			{  				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));  				t.blue = 1.0f;  			}  			else if (wl >= 440.0 && wl <= 490.0)  			{  				t.green = (float)((wl - 440.0) / (490.0 - 440.0));  				t.blue = 1.0f;  			}  			else if (wl >= 490.0 && wl <= 510.0)  			{  				t.green = 1.0f;  				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));  			}  			else if (wl >= 510.0 && wl <= 580.0)  			{  				t.red = (float)((wl - 510.0) / (580.0 - 510.0));  				t.green = 1.0f;  			}  			else if (wl >= 580.0 && wl <= 645.0)  			{  				t.red = 1.0f;  				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));  			}  			else if (wl >= 645.0 && wl <= 780.0)  			{  				t.red = 1.0f;  			}
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,from_wavelength,The following statement contains a magic number: if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));  			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: red = (byte)Math.Min(Math.Max(r_' 0)' 255);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: green = (byte)Math.Min(Math.Max(g_' 0)' 255);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: blue = (byte)Math.Min(Math.Max(b_' 0)' 255);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: alpha = (byte)Math.Min(Math.Max(a_' 0)' 255);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: red = (byte)((fourByteColor >> 16) & 0xFF);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: green = (byte)((fourByteColor >> 8) & 0xFF);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,RGBA_Bytes,The following statement contains a magic number: alpha = (byte)((fourByteColor >> 24) & 0xFF);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,GetAsHTMLString,The following statement contains a magic number: if (alpha == 255)  			{  				return $"#{red:X2}{green:X2}{blue:X2}";  			}  			else  			{  				return $"#{red:X2}{green:X2}{blue:X2}{alpha:X2}";  			}
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,add,The following statement contains a magic number: if (cover == cover_mask)  			{  				if (c.Alpha0To255 == base_mask)  				{  					this = c;  				}  				else  				{  					cr = Red0To255 + c.Red0To255; Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  					cg = Green0To255 + c.Green0To255; Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  					cb = Blue0To255 + c.Blue0To255; Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  					ca = Alpha0To255 + c.Alpha0To255; Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  				}  			}  			else  			{  				cr = Red0To255 + ((c.Red0To255 * cover + cover_mask / 2) >> cover_shift);  				cg = Green0To255 + ((c.Green0To255 * cover + cover_mask / 2) >> cover_shift);  				cb = Blue0To255 + ((c.Blue0To255 * cover + cover_mask / 2) >> cover_shift);  				ca = Alpha0To255 + ((c.Alpha0To255 * cover + cover_mask / 2) >> cover_shift);  				Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  				Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  				Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  				Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  			}
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,add,The following statement contains a magic number: if (cover == cover_mask)  			{  				if (c.Alpha0To255 == base_mask)  				{  					this = c;  				}  				else  				{  					cr = Red0To255 + c.Red0To255; Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  					cg = Green0To255 + c.Green0To255; Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  					cb = Blue0To255 + c.Blue0To255; Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  					ca = Alpha0To255 + c.Alpha0To255; Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  				}  			}  			else  			{  				cr = Red0To255 + ((c.Red0To255 * cover + cover_mask / 2) >> cover_shift);  				cg = Green0To255 + ((c.Green0To255 * cover + cover_mask / 2) >> cover_shift);  				cb = Blue0To255 + ((c.Blue0To255 * cover + cover_mask / 2) >> cover_shift);  				ca = Alpha0To255 + ((c.Alpha0To255 * cover + cover_mask / 2) >> cover_shift);  				Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  				Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  				Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  				Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  			}
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,add,The following statement contains a magic number: if (cover == cover_mask)  			{  				if (c.Alpha0To255 == base_mask)  				{  					this = c;  				}  				else  				{  					cr = Red0To255 + c.Red0To255; Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  					cg = Green0To255 + c.Green0To255; Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  					cb = Blue0To255 + c.Blue0To255; Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  					ca = Alpha0To255 + c.Alpha0To255; Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  				}  			}  			else  			{  				cr = Red0To255 + ((c.Red0To255 * cover + cover_mask / 2) >> cover_shift);  				cg = Green0To255 + ((c.Green0To255 * cover + cover_mask / 2) >> cover_shift);  				cb = Blue0To255 + ((c.Blue0To255 * cover + cover_mask / 2) >> cover_shift);  				ca = Alpha0To255 + ((c.Alpha0To255 * cover + cover_mask / 2) >> cover_shift);  				Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  				Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  				Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  				Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  			}
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,add,The following statement contains a magic number: if (cover == cover_mask)  			{  				if (c.Alpha0To255 == base_mask)  				{  					this = c;  				}  				else  				{  					cr = Red0To255 + c.Red0To255; Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  					cg = Green0To255 + c.Green0To255; Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  					cb = Blue0To255 + c.Blue0To255; Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  					ca = Alpha0To255 + c.Alpha0To255; Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  				}  			}  			else  			{  				cr = Red0To255 + ((c.Red0To255 * cover + cover_mask / 2) >> cover_shift);  				cg = Green0To255 + ((c.Green0To255 * cover + cover_mask / 2) >> cover_shift);  				cb = Blue0To255 + ((c.Blue0To255 * cover + cover_mask / 2) >> cover_shift);  				ca = Alpha0To255 + ((c.Alpha0To255 * cover + cover_mask / 2) >> cover_shift);  				Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;  				Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;  				Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;  				Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;  			}
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,rgb8_packed,The following statement contains a magic number: return new RGBA_Bytes((v >> 16) & 0xFF' (v >> 8) & 0xFF' v & 0xFF);
Magic Number,MatterHackers.Agg,RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,rgb8_packed,The following statement contains a magic number: return new RGBA_Bytes((v >> 16) & 0xFF' (v >> 8) & 0xFF' v & 0xFF);
Magic Number,MatterHackers.Agg,gamma_threshold,C:\repos\MatterHackers_agg-sharp\agg\agg_gamma_functions.cs,gamma_threshold,The following statement contains a magic number: m_threshold = 0.5;
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,ImageFilterLookUpTable,The following statement contains a magic number: m_weight_array = new ArrayPOD<int>(256);
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,ImageFilterLookUpTable,The following statement contains a magic number: m_weight_array = new ArrayPOD<int>(256);
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,normalize,The following statement contains a magic number: for (i = 0; i < (int)image_subpixel_scale_e.image_subpixel_scale; i++)  			{  				for (; ; )  				{  					int sum = 0;  					int j;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i];  					}    					if (sum == (int)image_filter_scale_e.image_filter_scale) break;    					double k = (double)((int)image_filter_scale_e.image_filter_scale) / (double)(sum);  					sum = 0;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] =  							(int)agg_basics.iround(m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] * k);  					}    					sum -= (int)image_filter_scale_e.image_filter_scale;  					int inc = (sum > 0) ? -1 : 1;    					for (j = 0; j < m_diameter && sum != 0; j++)  					{  						flip ^= 1;  						int idx = flip != 0 ? m_diameter / 2 + j / 2 : m_diameter / 2 - j / 2;  						int v = m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i];  						if (v < (int)image_filter_scale_e.image_filter_scale)  						{  							m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i] += (int)inc;  							sum += inc;  						}  					}  				}  			}
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,normalize,The following statement contains a magic number: for (i = 0; i < (int)image_subpixel_scale_e.image_subpixel_scale; i++)  			{  				for (; ; )  				{  					int sum = 0;  					int j;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i];  					}    					if (sum == (int)image_filter_scale_e.image_filter_scale) break;    					double k = (double)((int)image_filter_scale_e.image_filter_scale) / (double)(sum);  					sum = 0;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] =  							(int)agg_basics.iround(m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] * k);  					}    					sum -= (int)image_filter_scale_e.image_filter_scale;  					int inc = (sum > 0) ? -1 : 1;    					for (j = 0; j < m_diameter && sum != 0; j++)  					{  						flip ^= 1;  						int idx = flip != 0 ? m_diameter / 2 + j / 2 : m_diameter / 2 - j / 2;  						int v = m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i];  						if (v < (int)image_filter_scale_e.image_filter_scale)  						{  							m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i] += (int)inc;  							sum += inc;  						}  					}  				}  			}
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,normalize,The following statement contains a magic number: for (i = 0; i < (int)image_subpixel_scale_e.image_subpixel_scale; i++)  			{  				for (; ; )  				{  					int sum = 0;  					int j;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i];  					}    					if (sum == (int)image_filter_scale_e.image_filter_scale) break;    					double k = (double)((int)image_filter_scale_e.image_filter_scale) / (double)(sum);  					sum = 0;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] =  							(int)agg_basics.iround(m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] * k);  					}    					sum -= (int)image_filter_scale_e.image_filter_scale;  					int inc = (sum > 0) ? -1 : 1;    					for (j = 0; j < m_diameter && sum != 0; j++)  					{  						flip ^= 1;  						int idx = flip != 0 ? m_diameter / 2 + j / 2 : m_diameter / 2 - j / 2;  						int v = m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i];  						if (v < (int)image_filter_scale_e.image_filter_scale)  						{  							m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i] += (int)inc;  							sum += inc;  						}  					}  				}  			}
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,normalize,The following statement contains a magic number: for (i = 0; i < (int)image_subpixel_scale_e.image_subpixel_scale; i++)  			{  				for (; ; )  				{  					int sum = 0;  					int j;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i];  					}    					if (sum == (int)image_filter_scale_e.image_filter_scale) break;    					double k = (double)((int)image_filter_scale_e.image_filter_scale) / (double)(sum);  					sum = 0;  					for (j = 0; j < m_diameter; j++)  					{  						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] =  							(int)agg_basics.iround(m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] * k);  					}    					sum -= (int)image_filter_scale_e.image_filter_scale;  					int inc = (sum > 0) ? -1 : 1;    					for (j = 0; j < m_diameter && sum != 0; j++)  					{  						flip ^= 1;  						int idx = flip != 0 ? m_diameter / 2 + j / 2 : m_diameter / 2 - j / 2;  						int v = m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i];  						if (v < (int)image_filter_scale_e.image_filter_scale)  						{  							m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i] += (int)inc;  							sum += inc;  						}  					}  				}  			}
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,realloc_lut,The following statement contains a magic number: m_diameter = agg_basics.uceil(radius) * 2;
Magic Number,MatterHackers.Agg,ImageFilterLookUpTable,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,realloc_lut,The following statement contains a magic number: m_start = -(int)(m_diameter / 2 - 1);
Magic Number,MatterHackers.Agg,image_filter_hanning,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return 0.5 + 0.5 * Math.Cos(Math.PI * x);
Magic Number,MatterHackers.Agg,image_filter_hanning,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return 0.5 + 0.5 * Math.Cos(Math.PI * x);
Magic Number,MatterHackers.Agg,image_filter_hamming,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return 0.54 + 0.46 * Math.Cos(Math.PI * x);
Magic Number,MatterHackers.Agg,image_filter_hamming,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return 0.54 + 0.46 * Math.Cos(Math.PI * x);
Magic Number,MatterHackers.Agg,image_filter_hermite,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (2.0 * x - 3.0) * x * x + 1.0;
Magic Number,MatterHackers.Agg,image_filter_hermite,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (2.0 * x - 3.0) * x * x + 1.0;
Magic Number,MatterHackers.Agg,image_filter_quadric,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 1.5;
Magic Number,MatterHackers.Agg,image_filter_quadric,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 0.5) return 0.75 - x * x;
Magic Number,MatterHackers.Agg,image_filter_quadric,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 0.5) return 0.75 - x * x;
Magic Number,MatterHackers.Agg,image_filter_quadric,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.5) { t = x - 1.5; return 0.5 * t * t; }
Magic Number,MatterHackers.Agg,image_filter_quadric,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.5) { t = x - 1.5; return 0.5 * t * t; }
Magic Number,MatterHackers.Agg,image_filter_quadric,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.5) { t = x - 1.5; return 0.5 * t * t; }
Magic Number,MatterHackers.Agg,image_filter_bicubic,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 2.0;
Magic Number,MatterHackers.Agg,image_filter_bicubic,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return  				(1.0 / 6.0) *  				(pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
Magic Number,MatterHackers.Agg,image_filter_bicubic,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return  				(1.0 / 6.0) *  				(pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
Magic Number,MatterHackers.Agg,image_filter_bicubic,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return  				(1.0 / 6.0) *  				(pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
Magic Number,MatterHackers.Agg,image_filter_bicubic,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return  				(1.0 / 6.0) *  				(pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
Magic Number,MatterHackers.Agg,image_filter_bicubic,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return  				(1.0 / 6.0) *  				(pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
Magic Number,MatterHackers.Agg,image_filter_kaiser,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_kaiser,The following statement contains a magic number: epsilon = (1e-12);
Magic Number,MatterHackers.Agg,image_filter_kaiser,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,bessel_i0,The following statement contains a magic number: y = x * x / 4.0;
Magic Number,MatterHackers.Agg,image_filter_kaiser,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,bessel_i0,The following statement contains a magic number: for (i = 2; t > epsilon; i++)  			{  				sum += t;  				t *= (double)y / (i * i);  			}
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 2.0;
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0) return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0) return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0) return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0) return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
Magic Number,MatterHackers.Agg,image_filter_catrom,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p0 = ((6.0 - 2.0 * b) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p0 = ((6.0 - 2.0 * b) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p0 = ((6.0 - 2.0 * b) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p2 = ((-18.0 + 12.0 * b + 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p2 = ((-18.0 + 12.0 * b + 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p2 = ((-18.0 + 12.0 * b + 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p2 = ((-18.0 + 12.0 * b + 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p3 = ((12.0 - 9.0 * b - 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p3 = ((12.0 - 9.0 * b - 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p3 = ((12.0 - 9.0 * b - 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: p3 = ((12.0 - 9.0 * b - 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q0 = ((8.0 * b + 24.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q0 = ((8.0 * b + 24.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q0 = ((8.0 * b + 24.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q1 = ((-12.0 * b - 48.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q1 = ((-12.0 * b - 48.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q1 = ((-12.0 * b - 48.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q2 = ((6.0 * b + 30.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q2 = ((6.0 * b + 30.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q2 = ((6.0 * b + 30.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q3 = ((-b - 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_mitchell,The following statement contains a magic number: q3 = ((-b - 6.0 * c) / 6.0);
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 2.0;
Magic Number,MatterHackers.Agg,image_filter_mitchell,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0) return q0 + x * (q1 + x * (q2 + x * q3));
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 2.0;
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((x - 9.0 / 5.0) * x - 1.0 / 5.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((x - 9.0 / 5.0) * x - 1.0 / 5.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((x - 9.0 / 5.0) * x - 1.0 / 5.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
Magic Number,MatterHackers.Agg,image_filter_spline16,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 3.0;
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 1.0)  			{  				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: if (x < 2.0)  			{  				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);  			}
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_spline36,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
Magic Number,MatterHackers.Agg,image_filter_gaussian,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 2.0;
Magic Number,MatterHackers.Agg,image_filter_gaussian,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return Math.Exp(-2.0 * x * x) * Math.Sqrt(2.0 / Math.PI);
Magic Number,MatterHackers.Agg,image_filter_gaussian,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return Math.Exp(-2.0 * x * x) * Math.Sqrt(2.0 / Math.PI);
Magic Number,MatterHackers.Agg,image_filter_bessel,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,radius,The following statement contains a magic number: return 3.2383;
Magic Number,MatterHackers.Agg,image_filter_bessel,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (x == 0.0) ? Math.PI / 4.0 : agg_math.besj(Math.PI * x' 1) / (2.0 * x);
Magic Number,MatterHackers.Agg,image_filter_bessel,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (x == 0.0) ? Math.PI / 4.0 : agg_math.besj(Math.PI * x' 1) / (2.0 * x);
Magic Number,MatterHackers.Agg,image_filter_sinc,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_sinc,The following statement contains a magic number: m_radius = (r < 2.0 ? 2.0 : r);
Magic Number,MatterHackers.Agg,image_filter_sinc,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_sinc,The following statement contains a magic number: m_radius = (r < 2.0 ? 2.0 : r);
Magic Number,MatterHackers.Agg,image_filter_lanczos,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_lanczos,The following statement contains a magic number: m_radius = (r < 2.0 ? 2.0 : r);
Magic Number,MatterHackers.Agg,image_filter_lanczos,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_lanczos,The following statement contains a magic number: m_radius = (r < 2.0 ? 2.0 : r);
Magic Number,MatterHackers.Agg,image_filter_blackman,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_blackman,The following statement contains a magic number: m_radius = (r < 2.0 ? 2.0 : r);
Magic Number,MatterHackers.Agg,image_filter_blackman,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,image_filter_blackman,The following statement contains a magic number: m_radius = (r < 2.0 ? 2.0 : r);
Magic Number,MatterHackers.Agg,image_filter_blackman,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (Math.Sin(x) / x) * (0.42 + 0.5 * Math.Cos(xr) + 0.08 * Math.Cos(2 * xr));
Magic Number,MatterHackers.Agg,image_filter_blackman,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (Math.Sin(x) / x) * (0.42 + 0.5 * Math.Cos(xr) + 0.08 * Math.Cos(2 * xr));
Magic Number,MatterHackers.Agg,image_filter_blackman,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (Math.Sin(x) / x) * (0.42 + 0.5 * Math.Cos(xr) + 0.08 * Math.Cos(2 * xr));
Magic Number,MatterHackers.Agg,image_filter_blackman,C:\repos\MatterHackers_agg-sharp\agg\agg_image_filters.cs,calc_weight,The following statement contains a magic number: return (Math.Sin(x) / x) * (0.42 + 0.5 * Math.Cos(xr) + 0.08 * Math.Cos(2 * xr));
Magic Number,MatterHackers.Agg,line_parameters,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,line_parameters,The following statement contains a magic number: octant = ((sy & 4) | (sx & 2) | (vertical ? 1 : 0));
Magic Number,MatterHackers.Agg,line_parameters,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,line_parameters,The following statement contains a magic number: octant = ((sy & 4) | (sx & 2) | (vertical ? 1 : 0));
Magic Number,MatterHackers.Agg,LineAABasics,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,bisectrix,The following statement contains a magic number: if ((double)(l2.x2 - l2.x1) * (double)(l2.y1 - l1.y1) <  			   (double)(l2.y2 - l2.y1) * (double)(l2.x1 - l1.x1) + 100.0)  			{  				tx -= (tx - l2.x1) * 2.0;  				ty -= (ty - l2.y1) * 2.0;  			}
Magic Number,MatterHackers.Agg,LineAABasics,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,bisectrix,The following statement contains a magic number: if ((double)(l2.x2 - l2.x1) * (double)(l2.y1 - l1.y1) <  			   (double)(l2.y2 - l2.y1) * (double)(l2.x1 - l1.x1) + 100.0)  			{  				tx -= (tx - l2.x1) * 2.0;  				ty -= (ty - l2.y1) * 2.0;  			}
Magic Number,MatterHackers.Agg,LineAABasics,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,bisectrix,The following statement contains a magic number: if ((double)(l2.x2 - l2.x1) * (double)(l2.y1 - l1.y1) <  			   (double)(l2.y2 - l2.y1) * (double)(l2.x1 - l1.x1) + 100.0)  			{  				tx -= (tx - l2.x1) * 2.0;  				ty -= (ty - l2.y1) * 2.0;  			}
Magic Number,MatterHackers.Agg,LineAABasics,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,fix_degenerate_bisectrix_start,The following statement contains a magic number: if (d < line_subpixel_scale / 2)  			{  				x = lp.x1 + (lp.y2 - lp.y1);  				y = lp.y1 - (lp.x2 - lp.x1);  			}
Magic Number,MatterHackers.Agg,LineAABasics,C:\repos\MatterHackers_agg-sharp\agg\agg_line_aa_basics.cs,fix_degenerate_bisectrix_end,The following statement contains a magic number: if (d < line_subpixel_scale / 2)  			{  				x = lp.x2 + (lp.y2 - lp.y1);  				y = lp.y2 - (lp.x2 - lp.x1);  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: x[2] = x2 + dx2;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: y[2] = y2 + dy2;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: x[3] = x3 + dx2;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: y[3] = y3 + dy2;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: x[4] = x3 + dx3;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: y[4] = y3 + dy3;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: x[5] = x1 + dx3;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,dilate_triangle,The following statement contains a magic number: y[5] = y1 + dy3;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_triangle_area,The following statement contains a magic number: return (x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3) * 0.5;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,calc_polygon_area,The following statement contains a magic number: return (sum + x * ys - y * xs) * 0.5;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: int shift = 11;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: bit = (int)t >> 24;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: if (bit != 0)  			{  				bit = g_elder_bit_table[bit] + 24;  			}  			else  			{  				bit = ((int)t >> 16) & 0xFF;  				if (bit != 0)  				{  					bit = g_elder_bit_table[bit] + 16;  				}  				else  				{  					bit = ((int)t >> 8) & 0xFF;  					if (bit != 0)  					{  						bit = g_elder_bit_table[bit] + 8;  					}  					else  					{  						bit = g_elder_bit_table[t];  					}  				}  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: if (bit != 0)  			{  				bit = g_elder_bit_table[bit] + 24;  			}  			else  			{  				bit = ((int)t >> 16) & 0xFF;  				if (bit != 0)  				{  					bit = g_elder_bit_table[bit] + 16;  				}  				else  				{  					bit = ((int)t >> 8) & 0xFF;  					if (bit != 0)  					{  						bit = g_elder_bit_table[bit] + 8;  					}  					else  					{  						bit = g_elder_bit_table[t];  					}  				}  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: if (bit != 0)  			{  				bit = g_elder_bit_table[bit] + 24;  			}  			else  			{  				bit = ((int)t >> 16) & 0xFF;  				if (bit != 0)  				{  					bit = g_elder_bit_table[bit] + 16;  				}  				else  				{  					bit = ((int)t >> 8) & 0xFF;  					if (bit != 0)  					{  						bit = g_elder_bit_table[bit] + 8;  					}  					else  					{  						bit = g_elder_bit_table[t];  					}  				}  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: if (bit != 0)  			{  				bit = g_elder_bit_table[bit] + 24;  			}  			else  			{  				bit = ((int)t >> 16) & 0xFF;  				if (bit != 0)  				{  					bit = g_elder_bit_table[bit] + 16;  				}  				else  				{  					bit = ((int)t >> 8) & 0xFF;  					if (bit != 0)  					{  						bit = g_elder_bit_table[bit] + 8;  					}  					else  					{  						bit = g_elder_bit_table[t];  					}  				}  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: if (bit != 0)  			{  				bit = g_elder_bit_table[bit] + 24;  			}  			else  			{  				bit = ((int)t >> 16) & 0xFF;  				if (bit != 0)  				{  					bit = g_elder_bit_table[bit] + 16;  				}  				else  				{  					bit = ((int)t >> 8) & 0xFF;  					if (bit != 0)  					{  						bit = g_elder_bit_table[bit] + 8;  					}  					else  					{  						bit = g_elder_bit_table[t];  					}  				}  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,fast_sqrt,The following statement contains a magic number: bit -= 9;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: double d = 1E-6;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: int m1 = (int)Math.Abs(x) + 6;
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: if (Math.Abs(x) > 5)  			{  				m1 = (int)(Math.Abs(1.4 * x + 60 / x));  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: if (Math.Abs(x) > 5)  			{  				m1 = (int)(Math.Abs(1.4 * x + 60 / x));  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: if (Math.Abs(x) > 5)  			{  				m1 = (int)(Math.Abs(1.4 * x + 60 / x));  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: int m2 = (int)(n + 2 + Math.Abs(x) / 4);
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: int m2 = (int)(n + 2 + Math.Abs(x) / 4);
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,agg_math,C:\repos\MatterHackers_agg-sharp\agg\agg_math.cs,besj,The following statement contains a magic number: for (; ; )  			{  				double c3 = 0;  				double c2 = 1E-30;  				double c4 = 0;  				int m8 = 1;  				if (m2 / 2 * 2 == m2)  				{  					m8 = -1;  				}  				int imax = m2 - 2;  				for (int i = 1; i <= imax; i++)  				{  					double c6t = 2 * (m2 - i) * c2 / x - c3;  					c3 = c2;  					c2 = c6t;  					if (m2 - i - 1 == n)  					{  						b = c6t;  					}  					m8 = -1 * m8;  					if (m8 > 0)  					{  						c4 = c4 + 2 * c6t;  					}  				}  				double c6 = 2 * c2 / x - c3;  				if (n == 0)  				{  					b = c6;  				}  				c4 += c6;  				b /= c4;  				if (Math.Abs(b - b1) < d)  				{  					return b;  				}  				b1 = b;  				m2 += 3;  			}
Magic Number,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The following statement contains a magic number: r = g = b = a = LineAABasics.line_subpixel_scale * LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The following statement contains a magic number: destBuffer[destBufferOffset].red = (byte)(r >> LineAABasics.line_subpixel_shift * 2);
Magic Number,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The following statement contains a magic number: destBuffer[destBufferOffset].green = (byte)(g >> LineAABasics.line_subpixel_shift * 2);
Magic Number,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The following statement contains a magic number: destBuffer[destBufferOffset].blue = (byte)(b >> LineAABasics.line_subpixel_shift * 2);
Magic Number,MatterHackers.Agg,pattern_filter_bilinear_RGBA_Bytes,C:\repos\MatterHackers_agg-sharp\agg\agg_pattern_filters_rgba.cs,pixel_high_res,The following statement contains a magic number: destBuffer[destBufferOffset].alpha = (byte)(a >> LineAABasics.line_subpixel_shift * 2);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,rewind_scanlines,The following statement contains a magic number: m_styles.Allocate((int)(m_max_style - m_min_style + 2)' 128);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,rewind_scanlines,The following statement contains a magic number: m_styles.Allocate((int)(m_max_style - m_min_style + 2)' 128);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,sweep_styles,The following statement contains a magic number: for (; ; )  			{  				if (m_scan_y > m_Rasterizer.max_y()) return 0;  				int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  				cell_aa[] cells;  				int cellOffset = 0;  				int curCellOffset;  				m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);  				int num_styles = (int)(m_max_style - m_min_style + 2);  				int style_id;  				int styleOffset = 0;    				m_cells.Allocate((int)num_cells * 2' 256); // Each cell can have two styles  				m_ast.Capacity(num_styles' 64);  				m_asm.Allocate((num_styles + 7) >> 3' 8);  				m_asm.zero();    				if (num_cells > 0)  				{  					// Pre-add zero (for no-fill style' that is' -1).  					// We need that to ensure that the "-1 style" would go first.  					m_asm.Array[0] |= 1;  					m_ast.add(0);  					m_styles.Array[styleOffset].start_cell = 0;  					m_styles.Array[styleOffset].num_cells = 0;  					m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;    					m_sl_start = cells[0].x;  					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);  					while (num_cells-- != 0)  					{  						curCellOffset = (int)cellOffset++;  						add_style(cells[curCellOffset].left);  						add_style(cells[curCellOffset].right);  					}    					// Convert the Y-histogram into the array of starting indexes  					int i;  					int start_cell = 0;  					style_info[] stylesArray = m_styles.Array;  					for (i = 0; i < m_ast.size(); i++)  					{  						int IndexToModify = (int)m_ast[i];  						int v = stylesArray[IndexToModify].start_cell;  						stylesArray[IndexToModify].start_cell = start_cell;  						start_cell += v;  					}    					num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);  					m_Rasterizer.scanline_cells(m_scan_y' out cells' out cellOffset);    					while (num_cells-- > 0)  					{  						curCellOffset = (int)cellOffset++;  						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :  									cells[curCellOffset].left - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area += cells[curCellOffset].area;  								cells[cellOffset].cover += cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = cells[curCellOffset].area;  							cells[cellOffset].cover = cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}    						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :  									cells[curCellOffset].right - m_min_style + 1);    						styleOffset = (int)style_id;  						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;  							unchecked  							{  								cells[cellOffset].area -= cells[curCellOffset].area;  								cells[cellOffset].cover -= cells[curCellOffset].cover;  							}  						}  						else  						{  							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;  							cells[cellOffset].x = cells[curCellOffset].x;  							cells[cellOffset].area = -cells[curCellOffset].area;  							cells[cellOffset].cover = -cells[curCellOffset].cover;  							stylesArray[styleOffset].last_x = cells[curCellOffset].x;  							stylesArray[styleOffset].num_cells++;  						}  					}  				}  				if (m_ast.size() > 1) break;  				++m_scan_y;  			}
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,navigate_scanline,The following statement contains a magic number: m_styles.Allocate((int)(m_max_style - m_min_style + 2)' 128);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,navigate_scanline,The following statement contains a magic number: m_styles.Allocate((int)(m_max_style - m_min_style + 2)' 128);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,allocate_cover_buffer,The following statement contains a magic number: m_cover_buf.Allocate(len' 256);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,calculate_alpha,The following statement contains a magic number: int cover = area >> (poly_subpixel_shift * 2 + 1 - aa_shift);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,add_style,The following statement contains a magic number: int nbyte = (int)((int)style_id >> 3);
Magic Number,MatterHackers.Agg,rasterizer_compound_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_compound_aa.cs,add_style,The following statement contains a magic number: int mask = (int)(1 << (style_id & 7));
Magic Number,MatterHackers.Agg,line_aa_vertex,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,Compare,The following statement contains a magic number: return (len = agg_basics.uround(Math.Sqrt(dx * dx + dy * dy))) >  				   (LineAABasics.line_subpixel_scale + LineAABasics.line_subpixel_scale / 2);
Magic Number,MatterHackers.Agg,line_aa_vertex_sequence,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,add,The following statement contains a magic number: if (base.size() > 1)  			{  				if (!Array[base.size() - 2].Compare(Array[base.size() - 1]))  				{  					base.RemoveLast();  				}  			}
Magic Number,MatterHackers.Agg,line_aa_vertex_sequence,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,close,The following statement contains a magic number: while (base.size() > 1)  			{  				if (Array[base.size() - 2].Compare(Array[base.size() - 1])) break;  				line_aa_vertex t = this[base.size() - 1];  				base.RemoveLast();  				modify_last(t);  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following statement contains a magic number: for (i = start; i < end; i++)  			{  				if (m_line_join == outline_aa_join_e.outline_round_join)  				{  					dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);  					dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);  					dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);  					dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);  				}    				switch (dv.flags)  				{  					case 0: m_ren.line3(dv.curr' dv.xb1' dv.yb1' dv.xb2' dv.yb2); break;  					case 1: m_ren.line2(dv.curr' dv.xb2' dv.yb2); break;  					case 2: m_ren.line1(dv.curr' dv.xb1' dv.yb1); break;  					case 3: m_ren.line0(dv.curr); break;  				}    				if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)  				{  					m_ren.pie(dv.curr.x2' dv.curr.y2'  							   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  							   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1)'  							   dv.curr.x2 + (dv.next.y2 - dv.next.y1)'  							   dv.curr.y2 - (dv.next.x2 - dv.next.x1));  				}    				dv.x1 = dv.x2;  				dv.y1 = dv.y2;  				dv.lcurr = dv.lnext;  				dv.lnext = m_src_vertices[dv.idx].len;    				++dv.idx;  				if (dv.idx >= m_src_vertices.size()) dv.idx = 0;    				dv.x2 = m_src_vertices[dv.idx].x;  				dv.y2 = m_src_vertices[dv.idx].y;    				dv.curr = dv.next;  				dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);  				dv.xb1 = dv.xb2;  				dv.yb1 = dv.yb2;    				switch (m_line_join)  				{  					case outline_aa_join_e.outline_no_join:  						dv.flags = 3;  						break;    					case outline_aa_join_e.outline_miter_join:  						dv.flags >>= 1;  						dv.flags |= (dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant() ? 1 : 0);  						if ((dv.flags & 2) == 0)  						{  							LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						}  						break;    					case outline_aa_join_e.outline_round_join:  						dv.flags >>= 1;  						dv.flags |= (((dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);  						break;    					case outline_aa_join_e.outline_miter_accurate_join:  						dv.flags = 0;  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following statement contains a magic number: for (i = start; i < end; i++)  			{  				if (m_line_join == outline_aa_join_e.outline_round_join)  				{  					dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);  					dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);  					dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);  					dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);  				}    				switch (dv.flags)  				{  					case 0: m_ren.line3(dv.curr' dv.xb1' dv.yb1' dv.xb2' dv.yb2); break;  					case 1: m_ren.line2(dv.curr' dv.xb2' dv.yb2); break;  					case 2: m_ren.line1(dv.curr' dv.xb1' dv.yb1); break;  					case 3: m_ren.line0(dv.curr); break;  				}    				if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)  				{  					m_ren.pie(dv.curr.x2' dv.curr.y2'  							   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  							   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1)'  							   dv.curr.x2 + (dv.next.y2 - dv.next.y1)'  							   dv.curr.y2 - (dv.next.x2 - dv.next.x1));  				}    				dv.x1 = dv.x2;  				dv.y1 = dv.y2;  				dv.lcurr = dv.lnext;  				dv.lnext = m_src_vertices[dv.idx].len;    				++dv.idx;  				if (dv.idx >= m_src_vertices.size()) dv.idx = 0;    				dv.x2 = m_src_vertices[dv.idx].x;  				dv.y2 = m_src_vertices[dv.idx].y;    				dv.curr = dv.next;  				dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);  				dv.xb1 = dv.xb2;  				dv.yb1 = dv.yb2;    				switch (m_line_join)  				{  					case outline_aa_join_e.outline_no_join:  						dv.flags = 3;  						break;    					case outline_aa_join_e.outline_miter_join:  						dv.flags >>= 1;  						dv.flags |= (dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant() ? 1 : 0);  						if ((dv.flags & 2) == 0)  						{  							LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						}  						break;    					case outline_aa_join_e.outline_round_join:  						dv.flags >>= 1;  						dv.flags |= (((dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);  						break;    					case outline_aa_join_e.outline_miter_accurate_join:  						dv.flags = 0;  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following statement contains a magic number: for (i = start; i < end; i++)  			{  				if (m_line_join == outline_aa_join_e.outline_round_join)  				{  					dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);  					dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);  					dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);  					dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);  				}    				switch (dv.flags)  				{  					case 0: m_ren.line3(dv.curr' dv.xb1' dv.yb1' dv.xb2' dv.yb2); break;  					case 1: m_ren.line2(dv.curr' dv.xb2' dv.yb2); break;  					case 2: m_ren.line1(dv.curr' dv.xb1' dv.yb1); break;  					case 3: m_ren.line0(dv.curr); break;  				}    				if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)  				{  					m_ren.pie(dv.curr.x2' dv.curr.y2'  							   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  							   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1)'  							   dv.curr.x2 + (dv.next.y2 - dv.next.y1)'  							   dv.curr.y2 - (dv.next.x2 - dv.next.x1));  				}    				dv.x1 = dv.x2;  				dv.y1 = dv.y2;  				dv.lcurr = dv.lnext;  				dv.lnext = m_src_vertices[dv.idx].len;    				++dv.idx;  				if (dv.idx >= m_src_vertices.size()) dv.idx = 0;    				dv.x2 = m_src_vertices[dv.idx].x;  				dv.y2 = m_src_vertices[dv.idx].y;    				dv.curr = dv.next;  				dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);  				dv.xb1 = dv.xb2;  				dv.yb1 = dv.yb2;    				switch (m_line_join)  				{  					case outline_aa_join_e.outline_no_join:  						dv.flags = 3;  						break;    					case outline_aa_join_e.outline_miter_join:  						dv.flags >>= 1;  						dv.flags |= (dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant() ? 1 : 0);  						if ((dv.flags & 2) == 0)  						{  							LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						}  						break;    					case outline_aa_join_e.outline_round_join:  						dv.flags >>= 1;  						dv.flags |= (((dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);  						break;    					case outline_aa_join_e.outline_miter_accurate_join:  						dv.flags = 0;  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following statement contains a magic number: for (i = start; i < end; i++)  			{  				if (m_line_join == outline_aa_join_e.outline_round_join)  				{  					dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);  					dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);  					dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);  					dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);  				}    				switch (dv.flags)  				{  					case 0: m_ren.line3(dv.curr' dv.xb1' dv.yb1' dv.xb2' dv.yb2); break;  					case 1: m_ren.line2(dv.curr' dv.xb2' dv.yb2); break;  					case 2: m_ren.line1(dv.curr' dv.xb1' dv.yb1); break;  					case 3: m_ren.line0(dv.curr); break;  				}    				if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)  				{  					m_ren.pie(dv.curr.x2' dv.curr.y2'  							   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  							   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1)'  							   dv.curr.x2 + (dv.next.y2 - dv.next.y1)'  							   dv.curr.y2 - (dv.next.x2 - dv.next.x1));  				}    				dv.x1 = dv.x2;  				dv.y1 = dv.y2;  				dv.lcurr = dv.lnext;  				dv.lnext = m_src_vertices[dv.idx].len;    				++dv.idx;  				if (dv.idx >= m_src_vertices.size()) dv.idx = 0;    				dv.x2 = m_src_vertices[dv.idx].x;  				dv.y2 = m_src_vertices[dv.idx].y;    				dv.curr = dv.next;  				dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);  				dv.xb1 = dv.xb2;  				dv.yb1 = dv.yb2;    				switch (m_line_join)  				{  					case outline_aa_join_e.outline_no_join:  						dv.flags = 3;  						break;    					case outline_aa_join_e.outline_miter_join:  						dv.flags >>= 1;  						dv.flags |= (dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant() ? 1 : 0);  						if ((dv.flags & 2) == 0)  						{  							LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						}  						break;    					case outline_aa_join_e.outline_round_join:  						dv.flags >>= 1;  						dv.flags |= (((dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);  						break;    					case outline_aa_join_e.outline_miter_accurate_join:  						dv.flags = 0;  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following statement contains a magic number: for (i = start; i < end; i++)  			{  				if (m_line_join == outline_aa_join_e.outline_round_join)  				{  					dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);  					dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);  					dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);  					dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);  				}    				switch (dv.flags)  				{  					case 0: m_ren.line3(dv.curr' dv.xb1' dv.yb1' dv.xb2' dv.yb2); break;  					case 1: m_ren.line2(dv.curr' dv.xb2' dv.yb2); break;  					case 2: m_ren.line1(dv.curr' dv.xb1' dv.yb1); break;  					case 3: m_ren.line0(dv.curr); break;  				}    				if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)  				{  					m_ren.pie(dv.curr.x2' dv.curr.y2'  							   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  							   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1)'  							   dv.curr.x2 + (dv.next.y2 - dv.next.y1)'  							   dv.curr.y2 - (dv.next.x2 - dv.next.x1));  				}    				dv.x1 = dv.x2;  				dv.y1 = dv.y2;  				dv.lcurr = dv.lnext;  				dv.lnext = m_src_vertices[dv.idx].len;    				++dv.idx;  				if (dv.idx >= m_src_vertices.size()) dv.idx = 0;    				dv.x2 = m_src_vertices[dv.idx].x;  				dv.y2 = m_src_vertices[dv.idx].y;    				dv.curr = dv.next;  				dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);  				dv.xb1 = dv.xb2;  				dv.yb1 = dv.yb2;    				switch (m_line_join)  				{  					case outline_aa_join_e.outline_no_join:  						dv.flags = 3;  						break;    					case outline_aa_join_e.outline_miter_join:  						dv.flags >>= 1;  						dv.flags |= (dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant() ? 1 : 0);  						if ((dv.flags & 2) == 0)  						{  							LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						}  						break;    					case outline_aa_join_e.outline_round_join:  						dv.flags >>= 1;  						dv.flags |= (((dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);  						break;    					case outline_aa_join_e.outline_miter_accurate_join:  						dv.flags = 0;  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following statement contains a magic number: if (close_polygon)  			{  				if (m_src_vertices.size() >= 3)  				{  					dv.idx = 2;    					v = m_src_vertices[m_src_vertices.size() - 1];  					x1 = v.x;  					y1 = v.y;  					lprev = v.len;    					v = m_src_vertices[0];  					x2 = v.x;  					y2 = v.y;  					dv.lcurr = v.len;  					line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    					v = m_src_vertices[1];  					dv.x1 = v.x;  					dv.y1 = v.y;  					dv.lnext = v.len;  					dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    					v = m_src_vertices[dv.idx];  					dv.x2 = v.x;  					dv.y2 = v.y;  					dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    					dv.xb1 = 0;  					dv.yb1 = 0;  					dv.xb2 = 0;  					dv.yb2 = 0;    					switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}    					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  					}    					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  					{  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  					}  					draw(ref dv' 0' m_src_vertices.size());  				}  			}  			else  			{  				switch (m_src_vertices.size())  				{  					case 0:  					case 1:  						break;    					case 2:  						{  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							line_parameters lp = new line_parameters(x1' y1' x2' y2' lprev);  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							m_ren.line3(lp'  										 x1 + (y2 - y1)'  										 y1 - (x2 - x1)'  										 x2 + (y2 - y1)'  										 y2 - (x2 - x1));  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1));  							}  						}  						break;    					case 3:  						{  							int x3' y3;  							int lnext;  							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;  							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							lnext = v.len;  							v = m_src_vertices[2];  							x3 = v.x;  							y3 = v.y;  							line_parameters lp1 = new line_parameters(x1' y1' x2' y2' lprev);  							line_parameters lp2 = new line_parameters(x2' y2' x3' y3' lnext);    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}    							if (m_line_join == outline_aa_join_e.outline_round_join)  							{  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  x2 + (y2 - y1)' y2 - (x2 - x1));    								m_ren.pie(x2' y2' x2 + (y2 - y1)' y2 - (x2 - x1)'  												   x2 + (y3 - y2)' y2 - (x3 - x2));    								m_ren.line3(lp2' x2 + (y3 - y2)' y2 - (x3 - x2)'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							else  							{  								LineAABasics.bisectrix(lp1' lp2' out dv.xb1' out dv.yb1);  								m_ren.line3(lp1' x1 + (y2 - y1)' y1 - (x2 - x1)'  												  dv.xb1' dv.yb1);    								m_ren.line3(lp2' dv.xb1' dv.yb1'  												  x3 + (y3 - y2)' y3 - (x3 - x2));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' x3' y3' x3 + (y3 - y2)' y3 - (x3 - x2));  							}  						}  						break;    					default:  						{  							dv.idx = 3;    							v = m_src_vertices[0];  							x1 = v.x;  							y1 = v.y;  							lprev = v.len;    							v = m_src_vertices[1];  							x2 = v.x;  							y2 = v.y;  							dv.lcurr = v.len;  							line_parameters prev = new line_parameters(x1' y1' x2' y2' lprev);    							v = m_src_vertices[2];  							dv.x1 = v.x;  							dv.y1 = v.y;  							dv.lnext = v.len;  							dv.curr = new line_parameters(x2' y2' dv.x1' dv.y1' dv.lcurr);    							v = m_src_vertices[dv.idx];  							dv.x2 = v.x;  							dv.y2 = v.y;  							dv.next = new line_parameters(dv.x1' dv.y1' dv.x2' dv.y2' dv.lnext);    							dv.xb1 = 0;  							dv.yb1 = 0;  							dv.xb2 = 0;  							dv.yb2 = 0;    							switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}    							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_start' x1' y1' x1 + (y2 - y1)' y1 - (x2 - x1));  							}  							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   x2 + (y2 - y1)' y2 - (x2 - x1));  									m_ren.pie(prev.x2' prev.y2'  											   x2 + (y2 - y1)' y2 - (x2 - x1)'  											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									LineAABasics.bisectrix(prev' dv.curr' out dv.xb1' out dv.yb1);  									m_ren.line3(prev' x1 + (y2 - y1)' y1 - (x2 - x1)'  													   dv.xb1' dv.yb1);  								}  							}  							else  							{  								m_ren.line1(prev'  											 x1 + (y2 - y1)'  											 y1 - (x2 - x1));  							}  							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)  							{  								LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  							}    							draw(ref dv' 1' m_src_vertices.size() - 2);    							if ((dv.flags & 1) == 0)  							{  								if (m_line_join == outline_aa_join_e.outline_round_join)  								{  									m_ren.line3(dv.curr'  												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1)'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  								else  								{  									m_ren.line3(dv.curr' dv.xb1' dv.yb1'  												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  								}  							}  							else  							{  								m_ren.line2(dv.curr'  											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  							if (m_round_cap)  							{  								m_ren.semidot(cmp_dist_end' dv.curr.x2' dv.curr.y2'  											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1)'  											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));  							}  						}  						break;  				}  			}
Magic Number,MatterHackers.Agg,DumpCallStackIfSlow,C:\repos\MatterHackers_agg-sharp\agg\DumpCallStackIfSlow.cs,DumpCallStackIfSlow,The following statement contains a magic number: millisecondsToReportIfOver = (int)(maxSecondsBeforePrintCallStack * 1000);
Magic Number,MatterHackers.Agg,ScanlineRasterizer,C:\repos\MatterHackers_agg-sharp\agg\ScanlineRasterizer.cs,calculate_alpha,The following statement contains a magic number: int cover = area >> ((int)poly_subpixel_scale_e.poly_subpixel_shift * 2 + 1 - (int)aa_scale_e.aa_shift);
Magic Number,MatterHackers.Agg,ShapePath,C:\repos\MatterHackers_agg-sharp\agg\ShapePath.cs,shorten_path,The following statement contains a magic number: if (s > 0.0 && vs.size() > 1)  			{  				double d;  				int n = (int)(vs.size() - 2);  				while (n != 0)  				{  					d = vs[n].dist;  					if (d > s) break;  					vs.RemoveLast();  					s -= d;  					--n;  				}  				if (vs.size() < 2)  				{  					vs.remove_all();  				}  				else  				{  					n = (int)vs.size() - 1;  					VertexDistance prev = vs[n - 1];  					VertexDistance last = vs[n];  					d = (prev.dist - s) / prev.dist;  					double x = prev.x + (last.x - prev.x) * d;  					double y = prev.y + (last.y - prev.y) * d;  					last.x = x;  					last.y = y;  					if (!prev.IsEqual(last)) vs.RemoveLast();  					vs.close(closed != 0);  				}  			}
Magic Number,MatterHackers.Agg,ShapePath,C:\repos\MatterHackers_agg-sharp\agg\ShapePath.cs,shorten_path,The following statement contains a magic number: if (s > 0.0 && vs.size() > 1)  			{  				double d;  				int n = (int)(vs.size() - 2);  				while (n != 0)  				{  					d = vs[n].dist;  					if (d > s) break;  					vs.RemoveLast();  					s -= d;  					--n;  				}  				if (vs.size() < 2)  				{  					vs.remove_all();  				}  				else  				{  					n = (int)vs.size() - 1;  					VertexDistance prev = vs[n - 1];  					VertexDistance last = vs[n];  					d = (prev.dist - s) / prev.dist;  					double x = prev.x + (last.x - prev.x) * d;  					double y = prev.y + (last.y - prev.y) * d;  					last.x = x;  					last.y = y;  					if (!prev.IsEqual(last)) vs.RemoveLast();  					vs.close(closed != 0);  				}  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The following statement contains a magic number: f1 &= 10;
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The following statement contains a magic number: f2 &= 10;
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The following statement contains a magic number: if ((f1 | f2) == 0)  			{  				// Fully visible  				ras.line(x1' y1' x2' y2);  			}  			else  			{  				if (f1 == f2)  				{  					// Invisible by Y  					return;  				}    				int tx1 = x1;  				int ty1 = y1;  				int tx2 = x2;  				int ty2 = y2;    				if ((f1 & 8) != 0) // y1 < clip.y1  				{  					tx1 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Bottom;  				}    				if ((f1 & 2) != 0) // y1 > clip.y2  				{  					tx1 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Top;  				}    				if ((f2 & 8) != 0) // y2 < clip.y1  				{  					tx2 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Bottom;  				}    				if ((f2 & 2) != 0) // y2 > clip.y2  				{  					tx2 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Top;  				}    				ras.line(tx1' ty1' tx2' ty2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The following statement contains a magic number: if ((f1 | f2) == 0)  			{  				// Fully visible  				ras.line(x1' y1' x2' y2);  			}  			else  			{  				if (f1 == f2)  				{  					// Invisible by Y  					return;  				}    				int tx1 = x1;  				int ty1 = y1;  				int tx2 = x2;  				int ty2 = y2;    				if ((f1 & 8) != 0) // y1 < clip.y1  				{  					tx1 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Bottom;  				}    				if ((f1 & 2) != 0) // y1 > clip.y2  				{  					tx1 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Top;  				}    				if ((f2 & 8) != 0) // y2 < clip.y1  				{  					tx2 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Bottom;  				}    				if ((f2 & 2) != 0) // y2 > clip.y2  				{  					tx2 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Top;  				}    				ras.line(tx1' ty1' tx2' ty2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The following statement contains a magic number: if ((f1 | f2) == 0)  			{  				// Fully visible  				ras.line(x1' y1' x2' y2);  			}  			else  			{  				if (f1 == f2)  				{  					// Invisible by Y  					return;  				}    				int tx1 = x1;  				int ty1 = y1;  				int tx2 = x2;  				int ty2 = y2;    				if ((f1 & 8) != 0) // y1 < clip.y1  				{  					tx1 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Bottom;  				}    				if ((f1 & 2) != 0) // y1 > clip.y2  				{  					tx1 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Top;  				}    				if ((f2 & 8) != 0) // y2 < clip.y1  				{  					tx2 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Bottom;  				}    				if ((f2 & 2) != 0) // y2 > clip.y2  				{  					tx2 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Top;  				}    				ras.line(tx1' ty1' tx2' ty2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_clip_y,The following statement contains a magic number: if ((f1 | f2) == 0)  			{  				// Fully visible  				ras.line(x1' y1' x2' y2);  			}  			else  			{  				if (f1 == f2)  				{  					// Invisible by Y  					return;  				}    				int tx1 = x1;  				int ty1 = y1;  				int tx2 = x2;  				int ty2 = y2;    				if ((f1 & 8) != 0) // y1 < clip.y1  				{  					tx1 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Bottom;  				}    				if ((f1 & 2) != 0) // y1 > clip.y2  				{  					tx1 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty1 = clipBox.Top;  				}    				if ((f2 & 8) != 0) // y2 < clip.y1  				{  					tx2 = x1 + mul_div(clipBox.Bottom - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Bottom;  				}    				if ((f2 & 2) != 0) // y2 > clip.y2  				{  					tx2 = x1 + mul_div(clipBox.Top - y1' x2 - x1' y2 - y1);  					ty2 = clipBox.Top;  				}    				ras.line(tx1' ty1' tx2' ty2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following statement contains a magic number: if (m_clipping)  			{  				int f2 = ClipLiangBarsky.clipping_flags(x2' y2' clipBox);    				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)  				{  					// Invisible by Y  					m_x1 = x2;  					m_y1 = y2;  					m_f1 = f2;  					return;  				}    				int x1 = m_x1;  				int y1 = m_y1;  				int f1 = m_f1;  				int y3' y4;  				int f3' f4;    				switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}  				m_f1 = f2;  			}  			else  			{  				ras.line(m_x1' m_y1'  						 x2' y2);  			}
Magic Number,MatterHackers.Agg,distance_interpolator0,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator0,The following statement contains a magic number: unchecked  			{  				m_dx = (LineAABasics.line_mr(x2) - LineAABasics.line_mr(x1));  				m_dy = (LineAABasics.line_mr(y2) - LineAABasics.line_mr(y1));  				m_dist = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy -  					   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx);    				m_dx <<= LineAABasics.line_mr_subpixel_shift;  				m_dy <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator0,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator0,The following statement contains a magic number: unchecked  			{  				m_dx = (LineAABasics.line_mr(x2) - LineAABasics.line_mr(x1));  				m_dy = (LineAABasics.line_mr(y2) - LineAABasics.line_mr(y1));  				m_dist = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy -  					   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx);    				m_dx <<= LineAABasics.line_mr_subpixel_shift;  				m_dy <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator00,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator00,The following statement contains a magic number: m_dist1 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x1)) * m_dy1 -  					(LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y1)) * m_dx1);
Magic Number,MatterHackers.Agg,distance_interpolator00,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator00,The following statement contains a magic number: m_dist1 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x1)) * m_dy1 -  					(LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y1)) * m_dx1);
Magic Number,MatterHackers.Agg,distance_interpolator00,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator00,The following statement contains a magic number: m_dist2 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy2 -  					(LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx2);
Magic Number,MatterHackers.Agg,distance_interpolator00,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator00,The following statement contains a magic number: m_dist2 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy2 -  					(LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx2);
Magic Number,MatterHackers.Agg,distance_interpolator1,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator1,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator1,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator1,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_start -  						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_start);
Magic Number,MatterHackers.Agg,distance_interpolator2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator2,The following statement contains a magic number: m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_start -  						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_start);
Magic Number,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The following statement contains a magic number: unchecked  			{  				m_dx = (x2 - x1);  				m_dy = (y2 - y1);  				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));  				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));  				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));  				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));    				m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));    				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);    				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);    				m_dx <<= LineAABasics.line_subpixel_shift;  				m_dy <<= LineAABasics.line_subpixel_shift;  				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The following statement contains a magic number: unchecked  			{  				m_dx = (x2 - x1);  				m_dy = (y2 - y1);  				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));  				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));  				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));  				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));    				m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));    				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);    				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);    				m_dx <<= LineAABasics.line_subpixel_shift;  				m_dy <<= LineAABasics.line_subpixel_shift;  				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The following statement contains a magic number: unchecked  			{  				m_dx = (x2 - x1);  				m_dy = (y2 - y1);  				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));  				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));  				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));  				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));    				m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));    				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);    				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);    				m_dx <<= LineAABasics.line_subpixel_shift;  				m_dy <<= LineAABasics.line_subpixel_shift;  				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The following statement contains a magic number: unchecked  			{  				m_dx = (x2 - x1);  				m_dy = (y2 - y1);  				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));  				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));  				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));  				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));    				m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));    				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);    				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);    				m_dx <<= LineAABasics.line_subpixel_shift;  				m_dy <<= LineAABasics.line_subpixel_shift;  				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The following statement contains a magic number: unchecked  			{  				m_dx = (x2 - x1);  				m_dy = (y2 - y1);  				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));  				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));  				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));  				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));    				m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));    				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);    				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);    				m_dx <<= LineAABasics.line_subpixel_shift;  				m_dy <<= LineAABasics.line_subpixel_shift;  				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,distance_interpolator3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,distance_interpolator3,The following statement contains a magic number: unchecked  			{  				m_dx = (x2 - x1);  				m_dy = (y2 - y1);  				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));  				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));  				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));  				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));    				m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));    				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);    				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);    				m_dx <<= LineAABasics.line_subpixel_shift;  				m_dy <<= LineAABasics.line_subpixel_shift;  				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;  				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;  				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;  			}
Magic Number,MatterHackers.Agg,line_interpolator_aa_base,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line_interpolator_aa_base,The following statement contains a magic number: int stop = m_width + LineAABasics.line_subpixel_scale * 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa0,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_hor,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa0,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_ver,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa1,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_hor,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa1,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_ver,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_hor,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa2,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_ver,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_hor,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,line_interpolator_aa3,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,step_ver,The following statement contains a magic number: int Offset0 = max_half_width + 2;
Magic Number,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,width,The following statement contains a magic number: w *= 0.5;
Magic Number,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,value,The following statement contains a magic number: return m_profile.Array[dist + subpixel_scale * 2];
Magic Number,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,profile,The following statement contains a magic number: int size = m_subpixel_width + subpixel_scale * 6;
Magic Number,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,set,The following statement contains a magic number: int ch_center = subpixel_scale * 2;
Magic Number,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,set,The following statement contains a magic number: int n_smoother = ch.Length -  								  subpixel_smoother_width -  								  subpixel_center_width -  								  subpixel_scale * 2;
Magic Number,MatterHackers.Agg,LineProfileAnitAlias,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,set,The following statement contains a magic number: for (i = 0; i < subpixel_scale * 2; i++)  			{  				ch[--chIndex] = ch[ch_center++];  			}
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot_hline,The following statement contains a magic number: byte[] covers = new byte[max_half_width * 2 + 4];
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot_hline,The following statement contains a magic number: byte[] covers = new byte[max_half_width * 2 + 4];
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot_hline,The following statement contains a magic number: x += LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,semidot_hline,The following statement contains a magic number: y += LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie_hline,The following statement contains a magic number: byte[] covers = new byte[max_half_width * 2 + 4];
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie_hline,The following statement contains a magic number: byte[] covers = new byte[max_half_width * 2 + 4];
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie_hline,The following statement contains a magic number: x += LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,pie_hline,The following statement contains a magic number: y += LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line0,The following statement contains a magic number: if (doClipping)  			{  				int x1 = lp.x1;  				int y1 = lp.y1;  				int x2 = lp.x2;  				int y2 = lp.y2;  				int flags = ClipLiangBarsky.clip_line_segment(ref x1' ref y1' ref x2' ref y2' clippingRectangle);  				if ((flags & 4) == 0)  				{  					if (flags != 0)  					{  						line_parameters lp2 = new line_parameters(x1' y1' x2' y2'  										   agg_basics.uround(agg_math.calc_distance(x1' y1' x2' y2)));  						line0_no_clip(lp2);  					}  					else  					{  						line0_no_clip(lp);  					}  				}  			}  			else  			{  				line0_no_clip(lp);  			}
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line1,The following statement contains a magic number: if (doClipping)  			{  				int x1 = lp.x1;  				int y1 = lp.y1;  				int x2 = lp.x2;  				int y2 = lp.y2;  				int flags = ClipLiangBarsky.clip_line_segment(ref x1' ref y1' ref x2' ref y2' clippingRectangle);  				if ((flags & 4) == 0)  				{  					if (flags != 0)  					{  						line_parameters lp2 = new line_parameters(x1' y1' x2' y2'  										   agg_basics.uround(agg_math.calc_distance(x1' y1' x2' y2)));  						if (((int)flags & 1) != 0)  						{  							sx = x1 + (y2 - y1);  							sy = y1 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)  							{  								sx = (lp.x1 + sx) >> 1;  								sy = (lp.y1 + sy) >> 1;  							}  						}  						line1_no_clip(lp2' sx' sy);  					}  					else  					{  						line1_no_clip(lp' sx' sy);  					}  				}  			}  			else  			{  				line1_no_clip(lp' sx' sy);  			}
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line2,The following statement contains a magic number: if (doClipping)  			{  				int x1 = lp.x1;  				int y1 = lp.y1;  				int x2 = lp.x2;  				int y2 = lp.y2;  				int flags = ClipLiangBarsky.clip_line_segment(ref x1' ref y1' ref x2' ref y2' clippingRectangle);  				if ((flags & 4) == 0)  				{  					if (flags != 0)  					{  						line_parameters lp2 = new line_parameters(x1' y1' x2' y2'  										   agg_basics.uround(agg_math.calc_distance(x1' y1' x2' y2)));  						if ((flags & 2) != 0)  						{  							ex = x2 + (y2 - y1);  							ey = y2 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)  							{  								ex = (lp.x2 + ex) >> 1;  								ey = (lp.y2 + ey) >> 1;  							}  						}  						line2_no_clip(lp2' ex' ey);  					}  					else  					{  						line2_no_clip(lp' ex' ey);  					}  				}  			}  			else  			{  				line2_no_clip(lp' ex' ey);  			}
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line2,The following statement contains a magic number: if (doClipping)  			{  				int x1 = lp.x1;  				int y1 = lp.y1;  				int x2 = lp.x2;  				int y2 = lp.y2;  				int flags = ClipLiangBarsky.clip_line_segment(ref x1' ref y1' ref x2' ref y2' clippingRectangle);  				if ((flags & 4) == 0)  				{  					if (flags != 0)  					{  						line_parameters lp2 = new line_parameters(x1' y1' x2' y2'  										   agg_basics.uround(agg_math.calc_distance(x1' y1' x2' y2)));  						if ((flags & 2) != 0)  						{  							ex = x2 + (y2 - y1);  							ey = y2 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)  							{  								ex = (lp.x2 + ex) >> 1;  								ey = (lp.y2 + ey) >> 1;  							}  						}  						line2_no_clip(lp2' ex' ey);  					}  					else  					{  						line2_no_clip(lp' ex' ey);  					}  				}  			}  			else  			{  				line2_no_clip(lp' ex' ey);  			}
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line3,The following statement contains a magic number: if (doClipping)  			{  				int x1 = lp.x1;  				int y1 = lp.y1;  				int x2 = lp.x2;  				int y2 = lp.y2;  				int flags = ClipLiangBarsky.clip_line_segment(ref x1' ref y1' ref x2' ref y2' clippingRectangle);  				if ((flags & 4) == 0)  				{  					if (flags != 0)  					{  						line_parameters lp2 = new line_parameters(x1' y1' x2' y2'  							agg_basics.uround(agg_math.calc_distance(x1' y1' x2' y2)));  						if ((flags & 1) != 0)  						{  							sx = x1 + (y2 - y1);  							sy = y1 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)  							{  								sx = (lp.x1 + sx) >> 1;  								sy = (lp.y1 + sy) >> 1;  							}  						}  						if ((flags & 2) != 0)  						{  							ex = x2 + (y2 - y1);  							ey = y2 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)  							{  								ex = (lp.x2 + ex) >> 1;  								ey = (lp.y2 + ey) >> 1;  							}  						}  						line3_no_clip(lp2' sx' sy' ex' ey);  					}  					else  					{  						line3_no_clip(lp' sx' sy' ex' ey);  					}  				}  			}  			else  			{  				line3_no_clip(lp' sx' sy' ex' ey);  			}
Magic Number,MatterHackers.Agg,OutlineRenderer,C:\repos\MatterHackers_agg-sharp\agg\OutlineRenderer.cs,line3,The following statement contains a magic number: if (doClipping)  			{  				int x1 = lp.x1;  				int y1 = lp.y1;  				int x2 = lp.x2;  				int y2 = lp.y2;  				int flags = ClipLiangBarsky.clip_line_segment(ref x1' ref y1' ref x2' ref y2' clippingRectangle);  				if ((flags & 4) == 0)  				{  					if (flags != 0)  					{  						line_parameters lp2 = new line_parameters(x1' y1' x2' y2'  							agg_basics.uround(agg_math.calc_distance(x1' y1' x2' y2)));  						if ((flags & 1) != 0)  						{  							sx = x1 + (y2 - y1);  							sy = y1 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)  							{  								sx = (lp.x1 + sx) >> 1;  								sy = (lp.y1 + sy) >> 1;  							}  						}  						if ((flags & 2) != 0)  						{  							ex = x2 + (y2 - y1);  							ey = y2 - (x2 - x1);  						}  						else  						{  							while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)  							{  								ex = (lp.x2 + ex) >> 1;  								ey = (lp.y2 + ey) >> 1;  							}  						}  						line3_no_clip(lp2' sx' sy' ex' ey);  					}  					else  					{  						line3_no_clip(lp' sx' sy' ex' ey);  					}  				}  			}  			else  			{  				line3_no_clip(lp' sx' sy' ex' ey);  			}
Magic Number,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,The following statement contains a magic number: m_half_height_hr = (int)agg_basics.uround(src.Height * LineAABasics.line_subpixel_scale / 2);
Magic Number,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,The following statement contains a magic number: m_offset_y_hr = m_dilation_hr + m_half_height_hr - LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,The following statement contains a magic number: m_half_height_hr += LineAABasics.line_subpixel_scale / 2;
Magic Number,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,The following statement contains a magic number: int bufferWidth = m_width + m_dilation * 2;
Magic Number,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,The following statement contains a magic number: int bufferHeight = m_height + m_dilation * 2;
Magic Number,MatterHackers.Agg,line_image_pattern,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,create,The following statement contains a magic number: int bytesPerPixel = src.BitDepth / 8;
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -  						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -  						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  					   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -  					   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist_pict = ((x + LineAABasics.line_subpixel_scale / 2 - (x1 - dy)) * m_dy_pict -  							(y + LineAABasics.line_subpixel_scale / 2 - (y1 + dx)) * m_dx_pict) >>  						   LineAABasics.line_subpixel_shift;
Magic Number,MatterHackers.Agg,distance_interpolator4,C:\repos\MatterHackers_agg-sharp\agg\ImageLineRenderer.cs,distance_interpolator4,The following statement contains a magic number: m_dist_pict = ((x + LineAABasics.line_subpixel_scale / 2 - (x1 - dy)) * m_dy_pict -  							(y + LineAABasics.line_subpixel_scale / 2 - (y1 + dx)) * m_dx_pict) >>  						   LineAABasics.line_subpixel_shift;
Magic Number,MatterHackers.Agg,scanline_bin,C:\repos\MatterHackers_agg-sharp\agg\agg_scanline_bin.cs,scanline_bin,The following statement contains a magic number: m_spans = new ArrayPOD<ScanlineSpan>(1000);
Magic Number,MatterHackers.Agg,scanline_bin,C:\repos\MatterHackers_agg-sharp\agg\agg_scanline_bin.cs,reset,The following statement contains a magic number: int max_len = max_x - min_x + 3;
Magic Number,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The following statement contains a magic number: if (left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2)  			{  				throw new System.FormatException("left right and result must all be the same size.");  			}
Magic Number,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The following statement contains a magic number: if (left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2)  			{  				throw new System.FormatException("left right and result must all be the same size.");  			}
Magic Number,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The following statement contains a magic number: if (left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2)  			{  				throw new System.FormatException("left right and result must all be the same size.");  			}
Magic Number,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The following statement contains a magic number: if (left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2)  			{  				throw new System.FormatException("left right and result must all be the same size.");  			}
Magic Number,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The following statement contains a magic number: if (left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2)  			{  				throw new System.FormatException("left right and result must all be the same size.");  			}
Magic Number,MatterHackers.Agg,simul_eq,C:\repos\MatterHackers_agg-sharp\agg\agg_simul_eq.cs,solve,The following statement contains a magic number: if (left.GetLength(0) != 4  				|| right.GetLength(0) != 4  				|| left.GetLength(1) != 4  				|| result.GetLength(0) != 4  				|| right.GetLength(1) != 2  				|| result.GetLength(1) != 2)  			{  				throw new System.FormatException("left right and result must all be the same size.");  			}
Magic Number,MatterHackers.Agg,span_allocator,C:\repos\MatterHackers_agg-sharp\agg\agg_span_allocator.cs,span_allocator,The following statement contains a magic number: m_span = new ArrayPOD<RGBA_Bytes>(255);
Magic Number,MatterHackers.Agg,span_allocator,C:\repos\MatterHackers_agg-sharp\agg\agg_span_allocator.cs,allocate,The following statement contains a magic number: if (span_len > m_span.Size())  			{  				// To reduce the number of reallocs we align the  				// span_len to 256 color elements.  				// Well' I just like this number and it looks reasonable.  				//-----------------------  				m_span.Resize((((int)span_len + 255) >> 8) << 8);  			}
Magic Number,MatterHackers.Agg,span_allocator,C:\repos\MatterHackers_agg-sharp\agg\agg_span_allocator.cs,allocate,The following statement contains a magic number: if (span_len > m_span.Size())  			{  				// To reduce the number of reallocs we align the  				// span_len to 256 color elements.  				// Well' I just like this number and it looks reasonable.  				//-----------------------  				m_span.Resize((((int)span_len + 255) >> 8) << 8);  			}
Magic Number,MatterHackers.Agg,span_allocator,C:\repos\MatterHackers_agg-sharp\agg\agg_span_allocator.cs,allocate,The following statement contains a magic number: if (span_len > m_span.Size())  			{  				// To reduce the number of reallocs we align the  				// span_len to 256 color elements.  				// Well' I just like this number and it looks reasonable.  				//-----------------------  				m_span.Resize((((int)span_len + 255) >> 8) << 8);  			}
Magic Number,MatterHackers.Agg,span_gradient,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,generate,The following statement contains a magic number: m_interpolator.begin(x + 0.5' y + 0.5' len);
Magic Number,MatterHackers.Agg,span_gradient,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,generate,The following statement contains a magic number: m_interpolator.begin(x + 0.5' y + 0.5' len);
Magic Number,MatterHackers.Agg,gradient_linear_color,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,colors,The following statement contains a magic number: colors(c1' c2' 256);
Magic Number,MatterHackers.Agg,gradient_radial_focus,C:\repos\MatterHackers_agg-sharp\agg\agg_span_gradient.cs,gradient_radial_focus,The following statement contains a magic number: m_r = (100 * span_gradient.gradient_subpixel_scale);
Magic Number,MatterHackers.Agg,span_image_filter,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,span_image_filter,The following statement contains a magic number: m_dx_dbl = (0.5);
Magic Number,MatterHackers.Agg,span_image_filter,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,span_image_filter,The following statement contains a magic number: m_dy_dbl = (0.5);
Magic Number,MatterHackers.Agg,span_image_filter,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,span_image_filter,The following statement contains a magic number: m_dx_int = ((int)image_subpixel_scale_e.image_subpixel_scale / 2);
Magic Number,MatterHackers.Agg,span_image_filter,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,span_image_filter,The following statement contains a magic number: m_dy_int = ((int)image_subpixel_scale_e.image_subpixel_scale / 2);
Magic Number,MatterHackers.Agg,span_image_resample,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter.cs,span_image_resample,The following statement contains a magic number: m_scale_limit = (20);
Magic Number,MatterHackers.Agg,span_image_filter_gray_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_gray.cs,generate,The following statement contains a magic number: if (SourceRenderingBuffer.BitDepth != 8)  			{  				throw new NotSupportedException("The source is expected to be 32 bit.");  			}
Magic Number,MatterHackers.Agg,span_image_filter_gray_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_gray.cs,generate,The following statement contains a magic number: unsafe  			{  				fixed (byte* pSource = fg_ptr)  				{  					do  					{  						span[spanIndex].red = pSource[bufferIndex];  						span[spanIndex].green = pSource[bufferIndex];  						span[spanIndex].blue = pSource[bufferIndex];  						span[spanIndex].alpha = 255;  						spanIndex++;  						bufferIndex += bytesBetweenPixelsInclusive;  					} while (--len != 0);  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: if (SourceRenderingBuffer.BitDepth != 24)  			{  				throw new NotSupportedException("The source is expected to be 32 bit.");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_nn,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: if (SourceRenderingBuffer.BitDepth != 24)  			{  				throw new NotSupportedException("The source is expected to be 32 bit.");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_nn,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int x_hr;  				int y_hr;  				spanInterpolator.coordinates(out x_hr' out y_hr);  				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  				int bufferIndex;  				bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);  				RGBA_Bytes color;  				color.blue = fg_ptr[bufferIndex++];  				color.green = fg_ptr[bufferIndex++];  				color.red = fg_ptr[bufferIndex++];  				color.alpha = 255;  				span[spanIndex] = color;  				spanIndex++;  				spanInterpolator.Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,span_image_filter_rgb_bilinear,The following statement contains a magic number: if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 3)  			{  				throw new System.NotSupportedException("span_image_filter_rgb must have a 24 bit DestImage");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					bufferIndex += 3;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = 255;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: int[] accumulatedColor = new int[3];
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						y_lr++;  						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						bufferIndex += 3;  						weight = (x_hr * y_hr);  						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    						sourceAlpha = base_mask;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							sourceAlpha = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;  							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							x_lr++;    							weight = (x_hr * y_hr);  							BlendInFilterPixel(accumulatedColor' ref sourceAlpha' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)sourceAlpha;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,BlendInFilterPixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)  				{  					int bufferIndex;  					fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					sourceAlpha += weight * base_mask;  				}  				else  				{  					accumulatedColor[0] += back_r * weight;  					accumulatedColor[1] += back_g * weight;  					accumulatedColor[2] += back_b * weight;  					sourceAlpha += back_a * weight;  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,BlendInFilterPixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)  				{  					int bufferIndex;  					fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					sourceAlpha += weight * base_mask;  				}  				else  				{  					accumulatedColor[0] += back_r * weight;  					accumulatedColor[1] += back_g * weight;  					accumulatedColor[2] += back_b * weight;  					sourceAlpha += back_a * weight;  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,span_image_filter_rgb,The following statement contains a magic number: if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 3)  			{  				throw new System.NotSupportedException("span_image_filter_rgb must have a 24 bit DestImage");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				spanInterpolator.coordinates(out x' out y);    				x -= base.filter_dx_int();  				y -= base.filter_dy_int();    				int x_hr = x;  				int y_hr = y;    				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;    				f_b = f_g = f_r = (int)image_filter_scale_e.image_filter_scale / 2;    				int x_fract = x_hr & (int)image_subpixel_scale_e.image_subpixel_mask;  				int y_count = diameter;    				y_hr = (int)image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)image_subpixel_scale_e.image_subpixel_mask);    				int bufferIndex;  				fg_ptr = GetImageBufferAccessor().span(x_lr + start' y_lr + start' diameter' out bufferIndex);  				for (; ; )  				{  					x_count = (int)diameter;  					weight_y = weight_array[y_hr];  					x_hr = (int)image_subpixel_scale_e.image_subpixel_mask - x_fract;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 (int)image_filter_scale_e.image_filter_shift;    						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						if (--x_count == 0) break;  						x_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  						GetImageBufferAccessor().next_x(out bufferIndex);  					}    					if (--y_count == 0) break;  					y_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  					fg_ptr = GetImageBufferAccessor().next_y(out bufferIndex);  				}    				f_b >>= (int)image_filter_scale_e.image_filter_shift;  				f_g >>= (int)image_filter_scale_e.image_filter_shift;  				f_r >>= (int)image_filter_scale_e.image_filter_shift;    				unchecked  				{  					if ((uint)f_b > base_mask)  					{  						if (f_b < 0) f_b = 0;  						if (f_b > base_mask) f_b = (int)base_mask;  					}    					if ((uint)f_g > base_mask)  					{  						if (f_g < 0) f_g = 0;  						if (f_g > base_mask) f_g = (int)base_mask;  					}    					if ((uint)f_r > base_mask)  					{  						if (f_r < 0) f_r = 0;  						if (f_r > base_mask) f_r = (int)base_mask;  					}  				}    				span[spanIndex].alpha = (byte)base_mask;  				span[spanIndex].red = (byte)f_b;  				span[spanIndex].green = (byte)f_g;  				span[spanIndex].blue = (byte)f_r;    				spanIndex++;  				spanInterpolator.Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_filter_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				spanInterpolator.coordinates(out x' out y);    				x -= base.filter_dx_int();  				y -= base.filter_dy_int();    				int x_hr = x;  				int y_hr = y;    				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;    				f_b = f_g = f_r = (int)image_filter_scale_e.image_filter_scale / 2;    				int x_fract = x_hr & (int)image_subpixel_scale_e.image_subpixel_mask;  				int y_count = diameter;    				y_hr = (int)image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)image_subpixel_scale_e.image_subpixel_mask);    				int bufferIndex;  				fg_ptr = GetImageBufferAccessor().span(x_lr + start' y_lr + start' diameter' out bufferIndex);  				for (; ; )  				{  					x_count = (int)diameter;  					weight_y = weight_array[y_hr];  					x_hr = (int)image_subpixel_scale_e.image_subpixel_mask - x_fract;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 (int)image_filter_scale_e.image_filter_shift;    						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];    						if (--x_count == 0) break;  						x_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  						GetImageBufferAccessor().next_x(out bufferIndex);  					}    					if (--y_count == 0) break;  					y_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  					fg_ptr = GetImageBufferAccessor().next_y(out bufferIndex);  				}    				f_b >>= (int)image_filter_scale_e.image_filter_shift;  				f_g >>= (int)image_filter_scale_e.image_filter_shift;  				f_r >>= (int)image_filter_scale_e.image_filter_shift;    				unchecked  				{  					if ((uint)f_b > base_mask)  					{  						if (f_b < 0) f_b = 0;  						if (f_b > base_mask) f_b = (int)base_mask;  					}    					if ((uint)f_g > base_mask)  					{  						if (f_g < 0) f_g = 0;  						if (f_g > base_mask) f_g = (int)base_mask;  					}    					if ((uint)f_r > base_mask)  					{  						if (f_r < 0) f_r = 0;  						if (f_r > base_mask) f_r = (int)base_mask;  					}  				}    				span[spanIndex].alpha = (byte)base_mask;  				span[spanIndex].red = (byte)f_b;  				span[spanIndex].green = (byte)f_g;  				span[spanIndex].blue = (byte)f_r;    				spanIndex++;  				spanInterpolator.Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,span_image_resample_rgb,The following statement contains a magic number: if (src.SourceImage.GetRecieveBlender().NumPixelBits != 24)  			{  				throw new System.FormatException("You have to use a rgb blender with span_image_resample_rgb");  			}
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: int[] fg = new int[3];
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgb,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgb.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;    				span[spanIndex].alpha = base_mask;  				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_filter_rgba_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: if (SourceRenderingBuffer.BitDepth != 32)  			{  				throw new NotSupportedException("The source is expected to be 32 bit.");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_nn_stepXby1,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unsafe  			{  				fixed (byte* pSource = fg_ptr)  				{  					do  					{  						span[spanIndex++] = *(RGBA_Bytes*)&(pSource[bufferIndex]);  						bufferIndex += 4;  					} while (--len != 0);  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_nn,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: if (SourceRenderingBuffer.BitDepth != 32)  			{  				throw new NotSupportedException("The source is expected to be 32 bit.");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int tempR;  					int tempG;  					int tempB;  					int tempA;    					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					tempR =  					tempG =  					tempB =  					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr * y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;    					RGBA_Bytes color;  					color.red = (byte)tempR;  					color.green = (byte)tempG;  					color.blue = (byte)tempB;  					color.alpha = (byte)255;// tempA;  					span[spanIndex] = color;  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					float tempR;  					float tempG;  					float tempB;  					float tempA;    					float x_hr;  					float y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_dbl();  					y_hr -= base.filter_dy_dbl();    					int x_lr = (int)x_hr;  					int y_lr = (int)y_hr;  					float weight;    					tempR = tempG = tempB = tempA = 0;    					x_hr -= x_lr;  					y_hr -= y_lr;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    #if false                      unsafe                      {                          fixed (float* pSource = fg_ptr)                          {                              Vector4f tempFinal = new Vector4f(0.0f' 0.0f' 0.0f' 0.0f);                                Vector4f color0 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);                              weight = (1.0f - x_hr) * (1.0f - y_hr);                              Vector4f weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color0;                                Vector4f color1 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);                              weight = (x_hr) * (1.0f - y_hr);                              weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color1;                                y_lr++;                              bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);                                Vector4f color2 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);                              weight = (1.0f - x_hr) * (y_hr);                              weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color2;                                Vector4f color3 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);                              weight = (x_hr) * (y_hr);                              weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color3;                                RGBA_Floats color;                              color.m_B = tempFinal.X;                              color.m_G = tempFinal.Y;                              color.m_R = tempFinal.Z;                              color.m_A = tempFinal.W;                              span[spanIndex] = color;                          }                      }  #else  					weight = (1.0f - x_hr) * (1.0f - y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr) * (1.0f - y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (1.0f - x_hr) * (y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr) * (y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					RGBA_Floats color;  					color.red = tempR;  					color.green = tempG;  					color.blue = tempB;  					color.alpha = tempA;  					span[spanIndex] = color;  #endif  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					float tempR;  					float tempG;  					float tempB;  					float tempA;    					float x_hr;  					float y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_dbl();  					y_hr -= base.filter_dy_dbl();    					int x_lr = (int)x_hr;  					int y_lr = (int)y_hr;  					float weight;    					tempR = tempG = tempB = tempA = 0;    					x_hr -= x_lr;  					y_hr -= y_lr;    					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    #if false                      unsafe                      {                          fixed (float* pSource = fg_ptr)                          {                              Vector4f tempFinal = new Vector4f(0.0f' 0.0f' 0.0f' 0.0f);                                Vector4f color0 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);                              weight = (1.0f - x_hr) * (1.0f - y_hr);                              Vector4f weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color0;                                Vector4f color1 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);                              weight = (x_hr) * (1.0f - y_hr);                              weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color1;                                y_lr++;                              bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);                                Vector4f color2 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);                              weight = (1.0f - x_hr) * (y_hr);                              weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color2;                                Vector4f color3 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);                              weight = (x_hr) * (y_hr);                              weight4f = new Vector4f(weight' weight' weight' weight);                              tempFinal = tempFinal + weight4f * color3;                                RGBA_Floats color;                              color.m_B = tempFinal.X;                              color.m_G = tempFinal.Y;                              color.m_R = tempFinal.Z;                              color.m_A = tempFinal.W;                              span[spanIndex] = color;                          }                      }  #else  					weight = (1.0f - x_hr) * (1.0f - y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr) * (1.0f - y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					y_lr++;  					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);    					weight = (1.0f - x_hr) * (y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  					bufferIndex += 4;    					weight = (x_hr) * (y_hr);  					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    					RGBA_Floats color;  					color.red = tempR;  					color.green = tempG;  					color.blue = tempB;  					color.alpha = tempA;  					span[spanIndex] = color;  #endif  					spanIndex++;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: int[] accumulatedColor = new int[4];
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: unchecked  			{  				do  				{  					int x_hr;  					int y_hr;    					spanInterpolator.coordinates(out x_hr' out y_hr);    					x_hr -= base.filter_dx_int();  					y_hr -= base.filter_dy_int();    					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  					int weight;    					if (x_lr >= 0 && y_lr >= 0 &&  					   x_lr < maxx && y_lr < maxy)  					{  						accumulatedColor[0] =  						accumulatedColor[1] =  						accumulatedColor[2] =  						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}    						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  						if (weight > base_mask)  						{  							++y_lr;  							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr' y_lr' out bufferIndex);  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						weight = (x_hr * y_hr);  						if (weight > base_mask)  						{  							bufferIndex += distanceBetweenPixelsInclusive;  							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  						}  						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  					}  					else  					{  						if (x_lr < -1 || y_lr < -1 ||  						   x_lr > maxx || y_lr > maxy)  						{  							accumulatedColor[0] = back_r;  							accumulatedColor[1] = back_g;  							accumulatedColor[2] = back_b;  							accumulatedColor[3] = back_a;  						}  						else  						{  							accumulatedColor[0] =  							accumulatedColor[1] =  							accumulatedColor[2] =  							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;    							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;  							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *  									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr--;  							y_lr++;    							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							x_lr++;    							weight = (x_hr * y_hr);  							if (weight > base_mask)  							{  								BlendInFilterPixel(accumulatedColor' back_r' back_g' back_b' back_a' SourceRenderingBuffer' maxx' maxy' x_lr' y_lr' weight);  							}    							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;  						}  					}    					span[spanIndex].red = (byte)accumulatedColor[0];  					span[spanIndex].green = (byte)accumulatedColor[1];  					span[spanIndex].blue = (byte)accumulatedColor[2];  					span[spanIndex].alpha = (byte)accumulatedColor[3];  					++spanIndex;  					spanInterpolator.Next();  				} while (--len != 0);  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,BlendInFilterPixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)  				{  					int bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);  					fg_ptr = SourceRenderingBuffer.GetBuffer();    					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  				}  				else  				{  					accumulatedColor[0] += back_r * weight;  					accumulatedColor[1] += back_g * weight;  					accumulatedColor[2] += back_b * weight;  					accumulatedColor[3] += back_a * weight;  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,BlendInFilterPixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)  				{  					int bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);  					fg_ptr = SourceRenderingBuffer.GetBuffer();    					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  				}  				else  				{  					accumulatedColor[0] += back_r * weight;  					accumulatedColor[1] += back_g * weight;  					accumulatedColor[2] += back_b * weight;  					accumulatedColor[3] += back_a * weight;  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,BlendInFilterPixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)  				{  					int bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);  					fg_ptr = SourceRenderingBuffer.GetBuffer();    					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  				}  				else  				{  					accumulatedColor[0] += back_r * weight;  					accumulatedColor[1] += back_g * weight;  					accumulatedColor[2] += back_b * weight;  					accumulatedColor[3] += back_a * weight;  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_bilinear_clip,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,BlendInFilterPixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)  				{  					int bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr' y_lr);  					fg_ptr = SourceRenderingBuffer.GetBuffer();    					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  					accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];  				}  				else  				{  					accumulatedColor[0] += back_r * weight;  					accumulatedColor[1] += back_g * weight;  					accumulatedColor[2] += back_b * weight;  					accumulatedColor[3] += back_a * weight;  				}  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,span_image_filter_rgba,The following statement contains a magic number: if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 4)  			{  				throw new System.NotSupportedException("span_image_filter_rgba must have a 32 bit DestImage");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				spanInterpolator.coordinates(out x' out y);    				x -= base.filter_dx_int();  				y -= base.filter_dy_int();    				int x_hr = x;  				int y_hr = y;    				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;    				f_b = f_g = f_r = f_a = (int)image_filter_scale_e.image_filter_scale / 2;    				int x_fract = x_hr & (int)image_subpixel_scale_e.image_subpixel_mask;  				int y_count = diameter;    				y_hr = (int)image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)image_subpixel_scale_e.image_subpixel_mask);    				int bufferIndex;  				fg_ptr = sourceAccessor.span(x_lr + start' y_lr + start' diameter' out bufferIndex);  				for (; ; )  				{  					x_count = (int)diameter;  					weight_y = weight_array[y_hr];  					x_hr = (int)image_subpixel_scale_e.image_subpixel_mask - x_fract;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 (int)image_filter_scale_e.image_filter_shift;    						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  						f_a += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    						if (--x_count == 0) break;  						x_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  						sourceAccessor.next_x(out bufferIndex);  					}    					if (--y_count == 0) break;  					y_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  					fg_ptr = sourceAccessor.next_y(out bufferIndex);  				}    				f_b >>= (int)image_filter_scale_e.image_filter_shift;  				f_g >>= (int)image_filter_scale_e.image_filter_shift;  				f_r >>= (int)image_filter_scale_e.image_filter_shift;  				f_a >>= (int)image_filter_scale_e.image_filter_shift;    				unchecked  				{  					if ((uint)f_b > base_mask)  					{  						if (f_b < 0) f_b = 0;  						if (f_b > base_mask) f_b = (int)base_mask;  					}    					if ((uint)f_g > base_mask)  					{  						if (f_g < 0) f_g = 0;  						if (f_g > base_mask) f_g = (int)base_mask;  					}    					if ((uint)f_r > base_mask)  					{  						if (f_r < 0) f_r = 0;  						if (f_r > base_mask) f_r = (int)base_mask;  					}    					if ((uint)f_a > base_mask)  					{  						if (f_a < 0) f_a = 0;  						if (f_a > base_mask) f_a = (int)base_mask;  					}  				}    				span[spanIndex].red = (byte)f_b;  				span[spanIndex].green = (byte)f_g;  				span[spanIndex].blue = (byte)f_r;  				span[spanIndex].alpha = (byte)f_a;    				spanIndex++;  				spanInterpolator.Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_filter_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				spanInterpolator.coordinates(out x' out y);    				x -= base.filter_dx_int();  				y -= base.filter_dy_int();    				int x_hr = x;  				int y_hr = y;    				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;  				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;    				f_b = f_g = f_r = f_a = (int)image_filter_scale_e.image_filter_scale / 2;    				int x_fract = x_hr & (int)image_subpixel_scale_e.image_subpixel_mask;  				int y_count = diameter;    				y_hr = (int)image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)image_subpixel_scale_e.image_subpixel_mask);    				int bufferIndex;  				fg_ptr = sourceAccessor.span(x_lr + start' y_lr + start' diameter' out bufferIndex);  				for (; ; )  				{  					x_count = (int)diameter;  					weight_y = weight_array[y_hr];  					x_hr = (int)image_subpixel_scale_e.image_subpixel_mask - x_fract;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 (int)image_filter_scale_e.image_filter_shift;    						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];  						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];  						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];  						f_a += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];    						if (--x_count == 0) break;  						x_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  						sourceAccessor.next_x(out bufferIndex);  					}    					if (--y_count == 0) break;  					y_hr += (int)image_subpixel_scale_e.image_subpixel_scale;  					fg_ptr = sourceAccessor.next_y(out bufferIndex);  				}    				f_b >>= (int)image_filter_scale_e.image_filter_shift;  				f_g >>= (int)image_filter_scale_e.image_filter_shift;  				f_r >>= (int)image_filter_scale_e.image_filter_shift;  				f_a >>= (int)image_filter_scale_e.image_filter_shift;    				unchecked  				{  					if ((uint)f_b > base_mask)  					{  						if (f_b < 0) f_b = 0;  						if (f_b > base_mask) f_b = (int)base_mask;  					}    					if ((uint)f_g > base_mask)  					{  						if (f_g < 0) f_g = 0;  						if (f_g > base_mask) f_g = (int)base_mask;  					}    					if ((uint)f_r > base_mask)  					{  						if (f_r < 0) f_r = 0;  						if (f_r > base_mask) f_r = (int)base_mask;  					}    					if ((uint)f_a > base_mask)  					{  						if (f_a < 0) f_a = 0;  						if (f_a > base_mask) f_a = (int)base_mask;  					}  				}    				span[spanIndex].red = (byte)f_b;  				span[spanIndex].green = (byte)f_g;  				span[spanIndex].blue = (byte)f_r;  				span[spanIndex].alpha = (byte)f_a;    				spanIndex++;  				spanInterpolator.Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_filter_rgba_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,span_image_filter_rgba_float,The following statement contains a magic number: if (src.SourceImage.GetFloatsBetweenPixelsInclusive() != 4)  			{  				throw new System.NotSupportedException("span_image_filter_rgba must have a 32 bit DestImage");  			}
Magic Number,MatterHackers.Agg,span_image_filter_rgba_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: int diameter = radius * 2;
Magic Number,MatterHackers.Agg,span_image_filter_rgba_float,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: int start = -(int)(diameter / 2 - 1);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,span_image_resample_rgba,The following statement contains a magic number: if (src.SourceImage.GetRecieveBlender().NumPixelBits != 32)  			{  				throw new System.FormatException("You have to use a rgba blender with span_image_resample_rgba");  			}
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: int[] fg = new int[4];
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_image_resample_rgba,C:\repos\MatterHackers_agg-sharp\agg\agg_span_image_filter_rgba.cs,generate,The following statement contains a magic number: do  			{  				int rx;  				int ry;  				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;  				spanInterpolator.coordinates(out x' out y);  				spanInterpolator.local_scale(out rx' out ry);  				base.adjust_scale(ref rx' ref ry);    				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;  				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;    				int radius_x = (diameter * rx) >> 1;  				int radius_y = (diameter * ry) >> 1;  				int len_x_lr =  					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>  						(int)(int)image_subpixel_scale_e.image_subpixel_shift;    				x += base.filter_dx_int() - radius_x;  				y += base.filter_dy_int() - radius_y;    				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;    				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int total_weight = 0;  				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *  							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;  				int x_hr2 = x_hr;  				int sourceIndex;  				fg_ptr = base.GetImageBufferAccessor().span(x_lr' y_lr' len_x_lr' out sourceIndex);    				for (; ; )  				{  					int weight_y = weight_array[y_hr];  					x_hr = x_hr2;  					for (; ; )  					{  						int weight = (weight_y * weight_array[x_hr] +  									 (int)image_filter_scale_e.image_filter_scale / 2) >>  									 downscale_shift;  						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;  						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;  						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;  						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;  						total_weight += weight;  						x_hr += rx_inv;  						if (x_hr >= filter_scale) break;  						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);  					}  					y_hr += ry_inv;  					if (y_hr >= filter_scale)  					{  						break;  					}    					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);  				}    				fg[0] /= total_weight;  				fg[1] /= total_weight;  				fg[2] /= total_weight;  				fg[3] /= total_weight;    				if (fg[0] < 0) fg[0] = 0;  				if (fg[1] < 0) fg[1] = 0;  				if (fg[2] < 0) fg[2] = 0;  				if (fg[3] < 0) fg[3] = 0;    				if (fg[0] > base_mask) fg[0] = base_mask;  				if (fg[1] > base_mask) fg[1] = base_mask;  				if (fg[2] > base_mask) fg[2] = base_mask;  				if (fg[3] > base_mask) fg[3] = base_mask;    				span[spanIndex].red = (byte)fg[0];  				span[spanIndex].green = (byte)fg[1];  				span[spanIndex].blue = (byte)fg[2];  				span[spanIndex].alpha = (byte)fg[3];    				spanIndex++;  				interpolator().Next();  			} while (--len != 0);
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: double[] src = new double[8];
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: src[0] = src[6] = x1;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: src[2] = src[4] = x2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: src[2] = src[4] = x2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: src[1] = src[3] = y1;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: src[5] = src[7] = y2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,rect_to_quad,The following statement contains a magic number: src[5] = src[7] = y2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: double[] dst = new double[8];
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: dst[0] = dst[6] = x1;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: dst[2] = dst[4] = x2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: dst[2] = dst[4] = x2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: dst[1] = dst[3] = y1;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: dst[5] = dst[7] = y2;
Magic Number,MatterHackers.Agg,span_interpolator_persp_lerp,C:\repos\MatterHackers_agg-sharp\agg\agg_span_interpolator_persp.cs,quad_to_rect,The following statement contains a magic number: dst[5] = dst[7] = y2;
Magic Number,MatterHackers.Agg,FloodFill,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,Fill,The following statement contains a magic number: fillRule.SetStartColor(new RGBA_Bytes(destImage.GetBuffer()[startColorBufferOffset + 2]' destImage.GetBuffer()[startColorBufferOffset + 1]' destImage.GetBuffer()[startColorBufferOffset]));
Magic Number,MatterHackers.Agg,ExactMatch,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,CheckPixel,The following statement contains a magic number: return (destBuffer[bufferOffset] == startColor.red) &&  					(destBuffer[bufferOffset + 1] == startColor.green) &&  					(destBuffer[bufferOffset + 2] == startColor.blue);
Magic Number,MatterHackers.Agg,FillingRule,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,SetPixel,The following statement contains a magic number: destBuffer[bufferOffset + 2] = fillColor.red;
Magic Number,MatterHackers.Agg,ToleranceMatch,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,CheckPixel,The following statement contains a magic number: return (destBuffer[bufferOffset] >= (startColor.red - tolerance0To255)) && destBuffer[bufferOffset] <= (startColor.red + tolerance0To255) &&  					(destBuffer[bufferOffset + 1] >= (startColor.green - tolerance0To255)) && destBuffer[bufferOffset + 1] <= (startColor.green + tolerance0To255) &&  					(destBuffer[bufferOffset + 2] >= (startColor.blue - tolerance0To255)) && destBuffer[bufferOffset + 2] <= (startColor.blue + tolerance0To255);
Magic Number,MatterHackers.Agg,ToleranceMatch,C:\repos\MatterHackers_agg-sharp\agg\FloodFiller.cs,CheckPixel,The following statement contains a magic number: return (destBuffer[bufferOffset] >= (startColor.red - tolerance0To255)) && destBuffer[bufferOffset] <= (startColor.red + tolerance0To255) &&  					(destBuffer[bufferOffset + 1] >= (startColor.green - tolerance0To255)) && destBuffer[bufferOffset + 1] <= (startColor.green + tolerance0To255) &&  					(destBuffer[bufferOffset + 2] >= (startColor.blue - tolerance0To255)) && destBuffer[bufferOffset + 2] <= (startColor.blue + tolerance0To255);
Magic Number,MatterHackers.Agg,Graphics2D,C:\repos\MatterHackers_agg-sharp\agg\Graphics2D.cs,PushTransform,The following statement contains a magic number: if (affineTransformStack.Count > 1000)  			{  				throw new System.Exception("You seem to be leaking transforms.  You should be popping some of them at some point.");  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (Math.Abs(angleRadians) < (0.1 * MathHelper.Tau / 360))  			{  				IsRotated = false;  				angleRadians = 0;  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (Math.Abs(angleRadians) < (0.1 * MathHelper.Tau / 360))  			{  				IsRotated = false;  				angleRadians = 0;  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (scaleX > 0.5 || scaleY > 0.5)  			{  				CanUseMipMaps = false;  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (scaleX > 0.5 || scaleY > 0.5)  			{  				CanUseMipMaps = false;  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (renderRequriesSourceSampling)  			{  #if false // if the scaling is small enough the results can be improved by using mip maps  	        if(CanUseMipMaps)  	        {  		        CMipMapFrameProperty* pMipMapFrameProperty = CMipMapFrameProperty::GetMipMapFrameProperty(source);  		        double OldScaleX = scaleX;  		        double OldScaleY = scaleY;  		        const CFrameInterface* pMippedFrame = pMipMapFrameProperty.GetMipMapFrame(ref scaleX' ref scaleY);  		        if(pMippedFrame != source)  		        {  			        IsMipped = true;  			        source = pMippedFrame;  			        sourceOriginOffsetX *= (OldScaleX / scaleX);  			        sourceOriginOffsetY *= (OldScaleY / scaleY);  		        }    			    HotspotOffsetX *= (inScaleX / scaleX);  			    HotspotOffsetY *= (inScaleY / scaleY);  	        }  #endif                  switch (ImageRenderQuality)  				{  					case TransformQuality.Fastest:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_image_filter spanImageFilter;  							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							DrawImage(source' spanImageFilter' destRectTransform);  						}  						break;    					case TransformQuality.Best:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							//spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							IImageFilterFunction filterFunction = null;  							filterFunction = new image_filter_blackman(4);  							ImageFilterLookUpTable filter = new ImageFilterLookUpTable();  							filter.calculate(filterFunction' true);    							span_image_filter spanGenerator = new span_image_filter_rgba(sourceAccessor' interpolator' filter);    							DrawImage(source' spanGenerator' destRectTransform);  						}  						break;  				}  #if false // this is some debug you can enable to visualize the dest bounding box  		        LineFloat(BoundingRect.left' BoundingRect.top' BoundingRect.right' BoundingRect.top' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.top' BoundingRect.right' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.bottom' BoundingRect.left' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.left' BoundingRect.bottom' BoundingRect.left' BoundingRect.top' WHITE);  #endif  			}  			else // TODO: this can be even faster if we do not use an intermediate buffer  			{  				Affine destRectTransform;  				DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    				Affine sourceRectTransform = new Affine(destRectTransform);  				// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  				sourceRectTransform.invert();    				span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  				ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    				span_image_filter spanImageFilter = null;  				switch (source.BitDepth)  				{  					case 32:  						spanImageFilter = new span_image_filter_rgba_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 24:  						spanImageFilter = new span_image_filter_rgb_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 8:  						spanImageFilter = new span_image_filter_gray_nn_stepXby1(sourceAccessor' interpolator);  						break;    					default:  						throw new NotImplementedException();  				}  				//spanImageFilter = new span_image_filter_rgba_nn(sourceAccessor' interpolator);    				DrawImage(source' spanImageFilter' destRectTransform);  				DestImage.MarkImageChanged();  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (renderRequriesSourceSampling)  			{  #if false // if the scaling is small enough the results can be improved by using mip maps  	        if(CanUseMipMaps)  	        {  		        CMipMapFrameProperty* pMipMapFrameProperty = CMipMapFrameProperty::GetMipMapFrameProperty(source);  		        double OldScaleX = scaleX;  		        double OldScaleY = scaleY;  		        const CFrameInterface* pMippedFrame = pMipMapFrameProperty.GetMipMapFrame(ref scaleX' ref scaleY);  		        if(pMippedFrame != source)  		        {  			        IsMipped = true;  			        source = pMippedFrame;  			        sourceOriginOffsetX *= (OldScaleX / scaleX);  			        sourceOriginOffsetY *= (OldScaleY / scaleY);  		        }    			    HotspotOffsetX *= (inScaleX / scaleX);  			    HotspotOffsetY *= (inScaleY / scaleY);  	        }  #endif                  switch (ImageRenderQuality)  				{  					case TransformQuality.Fastest:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_image_filter spanImageFilter;  							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							DrawImage(source' spanImageFilter' destRectTransform);  						}  						break;    					case TransformQuality.Best:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							//spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							IImageFilterFunction filterFunction = null;  							filterFunction = new image_filter_blackman(4);  							ImageFilterLookUpTable filter = new ImageFilterLookUpTable();  							filter.calculate(filterFunction' true);    							span_image_filter spanGenerator = new span_image_filter_rgba(sourceAccessor' interpolator' filter);    							DrawImage(source' spanGenerator' destRectTransform);  						}  						break;  				}  #if false // this is some debug you can enable to visualize the dest bounding box  		        LineFloat(BoundingRect.left' BoundingRect.top' BoundingRect.right' BoundingRect.top' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.top' BoundingRect.right' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.bottom' BoundingRect.left' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.left' BoundingRect.bottom' BoundingRect.left' BoundingRect.top' WHITE);  #endif  			}  			else // TODO: this can be even faster if we do not use an intermediate buffer  			{  				Affine destRectTransform;  				DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    				Affine sourceRectTransform = new Affine(destRectTransform);  				// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  				sourceRectTransform.invert();    				span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  				ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    				span_image_filter spanImageFilter = null;  				switch (source.BitDepth)  				{  					case 32:  						spanImageFilter = new span_image_filter_rgba_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 24:  						spanImageFilter = new span_image_filter_rgb_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 8:  						spanImageFilter = new span_image_filter_gray_nn_stepXby1(sourceAccessor' interpolator);  						break;    					default:  						throw new NotImplementedException();  				}  				//spanImageFilter = new span_image_filter_rgba_nn(sourceAccessor' interpolator);    				DrawImage(source' spanImageFilter' destRectTransform);  				DestImage.MarkImageChanged();  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (renderRequriesSourceSampling)  			{  #if false // if the scaling is small enough the results can be improved by using mip maps  	        if(CanUseMipMaps)  	        {  		        CMipMapFrameProperty* pMipMapFrameProperty = CMipMapFrameProperty::GetMipMapFrameProperty(source);  		        double OldScaleX = scaleX;  		        double OldScaleY = scaleY;  		        const CFrameInterface* pMippedFrame = pMipMapFrameProperty.GetMipMapFrame(ref scaleX' ref scaleY);  		        if(pMippedFrame != source)  		        {  			        IsMipped = true;  			        source = pMippedFrame;  			        sourceOriginOffsetX *= (OldScaleX / scaleX);  			        sourceOriginOffsetY *= (OldScaleY / scaleY);  		        }    			    HotspotOffsetX *= (inScaleX / scaleX);  			    HotspotOffsetY *= (inScaleY / scaleY);  	        }  #endif                  switch (ImageRenderQuality)  				{  					case TransformQuality.Fastest:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_image_filter spanImageFilter;  							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							DrawImage(source' spanImageFilter' destRectTransform);  						}  						break;    					case TransformQuality.Best:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							//spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							IImageFilterFunction filterFunction = null;  							filterFunction = new image_filter_blackman(4);  							ImageFilterLookUpTable filter = new ImageFilterLookUpTable();  							filter.calculate(filterFunction' true);    							span_image_filter spanGenerator = new span_image_filter_rgba(sourceAccessor' interpolator' filter);    							DrawImage(source' spanGenerator' destRectTransform);  						}  						break;  				}  #if false // this is some debug you can enable to visualize the dest bounding box  		        LineFloat(BoundingRect.left' BoundingRect.top' BoundingRect.right' BoundingRect.top' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.top' BoundingRect.right' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.bottom' BoundingRect.left' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.left' BoundingRect.bottom' BoundingRect.left' BoundingRect.top' WHITE);  #endif  			}  			else // TODO: this can be even faster if we do not use an intermediate buffer  			{  				Affine destRectTransform;  				DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    				Affine sourceRectTransform = new Affine(destRectTransform);  				// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  				sourceRectTransform.invert();    				span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  				ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    				span_image_filter spanImageFilter = null;  				switch (source.BitDepth)  				{  					case 32:  						spanImageFilter = new span_image_filter_rgba_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 24:  						spanImageFilter = new span_image_filter_rgb_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 8:  						spanImageFilter = new span_image_filter_gray_nn_stepXby1(sourceAccessor' interpolator);  						break;    					default:  						throw new NotImplementedException();  				}  				//spanImageFilter = new span_image_filter_rgba_nn(sourceAccessor' interpolator);    				DrawImage(source' spanImageFilter' destRectTransform);  				DestImage.MarkImageChanged();  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following statement contains a magic number: if (renderRequriesSourceSampling)  			{  #if false // if the scaling is small enough the results can be improved by using mip maps  	        if(CanUseMipMaps)  	        {  		        CMipMapFrameProperty* pMipMapFrameProperty = CMipMapFrameProperty::GetMipMapFrameProperty(source);  		        double OldScaleX = scaleX;  		        double OldScaleY = scaleY;  		        const CFrameInterface* pMippedFrame = pMipMapFrameProperty.GetMipMapFrame(ref scaleX' ref scaleY);  		        if(pMippedFrame != source)  		        {  			        IsMipped = true;  			        source = pMippedFrame;  			        sourceOriginOffsetX *= (OldScaleX / scaleX);  			        sourceOriginOffsetY *= (OldScaleY / scaleY);  		        }    			    HotspotOffsetX *= (inScaleX / scaleX);  			    HotspotOffsetY *= (inScaleY / scaleY);  	        }  #endif                  switch (ImageRenderQuality)  				{  					case TransformQuality.Fastest:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_image_filter spanImageFilter;  							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							DrawImage(source' spanImageFilter' destRectTransform);  						}  						break;    					case TransformQuality.Best:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							//spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							IImageFilterFunction filterFunction = null;  							filterFunction = new image_filter_blackman(4);  							ImageFilterLookUpTable filter = new ImageFilterLookUpTable();  							filter.calculate(filterFunction' true);    							span_image_filter spanGenerator = new span_image_filter_rgba(sourceAccessor' interpolator' filter);    							DrawImage(source' spanGenerator' destRectTransform);  						}  						break;  				}  #if false // this is some debug you can enable to visualize the dest bounding box  		        LineFloat(BoundingRect.left' BoundingRect.top' BoundingRect.right' BoundingRect.top' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.top' BoundingRect.right' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.right' BoundingRect.bottom' BoundingRect.left' BoundingRect.bottom' WHITE);  		        LineFloat(BoundingRect.left' BoundingRect.bottom' BoundingRect.left' BoundingRect.top' WHITE);  #endif  			}  			else // TODO: this can be even faster if we do not use an intermediate buffer  			{  				Affine destRectTransform;  				DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    				Affine sourceRectTransform = new Affine(destRectTransform);  				// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  				sourceRectTransform.invert();    				span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  				ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    				span_image_filter spanImageFilter = null;  				switch (source.BitDepth)  				{  					case 32:  						spanImageFilter = new span_image_filter_rgba_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 24:  						spanImageFilter = new span_image_filter_rgb_nn_stepXby1(sourceAccessor' interpolator);  						break;    					case 8:  						spanImageFilter = new span_image_filter_gray_nn_stepXby1(sourceAccessor' interpolator);  						break;    					default:  						throw new NotImplementedException();  				}  				//spanImageFilter = new span_image_filter_rgba_nn(sourceAccessor' interpolator);    				DrawImage(source' spanImageFilter' destRectTransform);  				DestImage.MarkImageChanged();  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Rectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Rectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Rectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Rectangle,The following statement contains a magic number: RoundedRect rect = new RoundedRect(left + .5' bottom + .5' right - .5' top - .5' 0);
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Clear,The following statement contains a magic number: if (DestImage != null)  			{  				RGBA_Bytes color = iColor.GetAsRGBA_Bytes();  				int width = DestImage.Width;  				int height = DestImage.Height;  				byte[] buffer = DestImage.GetBuffer();  				switch (DestImage.BitDepth)  				{  					case 8:  						{  							byte byteColor = (byte)iColor.Red0To255;  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset] = color.blue;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					case 24:  						for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  						{  							int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  							int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					case 32:  						{  							for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)  							{  								int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left' y);  								int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();  								for (int x = 0; x < clippingRectInt.Width; x++)  								{  									buffer[bufferOffset + 0] = color.blue;  									buffer[bufferOffset + 1] = color.green;  									buffer[bufferOffset + 2] = color.red;  									buffer[bufferOffset + 3] = color.alpha;  									bufferOffset += bytesBetweenPixels;  								}  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}  			else // it is a float  			{  				if (DestImageFloat == null)  				{  					throw new Exception("You have to have either a byte or float DestImage.");  				}    				RGBA_Floats color = iColor.GetAsRGBA_Floats();  				int width = DestImageFloat.Width;  				int height = DestImageFloat.Height;  				float[] buffer = DestImageFloat.GetBuffer();  				switch (DestImageFloat.BitDepth)  				{  					case 128:  						for (int y = 0; y < height; y++)  						{  							int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left' y);  							int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();  							for (int x = 0; x < clippingRectInt.Width; x++)  							{  								buffer[bufferOffset + 0] = color.blue;  								buffer[bufferOffset + 1] = color.green;  								buffer[bufferOffset + 2] = color.red;  								buffer[bufferOffset + 3] = color.alpha;  								bufferOffset += bytesBetweenPixels;  							}  						}  						break;    					default:  						throw new NotImplementedException();  				}  			}
Magic Number,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_pixel,The following statement contains a magic number: unchecked  			{  				int bufferIndex = m_rbuf.GetBufferOffsetXY(x' y);  				byte[] buffer = m_rbuf.GetBuffer();  				return (byte)((255 + val * buffer[bufferIndex]) >> 8);  			}
Magic Number,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_pixel,The following statement contains a magic number: unchecked  			{  				int bufferIndex = m_rbuf.GetBufferOffsetXY(x' y);  				byte[] buffer = m_rbuf.GetBuffer();  				return (byte)((255 + val * buffer[bufferIndex]) >> 8);  			}
Magic Number,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The following statement contains a magic number: do  			{  				covers[coversIndex] = (byte)((255 + (covers[coversIndex]) * mask[maskIndex]) >> 8);  				coversIndex++;  				maskIndex++;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg,AlphaMaskByteUnclipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The following statement contains a magic number: do  			{  				covers[coversIndex] = (byte)((255 + (covers[coversIndex]) * mask[maskIndex]) >> 8);  				coversIndex++;  				maskIndex++;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_pixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x < (uint)m_rbuf.Width  					&& (uint)y < (uint)m_rbuf.Height)  				{  					int bufferIndex = m_rbuf.GetBufferOffsetXY(x' y);  					byte[] buffer = m_rbuf.GetBuffer();  					return (byte)((val * buffer[bufferIndex] + 255) >> 8);  				}  			}
Magic Number,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_pixel,The following statement contains a magic number: unchecked  			{  				if ((uint)x < (uint)m_rbuf.Width  					&& (uint)y < (uint)m_rbuf.Height)  				{  					int bufferIndex = m_rbuf.GetBufferOffsetXY(x' y);  					byte[] buffer = m_rbuf.GetBuffer();  					return (byte)((val * buffer[bufferIndex] + 255) >> 8);  				}  			}
Magic Number,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The following statement contains a magic number: do  			{  				covers[coversIndex] = (byte)(((covers[coversIndex]) * mask[maskIndex] + 255) >> 8);  				coversIndex++;  				maskIndex++;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg,AlphaMaskByteClipped,C:\repos\MatterHackers_agg-sharp\agg\Image\agg_alpha_mask_u8.cs,combine_hspan,The following statement contains a magic number: do  			{  				covers[coversIndex] = (byte)(((covers[coversIndex]) * mask[maskIndex] + 255) >> 8);  				coversIndex++;  				maskIndex++;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg,Point2D,C:\repos\MatterHackers_agg-sharp\agg\Point2D.cs,Range0To2PI,The following statement contains a magic number: if (Value < 0)  			{  				Value += 2 * (double)System.Math.PI;  			}
Magic Number,MatterHackers.Agg,Point2D,C:\repos\MatterHackers_agg-sharp\agg\Point2D.cs,Range0To2PI,The following statement contains a magic number: if (Value >= 2 * (double)System.Math.PI)  			{  				Value -= 2 * (double)System.Math.PI;  			}
Magic Number,MatterHackers.Agg,Point2D,C:\repos\MatterHackers_agg-sharp\agg\Point2D.cs,Range0To2PI,The following statement contains a magic number: if (Value >= 2 * (double)System.Math.PI)  			{  				Value -= 2 * (double)System.Math.PI;  			}
Magic Number,MatterHackers.Agg,Point2D,C:\repos\MatterHackers_agg-sharp\agg\Point2D.cs,Range0To2PI,The following statement contains a magic number: if (Value < 0 || Value > 2 * System.Math.PI) throw new Exception("Value >= 0 && Value <= 2 * PI");
Magic Number,MatterHackers.Agg,Point2D,C:\repos\MatterHackers_agg-sharp\agg\Point2D.cs,GetDeltaAngle,The following statement contains a magic number: if (DeltaAngle > System.Math.PI)  			{  				DeltaAngle -= 2 * (double)System.Math.PI;  			}
Magic Number,MatterHackers.Agg,Point2D,C:\repos\MatterHackers_agg-sharp\agg\Point2D.cs,GetDeltaAngle,The following statement contains a magic number: if (DeltaAngle < -System.Math.PI)  			{  				DeltaAngle += 2 * (double)System.Math.PI;  			}
Magic Number,MatterHackers.Agg,ImageBufferAccessorClip,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,ImageBufferAccessorClip,The following statement contains a magic number: m_OutsideBufferColor = new byte[4];
Magic Number,MatterHackers.Agg,ImageBufferAccessorClip,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,ImageBufferAccessorClip,The following statement contains a magic number: m_OutsideBufferColor[2] = bk.blue;
Magic Number,MatterHackers.Agg,ImageBufferAccessorClip,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,ImageBufferAccessorClip,The following statement contains a magic number: m_OutsideBufferColor[3] = bk.alpha;
Magic Number,MatterHackers.Agg,ImageBufferAccessorClipFloat,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,ImageBufferAccessorClipFloat,The following statement contains a magic number: m_OutsideBufferColor = new float[4];
Magic Number,MatterHackers.Agg,ImageBufferAccessorClipFloat,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,ImageBufferAccessorClipFloat,The following statement contains a magic number: m_OutsideBufferColor[2] = bk.blue;
Magic Number,MatterHackers.Agg,ImageBufferAccessorClipFloat,C:\repos\MatterHackers_agg-sharp\agg\RasterBufferAccessors.cs,ImageBufferAccessorClipFloat,The following statement contains a magic number: m_OutsideBufferColor[3] = bk.alpha;
Magic Number,MatterHackers.Agg,VertexSequence,C:\repos\MatterHackers_agg-sharp\agg\agg_VertexSequence.cs,add,The following statement contains a magic number: if (base.size() > 1)  			{  				if (!Array[base.size() - 2].IsEqual(Array[base.size() - 1]))  				{  					base.RemoveLast();  				}  			}
Magic Number,MatterHackers.Agg,VertexSequence,C:\repos\MatterHackers_agg-sharp\agg\agg_VertexSequence.cs,close,The following statement contains a magic number: while (base.size() > 1)  			{  				if (Array[base.size() - 2].IsEqual(Array[base.size() - 1])) break;  				VertexDistance t = this[base.size() - 1];  				base.RemoveLast();  				modify_last(t);  			}
Magic Number,MatterHackers.Agg.Collections,CompareCentersOnAxis,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CompareCentersOnAxis,The following statement contains a magic number: this.whichAxis = whichAxis % 3;
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Collections,BoundingVolumeHierarchy,C:\repos\MatterHackers_agg-sharp\agg\Collections\BoundingVolumeHierarchy.cs,CreateNewHierachy,The following statement contains a magic number: if (recursionDepth < maxRecursion)  			{  				if (numItems > 5000)  				{  					bestAxis = accelerator.NextAxis;  					bestIndexToSplitOn = numItems / 2;  				}  				else  				{  					double totalIntersectCost = 0;  					int skipInterval = 1;  					for (int i = 0; i < numItems; i += skipInterval)  					{                          IBoundedItem item = traceableItems[i];  						totalIntersectCost += item.GetIntersectCost();  					}    					// get the bounding box of all the items we are going to consider.  					AxisAlignedBoundingBox OverallBox = traceableItems[0].GetAxisAlignedBoundingBox();  					for (int i = skipInterval; i < numItems; i += skipInterval)  					{  						OverallBox += traceableItems[i].GetAxisAlignedBoundingBox();  					}  					double areaOfTotalBounds = OverallBox.GetSurfaceArea();    					double bestCost = totalIntersectCost;    					Vector3 totalDeviationOnAxis = new Vector3();  					double[] surfaceArreaOfItem = new double[numItems - 1];  					double[] rightBoundsAtItem = new double[numItems - 1];    					for (int axis = 0; axis < 3; axis++)  					{  						double intersectCostOnLeft = 0;    						axisSorter.WhichAxis = axis;  						traceableItems.Sort(axisSorter);    						// Get all left bounds  						AxisAlignedBoundingBox currentLeftBounds = traceableItems[0].GetAxisAlignedBoundingBox();  						surfaceArreaOfItem[0] = currentLeftBounds.GetSurfaceArea();  						for (int itemIndex = 1; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							currentLeftBounds += traceableItems[itemIndex].GetAxisAlignedBoundingBox();  							surfaceArreaOfItem[itemIndex] = currentLeftBounds.GetSurfaceArea();    							totalDeviationOnAxis[axis] += Math.Abs(traceableItems[itemIndex].GetCenter()[axis] - traceableItems[itemIndex - 1].GetCenter()[axis]);  						}    						// Get all right bounds  						if (numItems > 1)  						{  							AxisAlignedBoundingBox currentRightBounds = traceableItems[numItems - 1].GetAxisAlignedBoundingBox();  							rightBoundsAtItem[numItems - 2] = currentRightBounds.GetSurfaceArea();  							for (int itemIndex = numItems - 1; itemIndex > 1; itemIndex -= skipInterval)  							{  								currentRightBounds += traceableItems[itemIndex - 1].GetAxisAlignedBoundingBox();  								rightBoundsAtItem[itemIndex - 2] = currentRightBounds.GetSurfaceArea();  							}  						}    						// Sweep from left  						for (int itemIndex = 0; itemIndex < numItems - 1; itemIndex += skipInterval)  						{  							double thisCost = 0;    							{  								// Evaluate Surface Cost Equation  								double costOfTwoAABB = 2 * AxisAlignedBoundingBox.GetIntersectCost(); // the cost of the two children AABB tests    								// do the left cost  								intersectCostOnLeft += traceableItems[itemIndex].GetIntersectCost();  								double leftCost = (surfaceArreaOfItem[itemIndex] / areaOfTotalBounds) * intersectCostOnLeft;    								// do the right cost  								double intersectCostOnRight = totalIntersectCost - intersectCostOnLeft;  								double rightCost = (rightBoundsAtItem[itemIndex] / areaOfTotalBounds) * intersectCostOnRight;    								thisCost = costOfTwoAABB + leftCost + rightCost;  							}    							if (thisCost < bestCost + .000000001) // if it is less within some tiny error  							{  								if (thisCost > bestCost - .000000001)  								{  									// they are the same within the error  									if (axis > 0 && bestAxis != axis) // we have changed axis since last best and we need to decide if this is better than the last axis best  									{  										if (totalDeviationOnAxis[axis] > totalDeviationOnAxis[axis - 1])  										{  											// this new axis is better and we'll switch to it.  Otherwise don't switch.  											bestCost = thisCost;  											bestIndexToSplitOn = itemIndex;  											bestAxis = axis;  										}  									}  								}  								else // this is just better  								{  									bestCost = thisCost;  									bestIndexToSplitOn = itemIndex;  									bestAxis = axis;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetXPositionForLineBasedOnJustification,The following statement contains a magic number: switch (Justification)  			{  				case Justification.Left:  					currentOffset.x = 0;  					break;    				case Justification.Center:  					currentOffset.x = -size.x / 2;  					break;    				case Justification.Right:  					currentOffset.x = -size.x;  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.Font,TypeFacePrinter,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFacePrinter.cs,GetBaseline,The following statement contains a magic number: switch (Baseline)  			{  				case Baseline.Text:  					currentOffset.y = 0;  					break;    				case Baseline.BoundsTop:  					currentOffset.y = -TypeFaceStyle.AscentInPixels;  					break;    				case Baseline.BoundsCenter:  					currentOffset.y = -TypeFaceStyle.AscentInPixels / 2;  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ReadSVG,The following statement contains a magic number: int.TryParse(valuesString[2]' out boundingBox.Right);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ReadSVG,The following statement contains a magic number: int.TryParse(valuesString[3]' out boundingBox.Top);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: StyledTypeFace typeFaceNameStyle = new StyledTypeFace(this' 30);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: double origX = 10 - bounds.Left;
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: double y = 10 - typeFaceNameStyle.DescentInPixels;
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: int width = 50;
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes ascentColor = new RGBA_Bytes(255' 0' 0);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes descentColor = new RGBA_Bytes(255' 0' 0);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes xHeightColor = new RGBA_Bytes(12' 25' 200);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes xHeightColor = new RGBA_Bytes(12' 25' 200);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes xHeightColor = new RGBA_Bytes(12' 25' 200);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes capHeightColor = new RGBA_Bytes(12' 25' 200);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes capHeightColor = new RGBA_Bytes(12' 25' 200);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes capHeightColor = new RGBA_Bytes(12' 25' 200);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes underlineColor = new RGBA_Bytes(0' 150' 55);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: RGBA_Bytes underlineColor = new RGBA_Bytes(0' 150' 55);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: x += typeFaceNameStyle.BoundingBoxInPixels.Width * 1.5;
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: width = width * 3;
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: textTransform *= Affine.NewTranslation(10' origX);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: StyledTypeFace legendFont = new StyledTypeFace(this' 12);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: Vector2 textPos = new Vector2(x + width / 2' y + typeFaceNameStyle.EmSizeInPixels * 1.5);
Magic Number,MatterHackers.Agg.Font,TypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,ShowDebugInfo,The following statement contains a magic number: Vector2 textPos = new Vector2(x + width / 2' y + typeFaceNameStyle.EmSizeInPixels * 1.5);
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[2]' out tempInt))  					weight = (Weight)tempInt;
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[3]' out tempInt))  					proportion = (Proportion)tempInt;
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[4]' out tempInt))  					contrast = (Contrast)tempInt;
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[5]' out tempInt))  					strokeVariation = (Stroke_Variation)tempInt;
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[6]' out tempInt))  					armStyle = (Arm_Style)tempInt;
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[7]' out tempInt))  					letterform = (Letterform)tempInt;
Magic Number,MatterHackers.Agg.Font,Panos_1,C:\repos\MatterHackers_agg-sharp\agg\Font\TypeFace.cs,Panos_1,The following statement contains a magic number: if (int.TryParse(valuesString[8]' out tempInt))  					midline = (Midline)tempInt;
Magic Number,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The following statement contains a magic number: int descentExtraHeight = (int)(-DescentInPixels + .5);
Magic Number,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The following statement contains a magic number: ImageBuffer charImage = new ImageBuffer(Math.Max((int)(bounds.Width + .5)' 1) + 1' Math.Max((int)(EmSizeInPixels + descentExtraHeight + .5)' 1) + 1' 32' new BlenderPreMultBGRA());
Magic Number,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The following statement contains a magic number: ImageBuffer charImage = new ImageBuffer(Math.Max((int)(bounds.Width + .5)' 1) + 1' Math.Max((int)(EmSizeInPixels + descentExtraHeight + .5)' 1) + 1' 32' new BlenderPreMultBGRA());
Magic Number,MatterHackers.Agg.Font,StyledTypeFace,C:\repos\MatterHackers_agg-sharp\agg\Font\StyledTypeFace.cs,GetImageForCharacter,The following statement contains a magic number: ImageBuffer charImage = new ImageBuffer(Math.Max((int)(bounds.Width + .5)' 1) + 1' Math.Max((int)(EmSizeInPixels + descentExtraHeight + .5)' 1) + 1' 32' new BlenderPreMultBGRA());
Magic Number,MatterHackers.Agg.Image,ImageSequence,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageSequence.cs,CenterOriginOffset,The following statement contains a magic number: foreach (ImageBuffer image in imageList)  			{  				image.OriginOffset = new Vector2(image.Width / 2' image.Height / 2);  			}
Magic Number,MatterHackers.Agg.Image,ImageSequence,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageSequence.cs,CenterOriginOffset,The following statement contains a magic number: foreach (ImageBuffer image in imageList)  			{  				image.OriginOffset = new Vector2(image.Width / 2' image.Height / 2);  			}
Magic Number,MatterHackers.Agg.Image,ImageSequence,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageSequence.cs,LoadFromTgas,The following statement contains a magic number: foreach (string tgaFile in sortedTgaFiles)  			{  				using (var imageStream = File.OpenRead(tgaFile))  				{  					var imageBuffer = new ImageBuffer(new BlenderPreMultBGRA());  					ImageTgaIO.LoadImageData(imageBuffer' imageStream' 32);  					sequenceLoaded.AddImage(imageBuffer);  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageSequence,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageSequence.cs,GetFrameIndexByRatio,The following statement contains a magic number: return (int)((fractionOfTotalLength * (NumFrames - 1)) + .5);
Magic Number,MatterHackers.Agg.Image,ImageSequence,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageSequence.cs,GetImageByIndex,The following statement contains a magic number: return GetImageByIndex((int)(ImageIndex + .5));
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The following statement contains a magic number: ImageBuffer destImage = new ImageBuffer(width' height' 32' unscaledSourceImage.GetRecieveBlender());
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The following statement contains a magic number: while (unscaledSourceImage.Width >= destImage.Width * 2)  			{  				// The image sampler we use is a 2x2 filter so we need to scale by a max of 1/2 if we want to get good results.  				// So we scale as many times as we need to get the Image to be the right size.  				// If this were going to be a non-uniform scale we could do the x and y separately to get better results.  				ImageBuffer halfImage = new ImageBuffer(unscaledSourceImage.Width / 2' unscaledSourceImage.Height / 2' 32' unscaledSourceImage.GetRecieveBlender());  				halfImage.NewGraphics2D().Render(unscaledSourceImage' 0' 0' 0' halfImage.Width / (double)unscaledSourceImage.Width' halfImage.Height / (double)unscaledSourceImage.Height);  				unscaledSourceImage = halfImage;    				if (unscaledSourceImage.Width == width)  				{  					return unscaledSourceImage;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The following statement contains a magic number: while (unscaledSourceImage.Width >= destImage.Width * 2)  			{  				// The image sampler we use is a 2x2 filter so we need to scale by a max of 1/2 if we want to get good results.  				// So we scale as many times as we need to get the Image to be the right size.  				// If this were going to be a non-uniform scale we could do the x and y separately to get better results.  				ImageBuffer halfImage = new ImageBuffer(unscaledSourceImage.Width / 2' unscaledSourceImage.Height / 2' 32' unscaledSourceImage.GetRecieveBlender());  				halfImage.NewGraphics2D().Render(unscaledSourceImage' 0' 0' 0' halfImage.Width / (double)unscaledSourceImage.Width' halfImage.Height / (double)unscaledSourceImage.Height);  				unscaledSourceImage = halfImage;    				if (unscaledSourceImage.Width == width)  				{  					return unscaledSourceImage;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The following statement contains a magic number: while (unscaledSourceImage.Width >= destImage.Width * 2)  			{  				// The image sampler we use is a 2x2 filter so we need to scale by a max of 1/2 if we want to get good results.  				// So we scale as many times as we need to get the Image to be the right size.  				// If this were going to be a non-uniform scale we could do the x and y separately to get better results.  				ImageBuffer halfImage = new ImageBuffer(unscaledSourceImage.Width / 2' unscaledSourceImage.Height / 2' 32' unscaledSourceImage.GetRecieveBlender());  				halfImage.NewGraphics2D().Render(unscaledSourceImage' 0' 0' 0' halfImage.Width / (double)unscaledSourceImage.Width' halfImage.Height / (double)unscaledSourceImage.Height);  				unscaledSourceImage = halfImage;    				if (unscaledSourceImage.Width == width)  				{  					return unscaledSourceImage;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CreateScaledImage,The following statement contains a magic number: while (unscaledSourceImage.Width >= destImage.Width * 2)  			{  				// The image sampler we use is a 2x2 filter so we need to scale by a max of 1/2 if we want to get good results.  				// So we scale as many times as we need to get the Image to be the right size.  				// If this were going to be a non-uniform scale we could do the x and y separately to get better results.  				ImageBuffer halfImage = new ImageBuffer(unscaledSourceImage.Width / 2' unscaledSourceImage.Height / 2' 32' unscaledSourceImage.GetRecieveBlender());  				halfImage.NewGraphics2D().Render(unscaledSourceImage' 0' 0' 0' halfImage.Width / (double)unscaledSourceImage.Width' halfImage.Height / (double)unscaledSourceImage.Height);  				unscaledSourceImage = halfImage;    				if (unscaledSourceImage.Width == width)  				{  					return unscaledSourceImage;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,ImageBuffer,The following statement contains a magic number: int bitsPerPixel = 32;
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,ImageBuffer,The following statement contains a magic number: Allocate(width' height' width* (bitsPerPixel / 8)' bitsPerPixel);
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,ImageBuffer,The following statement contains a magic number: Allocate(width' height' width * (bitsPerPixel / 8)' bitsPerPixel);
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The following statement contains a magic number: Allocate(width' height' width * (bitsPerPixel / 8)' bitsPerPixel);
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetAlpha,The following statement contains a magic number: if (BitDepth != 32)  			{  				throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + ".");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetAlpha,The following statement contains a magic number: for (int i = 0; i < numPixels; i++)  			{  				buffer[offset + i * 4 + 3] = value;  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetAlpha,The following statement contains a magic number: for (int i = 0; i < numPixels; i++)  			{  				buffer[offset + i * 4 + 3] = value;  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Deallocate,The following statement contains a magic number: if (m_ByteBuffer != null)  			{  				m_ByteBuffer = null;  				SetDimmensionAndFormat(0' 0' 0' 32' 4' true);  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Deallocate,The following statement contains a magic number: if (m_ByteBuffer != null)  			{  				m_ByteBuffer = null;  				SetDimmensionAndFormat(0' 0' 0' 32' 4' true);  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The following statement contains a magic number: if (bitsPerPixel != 32 && bitsPerPixel != 24 && bitsPerPixel != 8)  			{  				throw new Exception("Unsupported bits per pixel.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The following statement contains a magic number: if (bitsPerPixel != 32 && bitsPerPixel != 24 && bitsPerPixel != 8)  			{  				throw new Exception("Unsupported bits per pixel.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The following statement contains a magic number: if (bitsPerPixel != 32 && bitsPerPixel != 24 && bitsPerPixel != 8)  			{  				throw new Exception("Unsupported bits per pixel.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The following statement contains a magic number: if (inScanWidthInBytes < inWidth * (bitsPerPixel / 8))  			{  				throw new Exception("Your scan width is not big enough to hold your width and height.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Allocate,The following statement contains a magic number: SetDimmensionAndFormat(inWidth' inHeight' inScanWidthInBytes' bitsPerPixel' bitsPerPixel / 8' true);
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The following statement contains a magic number: if (GetBytesBetweenPixelsInclusive() != BitDepth / 8  				|| sourceImage.GetBytesBetweenPixelsInclusive() != sourceImage.BitDepth / 8)  			{  				throw new Exception("WIP we only support packed pixel formats at this time.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The following statement contains a magic number: if (GetBytesBetweenPixelsInclusive() != BitDepth / 8  				|| sourceImage.GetBytesBetweenPixelsInclusive() != sourceImage.BitDepth / 8)  			{  				throw new Exception("WIP we only support packed pixel formats at this time.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The following statement contains a magic number: if (BitDepth == sourceImage.BitDepth)  			{  				int lengthInBytes = clippedSourceImageRect.Width * GetBytesBetweenPixelsInclusive();    				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom);  				byte[] sourceBuffer = sourceImage.GetBuffer();  				int destOffset;  				byte[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset);    				for (int i = 0; i < clippedSourceImageRect.Height; i++)  				{  					agg_basics.memmove(destBuffer' destOffset' sourceBuffer' sourceOffset' lengthInBytes);  					sourceOffset += sourceImage.StrideInBytes();  					destOffset += StrideInBytes();  				}  			}  			else  			{  				bool haveConversion = true;  				switch (sourceImage.BitDepth)  				{  					case 24:  						switch (BitDepth)  						{  							case 32:  								{  									int numPixelsToCopy = clippedSourceImageRect.Width;  									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)  									{  										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom + i);  										byte[] sourceBuffer = sourceImage.GetBuffer();  										int destOffset;  										byte[] destBuffer = GetPixelPointerXY(  											clippedSourceImageRect.Left + destXOffset'  											clippedSourceImageRect.Bottom + i + destYOffset'  											out destOffset);  										for (int x = 0; x < numPixelsToCopy; x++)  										{  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = 255;  										}  									}  								}  								break;    							default:  								haveConversion = false;  								break;  						}  						break;    					default:  						haveConversion = false;  						break;  				}    				if (!haveConversion)  				{  					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The following statement contains a magic number: if (BitDepth == sourceImage.BitDepth)  			{  				int lengthInBytes = clippedSourceImageRect.Width * GetBytesBetweenPixelsInclusive();    				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom);  				byte[] sourceBuffer = sourceImage.GetBuffer();  				int destOffset;  				byte[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset);    				for (int i = 0; i < clippedSourceImageRect.Height; i++)  				{  					agg_basics.memmove(destBuffer' destOffset' sourceBuffer' sourceOffset' lengthInBytes);  					sourceOffset += sourceImage.StrideInBytes();  					destOffset += StrideInBytes();  				}  			}  			else  			{  				bool haveConversion = true;  				switch (sourceImage.BitDepth)  				{  					case 24:  						switch (BitDepth)  						{  							case 32:  								{  									int numPixelsToCopy = clippedSourceImageRect.Width;  									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)  									{  										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom + i);  										byte[] sourceBuffer = sourceImage.GetBuffer();  										int destOffset;  										byte[] destBuffer = GetPixelPointerXY(  											clippedSourceImageRect.Left + destXOffset'  											clippedSourceImageRect.Bottom + i + destYOffset'  											out destOffset);  										for (int x = 0; x < numPixelsToCopy; x++)  										{  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = 255;  										}  									}  								}  								break;    							default:  								haveConversion = false;  								break;  						}  						break;    					default:  						haveConversion = false;  						break;  				}    				if (!haveConversion)  				{  					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,CopyFromNoClipping,The following statement contains a magic number: if (BitDepth == sourceImage.BitDepth)  			{  				int lengthInBytes = clippedSourceImageRect.Width * GetBytesBetweenPixelsInclusive();    				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom);  				byte[] sourceBuffer = sourceImage.GetBuffer();  				int destOffset;  				byte[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset);    				for (int i = 0; i < clippedSourceImageRect.Height; i++)  				{  					agg_basics.memmove(destBuffer' destOffset' sourceBuffer' sourceOffset' lengthInBytes);  					sourceOffset += sourceImage.StrideInBytes();  					destOffset += StrideInBytes();  				}  			}  			else  			{  				bool haveConversion = true;  				switch (sourceImage.BitDepth)  				{  					case 24:  						switch (BitDepth)  						{  							case 32:  								{  									int numPixelsToCopy = clippedSourceImageRect.Width;  									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)  									{  										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom + i);  										byte[] sourceBuffer = sourceImage.GetBuffer();  										int destOffset;  										byte[] destBuffer = GetPixelPointerXY(  											clippedSourceImageRect.Left + destXOffset'  											clippedSourceImageRect.Bottom + i + destYOffset'  											out destOffset);  										for (int x = 0; x < numPixelsToCopy; x++)  										{  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = 255;  										}  									}  								}  								break;    							default:  								haveConversion = false;  								break;  						}  						break;    					default:  						haveConversion = false;  						break;  				}    				if (!haveConversion)  				{  					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,FlipY,The following statement contains a magic number: for (int y = 0; y < Height / 2; y++)  			{  				int bottomBuffer = GetBufferOffsetY(y);  				int topBuffer = GetBufferOffsetY(Height - y - 1);  				for (int x = 0; x < StrideInBytes(); x++)  				{  					byte hold = buffer[bottomBuffer + x];  					buffer[bottomBuffer + x] = buffer[topBuffer + x];  					buffer[topBuffer + x] = hold;  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetDimmensionAndFormat,The following statement contains a magic number: if (distanceInBytesBetweenPixelsInclusive > 4)  			{  				throw new System.Exception("It looks like you are passing bits per pixel rather than distance in bytes.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,SetDimmensionAndFormat,The following statement contains a magic number: if (distanceInBytesBetweenPixelsInclusive < (bitDepth / 8))  			{  				throw new Exception("You do not have enough room between pixels to support your bit depth.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_hline,The following statement contains a magic number: if (sourceColor.alpha != 0)  			{  				int len = x2 - x1 + 1;    				int bufferOffset;  				byte[] buffer = GetPixelPointerXY(x1' y' out bufferOffset);    				int alpha = (((int)(sourceColor.alpha) * (cover + 1)) >> 8);  				if (alpha == base_mask)  				{  					recieveBlender.CopyPixels(buffer' bufferOffset' sourceColor' len);  				}  				else  				{  					do  					{  						recieveBlender.BlendPixel(buffer' bufferOffset' new RGBA_Bytes(sourceColor.red' sourceColor.green' sourceColor.blue' alpha));  						bufferOffset += m_DistanceInBytesBetweenPixelsInclusive;  					}  					while (--len != 0);  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_solid_hspan,The following statement contains a magic number: if (colorAlpha != 0)  			{  				unchecked  				{  					int bufferOffset;  					byte[] buffer = GetPixelPointerXY(x' y' out bufferOffset);    					do  					{  						int alpha = ((colorAlpha) * ((covers[coversIndex]) + 1)) >> 8;  						if (alpha == base_mask)  						{  							recieveBlender.CopyPixels(buffer' bufferOffset' sourceColor' 1);  						}  						else  						{  							recieveBlender.BlendPixel(buffer' bufferOffset' new RGBA_Bytes(sourceColor.red' sourceColor.green' sourceColor.blue' alpha));  						}  						bufferOffset += m_DistanceInBytesBetweenPixelsInclusive;  						coversIndex++;  					}  					while (--len != 0);  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_solid_vspan,The following statement contains a magic number: if (sourceColor.alpha != 0)  			{  				int ScanWidthInBytes = StrideInBytes();  				unchecked  				{  					int bufferOffset = GetBufferOffsetXY(x' y);  					do  					{  						byte oldAlpha = sourceColor.alpha;  						sourceColor.alpha = (byte)(((int)(sourceColor.alpha) * ((int)(covers[coversIndex++]) + 1)) >> 8);  						if (sourceColor.alpha == base_mask)  						{  							recieveBlender.CopyPixels(m_ByteBuffer' bufferOffset' sourceColor' 1);  						}  						else  						{  							recieveBlender.BlendPixel(m_ByteBuffer' bufferOffset' sourceColor);  						}  						bufferOffset += ScanWidthInBytes;  						sourceColor.alpha = oldAlpha;  					}  					while (--len != 0);  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,blend_color_vspan,The following statement contains a magic number: if (!firstCoverForAll)  			{  				do  				{  					DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender' m_ByteBuffer' bufferOffset' colors[colorsIndex]' covers[coversIndex++]);  					bufferOffset += ScanWidth;  					++colorsIndex;  				}  				while (--len != 0);  			}  			else  			{  				if (covers[coversIndex] == 255)  				{  					do  					{  						DoCopyOrBlend.BasedOnAlpha(recieveBlender' m_ByteBuffer' bufferOffset' colors[colorsIndex]);  						bufferOffset += ScanWidth;  						++colorsIndex;  					}  					while (--len != 0);  				}  				else  				{  					do  					{  						DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender' m_ByteBuffer' bufferOffset' colors[colorsIndex]' covers[coversIndex]);  						bufferOffset += ScanWidth;  						++colorsIndex;  					}  					while (--len != 0);  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Equals,The following statement contains a magic number: if (Width == b.Width  				&& Height == b.Height  				&& BitDepth == b.BitDepth  				&& StrideInBytes() == b.StrideInBytes()  				&& OriginOffset == b.OriginOffset)  			{  				int bytesPerPixel = BitDepth / 8;  				int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();  				int bDistanceBetweenPixels = b.GetBytesBetweenPixelsInclusive();  				byte[] aBuffer = GetBuffer();  				byte[] bBuffer = b.GetBuffer();  				for (int y = 0; y < Height; y++)  				{  					int aBufferOffset = GetBufferOffsetY(y);  					int bBufferOffset = b.GetBufferOffsetY(y);  					for (int x = 0; x < Width; x++)  					{  						for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)  						{  							byte aByte = aBuffer[aBufferOffset + byteIndex];  							byte bByte = bBuffer[bBufferOffset + byteIndex];  							if (aByte < (bByte - maxError) || aByte > (bByte + maxError))  							{  								return false;  							}  						}  						aBufferOffset += aDistanceBetweenPixels;  						bBufferOffset += bDistanceBetweenPixels;  					}  				}  				return true;  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Contains,The following statement contains a magic number: if (Width >= imageToFind.Width  				&& Height >= imageToFind.Height  				&& BitDepth == imageToFind.BitDepth)  			{  				int bytesPerPixel = BitDepth / 8;  				int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();  				int bDistanceBetweenPixels = imageToFind.GetBytesBetweenPixelsInclusive();  				byte[] thisBuffer = GetBuffer();  				byte[] containedBuffer = imageToFind.GetBuffer();  				for (matchY = 0; matchY <= Height - imageToFind.Height; matchY++)  				{  					for (matchX = 0; matchX <= Width - imageToFind.Width; matchX++)  					{  						bool foundBadMatch = false;  						for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)  						{  							int thisBufferOffset = GetBufferOffsetXY(matchX' matchY + imageToFindY);  							int imageToFindBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);  							for (int imageToFindX = 0; imageToFindX < imageToFind.Width; imageToFindX++)  							{  								for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)  								{  									byte aByte = thisBuffer[thisBufferOffset + byteIndex];  									byte bByte = containedBuffer[imageToFindBufferOffset + byteIndex];  									if (aByte < (bByte - maxError) || aByte > (bByte + maxError))  									{  										foundBadMatch = true;  										byteIndex = bytesPerPixel;  										imageToFindX = imageToFind.Width;  										imageToFindY = imageToFind.Height;  									}  								}  								thisBufferOffset += aDistanceBetweenPixels;  								imageToFindBufferOffset += bDistanceBetweenPixels;  							}  						}  						if (!foundBadMatch)  						{  							return true;  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,FindLeastSquaresMatch,The following statement contains a magic number: if (Width >= imageToFind.Width  				&& Height >= imageToFind.Height  				&& BitDepth == imageToFind.BitDepth)  			{  				int bytesPerPixel = BitDepth / 8;  				int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();  				int bDistanceBetweenPixels = imageToFind.GetBytesBetweenPixelsInclusive();  				byte[] thisBuffer = GetBuffer();  				byte[] containedBuffer = imageToFind.GetBuffer();  				for (int matchY = 0; matchY <= Height - imageToFind.Height; matchY++)  				{  					for (int matchX = 0; matchX <= Width - imageToFind.Width; matchX++)  					{  						double currentLeastSquares = 0;    						for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)  						{  							int thisBufferOffset = GetBufferOffsetXY(matchX' matchY + imageToFindY);  							int imageToFindBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);  							for (int imageToFindX = 0; imageToFindX < imageToFind.Width; imageToFindX++)  							{  								for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)  								{  									byte aByte = thisBuffer[thisBufferOffset + byteIndex];  									byte bByte = containedBuffer[imageToFindBufferOffset + byteIndex];  									int difference = (int)aByte - (int)bByte;  									currentLeastSquares += difference * difference;  								}  								thisBufferOffset += aDistanceBetweenPixels;  								imageToFindBufferOffset += bDistanceBetweenPixels;  								if (currentLeastSquares > maxError)  								{  									// stop checking we have too much error.  									imageToFindX = imageToFind.Width;  									imageToFindY = imageToFind.Height;  								}  							}  						}    						if (currentLeastSquares < bestLeastSquares)  						{  							bestPosition = new Vector2(matchX' matchY);  							bestLeastSquares = currentLeastSquares;  							if (maxError > currentLeastSquares)  							{  								maxError = currentLeastSquares;  								if (currentLeastSquares == 0)  								{  									return true;  								}  							}  						}  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBuffer,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,Initialize,The following statement contains a magic number: Allocate(boundsToCopyFrom.Width' boundsToCopyFrom.Height' boundsToCopyFrom.Width * sourceImage.BitDepth / 8' sourceImage.BitDepth);
Magic Number,MatterHackers.Agg.Image,DoCopyOrBlend,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,BasedOnAlphaAndCover,The following statement contains a magic number: if (cover == 255)  			{  				BasedOnAlpha(recieveBlender' destBuffer' bufferOffset' sourceColor);  			}  			else  			{  				//if (sourceColor.m_A != 0)  				{  					sourceColor.alpha = (byte)((sourceColor.alpha * (cover + 1)) >> 8);  #if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB                      if (sourceColor.m_A == base_mask)                      {                          Blender.CopyPixel(pDestBuffer' sourceColor);                      }                      else  #endif  					{  						recieveBlender.BlendPixel(destBuffer' bufferOffset' sourceColor);  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,DoCopyOrBlend,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBuffer.cs,BasedOnAlphaAndCover,The following statement contains a magic number: if (cover == 255)  			{  				BasedOnAlpha(recieveBlender' destBuffer' bufferOffset' sourceColor);  			}  			else  			{  				//if (sourceColor.m_A != 0)  				{  					sourceColor.alpha = (byte)((sourceColor.alpha * (cover + 1)) >> 8);  #if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB                      if (sourceColor.m_A == base_mask)                      {                          Blender.CopyPixel(pDestBuffer' sourceColor);                      }                      else  #endif  					{  						recieveBlender.BlendPixel(destBuffer' bufferOffset' sourceColor);  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,ImageBufferFloat,The following statement contains a magic number: Allocate(width' height' width * (bitsPerPixel / 32)' bitsPerPixel);
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetAlpha,The following statement contains a magic number: if (BitDepth != 32)  			{  				throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + ".");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetAlpha,The following statement contains a magic number: for (int i = 0; i < numPixels; i++)  			{  				buffer[offset + i * 4 + 3] = value;  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetAlpha,The following statement contains a magic number: for (int i = 0; i < numPixels; i++)  			{  				buffer[offset + i * 4 + 3] = value;  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Deallocate,The following statement contains a magic number: SetDimmensionAndFormat(0' 0' 0' 32' 4);
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Deallocate,The following statement contains a magic number: SetDimmensionAndFormat(0' 0' 0' 32' 4);
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Allocate,The following statement contains a magic number: if (bitsPerPixel != 128 && bitsPerPixel != 96 && bitsPerPixel != 32)  			{  				throw new Exception("Unsupported bits per pixel.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Allocate,The following statement contains a magic number: if (bitsPerPixel != 128 && bitsPerPixel != 96 && bitsPerPixel != 32)  			{  				throw new Exception("Unsupported bits per pixel.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Allocate,The following statement contains a magic number: if (bitsPerPixel != 128 && bitsPerPixel != 96 && bitsPerPixel != 32)  			{  				throw new Exception("Unsupported bits per pixel.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Allocate,The following statement contains a magic number: if (inScanWidthInFloats < inWidth * (bitsPerPixel / 32))  			{  				throw new Exception("Your scan width is not big enough to hold your width and height.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Allocate,The following statement contains a magic number: SetDimmensionAndFormat(inWidth' inHeight' inScanWidthInFloats' bitsPerPixel' bitsPerPixel / 32);
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The following statement contains a magic number: if (GetFloatsBetweenPixelsInclusive() != BitDepth / 32  				|| sourceImage.GetFloatsBetweenPixelsInclusive() != sourceImage.BitDepth / 32)  			{  				throw new Exception("WIP we only support packed pixel formats at this time.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The following statement contains a magic number: if (GetFloatsBetweenPixelsInclusive() != BitDepth / 32  				|| sourceImage.GetFloatsBetweenPixelsInclusive() != sourceImage.BitDepth / 32)  			{  				throw new Exception("WIP we only support packed pixel formats at this time.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The following statement contains a magic number: if (BitDepth == sourceImage.BitDepth)  			{  				int lengthInFloats = clippedSourceImageRect.Width * GetFloatsBetweenPixelsInclusive();    				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom);  				float[] sourceBuffer = sourceImage.GetBuffer();  				int destOffset;  				float[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset);    				for (int i = 0; i < clippedSourceImageRect.Height; i++)  				{  					agg_basics.memmove(destBuffer' destOffset' sourceBuffer' sourceOffset' lengthInFloats);  					sourceOffset += sourceImage.StrideInFloats();  					destOffset += StrideInFloats();  				}  			}  			else  			{  				bool haveConversion = true;  				switch (sourceImage.BitDepth)  				{  					case 24:  						switch (BitDepth)  						{  							case 32:  								{  									int numPixelsToCopy = clippedSourceImageRect.Width;  									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)  									{  										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom + i);  										float[] sourceBuffer = sourceImage.GetBuffer();  										int destOffset;  										float[] destBuffer = GetPixelPointerXY(  											clippedSourceImageRect.Left + destXOffset'  											clippedSourceImageRect.Bottom + i + destYOffset'  											out destOffset);  										for (int x = 0; x < numPixelsToCopy; x++)  										{  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = 255;  										}  									}  								}  								break;    							default:  								haveConversion = false;  								break;  						}  						break;    					default:  						haveConversion = false;  						break;  				}    				if (!haveConversion)  				{  					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The following statement contains a magic number: if (BitDepth == sourceImage.BitDepth)  			{  				int lengthInFloats = clippedSourceImageRect.Width * GetFloatsBetweenPixelsInclusive();    				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom);  				float[] sourceBuffer = sourceImage.GetBuffer();  				int destOffset;  				float[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset);    				for (int i = 0; i < clippedSourceImageRect.Height; i++)  				{  					agg_basics.memmove(destBuffer' destOffset' sourceBuffer' sourceOffset' lengthInFloats);  					sourceOffset += sourceImage.StrideInFloats();  					destOffset += StrideInFloats();  				}  			}  			else  			{  				bool haveConversion = true;  				switch (sourceImage.BitDepth)  				{  					case 24:  						switch (BitDepth)  						{  							case 32:  								{  									int numPixelsToCopy = clippedSourceImageRect.Width;  									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)  									{  										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom + i);  										float[] sourceBuffer = sourceImage.GetBuffer();  										int destOffset;  										float[] destBuffer = GetPixelPointerXY(  											clippedSourceImageRect.Left + destXOffset'  											clippedSourceImageRect.Bottom + i + destYOffset'  											out destOffset);  										for (int x = 0; x < numPixelsToCopy; x++)  										{  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = 255;  										}  									}  								}  								break;    							default:  								haveConversion = false;  								break;  						}  						break;    					default:  						haveConversion = false;  						break;  				}    				if (!haveConversion)  				{  					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,CopyFromNoClipping,The following statement contains a magic number: if (BitDepth == sourceImage.BitDepth)  			{  				int lengthInFloats = clippedSourceImageRect.Width * GetFloatsBetweenPixelsInclusive();    				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom);  				float[] sourceBuffer = sourceImage.GetBuffer();  				int destOffset;  				float[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset' clippedSourceImageRect.Bottom + destYOffset' out destOffset);    				for (int i = 0; i < clippedSourceImageRect.Height; i++)  				{  					agg_basics.memmove(destBuffer' destOffset' sourceBuffer' sourceOffset' lengthInFloats);  					sourceOffset += sourceImage.StrideInFloats();  					destOffset += StrideInFloats();  				}  			}  			else  			{  				bool haveConversion = true;  				switch (sourceImage.BitDepth)  				{  					case 24:  						switch (BitDepth)  						{  							case 32:  								{  									int numPixelsToCopy = clippedSourceImageRect.Width;  									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)  									{  										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left' clippedSourceImageRect.Bottom + i);  										float[] sourceBuffer = sourceImage.GetBuffer();  										int destOffset;  										float[] destBuffer = GetPixelPointerXY(  											clippedSourceImageRect.Left + destXOffset'  											clippedSourceImageRect.Bottom + i + destYOffset'  											out destOffset);  										for (int x = 0; x < numPixelsToCopy; x++)  										{  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];  											destBuffer[destOffset++] = 255;  										}  									}  								}  								break;    							default:  								haveConversion = false;  								break;  						}  						break;    					default:  						haveConversion = false;  						break;  				}    				if (!haveConversion)  				{  					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetDimmensionAndFormat,The following statement contains a magic number: if (distanceInFloatsBetweenPixelsInclusive > 4)  			{  				throw new System.Exception("It looks like you are passing bits per pixel rather than distance in Floats.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,SetDimmensionAndFormat,The following statement contains a magic number: if (distanceInFloatsBetweenPixelsInclusive < (bitDepth / 32))  			{  				throw new Exception("You do not have enough room between pixels to support your bit depth.");  			}
Magic Number,MatterHackers.Agg.Image,ImageBufferFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,Initialize,The following statement contains a magic number: Allocate(boundsToCopyFrom.Width' boundsToCopyFrom.Height' boundsToCopyFrom.Width * sourceImage.BitDepth / 8' sourceImage.BitDepth);
Magic Number,MatterHackers.Agg.Image,DoCopyOrBlendFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,BasedOnAlphaAndCover,The following statement contains a magic number: if (cover == 255)  			{  				BasedOnAlpha(Blender' destBuffer' bufferOffset' sourceColor);  			}  			else  			{  				//if (sourceColor.m_A != 0)  				{  					sourceColor.alpha = sourceColor.alpha * ((float)cover * (1 / 255));  #if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB                      if (sourceColor.m_A == base_mask)                      {                          Blender.CopyPixel(pDestBuffer' sourceColor);                      }                      else  #endif  					{  						Blender.BlendPixel(destBuffer' bufferOffset' sourceColor);  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,DoCopyOrBlendFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageBufferFloat.cs,BasedOnAlphaAndCover,The following statement contains a magic number: if (cover == 255)  			{  				BasedOnAlpha(Blender' destBuffer' bufferOffset' sourceColor);  			}  			else  			{  				//if (sourceColor.m_A != 0)  				{  					sourceColor.alpha = sourceColor.alpha * ((float)cover * (1 / 255));  #if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB                      if (sourceColor.m_A == base_mask)                      {                          Blender.CopyPixel(pDestBuffer' sourceColor);                      }                      else  #endif  					{  						Blender.BlendPixel(destBuffer' bufferOffset' sourceColor);  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int DestOffset = Height * Width * 3;  				for (int i = 0; i < Width * 3; i++)  				{  					Dest[DestOffset + i] = Source[SourceOffset + i];  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int DestOffset = Height * Width * 3;  				for (int i = 0; i < Width * 3; i++)  				{  					Dest[DestOffset + i] = Source[SourceOffset + i];  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 3;  				do  				{  					Dest[DestOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];  					SourceOffset += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 3;  				do  				{  					Dest[DestOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];  					SourceOffset += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 3;  				do  				{  					Dest[DestOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];  					SourceOffset += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 3;  				do  				{  					Dest[DestOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];  					SourceOffset += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To24Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 3;  				do  				{  					Dest[DestOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];  					SourceOffset += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do24To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + i * 4 + 3] = 255;  					SourceOffset += 3;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + RGBA_ALPHA] = Source[SourceOffset + RGBA_ALPHA];  					SourceOffset += 4;  					DestOffest += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + RGBA_ALPHA] = Source[SourceOffset + RGBA_ALPHA];  					SourceOffset += 4;  					DestOffest += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Do32To32Bit,The following statement contains a magic number: if (Width > 0)  			{  				int i = 0;  				int DestOffest = Height * Width * 4;  				do  				{  					Dest[DestOffest + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];  					Dest[DestOffest + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];  					Dest[DestOffest + RGB_RED] = Source[SourceOffset + RGB_RED];  					Dest[DestOffest + RGBA_ALPHA] = Source[SourceOffset + RGBA_ALPHA];  					SourceOffset += 4;  					DestOffest += 4;  				} while (++i < Width);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.ImageType = WorkPtr[2];
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.ColorMapStart = BitConverter.ToUInt16(WorkPtr' 3);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.ColorMapLength = BitConverter.ToUInt16(WorkPtr' 5);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.ColorMapBits = WorkPtr[7];
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.XStart = BitConverter.ToUInt16(WorkPtr' 8);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.YStart = BitConverter.ToUInt16(WorkPtr' 10);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.Width = BitConverter.ToUInt16(WorkPtr' 12);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.Height = BitConverter.ToUInt16(WorkPtr' 14);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.BPP = WorkPtr[16];
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: TargaHeader.Descriptor = WorkPtr[17];
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB' 1 = Palette  				// 1 = Palette' 2 = RGB' 3 = mono' 9 = RLE Palette' 10 = RLE RGB' 11 RLE mono  				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||  				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32))  			{  #if DEBUG  				throw new NotImplementedException("Unsupported TGA mode");  #endif  #if ASSERTS_ENABLED  		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )  		        {  			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'  			        // if so it's a BMP not a TGA  		        }  		        else  		        {  			        byte * pColorMapType = NULL;  			        switch (TargaHeader.ColorMapType)  			        {  				        case 0:  					        pColorMapType = "RGB Color Map";  					        break;    				        case 1:  					        pColorMapType = "Palette Color Map";  					        break;    				        default:  					        pColorMapType = "<Illegal Color Map>";  					        break;  			        }  			        byte * pImageType = NULL;  			        switch (TargaHeader.ImageType)  			        {  				        case 1:  					        pImageType = "Palette Image Type";  					        break;    				        case 2:  					        pImageType = "RGB Image Type";  					        break;    				        case 3:  					        pImageType = "mono Image Type";  					        break;    				        case 9:  					        pImageType = "RLE Palette Image Type";  					        break;    				        case 10:  					        pImageType = "RLE RGB Image Type";  					        break;    				        case 11:  					        pImageType = "RLE mono Image Type";  					        break;    				        default:  					        pImageType = "<Illegal Image Type>";  					        break;  			        }  			        int ColorDepth = TargaHeader.BPP;  			        CJString ErrorString;  			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!"' pColorMapType' pImageType' ColorDepth);  			        ShowSystemMessage("TGA File IO Error"' ErrorString.GetBytePtr()' "TGA Error");  		        }  #endif // ASSERTS_ENABLED  				return false;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB' 1 = Palette  				// 1 = Palette' 2 = RGB' 3 = mono' 9 = RLE Palette' 10 = RLE RGB' 11 RLE mono  				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||  				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32))  			{  #if DEBUG  				throw new NotImplementedException("Unsupported TGA mode");  #endif  #if ASSERTS_ENABLED  		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )  		        {  			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'  			        // if so it's a BMP not a TGA  		        }  		        else  		        {  			        byte * pColorMapType = NULL;  			        switch (TargaHeader.ColorMapType)  			        {  				        case 0:  					        pColorMapType = "RGB Color Map";  					        break;    				        case 1:  					        pColorMapType = "Palette Color Map";  					        break;    				        default:  					        pColorMapType = "<Illegal Color Map>";  					        break;  			        }  			        byte * pImageType = NULL;  			        switch (TargaHeader.ImageType)  			        {  				        case 1:  					        pImageType = "Palette Image Type";  					        break;    				        case 2:  					        pImageType = "RGB Image Type";  					        break;    				        case 3:  					        pImageType = "mono Image Type";  					        break;    				        case 9:  					        pImageType = "RLE Palette Image Type";  					        break;    				        case 10:  					        pImageType = "RLE RGB Image Type";  					        break;    				        case 11:  					        pImageType = "RLE mono Image Type";  					        break;    				        default:  					        pImageType = "<Illegal Image Type>";  					        break;  			        }  			        int ColorDepth = TargaHeader.BPP;  			        CJString ErrorString;  			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!"' pColorMapType' pImageType' ColorDepth);  			        ShowSystemMessage("TGA File IO Error"' ErrorString.GetBytePtr()' "TGA Error");  		        }  #endif // ASSERTS_ENABLED  				return false;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB' 1 = Palette  				// 1 = Palette' 2 = RGB' 3 = mono' 9 = RLE Palette' 10 = RLE RGB' 11 RLE mono  				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||  				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32))  			{  #if DEBUG  				throw new NotImplementedException("Unsupported TGA mode");  #endif  #if ASSERTS_ENABLED  		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )  		        {  			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'  			        // if so it's a BMP not a TGA  		        }  		        else  		        {  			        byte * pColorMapType = NULL;  			        switch (TargaHeader.ColorMapType)  			        {  				        case 0:  					        pColorMapType = "RGB Color Map";  					        break;    				        case 1:  					        pColorMapType = "Palette Color Map";  					        break;    				        default:  					        pColorMapType = "<Illegal Color Map>";  					        break;  			        }  			        byte * pImageType = NULL;  			        switch (TargaHeader.ImageType)  			        {  				        case 1:  					        pImageType = "Palette Image Type";  					        break;    				        case 2:  					        pImageType = "RGB Image Type";  					        break;    				        case 3:  					        pImageType = "mono Image Type";  					        break;    				        case 9:  					        pImageType = "RLE Palette Image Type";  					        break;    				        case 10:  					        pImageType = "RLE RGB Image Type";  					        break;    				        case 11:  					        pImageType = "RLE mono Image Type";  					        break;    				        default:  					        pImageType = "<Illegal Image Type>";  					        break;  			        }  			        int ColorDepth = TargaHeader.BPP;  			        CJString ErrorString;  			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!"' pColorMapType' pImageType' ColorDepth);  			        ShowSystemMessage("TGA File IO Error"' ErrorString.GetBytePtr()' "TGA Error");  		        }  #endif // ASSERTS_ENABLED  				return false;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB' 1 = Palette  				// 1 = Palette' 2 = RGB' 3 = mono' 9 = RLE Palette' 10 = RLE RGB' 11 RLE mono  				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||  				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32))  			{  #if DEBUG  				throw new NotImplementedException("Unsupported TGA mode");  #endif  #if ASSERTS_ENABLED  		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )  		        {  			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'  			        // if so it's a BMP not a TGA  		        }  		        else  		        {  			        byte * pColorMapType = NULL;  			        switch (TargaHeader.ColorMapType)  			        {  				        case 0:  					        pColorMapType = "RGB Color Map";  					        break;    				        case 1:  					        pColorMapType = "Palette Color Map";  					        break;    				        default:  					        pColorMapType = "<Illegal Color Map>";  					        break;  			        }  			        byte * pImageType = NULL;  			        switch (TargaHeader.ImageType)  			        {  				        case 1:  					        pImageType = "Palette Image Type";  					        break;    				        case 2:  					        pImageType = "RGB Image Type";  					        break;    				        case 3:  					        pImageType = "mono Image Type";  					        break;    				        case 9:  					        pImageType = "RLE Palette Image Type";  					        break;    				        case 10:  					        pImageType = "RLE RGB Image Type";  					        break;    				        case 11:  					        pImageType = "RLE mono Image Type";  					        break;    				        default:  					        pImageType = "<Illegal Image Type>";  					        break;  			        }  			        int ColorDepth = TargaHeader.BPP;  			        CJString ErrorString;  			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!"' pColorMapType' pImageType' ColorDepth);  			        ShowSystemMessage("TGA File IO Error"' ErrorString.GetBytePtr()' "TGA Error");  		        }  #endif // ASSERTS_ENABLED  				return false;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,ReadTGAInfo,The following statement contains a magic number: if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB' 1 = Palette  				// 1 = Palette' 2 = RGB' 3 = mono' 9 = RLE Palette' 10 = RLE RGB' 11 RLE mono  				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||  				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32))  			{  #if DEBUG  				throw new NotImplementedException("Unsupported TGA mode");  #endif  #if ASSERTS_ENABLED  		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )  		        {  			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'  			        // if so it's a BMP not a TGA  		        }  		        else  		        {  			        byte * pColorMapType = NULL;  			        switch (TargaHeader.ColorMapType)  			        {  				        case 0:  					        pColorMapType = "RGB Color Map";  					        break;    				        case 1:  					        pColorMapType = "Palette Color Map";  					        break;    				        default:  					        pColorMapType = "<Illegal Color Map>";  					        break;  			        }  			        byte * pImageType = NULL;  			        switch (TargaHeader.ImageType)  			        {  				        case 1:  					        pImageType = "Palette Image Type";  					        break;    				        case 2:  					        pImageType = "RGB Image Type";  					        break;    				        case 3:  					        pImageType = "mono Image Type";  					        break;    				        case 9:  					        pImageType = "RLE Palette Image Type";  					        break;    				        case 10:  					        pImageType = "RLE RGB Image Type";  					        break;    				        case 11:  					        pImageType = "RLE mono Image Type";  					        break;    				        default:  					        pImageType = "<Illegal Image Type>";  					        break;  			        }  			        int ColorDepth = TargaHeader.BPP;  			        CJString ErrorString;  			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!"' pColorMapType' pImageType' ColorDepth);  			        ShowSystemMessage("TGA File IO Error"' ErrorString.GetBytePtr()' "TGA Error");  		        }  #endif // ASSERTS_ENABLED  				return false;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The following statement contains a magic number: do  			{  				int i;  				int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;  				Total += NumPixels;  				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)  				{  					// decompress the run for NumPixels  					byte r' g' b' a;  					b = pBitsToPars[ParsOffset++];  					g = pBitsToPars[ParsOffset++];  					r = pBitsToPars[ParsOffset++];  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  							}  							break;    						case 32:  							a = pBitsToPars[ParsOffset++];  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  								pDecompressBits[DecompressOffset++] = a;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  				else // store NumPixels normally  				{  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels * 3; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						case 32:  							for (i = 0; i < NumPixels * 4; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  			} while (Total < Width);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The following statement contains a magic number: do  			{  				int i;  				int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;  				Total += NumPixels;  				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)  				{  					// decompress the run for NumPixels  					byte r' g' b' a;  					b = pBitsToPars[ParsOffset++];  					g = pBitsToPars[ParsOffset++];  					r = pBitsToPars[ParsOffset++];  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  							}  							break;    						case 32:  							a = pBitsToPars[ParsOffset++];  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  								pDecompressBits[DecompressOffset++] = a;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  				else // store NumPixels normally  				{  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels * 3; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						case 32:  							for (i = 0; i < NumPixels * 4; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  			} while (Total < Width);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The following statement contains a magic number: do  			{  				int i;  				int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;  				Total += NumPixels;  				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)  				{  					// decompress the run for NumPixels  					byte r' g' b' a;  					b = pBitsToPars[ParsOffset++];  					g = pBitsToPars[ParsOffset++];  					r = pBitsToPars[ParsOffset++];  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  							}  							break;    						case 32:  							a = pBitsToPars[ParsOffset++];  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  								pDecompressBits[DecompressOffset++] = a;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  				else // store NumPixels normally  				{  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels * 3; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						case 32:  							for (i = 0; i < NumPixels * 4; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  			} while (Total < Width);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The following statement contains a magic number: do  			{  				int i;  				int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;  				Total += NumPixels;  				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)  				{  					// decompress the run for NumPixels  					byte r' g' b' a;  					b = pBitsToPars[ParsOffset++];  					g = pBitsToPars[ParsOffset++];  					r = pBitsToPars[ParsOffset++];  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  							}  							break;    						case 32:  							a = pBitsToPars[ParsOffset++];  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  								pDecompressBits[DecompressOffset++] = a;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  				else // store NumPixels normally  				{  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels * 3; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						case 32:  							for (i = 0; i < NumPixels * 4; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  			} while (Total < Width);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The following statement contains a magic number: do  			{  				int i;  				int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;  				Total += NumPixels;  				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)  				{  					// decompress the run for NumPixels  					byte r' g' b' a;  					b = pBitsToPars[ParsOffset++];  					g = pBitsToPars[ParsOffset++];  					r = pBitsToPars[ParsOffset++];  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  							}  							break;    						case 32:  							a = pBitsToPars[ParsOffset++];  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  								pDecompressBits[DecompressOffset++] = a;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  				else // store NumPixels normally  				{  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels * 3; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						case 32:  							for (i = 0; i < NumPixels * 4; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  			} while (Total < Width);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Decompress,The following statement contains a magic number: do  			{  				int i;  				int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;  				Total += NumPixels;  				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)  				{  					// decompress the run for NumPixels  					byte r' g' b' a;  					b = pBitsToPars[ParsOffset++];  					g = pBitsToPars[ParsOffset++];  					r = pBitsToPars[ParsOffset++];  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  							}  							break;    						case 32:  							a = pBitsToPars[ParsOffset++];  							for (i = 0; i < NumPixels; i++)  							{  								pDecompressBits[DecompressOffset++] = b;  								pDecompressBits[DecompressOffset++] = g;  								pDecompressBits[DecompressOffset++] = r;  								pDecompressBits[DecompressOffset++] = a;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  				else // store NumPixels normally  				{  					switch (Depth)  					{  						case 24:  							for (i = 0; i < NumPixels * 3; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						case 32:  							for (i = 0; i < NumPixels * 4; i++)  							{  								pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];  							}  							break;    						default:  							throw new System.Exception("Bad bit depth.");  					}  				}  			} while (Total < Width);
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if ((imageToReadTo.Width * imageToReadTo.Height) != (TargaHeader.Width * TargaHeader.Height))  			{  				imageToReadTo.Allocate(TargaHeader.Width' TargaHeader.Height' TargaHeader.Width * DestBitDepth / 8' DestBitDepth);  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: switch (imageToReadTo.BitDepth)  			{  				case 24:  					TGABytesPerLine = imageToReadTo.Width * 3;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGR());  					}  					break;    				case 32:  					TGABytesPerLine = imageToReadTo.Width * 4;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGRA());  					}  					break;    				default:  					throw new System.Exception("Bad bit depth.");  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: switch (imageToReadTo.BitDepth)  			{  				case 24:  					TGABytesPerLine = imageToReadTo.Width * 3;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGR());  					}  					break;    				case 32:  					TGABytesPerLine = imageToReadTo.Width * 4;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGRA());  					}  					break;    				default:  					throw new System.Exception("Bad bit depth.");  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: switch (imageToReadTo.BitDepth)  			{  				case 24:  					TGABytesPerLine = imageToReadTo.Width * 3;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGR());  					}  					break;    				case 32:  					TGABytesPerLine = imageToReadTo.Width * 4;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGRA());  					}  					break;    				default:  					throw new System.Exception("Bad bit depth.");  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: switch (imageToReadTo.BitDepth)  			{  				case 24:  					TGABytesPerLine = imageToReadTo.Width * 3;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGR());  					}  					break;    				case 32:  					TGABytesPerLine = imageToReadTo.Width * 4;  					if (imageToReadTo.GetRecieveBlender() == null)  					{  						imageToReadTo.SetRecieveBlender(new BlenderBGRA());  					}  					break;    				default:  					throw new System.Exception("Bad bit depth.");  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following statement contains a magic number: if (TGABytesPerLine > 0)  			{  				byte[] BufferToDecompressTo = null;  				FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;    				if (TargaHeader.ImageType == 10) // 10 is RLE compressed  				{  					BufferToDecompressTo = new byte[TGABytesPerLine * 2];  				}    				// read all the lines *  				for (int i = 0; i < imageToReadTo.Height; i++)  				{  					byte[] BufferToCopyFrom;  					int CopyOffset = 0;    					int CurReadLine;    					// bit 5 tells us if the image is stored top to bottom or bottom to top  					if ((TargaHeader.Descriptor & 0x20) != 0)  					{  						// bottom to top  						CurReadLine = imageToReadTo.Height - i - 1;  					}  					else  					{  						// top to bottom  						CurReadLine = i;  					}    					if (TargaHeader.ImageType == 10) // 10 is RLE compressed  					{  						FileReadOffset = Decompress(BufferToDecompressTo' wholeFileBuffer' FileReadOffset' imageToReadTo.Width' TargaHeader.BPP' CurReadLine);  						BufferToCopyFrom = BufferToDecompressTo;  					}  					else  					{  						BufferToCopyFrom = wholeFileBuffer;  						CopyOffset = FileReadOffset;  					}    					int bufferOffset;  					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);    					switch (imageToReadTo.BitDepth)  					{  						case 8:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 24:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						case 32:  							switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}  							break;    						default:  							throw new System.Exception("Bad bit depth");  					}    					if (TargaHeader.ImageType != 10) // 10 is RLE compressed  					{  						FileReadOffset += TGABytesPerLine;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine24,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 3' 3' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    					sourceOffset += (SameLength) * 3;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 3' 3' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the same length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];    						sourceOffset += 3;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,CompressLine32,The following statement contains a magic number: while (pixelsProcessed < Width)  			{  				// always get as many as you can that are the same first  				int Max = System.Math.Min(MAX_RUN_LENGTH' (Width - 1) - pixelsProcessed);  				int SameLength = GetSameLength(sourceBuffer' sourceOffset' sourceBuffer' sourceOffset + 4' 4' Max);  				if (SameLength > 0)  				{  					// write in the count  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}    					destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);    					// write in the same length pixel value  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  					destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    					sourceOffset += (SameLength) * 4;  					pixelsProcessed += SameLength + 1;  				}  				else  				{  					differenceHold[0] = sourceBuffer[sourceOffset + 0];  					differenceHold[1] = sourceBuffer[sourceOffset + 1];  					differenceHold[2] = sourceBuffer[sourceOffset + 2];  					differenceHold[3] = sourceBuffer[sourceOffset + 3];  					int DifLength = GetDifLength(differenceHold' sourceBuffer' sourceOffset + 4' 4' Max);  					if (DifLength == 0)  					{  						DifLength = 1;  					}    					// write in the count (if there is only one the count is 0)  					if (SameLength > MAX_RUN_LENGTH)  					{  						throw new Exception();  					}  					destBuffer[WritePos++] = (byte)(DifLength - 1);    					while (DifLength-- > 0)  					{  						// write in the dif length pixel value  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];  						destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];    						sourceOffset += 4;  						pixelsProcessed++;  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: if (SourceDepth == 8)  			{  				TargaHeader.ColorMapType = 1;		// Color type is Palette  				TargaHeader.ImageType = 9;		// 1 = Palette' 9 = RLE Palette  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 256;  				TargaHeader.ColorMapBits = 24;  			}  			else  			{  				TargaHeader.ColorMapType = 0;		// Color type is RGB  #if WRITE_RLE_COMPRESSED  		        TargaHeader.ImageType = 10;		// RLE RGB  #else  				TargaHeader.ImageType = 2;		// RGB  #endif  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 0;  				TargaHeader.ColorMapBits = 0;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: if (SourceDepth == 8)  			{  				TargaHeader.ColorMapType = 1;		// Color type is Palette  				TargaHeader.ImageType = 9;		// 1 = Palette' 9 = RLE Palette  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 256;  				TargaHeader.ColorMapBits = 24;  			}  			else  			{  				TargaHeader.ColorMapType = 0;		// Color type is RGB  #if WRITE_RLE_COMPRESSED  		        TargaHeader.ImageType = 10;		// RLE RGB  #else  				TargaHeader.ImageType = 2;		// RGB  #endif  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 0;  				TargaHeader.ColorMapBits = 0;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: if (SourceDepth == 8)  			{  				TargaHeader.ColorMapType = 1;		// Color type is Palette  				TargaHeader.ImageType = 9;		// 1 = Palette' 9 = RLE Palette  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 256;  				TargaHeader.ColorMapBits = 24;  			}  			else  			{  				TargaHeader.ColorMapType = 0;		// Color type is RGB  #if WRITE_RLE_COMPRESSED  		        TargaHeader.ImageType = 10;		// RLE RGB  #else  				TargaHeader.ImageType = 2;		// RGB  #endif  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 0;  				TargaHeader.ColorMapBits = 0;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: if (SourceDepth == 8)  			{  				TargaHeader.ColorMapType = 1;		// Color type is Palette  				TargaHeader.ImageType = 9;		// 1 = Palette' 9 = RLE Palette  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 256;  				TargaHeader.ColorMapBits = 24;  			}  			else  			{  				TargaHeader.ColorMapType = 0;		// Color type is RGB  #if WRITE_RLE_COMPRESSED  		        TargaHeader.ImageType = 10;		// RLE RGB  #else  				TargaHeader.ImageType = 2;		// RGB  #endif  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 0;  				TargaHeader.ColorMapBits = 0;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: if (SourceDepth == 8)  			{  				TargaHeader.ColorMapType = 1;		// Color type is Palette  				TargaHeader.ImageType = 9;		// 1 = Palette' 9 = RLE Palette  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 256;  				TargaHeader.ColorMapBits = 24;  			}  			else  			{  				TargaHeader.ColorMapType = 0;		// Color type is RGB  #if WRITE_RLE_COMPRESSED  		        TargaHeader.ImageType = 10;		// RLE RGB  #else  				TargaHeader.ImageType = 2;		// RGB  #endif  				TargaHeader.ColorMapStart = 0;  				TargaHeader.ColorMapLength = 0;  				TargaHeader.ColorMapBits = 0;  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: byte[] pLineBuffer = new byte[image.StrideInBytesAbs() * 2];
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: switch (SourceDepth)  			{  				case 8:  					/*  				if (image.HasPalette())  				{  					for(int i=0; i<256; i++)  					{  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);  					}  				}  				else  					 */  					{	// there is no palette for this DIB but we should write something  						for (int i = 0; i < 256; i++)  						{  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  						}  					}  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine8(pLineBuffer' buffer' bufferOffset' image.Width());  			        writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width);  #endif  					}  					break;    				case 24:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine24(pLineBuffer' buffer' bufferOffset' image.Width());                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 3);  #endif  					}  					break;    				case 32:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine32(pLineBuffer' buffer' bufferOffset' image.Width);                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 4);  #endif  					}  					break;    				default:  					throw new NotSupportedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: switch (SourceDepth)  			{  				case 8:  					/*  				if (image.HasPalette())  				{  					for(int i=0; i<256; i++)  					{  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);  					}  				}  				else  					 */  					{	// there is no palette for this DIB but we should write something  						for (int i = 0; i < 256; i++)  						{  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  						}  					}  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine8(pLineBuffer' buffer' bufferOffset' image.Width());  			        writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width);  #endif  					}  					break;    				case 24:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine24(pLineBuffer' buffer' bufferOffset' image.Width());                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 3);  #endif  					}  					break;    				case 32:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine32(pLineBuffer' buffer' bufferOffset' image.Width);                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 4);  #endif  					}  					break;    				default:  					throw new NotSupportedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: switch (SourceDepth)  			{  				case 8:  					/*  				if (image.HasPalette())  				{  					for(int i=0; i<256; i++)  					{  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);  					}  				}  				else  					 */  					{	// there is no palette for this DIB but we should write something  						for (int i = 0; i < 256; i++)  						{  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  						}  					}  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine8(pLineBuffer' buffer' bufferOffset' image.Width());  			        writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width);  #endif  					}  					break;    				case 24:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine24(pLineBuffer' buffer' bufferOffset' image.Width());                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 3);  #endif  					}  					break;    				case 32:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine32(pLineBuffer' buffer' bufferOffset' image.Width);                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 4);  #endif  					}  					break;    				default:  					throw new NotSupportedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: switch (SourceDepth)  			{  				case 8:  					/*  				if (image.HasPalette())  				{  					for(int i=0; i<256; i++)  					{  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);  					}  				}  				else  					 */  					{	// there is no palette for this DIB but we should write something  						for (int i = 0; i < 256; i++)  						{  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  						}  					}  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine8(pLineBuffer' buffer' bufferOffset' image.Width());  			        writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width);  #endif  					}  					break;    				case 24:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine24(pLineBuffer' buffer' bufferOffset' image.Width());                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 3);  #endif  					}  					break;    				case 32:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine32(pLineBuffer' buffer' bufferOffset' image.Width);                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 4);  #endif  					}  					break;    				default:  					throw new NotSupportedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: switch (SourceDepth)  			{  				case 8:  					/*  				if (image.HasPalette())  				{  					for(int i=0; i<256; i++)  					{  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);  					}  				}  				else  					 */  					{	// there is no palette for this DIB but we should write something  						for (int i = 0; i < 256; i++)  						{  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  						}  					}  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine8(pLineBuffer' buffer' bufferOffset' image.Width());  			        writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width);  #endif  					}  					break;    				case 24:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine24(pLineBuffer' buffer' bufferOffset' image.Width());                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 3);  #endif  					}  					break;    				case 32:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine32(pLineBuffer' buffer' bufferOffset' image.Width);                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 4);  #endif  					}  					break;    				default:  					throw new NotSupportedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,Save,The following statement contains a magic number: switch (SourceDepth)  			{  				case 8:  					/*  				if (image.HasPalette())  				{  					for(int i=0; i<256; i++)  					{  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);  						TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);  					}  				}  				else  					 */  					{	// there is no palette for this DIB but we should write something  						for (int i = 0; i < 256; i++)  						{  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  							writerToSaveTo.Write((byte)i);  						}  					}  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine8(pLineBuffer' buffer' bufferOffset' image.Width());  			        writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width);  #endif  					}  					break;    				case 24:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine24(pLineBuffer' buffer' bufferOffset' image.Width());                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 3);  #endif  					}  					break;    				case 32:  					for (int i = 0; i < image.Height; i++)  					{  						int bufferOffset;  						byte[] buffer = image.GetPixelPointerY(i' out bufferOffset);  #if WRITE_RLE_COMPRESSED                      BytesToSave = CompressLine32(pLineBuffer' buffer' bufferOffset' image.Width);                      writerToSaveTo.Write(pLineBuffer' 0' BytesToSave);  #else  						writerToSaveTo.Write(buffer' bufferOffset' image.Width * 4);  #endif  					}  					break;    				default:  					throw new NotSupportedException();  			}
Magic Number,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LoadImageData,The following statement contains a magic number: if (System.IO.File.Exists(fileName))  			{  				using (var stream = File.OpenRead(fileName))  				{  					return LoadImageData(image' stream' 32);  				}  			}
Magic Number,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,Blur,The following statement contains a magic number: switch (img.BitDepth)  			{  				case 24:  					stack_blur_bgr24(img' rx' ry);  					break;    				case 32:  					stack_blur_bgra32(img' rx' ry);  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,Blur,The following statement contains a magic number: switch (img.BitDepth)  			{  				case 24:  					stack_blur_bgr24(img' rx' ry);  					break;    				case 32:  					stack_blur_bgra32(img' rx' ry);  					break;    				default:  					throw new NotImplementedException();  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: if (radius < 0.62) return;
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: if (img.Width < 3) return;
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double s = (double)(radius * 0.5);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double q = (double)((s < 2.5) ?  									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :  									0.98711 * s - 0.96330);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double q = (double)((s < 2.5) ?  									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :  									0.98711 * s - 0.96330);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double q = (double)((s < 2.5) ?  									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :  									0.98711 * s - 0.96330);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double q = (double)((s < 2.5) ?  									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :  									0.98711 * s - 0.96330);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double q = (double)((s < 2.5) ?  									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :  									0.98711 * s - 0.96330);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double q = (double)((s < 2.5) ?  									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :  									0.98711 * s - 0.96330);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b0 = (double)(1.0 / (1.578250 +  											2.444130 * q +  											1.428100 * q2 +  											0.422205 * q3));
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b0 = (double)(1.0 / (1.578250 +  											2.444130 * q +  											1.428100 * q2 +  											0.422205 * q3));
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b0 = (double)(1.0 / (1.578250 +  											2.444130 * q +  											1.428100 * q2 +  											0.422205 * q3));
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b0 = (double)(1.0 / (1.578250 +  											2.444130 * q +  											1.428100 * q2 +  											0.422205 * q3));
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b1 = (double)(2.44413 * q +  									  2.85619 * q2 +  									  1.26661 * q3);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b1 = (double)(2.44413 * q +  									  2.85619 * q2 +  									  1.26661 * q3);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b1 = (double)(2.44413 * q +  									  2.85619 * q2 +  									  1.26661 * q3);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b2 = (double)(-1.42810 * q2 +  									 -1.26661 * q3);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b2 = (double)(-1.42810 * q2 +  									 -1.26661 * q3);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: double b3 = (double)(0.422205 * q3);
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,RecursiveBlur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,blur_x,The following statement contains a magic number: for (y = 0; y < h; y++)  			{  				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;  				c.from_pix(img.GetPixel(0' y));  				Sum1Array[0].calc(b' b1' b2' b3' c' c' c' c);  				c.from_pix(img.GetPixel(1' y));  				Sum1Array[1].calc(b' b1' b2' b3' c' Sum1Array[0]' Sum1Array[0]' Sum1Array[0]);  				c.from_pix(img.GetPixel(2' y));  				Sum1Array[2].calc(b' b1' b2' b3' c' Sum1Array[1]' Sum1Array[0]' Sum1Array[0]);    				for (x = 3; x < w; ++x)  				{  					c.from_pix(img.GetPixel(x' y));  					Sum1Array[x].calc(b' b1' b2' b3' c' Sum1Array[x - 1]' Sum1Array[x - 2]' Sum1Array[x - 3]);  				}    				Sum2Array[wm].calc(b' b1' b2' b3' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]' Sum1Array[wm]);  				Sum2Array[wm - 1].calc(b' b1' b2' b3' Sum1Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm - 2].calc(b' b1' b2' b3' Sum1Array[wm - 2]' Sum2Array[wm - 1]' Sum2Array[wm]' Sum2Array[wm]);  				Sum2Array[wm].to_pix(ref BufferArray[wm]);  				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);  				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);    				for (x = wm - 3; x >= 0; --x)  				{  					Sum2Array[x].calc(b' b1' b2' b3' Sum1Array[x]' Sum2Array[x + 1]' Sum2Array[x + 2]' Sum2Array[x + 3]);  					Sum2Array[x].to_pix(ref BufferArray[x]);  				}    				img.copy_color_hspan(0' y' w' BufferArray' 0);  			}
Magic Number,MatterHackers.Agg.Image,AlphaMaskAdaptor,C:\repos\MatterHackers_agg-sharp\agg\Image\AlphaMaskAdaptor.cs,AlphaMaskAdaptor,The following statement contains a magic number: m_span = new ArrayPOD<byte>(255);
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,blender_gray,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,blender_gray,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,PixelToColorRGBA_Bytes,The following statement contains a magic number: return new RGBA_Bytes(value' value' value' 255);
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,CopyPixels,The following statement contains a magic number: do  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				pDestBuffer[bufferOffset] = (byte)gray;  				bufferOffset += bytesBetweenPixelsInclusive;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,CopyPixels,The following statement contains a magic number: do  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				pDestBuffer[bufferOffset] = (byte)gray;  				bufferOffset += bytesBetweenPixelsInclusive;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,CopyPixels,The following statement contains a magic number: do  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				pDestBuffer[bufferOffset] = (byte)gray;  				bufferOffset += bytesBetweenPixelsInclusive;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,CopyPixels,The following statement contains a magic number: do  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				pDestBuffer[bufferOffset] = (byte)gray;  				bufferOffset += bytesBetweenPixelsInclusive;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);  				pDestBuffer[bufferOffset] = (byte)gray;  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);  				pDestBuffer[bufferOffset] = (byte)gray;  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);  				pDestBuffer[bufferOffset] = (byte)gray;  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);  				int gray = (y >> 8);  				gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);  				pDestBuffer[bufferOffset] = (byte)gray;  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blender_gray,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,blenderGrayFromRed,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,blenderGrayFromRed,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,PixelToColorRGBA_Bytes,The following statement contains a magic number: return new RGBA_Bytes(value' value' value' 255);
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayFromRed,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,blenderGrayClampedMax,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,blenderGrayClampedMax,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,PixelToColorRGBA_Bytes,The following statement contains a magic number: return new RGBA_Bytes(value' value' value' 255);
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,CopyPixels,The following statement contains a magic number: do  			{  				byte clampedMax = Math.Min(Math.Max(sourceColor.red' Math.Max(sourceColor.green' sourceColor.blue))' (byte)255);  				pDestBuffer[bufferOffset] = clampedMax;  				bufferOffset += bytesBetweenPixelsInclusive;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				byte clampedMax = Math.Min(Math.Max(sourceColor.red' Math.Max(sourceColor.green' sourceColor.blue))' (byte)255);  				byte gray = (byte)((((clampedMax - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);  				pDestBuffer[bufferOffset] = (byte)gray;  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,blenderGrayClampedMax,C:\repos\MatterHackers_agg-sharp\agg\Image\Gray.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += bytesBetweenPixelsInclusive;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += bytesBetweenPixelsInclusive;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += bytesBetweenPixelsInclusive;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,PixelToColorRGBA_Bytes,The following statement contains a magic number: return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' 255);
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				bufferOffset += 3;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderGammaBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,PixelToColorRGBA_Bytes,The following statement contains a magic number: return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' 255);
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlenderPreMultBGR,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlenderPreMultBGR,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,PixelToColorRGBA_Bytes,The following statement contains a magic number: return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR]' buffer[bufferOffset + ImageBuffer.OrderG]' buffer[bufferOffset + ImageBuffer.OrderB]' 255);
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				bufferOffset += 3;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixel,The following statement contains a magic number: if (sourceColor.alpha == 255)  			{  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  			}  			else  			{  				int OneOverAlpha = base_mask - sourceColor.alpha;  				unchecked  				{  					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];  					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];  					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];  					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGR,C:\repos\MatterHackers_agg-sharp\agg\Image\rgb.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 3;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 3;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 3;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				unchecked  				{  					if (sourceColor.alpha == 255)  					{  						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.red);  						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);  						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.blue);  						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);  					}  					else  					{  						int r = buffer[bufferOffset + ImageBuffer.OrderR];  						int g = buffer[bufferOffset + ImageBuffer.OrderG];  						int b = buffer[bufferOffset + ImageBuffer.OrderB];  						int a = buffer[bufferOffset + ImageBuffer.OrderA];  						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);  						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);  						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);  						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift));  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAExactCopy,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				unchecked  				{  					if (sourceColor.alpha == 255)  					{  						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.red);  						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);  						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.blue);  						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);  					}  					else  					{  						int r = buffer[bufferOffset + ImageBuffer.OrderB];  						int g = buffer[bufferOffset + ImageBuffer.OrderG];  						int b = buffer[bufferOffset + ImageBuffer.OrderR];  						int a = buffer[bufferOffset + ImageBuffer.OrderA];  						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);  						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);  						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);  						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift));  					}  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderRGBA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				int cover = covers[coversIndex];  				if (cover == 255)  				{  					do  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset++]);  						bufferOffset += 4;  					}  					while (--count != 0);  				}  				else  				{  					do  					{  						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  						bufferOffset += 4;  						++sourceColorsOffset;  					}  					while (--count != 0);  				}  			}  			else  			{  				do  				{  					int cover = covers[coversIndex++];  					if (cover == 255)  					{  						BlendPixel(destBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  					}  					else  					{  						RGBA_Bytes color = sourceColors[sourceColorsOffset];  						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);  						BlendPixel(destBuffer' bufferOffset' color);  					}  					bufferOffset += 4;  					++sourceColorsOffset;  				}  				while (--count != 0);  			}
Magic Number,MatterHackers.Agg.Image,BlenderBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderGammaBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv(sourceColor.red);  				buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv(sourceColor.green);  				buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv(sourceColor.blue);  				buffer[bufferOffset + ImageBuffer.OrderA] = m_gamma.inv(sourceColor.alpha);  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlenderPreMultBGRA,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlenderPreMultBGRA,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: unchecked  			{  				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];  				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];  				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];  				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;  				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;  				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;  				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				if (sourceCovers[sourceCoversOffset] == 255)  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						if (sourceColor.alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}    						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  				else  				{  					for (int i = 0; i < count; i++)  					{  						RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  						if (alpha == 0)  						{  							continue;  						}  						else if (alpha == 255)  						{  							CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  						}  						else  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColor);  						}  						sourceColorsOffset++;  						bufferOffset += 4;  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];  					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  					if (alpha == 255)  					{  						CopyOpaquePixel(pDestBuffer' bufferOffset' sourceColor);  					}  					else if (alpha > 0)  					{  						BlendPixel(pDestBuffer' bufferOffset' sourceColor);  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyOpaquePixel,The following statement contains a magic number: pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 255;
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlenderPolyColorPreMultBGRA,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlenderPolyColorPreMultBGRA,The following statement contains a magic number: if (m_Saturate9BitToByte[2] == 0)  			{  				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)  				{  					m_Saturate9BitToByte[i] = Math.Min(i' 255);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: for (int i = 0; i < count; i++)  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixel,The following statement contains a magic number: {  				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);  				int oneOverAlpha = base_mask - sourceA;  				unchecked  				{  					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);  					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);  					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);    					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];  					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];  					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];  					// TODO: calculated the correct dest alpha  					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];    					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;  					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;  					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;  					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						throw new NotImplementedException("need to consider the polyColor");  #if false                          for (int i = 0; i < count; i++)                          {                              RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];                              int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;                              if (alpha == 0)                              {                                  continue;                              }                              else if (alpha == 255)                              {                                  pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;                                  pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;                                  pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;                                  pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;                              }                              else                              {                                  int OneOverAlpha = base_mask - alpha;                                  unchecked                                  {                                      int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];                                      int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];                                      int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];                                      int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];                                      pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;                                      pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;                                      pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;                                      pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);                                  }                              }                              sourceColorsOffset++;                              bufferOffset += 4;                          }  #endif  					}  				}  			}  			else  			{  				throw new NotImplementedException("need to consider the polyColor");  #if false                  for (int i = 0; i < count; i++)                  {                      RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];                      int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;                      if (alpha == 255)                      {                          pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;                          pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;                          pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;                          pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;                      }                      else if (alpha > 0)                      {                          int OneOverAlpha = base_mask - alpha;                          unchecked                          {                              int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];                              int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];                              int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];                              int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];                              pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;                              pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;                              pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;                              pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);                          }                      }                      sourceColorsOffset++;                      sourceCoversOffset++;                      bufferOffset += 4;                  }  #endif  			}
Magic Number,MatterHackers.Agg.Image,BlenderPolyColorPreMultBGRA,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						throw new NotImplementedException("need to consider the polyColor");  #if false                          for (int i = 0; i < count; i++)                          {                              RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];                              int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;                              if (alpha == 0)                              {                                  continue;                              }                              else if (alpha == 255)                              {                                  pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;                                  pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;                                  pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;                                  pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;                              }                              else                              {                                  int OneOverAlpha = base_mask - alpha;                                  unchecked                                  {                                      int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];                                      int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];                                      int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];                                      int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];                                      pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;                                      pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;                                      pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;                                      pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);                                  }                              }                              sourceColorsOffset++;                              bufferOffset += 4;                          }  #endif  					}  				}  			}  			else  			{  				throw new NotImplementedException("need to consider the polyColor");  #if false                  for (int i = 0; i < count; i++)                  {                      RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];                      int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;                      if (alpha == 255)                      {                          pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;                          pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;                          pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;                          pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;                      }                      else if (alpha > 0)                      {                          int OneOverAlpha = base_mask - alpha;                          unchecked                          {                              int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];                              int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];                              int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];                              int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];                              pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;                              pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;                              pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;                              pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);                          }                      }                      sourceColorsOffset++;                      sourceCoversOffset++;                      bufferOffset += 4;                  }  #endif  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,SetPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,CopyPixels,The following statement contains a magic number: do  			{  				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;  				bufferOffset += 4;  			}  			while (--count != 0);
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.Image,BlenderPreMultBGRAFloat,C:\repos\MatterHackers_agg-sharp\agg\Image\rgba.cs,BlendPixels,The following statement contains a magic number: if (firstCoverForAll)  			{  				//unsafe  				{  					if (sourceCovers[sourceCoversOffset] == 255)  					{  						for (int i = 0; i < count; i++)  						{  							BlendPixel(pDestBuffer' bufferOffset' sourceColors[sourceColorsOffset]);  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  					else  					{  						for (int i = 0; i < count; i++)  						{  							RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;  							if (alpha == 0)  							{  								continue;  							}  							else if (alpha == 255)  							{  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;  							}  							else  							{  								float OneOverAlpha = base_mask - alpha;  								unchecked  								{  									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;  									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;  									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;  									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));  								}  							}  							sourceColorsOffset++;  							bufferOffset += 4;  						}  					}  				}  			}  			else  			{  				for (int i = 0; i < count; i++)  				{  					RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];  					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)  					{  						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;  						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;  						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;  						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;  					}  					else  					{  						// the cover is known to be less than opaque  						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));  						float alpha = sourceColor.alpha * coverFloat;  						if (coverFloat > 0 && alpha > 0)  						{  							float OneOverAlpha = 1.0f - alpha;  							unchecked  							{  								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover  								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;  								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;  								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;    								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];  								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);  								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;  								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;  								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;  								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;  							}  						}  					}  					sourceColorsOffset++;  					sourceCoversOffset++;  					bufferOffset += 4;  				}  			}
Magic Number,MatterHackers.Agg.RasterizerScanline,ScanlineCachePacked8,C:\repos\MatterHackers_agg-sharp\agg\RasterizerScanline\agg_scanline_p.cs,ScanlineCachePacked8,The following statement contains a magic number: m_covers = new byte[1000];
Magic Number,MatterHackers.Agg.RasterizerScanline,ScanlineCachePacked8,C:\repos\MatterHackers_agg-sharp\agg\RasterizerScanline\agg_scanline_p.cs,ScanlineCachePacked8,The following statement contains a magic number: m_spans = new ScanlineSpan[1000];
Magic Number,MatterHackers.Agg.RasterizerScanline,ScanlineCachePacked8,C:\repos\MatterHackers_agg-sharp\agg\RasterizerScanline\agg_scanline_p.cs,reset,The following statement contains a magic number: int max_len = max_x - min_x + 3;
Magic Number,MatterHackers.Agg.RasterizerScanline,scanline_unpacked_8,C:\repos\MatterHackers_agg-sharp\agg\RasterizerScanline\agg_scanline_u.cs,scanline_unpacked_8,The following statement contains a magic number: m_covers = new ArrayPOD<byte>(1000);
Magic Number,MatterHackers.Agg.RasterizerScanline,scanline_unpacked_8,C:\repos\MatterHackers_agg-sharp\agg\RasterizerScanline\agg_scanline_u.cs,scanline_unpacked_8,The following statement contains a magic number: m_spans = new ArrayPOD<ScanlineSpan>(1000);
Magic Number,MatterHackers.Agg.RasterizerScanline,scanline_unpacked_8,C:\repos\MatterHackers_agg-sharp\agg\RasterizerScanline\agg_scanline_u.cs,reset,The following statement contains a magic number: int max_len = max_x - min_x + 2;
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,Affine,The following statement contains a magic number: shx = m[2];
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,Affine,The following statement contains a magic number: sy = m[3];
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,Affine,The following statement contains a magic number: tx = m[4];
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,Affine,The following statement contains a magic number: ty = m[5];
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,GetScale,The following statement contains a magic number: double x = 0.707106781 * sx + 0.707106781 * shx;
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,GetScale,The following statement contains a magic number: double x = 0.707106781 * sx + 0.707106781 * shx;
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,GetScale,The following statement contains a magic number: double y = 0.707106781 * shy + 0.707106781 * sy;
Magic Number,MatterHackers.Agg.Transform,Affine,C:\repos\MatterHackers_agg-sharp\agg\Transform\Affine.cs,GetScale,The following statement contains a magic number: double y = 0.707106781 * shy + 0.707106781 * sy;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: double['] left = new double[4' 4];
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: double['] left = new double[4' 4];
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: double['] right = new double[4' 2];
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: double['] right = new double[4' 2];
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: for (i = 0; i < 4; i++)  			{  				uint ix = i * 2;  				uint iy = ix + 1;  				left[i' 0] = 1.0;  				left[i' 1] = src[ix] * src[iy];  				left[i' 2] = src[ix];  				left[i' 3] = src[iy];    				right[i' 0] = dst[ix];  				right[i' 1] = dst[iy];  			}
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: for (i = 0; i < 4; i++)  			{  				uint ix = i * 2;  				uint iy = ix + 1;  				left[i' 0] = 1.0;  				left[i' 1] = src[ix] * src[iy];  				left[i' 2] = src[ix];  				left[i' 3] = src[iy];    				right[i' 0] = dst[ix];  				right[i' 1] = dst[iy];  			}
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: for (i = 0; i < 4; i++)  			{  				uint ix = i * 2;  				uint iy = ix + 1;  				left[i' 0] = 1.0;  				left[i' 1] = src[ix] * src[iy];  				left[i' 2] = src[ix];  				left[i' 3] = src[iy];    				right[i' 0] = dst[ix];  				right[i' 1] = dst[iy];  			}
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_quad,The following statement contains a magic number: for (i = 0; i < 4; i++)  			{  				uint ix = i * 2;  				uint iy = ix + 1;  				left[i' 0] = 1.0;  				left[i' 1] = src[ix] * src[iy];  				left[i' 2] = src[ix];  				left[i' 3] = src[iy];    				right[i' 0] = dst[ix];  				right[i' 1] = dst[iy];  			}
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: double[] src = new double[8];
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: src[0] = src[6] = x1;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: src[2] = src[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: src[2] = src[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: src[1] = src[3] = y1;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: src[5] = src[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,rect_to_quad,The following statement contains a magic number: src[5] = src[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: double[] dst = new double[8];
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: dst[0] = dst[6] = x1;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: dst[2] = dst[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: dst[2] = dst[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: dst[1] = dst[3] = y1;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: dst[5] = dst[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,quad_to_rect,The following statement contains a magic number: dst[5] = dst[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,transform,The following statement contains a magic number: x = m_mtx[0' 0] + m_mtx[1' 0] * xy + m_mtx[2' 0] * tx + m_mtx[3' 0] * ty;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,transform,The following statement contains a magic number: x = m_mtx[0' 0] + m_mtx[1' 0] * xy + m_mtx[2' 0] * tx + m_mtx[3' 0] * ty;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,transform,The following statement contains a magic number: y = m_mtx[0' 1] + m_mtx[1' 1] * xy + m_mtx[2' 1] * tx + m_mtx[3' 1] * ty;
Magic Number,MatterHackers.Agg.Transform,Bilinear,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,transform,The following statement contains a magic number: y = m_mtx[0' 1] + m_mtx[1' 1] * xy + m_mtx[2' 1] * tx + m_mtx[3' 1] * ty;
Magic Number,MatterHackers.Agg.Transform,iterator_x,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,iterator_x,The following statement contains a magic number: inc_x = (m[1' 0] * step * ty + m[2' 0] * step);
Magic Number,MatterHackers.Agg.Transform,iterator_x,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,iterator_x,The following statement contains a magic number: inc_y = (m[1' 1] * step * ty + m[2' 1] * step);
Magic Number,MatterHackers.Agg.Transform,iterator_x,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,iterator_x,The following statement contains a magic number: x = (m[0' 0] + m[1' 0] * tx * ty + m[2' 0] * tx + m[3' 0] * ty);
Magic Number,MatterHackers.Agg.Transform,iterator_x,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,iterator_x,The following statement contains a magic number: x = (m[0' 0] + m[1' 0] * tx * ty + m[2' 0] * tx + m[3' 0] * ty);
Magic Number,MatterHackers.Agg.Transform,iterator_x,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,iterator_x,The following statement contains a magic number: y = (m[0' 1] + m[1' 1] * tx * ty + m[2' 1] * tx + m[3' 1] * ty);
Magic Number,MatterHackers.Agg.Transform,iterator_x,C:\repos\MatterHackers_agg-sharp\agg\Transform\Bilinear.cs,iterator_x,The following statement contains a magic number: y = (m[0' 1] + m[1' 1] * tx * ty + m[2' 1] * tx + m[3' 1] * ty);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: w0 = (m[2]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: shx = (m[3]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: sy = (m[4]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: w1 = (m[5]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: tx = (m[6]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: ty = (m[7]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,Perspective,The following statement contains a magic number: w2 = (m[8]);
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: double[] r = new double[8];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: r[0] = r[6] = x1;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: r[2] = r[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: r[2] = r[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: r[1] = r[3] = y1;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: r[5] = r[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,rect_to_quad,The following statement contains a magic number: r[5] = r[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: double[] r = new double[8];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: r[0] = r[6] = x1;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: r[2] = r[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: r[2] = r[4] = x2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: r[1] = r[3] = y1;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: r[5] = r[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,quad_to_rect,The following statement contains a magic number: r[5] = r[7] = y2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: double dx = q[0] - q[2] + q[4] - q[6];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: double dx = q[0] - q[2] + q[4] - q[6];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: double dx = q[0] - q[2] + q[4] - q[6];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: double dy = q[1] - q[3] + q[5] - q[7];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: double dy = q[1] - q[3] + q[5] - q[7];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: double dy = q[1] - q[3] + q[5] - q[7];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,square_to_quad,The following statement contains a magic number: if (dx == 0.0 && dy == 0.0)  			{  				// Affine case (parallelogram)  				//---------------  				sx = q[2] - q[0];  				shy = q[3] - q[1];  				w0 = 0.0;  				shx = q[4] - q[2];  				sy = q[5] - q[3];  				w1 = 0.0;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}  			else  			{  				double dx1 = q[2] - q[4];  				double dy1 = q[3] - q[5];  				double dx2 = q[6] - q[4];  				double dy2 = q[7] - q[5];  				double den = dx1 * dy2 - dx2 * dy1;  				if (den == 0.0)  				{  					// Singular case  					//---------------  					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;  					return false;  				}  				// General case  				//---------------  				double u = (dx * dy2 - dy * dx2) / den;  				double v = (dy * dx1 - dx * dy1) / den;  				sx = q[2] - q[0] + u * q[2];  				shy = q[3] - q[1] + u * q[3];  				w0 = u;  				shx = q[6] - q[0] + v * q[6];  				sy = q[7] - q[1] + v * q[7];  				w1 = v;  				tx = q[0];  				ty = q[1];  				w2 = 1.0;  			}
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[2] = w0;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[3] = shx;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[4] = sy;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[5] = w1;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[6] = tx;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[7] = ty;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,store_to,The following statement contains a magic number: m[8] = w2;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: w0 = m[2];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: shx = m[3];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: sy = m[4];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: w1 = m[5];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: tx = m[6];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: ty = m[7];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,load_from,The following statement contains a magic number: w2 = m[8];
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,scale,The following statement contains a magic number: double x = 0.707106781 * sx + 0.707106781 * shx;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,scale,The following statement contains a magic number: double x = 0.707106781 * sx + 0.707106781 * shx;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,scale,The following statement contains a magic number: double y = 0.707106781 * shy + 0.707106781 * sy;
Magic Number,MatterHackers.Agg.Transform,Perspective,C:\repos\MatterHackers_agg-sharp\agg\Transform\Perspective.cs,scale,The following statement contains a magic number: double y = 0.707106781 * shy + 0.707106781 * sy;
Magic Number,MatterHackers.Agg.Transform,Viewport,C:\repos\MatterHackers_agg-sharp\agg\Transform\Viewport.cs,Viewport,The following statement contains a magic number: m_align_x = (0.5);
Magic Number,MatterHackers.Agg.Transform,Viewport,C:\repos\MatterHackers_agg-sharp\agg\Transform\Viewport.cs,Viewport,The following statement contains a magic number: m_align_y = (0.5);
Magic Number,MatterHackers.Agg.Transform,Viewport,C:\repos\MatterHackers_agg-sharp\agg\Transform\Viewport.cs,scale,The following statement contains a magic number: return (m_kx + m_ky) * 0.5;
Magic Number,MatterHackers.Agg.Transform,Viewport,C:\repos\MatterHackers_agg-sharp\agg\Transform\Viewport.cs,update,The following statement contains a magic number: double epsilon = 1e-30;
Magic Number,MatterHackers.Agg.VertexSource,ContourGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\ContourGenerator.cs,Vertex,The following statement contains a magic number: while (!ShapePath.is_stop(cmd))  			{  				switch (m_status)  				{  					case StrokeMath.status_e.initial:  						Rewind(0);  						goto case StrokeMath.status_e.ready;    					case StrokeMath.status_e.ready:  						if (m_src_vertices.size() < 2 + (m_closed ? 1 : 0))  						{  							cmd = ShapePath.FlagsAndCommand.CommandStop;  							break;  						}  						m_status = StrokeMath.status_e.outline1;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						m_src_vertex = 0;  						m_out_vertex = 0;  						goto case StrokeMath.status_e.outline1;    					case StrokeMath.status_e.outline1:  						if (m_src_vertex >= m_src_vertices.size())  						{  							m_status = StrokeMath.status_e.end_poly1;  							break;  						}  						m_stroker.calc_join(m_out_vertices'  											m_src_vertices.prev(m_src_vertex)'  											m_src_vertices.curr(m_src_vertex)'  											m_src_vertices.next(m_src_vertex)'  											m_src_vertices.prev(m_src_vertex).dist'  											m_src_vertices.curr(m_src_vertex).dist);  						++m_src_vertex;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						goto case StrokeMath.status_e.out_vertices;    					case StrokeMath.status_e.out_vertices:  						if (m_out_vertex >= m_out_vertices.size())  						{  							m_status = StrokeMath.status_e.outline1;  						}  						else  						{  							Vector2 c = m_out_vertices[m_out_vertex++];  							x = c.x;  							y = c.y;  							return cmd;  						}  						break;    					case StrokeMath.status_e.end_poly1:  						if (!m_closed) return ShapePath.FlagsAndCommand.CommandStop;  						m_status = StrokeMath.status_e.stop;  						return ShapePath.FlagsAndCommand.CommandEndPoly | ShapePath.FlagsAndCommand.FlagClose | ShapePath.FlagsAndCommand.FlagCCW;    					case StrokeMath.status_e.stop:  						return ShapePath.FlagsAndCommand.CommandStop;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return new curve4_points(  				x2'  				y2'  				(-x1 + 6 * x2 + x3) / 6'  				(-y1 + 6 * y2 + y3) / 6'  				(x2 + 6 * x3 - x4) / 6'  				(y2 + 6 * y3 - y4) / 6'  				x3'  				y3);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return catrom_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return catrom_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return catrom_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return catrom_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return catrom_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,catrom_to_bezier,The following statement contains a magic number: return catrom_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return new curve4_points(  				(x1 + 4 * x2 + x3) / 6'  				(y1 + 4 * y2 + y3) / 6'  				(4 * x2 + 2 * x3) / 6'  				(4 * y2 + 2 * y3) / 6'  				(2 * x2 + 4 * x3) / 6'  				(2 * y2 + 4 * y3) / 6'  				(x2 + 4 * x3 + x4) / 6'  				(y2 + 4 * y3 + y4) / 6);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return ubspline_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									  cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return ubspline_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									  cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return ubspline_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									  cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return ubspline_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									  cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return ubspline_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									  cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,ubspline_to_bezier,The following statement contains a magic number: return ubspline_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									  cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return new curve4_points(  				x1'  				y1'  				(3 * x1 + x3) / 3'  				(3 * y1 + y3) / 3'  				(3 * x2 - x4) / 3'  				(3 * y2 - y4) / 3'  				x2'  				y2);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return hermite_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									 cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return hermite_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									 cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return hermite_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									 cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return hermite_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									 cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return hermite_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									 cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curves,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,hermite_to_bezier,The following statement contains a magic number: return hermite_to_bezier(cp[0]' cp[1]' cp[2]' cp[3]'  									 cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_num_steps = (int)agg_basics.uround(len * 0.25 * m_scale);
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: if (m_num_steps < 4)  			{  				m_num_steps = 4;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: if (m_num_steps < 4)  			{  				m_num_steps = 4;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double tmpx = (x1 - cx * 2.0 + x2) * subdivide_step2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double tmpy = (y1 - cy * 2.0 + y2) * subdivide_step2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_saved_dfx = m_dfx = tmpx + (cx - x1) * (2.0 * subdivide_step);
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_saved_dfy = m_dfy = tmpy + (cy - y1) * (2.0 * subdivide_step);
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_ddfx = tmpx * 2.0;
Magic Number,MatterHackers.Agg.VertexSource,curve3_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_ddfy = tmpy * 2.0;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_distance_tolerance_square = 0.5 / m_approximation_scale;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x12 = (x1 + x2) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y12 = (y1 + y2) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x23 = (x2 + x3) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y23 = (y2 + y3) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x123 = (x12 + x23) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y123 = (y12 + y23) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve3_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: if (d > Curves.curve_collinearity_epsilon)  			{  				// Regular case  				//-----------------  				if (d * d <= m_distance_tolerance_square * (dx * dx + dy * dy))  				{  					// If the curvature doesn't exceed the distance_tolerance value  					// we tend to finish subdivisions.  					//----------------------  					if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  					{  						m_points.add(new Vector2(x123' y123));  						return;  					}    					// Angle & Cusp Condition  					//----------------------  					da = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  					if (da >= Math.PI) da = 2 * Math.PI - da;    					if (da < m_angle_tolerance)  					{  						// Finally we can stop the recursion  						//----------------------  						m_points.add(new Vector2(x123' y123));  						return;  					}  				}  			}  			else  			{  				// Collinear case  				//------------------  				da = dx * dx + dy * dy;  				if (da == 0)  				{  					d = agg_math.calc_sq_distance(x1' y1' x2' y2);  				}  				else  				{  					d = ((x2 - x1) * dx + (y2 - y1) * dy) / da;  					if (d > 0 && d < 1)  					{  						// Simple collinear case' 1---2---3  						// We can leave just two endpoints  						return;  					}  					if (d <= 0) d = agg_math.calc_sq_distance(x2' y2' x1' y1);  					else if (d >= 1) d = agg_math.calc_sq_distance(x2' y2' x3' y3);  					else d = agg_math.calc_sq_distance(x2' y2' x1 + d * dx' y1 + d * dy);  				}  				if (d < m_distance_tolerance_square)  				{  					m_points.add(new Vector2(x2' y2));  					return;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The following statement contains a magic number: cp[2] = x2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The following statement contains a magic number: cp[3] = y2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The following statement contains a magic number: cp[4] = x3;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The following statement contains a magic number: cp[5] = y3;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The following statement contains a magic number: cp[6] = x4;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_points,The following statement contains a magic number: cp[7] = y4;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: cp[2] = x2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: cp[3] = y2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: cp[4] = x3;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: cp[5] = y3;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: cp[6] = x4;
Magic Number,MatterHackers.Agg.VertexSource,curve4_points,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: cp[7] = y4;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_inc,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double len = (Math.Sqrt(dx1 * dx1 + dy1 * dy1) +  						  Math.Sqrt(dx2 * dx2 + dy2 * dy2) +  						  Math.Sqrt(dx3 * dx3 + dy3 * dy3)) * 0.25 * m_scale;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: if (m_num_steps < 4)  			{  				m_num_steps = 4;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: if (m_num_steps < 4)  			{  				m_num_steps = 4;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double pre1 = 3.0 * subdivide_step;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double pre2 = 3.0 * subdivide_step2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double pre4 = 6.0 * subdivide_step2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double pre5 = 6.0 * subdivide_step3;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double tmp1x = x1 - cx1 * 2.0 + cx2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double tmp1y = y1 - cy1 * 2.0 + cy2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double tmp2x = (cx1 - cx2) * 3.0 - x1 + x2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: double tmp2y = (cy1 - cy2) * 3.0 - y1 + y2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_inc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,curve4_div,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: m_distance_tolerance_square = 0.5 / m_approximation_scale;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x12 = (x1 + x2) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y12 = (y1 + y2) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x23 = (x2 + x3) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y23 = (y2 + y3) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x34 = (x3 + x4) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y34 = (y3 + y4) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x123 = (x12 + x23) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y123 = (y12 + y23) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x234 = (x23 + x34) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y234 = (y23 + y34) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double x1234 = (x123 + x234) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: double y1234 = (y123 + y234) / 2;
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: if (d2 > Curves.curve_collinearity_epsilon)  			{  				SwitchCase = 2;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following statement contains a magic number: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,Curve4,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,Curve4,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,init,The following statement contains a magic number: init(cp[0]' cp[1]' cp[2]' cp[3]' cp[4]' cp[5]' cp[6]' cp[7]);
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,SetFontSizeAndWidthRatio,The following statement contains a magic number: m_SpaceBetweenLines = FontSize * 1.5;
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,translateIndex,The following statement contains a magic number: v |= (ushort)(m_font[indicesIndex + 1] << 8);
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,rewind,The following statement contains a magic number: m_StartOfGlyphsIndex = m_StartOfIndicesIndex + 257 * 2;
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,rewind,The following statement contains a magic number: m_StartOfGlyphsIndex = m_StartOfIndicesIndex + 257 * 2;
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetSize,The following statement contains a magic number: int maskedChracterGlyphIndex = maskedChracter * 2;
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,GetSize,The following statement contains a magic number: int EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,vertex,The following statement contains a magic number: while (!quit)  			{  				switch (m_status)  				{  					case status.initial:  						if (m_font == null)  						{  							quit = true;  							break;  						}  						m_status = status.next_char;  						goto case status.next_char;    					case status.next_char:  						if (m_CurrentCharacterIndex == m_Text.Length)  						{  							quit = true;  							break;  						}  						int maskedChracter = (int)((m_Text[m_CurrentCharacterIndex++]) & 0xFF);  						if (maskedChracter == '\r' || maskedChracter == '\n')  						{  							m_CurrentX = m_StartX;  							m_CurrentY -= FontSize + m_SpaceBetweenLines;  							break;  						}  						int maskedChracterGlyphIndex = maskedChracter * 2; // we have an x and y in the array so it's * 2.  						m_BeginGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex);  						m_EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);  						m_status = status.start_glyph;  						goto case status.start_glyph;    					case status.start_glyph:  						x = m_CurrentX;  						y = m_CurrentY;  						m_status = status.glyph;  						return ShapePath.FlagsAndCommand.CommandMoveTo;    					case status.glyph:  						if (m_BeginGlyphIndex >= m_EndGlyphIndex)  						{  							m_status = status.next_char;  							m_CurrentX += m_SpaceBetweenCharacters;  							break;  						}    						sbyte IsAMoveTo_Flag;  						unchecked  						{  							int DeltaX = (sbyte)m_font[m_BeginGlyphIndex++];  							sbyte yc = (sbyte)m_font[m_BeginGlyphIndex++];    							IsAMoveTo_Flag = (sbyte)(yc & 0x80);  							yc <<= 1;  							yc >>= 1;  							int DeltaY = (int)(yc);  							m_CurrentX += (double)(DeltaX) * m_WidthScaleRatio;  							m_CurrentY += (double)(DeltaY) * m_HeightScaleRatio;  						}  						x = m_CurrentX;  						y = m_CurrentY;  						if (IsAMoveTo_Flag != 0)  						{  							return ShapePath.FlagsAndCommand.CommandMoveTo;  						}    						return ShapePath.FlagsAndCommand.CommandLineTo;    					default:  						throw new System.Exception("Unknown Status");  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,gsv_text,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_gsv_text.cs,vertex,The following statement contains a magic number: while (!quit)  			{  				switch (m_status)  				{  					case status.initial:  						if (m_font == null)  						{  							quit = true;  							break;  						}  						m_status = status.next_char;  						goto case status.next_char;    					case status.next_char:  						if (m_CurrentCharacterIndex == m_Text.Length)  						{  							quit = true;  							break;  						}  						int maskedChracter = (int)((m_Text[m_CurrentCharacterIndex++]) & 0xFF);  						if (maskedChracter == '\r' || maskedChracter == '\n')  						{  							m_CurrentX = m_StartX;  							m_CurrentY -= FontSize + m_SpaceBetweenLines;  							break;  						}  						int maskedChracterGlyphIndex = maskedChracter * 2; // we have an x and y in the array so it's * 2.  						m_BeginGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex);  						m_EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);  						m_status = status.start_glyph;  						goto case status.start_glyph;    					case status.start_glyph:  						x = m_CurrentX;  						y = m_CurrentY;  						m_status = status.glyph;  						return ShapePath.FlagsAndCommand.CommandMoveTo;    					case status.glyph:  						if (m_BeginGlyphIndex >= m_EndGlyphIndex)  						{  							m_status = status.next_char;  							m_CurrentX += m_SpaceBetweenCharacters;  							break;  						}    						sbyte IsAMoveTo_Flag;  						unchecked  						{  							int DeltaX = (sbyte)m_font[m_BeginGlyphIndex++];  							sbyte yc = (sbyte)m_font[m_BeginGlyphIndex++];    							IsAMoveTo_Flag = (sbyte)(yc & 0x80);  							yc <<= 1;  							yc >>= 1;  							int DeltaY = (int)(yc);  							m_CurrentX += (double)(DeltaX) * m_WidthScaleRatio;  							m_CurrentY += (double)(DeltaY) * m_HeightScaleRatio;  						}  						x = m_CurrentX;  						y = m_CurrentY;  						if (IsAMoveTo_Flag != 0)  						{  							return ShapePath.FlagsAndCommand.CommandMoveTo;  						}    						return ShapePath.FlagsAndCommand.CommandLineTo;    					default:  						throw new System.Exception("Unknown Status");  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,colors,The following statement contains a magic number: m_coord[2].color = c3.GetAsRGBA_Bytes();
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: m_coord[2].x = m_x[2] = x3;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: m_coord[2].x = m_x[2] = x3;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: m_coord[2].y = m_y[2] = y3;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: m_coord[2].y = m_y[2] = y3;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: m_cmd[2] = ShapePath.FlagsAndCommand.CommandLineTo;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: m_cmd[3] = ShapePath.FlagsAndCommand.CommandStop;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,triangle,The following statement contains a magic number: if (dilation != 0.0)  			{  				agg_math.dilate_triangle(m_coord[0].x' m_coord[0].y'  								m_coord[1].x' m_coord[1].y'  								m_coord[2].x' m_coord[2].y'  								m_x' m_y' dilation);    				agg_math.calc_intersection(m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  out m_coord[0].x' out m_coord[0].y);    				agg_math.calc_intersection(m_x[0]' m_y[0]' m_x[1]' m_y[1]'  								  m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  out m_coord[1].x' out m_coord[1].y);    				agg_math.calc_intersection(m_x[2]' m_y[2]' m_x[3]' m_y[3]'  								  m_x[4]' m_y[4]' m_x[5]' m_y[5]'  								  out m_coord[2].x' out m_coord[2].y);  				m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;  				m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: coord[2] = m_coord[2];
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: coord[2] = m_coord[2];
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: if (m_coord[0].y > m_coord[2].y)  			{  				coord[0] = m_coord[2];  				coord[2] = m_coord[0];  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: if (m_coord[0].y > m_coord[2].y)  			{  				coord[0] = m_coord[2];  				coord[2] = m_coord[0];  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: if (m_coord[0].y > m_coord[2].y)  			{  				coord[0] = m_coord[2];  				coord[2] = m_coord[0];  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: if (coord[1].y > coord[2].y)  			{  				tmp = coord[2];  				coord[2] = coord[1];  				coord[1] = tmp;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: if (coord[1].y > coord[2].y)  			{  				tmp = coord[2];  				coord[2] = coord[1];  				coord[1] = tmp;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud.cs,arrange_vertices,The following statement contains a magic number: if (coord[1].y > coord[2].y)  			{  				tmp = coord[2];  				coord[2] = coord[1];  				coord[1] = tmp;  			}
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,prepare,The following statement contains a magic number: coord_type[] coord = new coord_type[3];
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,prepare,The following statement contains a magic number: m_swap = agg_math.cross_product(coord[0].x' coord[0].y'  								   coord[2].x' coord[2].y'  								   coord[1].x' coord[1].y) < 0.0;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,prepare,The following statement contains a magic number: m_swap = agg_math.cross_product(coord[0].x' coord[0].y'  								   coord[2].x' coord[2].y'  								   coord[1].x' coord[1].y) < 0.0;
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,prepare,The following statement contains a magic number: m_rgba1.init(coord[0]' coord[2]);
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,prepare,The following statement contains a magic number: m_rgba3.init(coord[1]' coord[2]);
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The following statement contains a magic number: dda_line_interpolator r = new dda_line_interpolator(pc1.m_r' pc2.m_r' nlen' 14);
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The following statement contains a magic number: dda_line_interpolator g = new dda_line_interpolator(pc1.m_g' pc2.m_g' nlen' 14);
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The following statement contains a magic number: dda_line_interpolator b = new dda_line_interpolator(pc1.m_b' pc2.m_b' nlen' 14);
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The following statement contains a magic number: dda_line_interpolator a = new dda_line_interpolator(pc1.m_a' pc2.m_a' nlen' 14);
Magic Number,MatterHackers.Agg.VertexSource,span_gouraud_rgba,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,generate,The following statement contains a magic number: uint lim = 255;
Magic Number,MatterHackers.Agg.VertexSource,rgba_calc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,init,The following statement contains a magic number: m_x1 = c1.x - 0.5;
Magic Number,MatterHackers.Agg.VertexSource,rgba_calc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,init,The following statement contains a magic number: m_y1 = c1.y - 0.5;
Magic Number,MatterHackers.Agg.VertexSource,rgba_calc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,init,The following statement contains a magic number: m_1dy = (dy < 1e-5) ? 1e5 : 1.0 / dy;
Magic Number,MatterHackers.Agg.VertexSource,rgba_calc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs,init,The following statement contains a magic number: m_1dy = (dy < 1e-5) ? 1e5 : 1.0 / dy;
Magic Number,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,Vertices,The following statement contains a magic number: double averageRadius = (Math.Abs(radius.x) + Math.Abs(radius.y)) / 2;
Magic Number,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,Vertices,The following statement contains a magic number: flatenDeltaAngle = Math.Acos(averageRadius / (averageRadius + 0.125 / scale)) * 2;
Magic Number,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,Vertices,The following statement contains a magic number: flatenDeltaAngle = Math.Acos(averageRadius / (averageRadius + 0.125 / scale)) * 2;
Magic Number,MatterHackers.Agg.VertexSource,Arc,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Arc.cs,Vertices,The following statement contains a magic number: while (endAngle < startAngle)  			{  				endAngle += Math.PI * 2.0;  			}
Magic Number,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,Ellipse,The following statement contains a magic number: numSteps = 4;
Magic Number,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,calc_num_steps,The following statement contains a magic number: double ra = (Math.Abs(radiusX) + Math.Abs(radiusY)) / 2;
Magic Number,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,calc_num_steps,The following statement contains a magic number: double da = Math.Acos(ra / (ra + 0.125 / m_scale)) * 2;
Magic Number,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,calc_num_steps,The following statement contains a magic number: double da = Math.Acos(ra / (ra + 0.125 / m_scale)) * 2;
Magic Number,MatterHackers.Agg.VertexSource,Ellipse,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\Ellipse.cs,calc_num_steps,The following statement contains a magic number: numSteps = (int)Math.Round(2 * Math.PI / da);
Magic Number,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,OldEqualsOldStyle,The following statement contains a magic number: if (controlFlagsAndCommand == otherFlagsAndCommand && controlX == testX && agg_basics.is_equal_eps(controlY' testY' .000000001))  			{  				while (controlFlagsAndCommand != ShapePath.FlagsAndCommand.CommandStop)  				{  					controlFlagsAndCommand = control.vertex(out controlX' out controlY);  					otherFlagsAndCommand = test.vertex(out testX' out testY);  					if (controlFlagsAndCommand != otherFlagsAndCommand  						|| controlX < testX - maxError || controlX > testX + maxError  						|| controlY < testY - maxError || controlY > testY + maxError)  					{  						return false;  					}  					index++;  				}    				return true;  			}
Magic Number,MatterHackers.Agg.VertexSource,PathStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,arrange_polygon_orientation,The following statement contains a magic number: if (end - start > 2)  			{  				if (perceive_polygon_orientation(start' end) != orientation)  				{  					// Invert polygon' set orientation flag' and skip all end_poly  					invert_polygon(start' end);  					ShapePath.FlagsAndCommand PathAndFlags;  					while (end < vertices.total_vertices() &&  						  ShapePath.is_end_poly(PathAndFlags = vertices.command(end)))  					{  						vertices.modify_command(end++' PathAndFlags | orientation);// Path.set_orientation(cmd' orientation));  					}  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,VertexStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,prev_vertex,The following statement contains a magic number: if (m_num_vertices > 1)  				{  					return vertex((int)(m_num_vertices - 2)' out x' out y);  				}
Magic Number,MatterHackers.Agg.VertexSource,VertexStorage,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\PathStorage.cs,allocate_if_required,The following statement contains a magic number: while (indexToAdd >= m_allocated_vertices)  				{  					int newSize = m_allocated_vertices + 256;  					double[] newX = new double[newSize];  					double[] newY = new double[newSize];  					ShapePath.FlagsAndCommand[] newCmd = new ShapePath.FlagsAndCommand[newSize];    					if (m_coord_x != null)  					{  						for (int i = 0; i < m_num_vertices; i++)  						{  							newX[i] = m_coord_x[i];  							newY[i] = m_coord_y[i];  							newCmd[i] = m_CommandAndFlags[i];  						}  					}    					m_coord_x = newX;  					m_coord_y = newY;  					m_CommandAndFlags = newCmd;    					m_allocated_vertices = newSize;  				}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The following statement contains a magic number: currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y' Math.PI' Math.PI + Math.PI * 0.5);
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The following statement contains a magic number: currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y' Math.PI + Math.PI * 0.5' 0.0);
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The following statement contains a magic number: currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y' 0.0' Math.PI * 0.5);
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,Vertices,The following statement contains a magic number: currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y' Math.PI * 0.5' Math.PI);
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following statement contains a magic number: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeGenerator.cs,Rewind,The following statement contains a magic number: if (m_status == StrokeMath.status_e.initial)  			{  				m_src_vertices.close(m_closed != 0);  				ShapePath.shorten_path(m_src_vertices' m_shorten' m_closed);  				if (m_src_vertices.size() < 3) m_closed = 0;  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeGenerator.cs,Vertex,The following statement contains a magic number: while (!ShapePath.is_stop(cmd))  			{  				switch (m_status)  				{  					case StrokeMath.status_e.initial:  						Rewind(0);  						goto case StrokeMath.status_e.ready;    					case StrokeMath.status_e.ready:  						if (m_src_vertices.size() < 2 + (m_closed != 0 ? 1 : 0))  						{  							cmd = ShapePath.FlagsAndCommand.CommandStop;  							break;  						}  						m_status = (m_closed != 0) ? StrokeMath.status_e.outline1 : StrokeMath.status_e.cap1;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						m_src_vertex = 0;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap1:  						m_stroker.calc_cap(m_out_vertices' m_src_vertices[0]' m_src_vertices[1]'  							m_src_vertices[0].dist);  						m_src_vertex = 1;  						m_prev_status = StrokeMath.status_e.outline1;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap2:  						m_stroker.calc_cap(m_out_vertices'  							m_src_vertices[m_src_vertices.size() - 1]'  							m_src_vertices[m_src_vertices.size() - 2]'  							m_src_vertices[m_src_vertices.size() - 2].dist);  						m_prev_status = StrokeMath.status_e.outline2;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.outline1:  						if (m_closed != 0)  						{  							if (m_src_vertex >= m_src_vertices.size())  							{  								m_prev_status = StrokeMath.status_e.close_first;  								m_status = StrokeMath.status_e.end_poly1;  								break;  							}  						}  						else  						{  							if (m_src_vertex >= m_src_vertices.size() - 1)  							{  								m_status = StrokeMath.status_e.cap2;  								break;  							}  						}  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex).dist'  							m_src_vertices.curr(m_src_vertex).dist);  						++m_src_vertex;  						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.close_first:  						m_status = StrokeMath.status_e.outline2;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						goto case StrokeMath.status_e.outline2;    					case StrokeMath.status_e.outline2:  						if (m_src_vertex <= (m_closed == 0 ? 1 : 0))  						{  							m_status = StrokeMath.status_e.end_poly2;  							m_prev_status = StrokeMath.status_e.stop;  							break;  						}    						--m_src_vertex;  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex).dist'  							m_src_vertices.prev(m_src_vertex).dist);    						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.out_vertices:  						if (m_out_vertex >= m_out_vertices.size())  						{  							m_status = m_prev_status;  						}  						else  						{  							Vector2 c = m_out_vertices[(int)m_out_vertex++];  							x = c.x;  							y = c.y;  							return cmd;  						}  						break;    					case StrokeMath.status_e.end_poly1:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCCW;    					case StrokeMath.status_e.end_poly2:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCW;    					case StrokeMath.status_e.stop:  						cmd = ShapePath.FlagsAndCommand.CommandStop;  						break;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeGenerator.cs,Vertex,The following statement contains a magic number: while (!ShapePath.is_stop(cmd))  			{  				switch (m_status)  				{  					case StrokeMath.status_e.initial:  						Rewind(0);  						goto case StrokeMath.status_e.ready;    					case StrokeMath.status_e.ready:  						if (m_src_vertices.size() < 2 + (m_closed != 0 ? 1 : 0))  						{  							cmd = ShapePath.FlagsAndCommand.CommandStop;  							break;  						}  						m_status = (m_closed != 0) ? StrokeMath.status_e.outline1 : StrokeMath.status_e.cap1;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						m_src_vertex = 0;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap1:  						m_stroker.calc_cap(m_out_vertices' m_src_vertices[0]' m_src_vertices[1]'  							m_src_vertices[0].dist);  						m_src_vertex = 1;  						m_prev_status = StrokeMath.status_e.outline1;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap2:  						m_stroker.calc_cap(m_out_vertices'  							m_src_vertices[m_src_vertices.size() - 1]'  							m_src_vertices[m_src_vertices.size() - 2]'  							m_src_vertices[m_src_vertices.size() - 2].dist);  						m_prev_status = StrokeMath.status_e.outline2;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.outline1:  						if (m_closed != 0)  						{  							if (m_src_vertex >= m_src_vertices.size())  							{  								m_prev_status = StrokeMath.status_e.close_first;  								m_status = StrokeMath.status_e.end_poly1;  								break;  							}  						}  						else  						{  							if (m_src_vertex >= m_src_vertices.size() - 1)  							{  								m_status = StrokeMath.status_e.cap2;  								break;  							}  						}  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex).dist'  							m_src_vertices.curr(m_src_vertex).dist);  						++m_src_vertex;  						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.close_first:  						m_status = StrokeMath.status_e.outline2;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						goto case StrokeMath.status_e.outline2;    					case StrokeMath.status_e.outline2:  						if (m_src_vertex <= (m_closed == 0 ? 1 : 0))  						{  							m_status = StrokeMath.status_e.end_poly2;  							m_prev_status = StrokeMath.status_e.stop;  							break;  						}    						--m_src_vertex;  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex).dist'  							m_src_vertices.prev(m_src_vertex).dist);    						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.out_vertices:  						if (m_out_vertex >= m_out_vertices.size())  						{  							m_status = m_prev_status;  						}  						else  						{  							Vector2 c = m_out_vertices[(int)m_out_vertex++];  							x = c.x;  							y = c.y;  							return cmd;  						}  						break;    					case StrokeMath.status_e.end_poly1:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCCW;    					case StrokeMath.status_e.end_poly2:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCW;    					case StrokeMath.status_e.stop:  						cmd = ShapePath.FlagsAndCommand.CommandStop;  						break;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeGenerator.cs,Vertex,The following statement contains a magic number: while (!ShapePath.is_stop(cmd))  			{  				switch (m_status)  				{  					case StrokeMath.status_e.initial:  						Rewind(0);  						goto case StrokeMath.status_e.ready;    					case StrokeMath.status_e.ready:  						if (m_src_vertices.size() < 2 + (m_closed != 0 ? 1 : 0))  						{  							cmd = ShapePath.FlagsAndCommand.CommandStop;  							break;  						}  						m_status = (m_closed != 0) ? StrokeMath.status_e.outline1 : StrokeMath.status_e.cap1;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						m_src_vertex = 0;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap1:  						m_stroker.calc_cap(m_out_vertices' m_src_vertices[0]' m_src_vertices[1]'  							m_src_vertices[0].dist);  						m_src_vertex = 1;  						m_prev_status = StrokeMath.status_e.outline1;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap2:  						m_stroker.calc_cap(m_out_vertices'  							m_src_vertices[m_src_vertices.size() - 1]'  							m_src_vertices[m_src_vertices.size() - 2]'  							m_src_vertices[m_src_vertices.size() - 2].dist);  						m_prev_status = StrokeMath.status_e.outline2;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.outline1:  						if (m_closed != 0)  						{  							if (m_src_vertex >= m_src_vertices.size())  							{  								m_prev_status = StrokeMath.status_e.close_first;  								m_status = StrokeMath.status_e.end_poly1;  								break;  							}  						}  						else  						{  							if (m_src_vertex >= m_src_vertices.size() - 1)  							{  								m_status = StrokeMath.status_e.cap2;  								break;  							}  						}  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex).dist'  							m_src_vertices.curr(m_src_vertex).dist);  						++m_src_vertex;  						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.close_first:  						m_status = StrokeMath.status_e.outline2;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						goto case StrokeMath.status_e.outline2;    					case StrokeMath.status_e.outline2:  						if (m_src_vertex <= (m_closed == 0 ? 1 : 0))  						{  							m_status = StrokeMath.status_e.end_poly2;  							m_prev_status = StrokeMath.status_e.stop;  							break;  						}    						--m_src_vertex;  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex).dist'  							m_src_vertices.prev(m_src_vertex).dist);    						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.out_vertices:  						if (m_out_vertex >= m_out_vertices.size())  						{  							m_status = m_prev_status;  						}  						else  						{  							Vector2 c = m_out_vertices[(int)m_out_vertex++];  							x = c.x;  							y = c.y;  							return cmd;  						}  						break;    					case StrokeMath.status_e.end_poly1:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCCW;    					case StrokeMath.status_e.end_poly2:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCW;    					case StrokeMath.status_e.stop:  						cmd = ShapePath.FlagsAndCommand.CommandStop;  						break;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,StrokeMath,The following statement contains a magic number: m_width = 0.5;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,StrokeMath,The following statement contains a magic number: m_width_abs = 0.5;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,StrokeMath,The following statement contains a magic number: m_width_eps = 0.5 / 1024.0;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,StrokeMath,The following statement contains a magic number: m_width_eps = 0.5 / 1024.0;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,StrokeMath,The following statement contains a magic number: m_miter_limit = 4.0;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,StrokeMath,The following statement contains a magic number: m_inner_miter_limit = 1.01;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,width,The following statement contains a magic number: m_width = w * 0.5;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,width,The following statement contains a magic number: m_width_eps = m_width / 1024.0;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,miter_limit_theta,The following statement contains a magic number: m_miter_limit = 1.0 / Math.Sin(t * 0.5);
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,width,The following statement contains a magic number: return m_width * 2.0;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_cap,The following statement contains a magic number: if (m_line_cap != LineCap.Round)  			{  				if (m_line_cap == LineCap.Square)  				{  					dx2 = dy1 * m_width_sign;  					dy2 = dx1 * m_width_sign;  				}  				add_vertex(vc' v0.x - dx1 - dx2' v0.y + dy1 - dy2);  				add_vertex(vc' v0.x + dx1 - dx2' v0.y - dy1 - dy2);  			}  			else  			{  				double da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;  				double a1;  				int i;  				int n = (int)(Math.PI / da);    				da = Math.PI / (n + 1);  				add_vertex(vc' v0.x - dx1' v0.y + dy1);  				if (m_width_sign > 0)  				{  					a1 = Math.Atan2(dy1' -dx1);  					a1 += da;  					for (i = 0; i < n; i++)  					{  						add_vertex(vc' v0.x + Math.Cos(a1) * m_width'  									   v0.y + Math.Sin(a1) * m_width);  						a1 += da;  					}  				}  				else  				{  					a1 = Math.Atan2(-dy1' dx1);  					a1 -= da;  					for (i = 0; i < n; i++)  					{  						add_vertex(vc' v0.x + Math.Cos(a1) * m_width'  									   v0.y + Math.Sin(a1) * m_width);  						a1 -= da;  					}  				}  				add_vertex(vc' v0.x + dx1' v0.y - dy1);  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_cap,The following statement contains a magic number: if (m_line_cap != LineCap.Round)  			{  				if (m_line_cap == LineCap.Square)  				{  					dx2 = dy1 * m_width_sign;  					dy2 = dx1 * m_width_sign;  				}  				add_vertex(vc' v0.x - dx1 - dx2' v0.y + dy1 - dy2);  				add_vertex(vc' v0.x + dx1 - dx2' v0.y - dy1 - dy2);  			}  			else  			{  				double da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;  				double a1;  				int i;  				int n = (int)(Math.PI / da);    				da = Math.PI / (n + 1);  				add_vertex(vc' v0.x - dx1' v0.y + dy1);  				if (m_width_sign > 0)  				{  					a1 = Math.Atan2(dy1' -dx1);  					a1 += da;  					for (i = 0; i < n; i++)  					{  						add_vertex(vc' v0.x + Math.Cos(a1) * m_width'  									   v0.y + Math.Sin(a1) * m_width);  						a1 += da;  					}  				}  				else  				{  					a1 = Math.Atan2(-dy1' dx1);  					a1 -= da;  					for (i = 0; i < n; i++)  					{  						add_vertex(vc' v0.x + Math.Cos(a1) * m_width'  									   v0.y + Math.Sin(a1) * m_width);  						a1 -= da;  					}  				}  				add_vertex(vc' v0.x + dx1' v0.y - dy1);  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_join,The following statement contains a magic number: if (cp != 0 && (cp > 0) == (m_width > 0))  			{  				// Inner join  				//---------------  				double limit = ((len1 < len2) ? len1 : len2) / m_width_abs;  				if (limit < m_inner_miter_limit)  				{  					limit = m_inner_miter_limit;  				}    				switch (m_inner_join)  				{  					default: // inner_bevel  						add_vertex(vc' v1.x + dx1' v1.y - dy1);  						add_vertex(vc' v1.x + dx2' v1.y - dy2);  						break;    					case InnerJoin.Miter:  						calc_miter(vc'  								   v0' v1' v2' dx1' dy1' dx2' dy2'  								   LineJoin.MiterRevert'  								   limit' 0);  						break;    					case InnerJoin.Jag:  					case InnerJoin.Round:  						cp = (dx1 - dx2) * (dx1 - dx2) + (dy1 - dy2) * (dy1 - dy2);  						if (cp < len1 * len1 && cp < len2 * len2)  						{  							calc_miter(vc'  									   v0' v1' v2' dx1' dy1' dx2' dy2'  									   LineJoin.MiterRevert'  									   limit' 0);  						}  						else  						{  							if (m_inner_join == InnerJoin.Jag)  							{  								add_vertex(vc' v1.x + dx1' v1.y - dy1);  								add_vertex(vc' v1.x' v1.y);  								add_vertex(vc' v1.x + dx2' v1.y - dy2);  							}  							else  							{  								add_vertex(vc' v1.x + dx1' v1.y - dy1);  								add_vertex(vc' v1.x' v1.y);  								calc_arc(vc' v1.x' v1.y' dx2' -dy2' dx1' -dy1);  								add_vertex(vc' v1.x' v1.y);  								add_vertex(vc' v1.x + dx2' v1.y - dy2);  							}  						}  						break;  				}  			}  			else  			{  				// Outer join  				//---------------    				// Calculate the distance between v1 and  				// the central point of the bevel line segment  				//---------------  				double dx = (dx1 + dx2) / 2;  				double dy = (dy1 + dy2) / 2;  				double dbevel = Math.Sqrt(dx * dx + dy * dy);    				if (m_line_join == LineJoin.Round || m_line_join == LineJoin.Bevel)  				{  					// This is an optimization that reduces the number of points  					// in cases of almost collinear segments. If there's no  					// visible difference between bevel and miter joins we'd rather  					// use miter join because it adds only one point instead of two.  					//  					// Here we calculate the middle point between the bevel points  					// and then' the distance between v1 and this middle point.  					// At outer joins this distance always less than stroke width'  					// because it's actually the height of an isosceles triangle of  					// v1 and its two bevel points. If the difference between this  					// width and this value is small (no visible bevel) we can  					// add just one point.  					//  					// The constant in the expression makes the result approximately  					// the same as in round joins and caps. You can safely comment  					// out this entire "if".  					//-------------------  					if (m_approx_scale * (m_width_abs - dbevel) < m_width_eps)  					{  						if (agg_math.calc_intersection(v0.x + dx1' v0.y - dy1'  											 v1.x + dx1' v1.y - dy1'  											 v1.x + dx2' v1.y - dy2'  											 v2.x + dx2' v2.y - dy2'  											 out dx' out dy))  						{  							add_vertex(vc' dx' dy);  						}  						else  						{  							add_vertex(vc' v1.x + dx1' v1.y - dy1);  						}  						return;  					}  				}    				switch (m_line_join)  				{  					case LineJoin.Miter:  					case LineJoin.MiterRevert:  					case LineJoin.MiterRound:  						calc_miter(vc'  								   v0' v1' v2' dx1' dy1' dx2' dy2'  								   m_line_join'  								   m_miter_limit'  								   dbevel);  						break;    					case LineJoin.Round:  						calc_arc(vc' v1.x' v1.y' dx1' -dy1' dx2' -dy2);  						break;    					default: // Bevel join  						add_vertex(vc' v1.x + dx1' v1.y - dy1);  						add_vertex(vc' v1.x + dx2' v1.y - dy2);  						break;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_join,The following statement contains a magic number: if (cp != 0 && (cp > 0) == (m_width > 0))  			{  				// Inner join  				//---------------  				double limit = ((len1 < len2) ? len1 : len2) / m_width_abs;  				if (limit < m_inner_miter_limit)  				{  					limit = m_inner_miter_limit;  				}    				switch (m_inner_join)  				{  					default: // inner_bevel  						add_vertex(vc' v1.x + dx1' v1.y - dy1);  						add_vertex(vc' v1.x + dx2' v1.y - dy2);  						break;    					case InnerJoin.Miter:  						calc_miter(vc'  								   v0' v1' v2' dx1' dy1' dx2' dy2'  								   LineJoin.MiterRevert'  								   limit' 0);  						break;    					case InnerJoin.Jag:  					case InnerJoin.Round:  						cp = (dx1 - dx2) * (dx1 - dx2) + (dy1 - dy2) * (dy1 - dy2);  						if (cp < len1 * len1 && cp < len2 * len2)  						{  							calc_miter(vc'  									   v0' v1' v2' dx1' dy1' dx2' dy2'  									   LineJoin.MiterRevert'  									   limit' 0);  						}  						else  						{  							if (m_inner_join == InnerJoin.Jag)  							{  								add_vertex(vc' v1.x + dx1' v1.y - dy1);  								add_vertex(vc' v1.x' v1.y);  								add_vertex(vc' v1.x + dx2' v1.y - dy2);  							}  							else  							{  								add_vertex(vc' v1.x + dx1' v1.y - dy1);  								add_vertex(vc' v1.x' v1.y);  								calc_arc(vc' v1.x' v1.y' dx2' -dy2' dx1' -dy1);  								add_vertex(vc' v1.x' v1.y);  								add_vertex(vc' v1.x + dx2' v1.y - dy2);  							}  						}  						break;  				}  			}  			else  			{  				// Outer join  				//---------------    				// Calculate the distance between v1 and  				// the central point of the bevel line segment  				//---------------  				double dx = (dx1 + dx2) / 2;  				double dy = (dy1 + dy2) / 2;  				double dbevel = Math.Sqrt(dx * dx + dy * dy);    				if (m_line_join == LineJoin.Round || m_line_join == LineJoin.Bevel)  				{  					// This is an optimization that reduces the number of points  					// in cases of almost collinear segments. If there's no  					// visible difference between bevel and miter joins we'd rather  					// use miter join because it adds only one point instead of two.  					//  					// Here we calculate the middle point between the bevel points  					// and then' the distance between v1 and this middle point.  					// At outer joins this distance always less than stroke width'  					// because it's actually the height of an isosceles triangle of  					// v1 and its two bevel points. If the difference between this  					// width and this value is small (no visible bevel) we can  					// add just one point.  					//  					// The constant in the expression makes the result approximately  					// the same as in round joins and caps. You can safely comment  					// out this entire "if".  					//-------------------  					if (m_approx_scale * (m_width_abs - dbevel) < m_width_eps)  					{  						if (agg_math.calc_intersection(v0.x + dx1' v0.y - dy1'  											 v1.x + dx1' v1.y - dy1'  											 v1.x + dx2' v1.y - dy2'  											 v2.x + dx2' v2.y - dy2'  											 out dx' out dy))  						{  							add_vertex(vc' dx' dy);  						}  						else  						{  							add_vertex(vc' v1.x + dx1' v1.y - dy1);  						}  						return;  					}  				}    				switch (m_line_join)  				{  					case LineJoin.Miter:  					case LineJoin.MiterRevert:  					case LineJoin.MiterRound:  						calc_miter(vc'  								   v0' v1' v2' dx1' dy1' dx2' dy2'  								   m_line_join'  								   m_miter_limit'  								   dbevel);  						break;    					case LineJoin.Round:  						calc_arc(vc' v1.x' v1.y' dx1' -dy1' dx2' -dy2);  						break;    					default: // Bevel join  						add_vertex(vc' v1.x + dx1' v1.y - dy1);  						add_vertex(vc' v1.x + dx2' v1.y - dy2);  						break;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_arc,The following statement contains a magic number: da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_arc,The following statement contains a magic number: da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_arc,The following statement contains a magic number: if (m_width_sign > 0)  			{  				if (a1 > a2) a2 += 2 * Math.PI;  				n = (int)((a2 - a1) / da);  				da = (a2 - a1) / (n + 1);  				a1 += da;  				for (i = 0; i < n; i++)  				{  					add_vertex(vc' x + Math.Cos(a1) * m_width' y + Math.Sin(a1) * m_width);  					a1 += da;  				}  			}  			else  			{  				if (a1 < a2) a2 -= 2 * Math.PI;  				n = (int)((a1 - a2) / da);  				da = (a1 - a2) / (n + 1);  				a1 -= da;  				for (i = 0; i < n; i++)  				{  					add_vertex(vc' x + Math.Cos(a1) * m_width' y + Math.Sin(a1) * m_width);  					a1 -= da;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,StrokeMath,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeMath.cs,calc_arc,The following statement contains a magic number: if (m_width_sign > 0)  			{  				if (a1 > a2) a2 += 2 * Math.PI;  				n = (int)((a2 - a1) / da);  				da = (a2 - a1) / (n + 1);  				a1 += da;  				for (i = 0; i < n; i++)  				{  					add_vertex(vc' x + Math.Cos(a1) * m_width' y + Math.Sin(a1) * m_width);  					a1 += da;  				}  			}  			else  			{  				if (a1 < a2) a2 -= 2 * Math.PI;  				n = (int)((a1 - a2) / da);  				da = (a1 - a2) / (n + 1);  				a1 -= da;  				for (i = 0; i < n; i++)  				{  					add_vertex(vc' x + Math.Cos(a1) * m_width' y + Math.Sin(a1) * m_width);  					a1 -= da;  				}  			}
Magic Number,MatterHackers.Agg.VertexSource,VertexSourceIO,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\VertexSourceIO.cs,Load,The following statement contains a magic number: foreach (string line in allLines)  			{  				string[] elements = line.Split(''');  				double x = double.Parse(elements[0]);  				double y = double.Parse(elements[1]);  				ShapePath.FlagsAndCommand flagsAndCommand = (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand)' elements[2].Trim());  				for (int i = 3; i < elements.Length; i++)  				{  					flagsAndCommand |= (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand)' elements[i].Trim());  				}    				vertexSource.Add(x' y' flagsAndCommand);  			}
Magic Number,MatterHackers.Agg.VertexSource,VertexSourceIO,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\VertexSourceIO.cs,Load,The following statement contains a magic number: foreach (string line in allLines)  			{  				string[] elements = line.Split(''');  				double x = double.Parse(elements[0]);  				double y = double.Parse(elements[1]);  				ShapePath.FlagsAndCommand flagsAndCommand = (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand)' elements[2].Trim());  				for (int i = 3; i < elements.Length; i++)  				{  					flagsAndCommand |= (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand)' elements[i].Trim());  				}    				vertexSource.Add(x' y' flagsAndCommand);  			}
Duplicate Code,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The method contains a code clone-set at the following line numbers (starting from the method definition): ((29' 61)' (174' 206))
Duplicate Code,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,stack_blur_bgr24,The method contains a code clone-set at the following line numbers (starting from the method definition): ((113' 138)' (218' 243))
Duplicate Code,MatterHackers.Agg.Image,stack_blur,C:\repos\MatterHackers_agg-sharp\agg\Image\RecursiveBlur.cs,stack_blur_bgra32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((128' 158)' (250' 280))
Missing Default,MatterHackers.Agg,RGBA_Floats,C:\repos\MatterHackers_agg-sharp\agg\agg_color_rgba.cs,FromHSL,The following switch statement is missing a default case: switch (sextant)  				{  					case 0:  						r = v;  						g = mid1;  						b = m;  						break;    					case 1:  						r = mid2;  						g = v;  						b = m;  						break;    					case 2:  						r = m;  						g = v;  						b = mid1;  						break;    					case 3:  						r = m;  						g = mid2;  						b = v;  						break;    					case 4:  						r = mid1;  						g = m;  						b = v;  						break;    					case 5:  						r = v;  						g = m;  						b = mid2;  						break;    					case 6:  						goto case 0;  				}
Missing Default,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following switch statement is missing a default case: switch (dv.flags)  				{  					case 0: m_ren.line3(dv.curr' dv.xb1' dv.yb1' dv.xb2' dv.yb2); break;  					case 1: m_ren.line2(dv.curr' dv.xb2' dv.yb2); break;  					case 2: m_ren.line1(dv.curr' dv.xb1' dv.yb1); break;  					case 3: m_ren.line0(dv.curr); break;  				}
Missing Default,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,draw,The following switch statement is missing a default case: switch (m_line_join)  				{  					case outline_aa_join_e.outline_no_join:  						dv.flags = 3;  						break;    					case outline_aa_join_e.outline_miter_join:  						dv.flags >>= 1;  						dv.flags |= (dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant() ? 1 : 0);  						if ((dv.flags & 2) == 0)  						{  							LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						}  						break;    					case outline_aa_join_e.outline_round_join:  						dv.flags >>= 1;  						dv.flags |= (((dv.curr.diagonal_quadrant() ==  							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);  						break;    					case outline_aa_join_e.outline_miter_accurate_join:  						dv.flags = 0;  						LineAABasics.bisectrix(dv.curr' dv.next' out dv.xb2' out dv.yb2);  						break;  				}
Missing Default,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following switch statement is missing a default case: switch (m_line_join)  					{  						case outline_aa_join_e.outline_no_join:  							dv.flags = 3;  							break;    						case outline_aa_join_e.outline_miter_join:  						case outline_aa_join_e.outline_round_join:  							dv.flags =  								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  							break;    						case outline_aa_join_e.outline_miter_accurate_join:  							dv.flags = 0;  							break;  					}
Missing Default,MatterHackers.Agg,rasterizer_outline_aa,C:\repos\MatterHackers_agg-sharp\agg\agg_rasterizer_outline_aa.cs,render,The following switch statement is missing a default case: switch (m_line_join)  							{  								case outline_aa_join_e.outline_no_join:  									dv.flags = 3;  									break;    								case outline_aa_join_e.outline_miter_join:  								case outline_aa_join_e.outline_round_join:  									dv.flags =  										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |  											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);  									break;    								case outline_aa_join_e.outline_miter_accurate_join:  									dv.flags = 0;  									break;  							}
Missing Default,MatterHackers.Agg,VectorClipper,C:\repos\MatterHackers_agg-sharp\agg\VectorClipper.cs,line_to,The following switch statement is missing a default case: switch (((f1 & 5) << 1) | (f2 & 5))  				{  					case 0: // Visible by X  						line_clip_y(ras' x1' y1' x2' y2' f1' f2);  						break;    					case 1: // x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Right' y2' f3' f2);  						break;    					case 2: // x1 > clip.x2  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' x2' y2' f3' f2);  						break;    					case 3: // x1 > clip.x2 && x2 > clip.x2  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y2' f1' f2);  						break;    					case 4: // x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' x1' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Left' y2' f3' f2);  						break;    					case 6: // x1 > clip.x2 && x2 < clip.x1  						y3 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Right' y1' clipBox.Right' y3' f1' f3);  						line_clip_y(ras' clipBox.Right' y3' clipBox.Left' y4' f3' f4);  						line_clip_y(ras' clipBox.Left' y4' clipBox.Left' y2' f4' f2);  						break;    					case 8: // x1 < clip.x1  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' x2' y2' f3' f2);  						break;    					case 9:  // x1 < clip.x1 && x2 > clip.x2  						y3 = y1 + mul_div(clipBox.Left - x1' y2 - y1' x2 - x1);  						y4 = y1 + mul_div(clipBox.Right - x1' y2 - y1' x2 - x1);  						f3 = ClipLiangBarsky.clipping_flags_y(y3' clipBox);  						f4 = ClipLiangBarsky.clipping_flags_y(y4' clipBox);  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y3' f1' f3);  						line_clip_y(ras' clipBox.Left' y3' clipBox.Right' y4' f3' f4);  						line_clip_y(ras' clipBox.Right' y4' clipBox.Right' y2' f4' f2);  						break;    					case 12: // x1 < clip.x1 && x2 < clip.x1  						line_clip_y(ras' clipBox.Left' y1' clipBox.Left' y2' f1' f2);  						break;  				}
Missing Default,MatterHackers.Agg,ImageGraphics2D,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageGraphics2D.cs,Render,The following switch statement is missing a default case: switch (ImageRenderQuality)  				{  					case TransformQuality.Fastest:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_image_filter spanImageFilter;  							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							DrawImage(source' spanImageFilter' destRectTransform);  						}  						break;    					case TransformQuality.Best:  						{  							Affine destRectTransform;  							DrawImageGetDestBounds(source' destX' destY' sourceOriginOffsetX' sourceOriginOffsetY' scaleX' scaleY' angleRadians' out destRectTransform);    							Affine sourceRectTransform = new Affine(destRectTransform);  							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]  							sourceRectTransform.invert();    							span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);  							ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source' RGBA_Floats.rgba_pre(0' 0' 0' 0).GetAsRGBA_Bytes());    							//spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor' RGBA_Floats.rgba_pre(0' 0' 0' 0)' interpolator);    							IImageFilterFunction filterFunction = null;  							filterFunction = new image_filter_blackman(4);  							ImageFilterLookUpTable filter = new ImageFilterLookUpTable();  							filter.calculate(filterFunction' true);    							span_image_filter spanGenerator = new span_image_filter_rgba(sourceAccessor' interpolator' filter);    							DrawImage(source' spanGenerator' destRectTransform);  						}  						break;  				}
Missing Default,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following switch statement is missing a default case: switch (TargaHeader.BPP)  							{  								case 24:  									Do24To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To8Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}
Missing Default,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following switch statement is missing a default case: switch (TargaHeader.BPP)  							{  								case 24:  									Do24To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To24Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}
Missing Default,MatterHackers.Agg.Image,ImageTgaIO,C:\repos\MatterHackers_agg-sharp\agg\Image\ImageTgaIO.cs,LowLevelReadTGABitsFromBuffer,The following switch statement is missing a default case: switch (TargaHeader.BPP)  							{  								case 24:  									Do24To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;    								case 32:  									Do32To32Bit(imageBuffer' BufferToCopyFrom' CopyOffset' imageToReadTo.Width' CurReadLine);  									break;  							}
Missing Default,MatterHackers.Agg.VertexSource,ContourGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\ContourGenerator.cs,Vertex,The following switch statement is missing a default case: switch (m_status)  				{  					case StrokeMath.status_e.initial:  						Rewind(0);  						goto case StrokeMath.status_e.ready;    					case StrokeMath.status_e.ready:  						if (m_src_vertices.size() < 2 + (m_closed ? 1 : 0))  						{  							cmd = ShapePath.FlagsAndCommand.CommandStop;  							break;  						}  						m_status = StrokeMath.status_e.outline1;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						m_src_vertex = 0;  						m_out_vertex = 0;  						goto case StrokeMath.status_e.outline1;    					case StrokeMath.status_e.outline1:  						if (m_src_vertex >= m_src_vertices.size())  						{  							m_status = StrokeMath.status_e.end_poly1;  							break;  						}  						m_stroker.calc_join(m_out_vertices'  											m_src_vertices.prev(m_src_vertex)'  											m_src_vertices.curr(m_src_vertex)'  											m_src_vertices.next(m_src_vertex)'  											m_src_vertices.prev(m_src_vertex).dist'  											m_src_vertices.curr(m_src_vertex).dist);  						++m_src_vertex;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						goto case StrokeMath.status_e.out_vertices;    					case StrokeMath.status_e.out_vertices:  						if (m_out_vertex >= m_out_vertices.size())  						{  							m_status = StrokeMath.status_e.outline1;  						}  						else  						{  							Vector2 c = m_out_vertices[m_out_vertex++];  							x = c.x;  							y = c.y;  							return cmd;  						}  						break;    					case StrokeMath.status_e.end_poly1:  						if (!m_closed) return ShapePath.FlagsAndCommand.CommandStop;  						m_status = StrokeMath.status_e.stop;  						return ShapePath.FlagsAndCommand.CommandEndPoly | ShapePath.FlagsAndCommand.FlagClose | ShapePath.FlagsAndCommand.FlagCCW;    					case StrokeMath.status_e.stop:  						return ShapePath.FlagsAndCommand.CommandStop;  				}
Missing Default,MatterHackers.Agg.VertexSource,VertexSourceAdapter,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\VertexSourceAdapter.cs,vertex,The following switch statement is missing a default case: switch (m_status)  				{  					case status.initial:  						markers.remove_all();  						m_last_cmd = VertexSource.vertex(out m_start_x' out m_start_y);  						m_status = status.accumulate;  						goto case status.accumulate;    					case status.accumulate:  						if (ShapePath.is_stop(m_last_cmd))  						{  							return ShapePath.FlagsAndCommand.CommandStop;  						}    						generator.RemoveAll();  						generator.AddVertex(m_start_x' m_start_y' ShapePath.FlagsAndCommand.CommandMoveTo);  						markers.add_vertex(m_start_x' m_start_y' ShapePath.FlagsAndCommand.CommandMoveTo);    						for (; ; )  						{  							command = VertexSource.vertex(out x' out y);  							//DebugFile.Print("x=" + x.ToString() + " y=" + y.ToString() + "\n");  							if (ShapePath.is_vertex(command))  							{  								m_last_cmd = command;  								if (ShapePath.is_move_to(command))  								{  									m_start_x = x;  									m_start_y = y;  									break;  								}  								generator.AddVertex(x' y' command);  								markers.add_vertex(x' y' ShapePath.FlagsAndCommand.CommandLineTo);  							}  							else  							{  								if (ShapePath.is_stop(command))  								{  									m_last_cmd = ShapePath.FlagsAndCommand.CommandStop;  									break;  								}  								if (ShapePath.is_end_poly(command))  								{  									generator.AddVertex(x' y' command);  									break;  								}  							}  						}  						generator.Rewind(0);  						m_status = status.generate;  						goto case status.generate;    					case status.generate:  						command = generator.Vertex(ref x' ref y);  						//DebugFile.Print("x=" + x.ToString() + " y=" + y.ToString() + "\n");  						if (ShapePath.is_stop(command))  						{  							m_status = status.accumulate;  							break;  						}  						done = true;  						break;  				}
Missing Default,MatterHackers.Agg.VertexSource,curve4_div,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\agg_curves.cs,recursive_bezier,The following switch statement is missing a default case: switch (SwitchCase)  			{  				case 0:  					// All collinear OR p1==p4  					//----------------------  					k = dx * dx + dy * dy;  					if (k == 0)  					{  						d2 = agg_math.calc_sq_distance(x1' y1' x2' y2);  						d3 = agg_math.calc_sq_distance(x4' y4' x3' y3);  					}  					else  					{  						k = 1 / k;  						da1 = x2 - x1;  						da2 = y2 - y1;  						d2 = k * (da1 * dx + da2 * dy);  						da1 = x3 - x1;  						da2 = y3 - y1;  						d3 = k * (da1 * dx + da2 * dy);  						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)  						{  							// Simple collinear case' 1---2---3---4  							// We can leave just two endpoints  							return;  						}  						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2' y2' x1' y1);  						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2' y2' x4' y4);  						else d2 = agg_math.calc_sq_distance(x2' y2' x1 + d2 * dx' y1 + d2 * dy);    						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3' y3' x1' y1);  						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3' y3' x4' y4);  						else d3 = agg_math.calc_sq_distance(x3' y3' x1 + d3 * dx' y1 + d3 * dy);  					}  					if (d2 > d3)  					{  						if (d2 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x2' y2));  							return;  						}  					}  					else  					{  						if (d3 < m_distance_tolerance_square)  						{  							m_points.add(new Vector2(x3' y3));  							return;  						}  					}  					break;    				case 1:  					// p1'p2'p4 are collinear' p3 is significant  					//----------------------  					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - Math.Atan2(y3 - y2' x3 - x2));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;    				case 2:  					// p1'p3'p4 are collinear' p2 is significant  					//----------------------  					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle Condition  						//----------------------  						da1 = Math.Abs(Math.Atan2(y3 - y2' x3 - x2) - Math.Atan2(y2 - y1' x2 - x1));  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;    						if (da1 < m_angle_tolerance)  						{  							m_points.add(new Vector2(x2' y2));  							m_points.add(new Vector2(x3' y3));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}  						}  					}  					break;    				case 3:  					// Regular case  					//-----------------  					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))  					{  						// If the curvature doesn't exceed the distance_tolerance value  						// we tend to finish subdivisions.  						//----------------------  						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)  						{  							m_points.add(new Vector2(x23' y23));  							return;  						}    						// Angle & Cusp Condition  						//----------------------  						k = Math.Atan2(y3 - y2' x3 - x2);  						da1 = Math.Abs(k - Math.Atan2(y2 - y1' x2 - x1));  						da2 = Math.Abs(Math.Atan2(y4 - y3' x4 - x3) - k);  						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;  						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;    						if (da1 + da2 < m_angle_tolerance)  						{  							// Finally we can stop the recursion  							//----------------------  							m_points.add(new Vector2(x23' y23));  							return;  						}    						if (m_cusp_limit != 0.0)  						{  							if (da1 > m_cusp_limit)  							{  								m_points.add(new Vector2(x2' y2));  								return;  							}    							if (da2 > m_cusp_limit)  							{  								m_points.add(new Vector2(x3' y3));  								return;  							}  						}  					}  					break;  			}
Missing Default,MatterHackers.Agg.VertexSource,RoundedRect,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\RoundedRect.cs,vertex,The following switch statement is missing a default case: switch (state)  			{  				case 0:  					currentProcessingArc.init(bounds.Left + leftBottomRadius.x' bounds.Bottom + leftBottomRadius.y' leftBottomRadius.x' leftBottomRadius.y'  							   Math.PI' Math.PI + Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 1;    				case 1:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return cmd;  					}  					goto case 2;    				case 2:  					currentProcessingArc.init(bounds.Right - rightBottomRadius.x' bounds.Bottom + rightBottomRadius.y' rightBottomRadius.x' rightBottomRadius.y'  							   Math.PI + Math.PI * 0.5' 0.0);  					currentProcessingArc.rewind(0);  					state++;  					goto case 3;    				case 3:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 4;    				case 4:  					currentProcessingArc.init(bounds.Right - rightTopRadius.x' bounds.Top - rightTopRadius.y' rightTopRadius.x' rightTopRadius.y'  							   0.0' Math.PI * 0.5);  					currentProcessingArc.rewind(0);  					state++;  					goto case 5;    				case 5:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 6;    				case 6:  					currentProcessingArc.init(bounds.Left + leftTopRadius.x' bounds.Top - leftTopRadius.y' leftTopRadius.x' leftTopRadius.y'  							   Math.PI * 0.5' Math.PI);  					currentProcessingArc.rewind(0);  					state++;  					goto case 7;    				case 7:  					cmd = currentProcessingArc.vertex(out x' out y);  					if (ShapePath.is_stop(cmd))  					{  						state++;  					}  					else  					{  						return ShapePath.FlagsAndCommand.CommandLineTo;  					}  					goto case 8;    				case 8:  					cmd = ShapePath.FlagsAndCommand.CommandEndPoly  						| ShapePath.FlagsAndCommand.FlagClose  						| ShapePath.FlagsAndCommand.FlagCCW;  					state++;  					break;  			}
Missing Default,MatterHackers.Agg.VertexSource,StrokeGenerator,C:\repos\MatterHackers_agg-sharp\agg\VertexSource\StrokeGenerator.cs,Vertex,The following switch statement is missing a default case: switch (m_status)  				{  					case StrokeMath.status_e.initial:  						Rewind(0);  						goto case StrokeMath.status_e.ready;    					case StrokeMath.status_e.ready:  						if (m_src_vertices.size() < 2 + (m_closed != 0 ? 1 : 0))  						{  							cmd = ShapePath.FlagsAndCommand.CommandStop;  							break;  						}  						m_status = (m_closed != 0) ? StrokeMath.status_e.outline1 : StrokeMath.status_e.cap1;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						m_src_vertex = 0;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap1:  						m_stroker.calc_cap(m_out_vertices' m_src_vertices[0]' m_src_vertices[1]'  							m_src_vertices[0].dist);  						m_src_vertex = 1;  						m_prev_status = StrokeMath.status_e.outline1;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.cap2:  						m_stroker.calc_cap(m_out_vertices'  							m_src_vertices[m_src_vertices.size() - 1]'  							m_src_vertices[m_src_vertices.size() - 2]'  							m_src_vertices[m_src_vertices.size() - 2].dist);  						m_prev_status = StrokeMath.status_e.outline2;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.outline1:  						if (m_closed != 0)  						{  							if (m_src_vertex >= m_src_vertices.size())  							{  								m_prev_status = StrokeMath.status_e.close_first;  								m_status = StrokeMath.status_e.end_poly1;  								break;  							}  						}  						else  						{  							if (m_src_vertex >= m_src_vertices.size() - 1)  							{  								m_status = StrokeMath.status_e.cap2;  								break;  							}  						}  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex).dist'  							m_src_vertices.curr(m_src_vertex).dist);  						++m_src_vertex;  						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.close_first:  						m_status = StrokeMath.status_e.outline2;  						cmd = ShapePath.FlagsAndCommand.CommandMoveTo;  						goto case StrokeMath.status_e.outline2;    					case StrokeMath.status_e.outline2:  						if (m_src_vertex <= (m_closed == 0 ? 1 : 0))  						{  							m_status = StrokeMath.status_e.end_poly2;  							m_prev_status = StrokeMath.status_e.stop;  							break;  						}    						--m_src_vertex;  						m_stroker.calc_join(m_out_vertices'  							m_src_vertices.next(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex)'  							m_src_vertices.prev(m_src_vertex)'  							m_src_vertices.curr(m_src_vertex).dist'  							m_src_vertices.prev(m_src_vertex).dist);    						m_prev_status = m_status;  						m_status = StrokeMath.status_e.out_vertices;  						m_out_vertex = 0;  						break;    					case StrokeMath.status_e.out_vertices:  						if (m_out_vertex >= m_out_vertices.size())  						{  							m_status = m_prev_status;  						}  						else  						{  							Vector2 c = m_out_vertices[(int)m_out_vertex++];  							x = c.x;  							y = c.y;  							return cmd;  						}  						break;    					case StrokeMath.status_e.end_poly1:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCCW;    					case StrokeMath.status_e.end_poly2:  						m_status = m_prev_status;  						return ShapePath.FlagsAndCommand.CommandEndPoly  							| ShapePath.FlagsAndCommand.FlagClose  							| ShapePath.FlagsAndCommand.FlagCW;    					case StrokeMath.status_e.stop:  						cmd = ShapePath.FlagsAndCommand.CommandStop;  						break;  				}
