Implementation smell,Namespace,Class,File,Method,Description
Long Method,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFaces,The method has 104 lines of code.
Long Method,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The method has 177 lines of code.
Complex Method,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFaces,Cyclomatic complexity of the method is 13
Complex Method,Net3dBool,Segment,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Segment.cs,Segment,Cyclomatic complexity of the method is 11
Long Parameter List,Net3dBool,BooleanModeller,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\BooleanModeller.cs,GroupObjectComponents,The method has 5 parameters. Parameters: obj' vertices' indices' faceStatus1' faceStatus2
Long Parameter List,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,BreakFaceInThree,The method has 5 parameters. Parameters: faceIndex' newPos1' newPos2' startVertex' endVertex
Long Parameter List,Net3dBool,Segment,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Segment.cs,Segment,The method has 5 parameters. Parameters: line' face' sign1' sign2' sign3
Long Statement,Net3dBool,Bound,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Bound.cs,Overlap,The length of the statement  "            if ((xMin > bound.xMax + EqualityTolerance) || (xMax < bound.xMin - EqualityTolerance) || (yMin > bound.yMax + EqualityTolerance) || (yMax < bound.yMin - EqualityTolerance) || (zMin > bound.zMax + EqualityTolerance) || (zMax < bound.zMin - EqualityTolerance)) " is 259.
Long Statement,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,LinePositionInX,The length of the statement  "			if ((Math.Abs(pointLine1.y - pointLine2.y) > EqualityTolerance) && (((point.y >= pointLine1.y) && (point.y <= pointLine2.y)) || ((point.y <= pointLine1.y) && (point.y >= pointLine2.y)))) " is 186.
Long Statement,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,LinePositionInY,The length of the statement  "			if ((Math.Abs(pointLine1.x - pointLine2.x) > EqualityTolerance) && (((point.x >= pointLine1.x) && (point.x <= pointLine2.x)) || ((point.x <= pointLine1.x) && (point.x >= pointLine2.x)))) " is 186.
Long Statement,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,LinePositionInZ,The length of the statement  "			if ((Math.Abs(pointLine1.x - pointLine2.x) > EqualityTolerance) && (((point.x >= pointLine1.x) && (point.x <= pointLine2.x)) || ((point.x <= pointLine1.x) && (point.x >= pointLine2.x)))) " is 186.
Long Statement,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,ContainsPoint,The length of the statement  "			if (((result1 == Side.UP) || (result2 == Side.UP) || (result3 == Side.UP)) && ((result1 == Side.DOWN) || (result2 == Side.DOWN) || (result3 == Side.DOWN))) " is 155.
Long Statement,Net3dBool,Line,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Line.cs,ComputeLineIntersection,The length of the statement  "				t = (-startPoint.y * lineDirection.x + linePoint.y * lineDirection.x + lineDirection.y * startPoint.x - lineDirection.y * linePoint.x) / (Direction.y * lineDirection.x - Direction.x * lineDirection.y); " is 201.
Long Statement,Net3dBool,Line,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Line.cs,ComputeLineIntersection,The length of the statement  "				t = -(-lineDirection.z * startPoint.x + lineDirection.z * linePoint.x + lineDirection.x * startPoint.z - lineDirection.x * linePoint.z) / (-Direction.x * lineDirection.z + Direction.z * lineDirection.x); " is 203.
Long Statement,Net3dBool,Line,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Line.cs,ComputeLineIntersection,The length of the statement  "				t = (startPoint.z * lineDirection.y - linePoint.z * lineDirection.y - lineDirection.z * startPoint.y + lineDirection.z * linePoint.y) / (-Direction.z * lineDirection.y + Direction.y * lineDirection.z); " is 201.
Long Statement,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The length of the statement  "					if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1)) " is 157.
Long Statement,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The length of the statement  "				if (Math.Abs(segmentVector.x) < EqualityTolerance && Math.Abs(segmentVector.y) < EqualityTolerance && Math.Abs(segmentVector.z) < EqualityTolerance) " is 148.
Long Statement,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The length of the statement  "				Vector3 vertexVector = new Vector3(endPos.x - face.v1.Position.x' endPos.y - face.v1.Position.y' endPos.z - face.v1.Position.z); " is 128.
Long Statement,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The length of the statement  "				vertexVector = new Vector3(endPos.x - face.v2.Position.x' endPos.y - face.v2.Position.y' endPos.z - face.v2.Position.z); " is 120.
Long Statement,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The length of the statement  "				vertexVector = new Vector3(endPos.x - face.v3.Position.x' endPos.y - face.v3.Position.y' endPos.z - face.v3.Position.z); " is 120.
Complex Conditional,Net3dBool,Bound,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Bound.cs,Overlap,The conditional expression  "(xMin > bound.xMax + EqualityTolerance) || (xMax < bound.xMin - EqualityTolerance) || (yMin > bound.yMax + EqualityTolerance) || (yMax < bound.yMin - EqualityTolerance) || (zMin > bound.zMax + EqualityTolerance) || (zMax < bound.zMin - EqualityTolerance)"  is complex.
Complex Conditional,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,LinePositionInX,The conditional expression  "(Math.Abs(pointLine1.y - pointLine2.y) > EqualityTolerance) && (((point.y >= pointLine1.y) && (point.y <= pointLine2.y)) || ((point.y <= pointLine1.y) && (point.y >= pointLine2.y)))"  is complex.
Complex Conditional,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,LinePositionInY,The conditional expression  "(Math.Abs(pointLine1.x - pointLine2.x) > EqualityTolerance) && (((point.x >= pointLine1.x) && (point.x <= pointLine2.x)) || ((point.x <= pointLine1.x) && (point.x >= pointLine2.x)))"  is complex.
Complex Conditional,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,LinePositionInZ,The conditional expression  "(Math.Abs(pointLine1.x - pointLine2.x) > EqualityTolerance) && (((point.x >= pointLine1.x) && (point.x <= pointLine2.x)) || ((point.x <= pointLine1.x) && (point.x >= pointLine2.x)))"  is complex.
Complex Conditional,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,ContainsPoint,The conditional expression  "((result1 == Side.UP) || (result2 == Side.UP) || (result3 == Side.UP)) && ((result1 == Side.DOWN) || (result2 == Side.DOWN) || (result3 == Side.DOWN))"  is complex.
Complex Conditional,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The conditional expression  "(startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1)"  is complex.
Complex Conditional,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The conditional expression  "(startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2)"  is complex.
Complex Conditional,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The conditional expression  "(startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1)"  is complex.
Complex Conditional,Net3dBool,Segment,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Segment.cs,Segment,The conditional expression  "(sign1 == 1 && sign2 == -1) || (sign1 == -1 && sign2 == 1)"  is complex.
Complex Conditional,Net3dBool,Segment,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Segment.cs,Segment,The conditional expression  "(sign2 == 1 && sign3 == -1) || (sign2 == -1 && sign3 == 1)"  is complex.
Complex Conditional,Net3dBool,Segment,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Segment.cs,Segment,The conditional expression  "(sign3 == 1 && sign1 == -1) || (sign3 == -1 && sign1 == 1)"  is complex.
Magic Number,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,Face,The following statement contains a magic number: center = (v1.Position + v2.Position + v3.Position) / 3.0;
Magic Number,Net3dBool,Face,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Face.cs,GetIntersectCost,The following statement contains a magic number: return 350;
Magic Number,Net3dBool,Line,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Line.cs,PerturbDirection,The following statement contains a magic number: perturbedDirection.x += 1e-5 * Random();
Magic Number,Net3dBool,Line,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Line.cs,PerturbDirection,The following statement contains a magic number: perturbedDirection.y += 1e-5 * Random();
Magic Number,Net3dBool,Line,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Line.cs,PerturbDirection,The following statement contains a magic number: perturbedDirection.z += 1e-5 * Random();
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,Object3D,The following statement contains a magic number: for (int i = 0; i < indices.Length; i = i + 3)  			{  				v1 = verticesTemp[indices[i]];  				v2 = verticesTemp[indices[i + 1]];  				v3 = verticesTemp[indices[i + 2]];  				AddFace(v1' v2' v3);  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,Object3D,The following statement contains a magic number: for (int i = 0; i < indices.Length; i = i + 3)  			{  				v1 = verticesTemp[indices[i]];  				v2 = verticesTemp[indices[i + 1]];  				v3 = verticesTemp[indices[i + 2]];  				AddFace(v1' v2' v3);  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFaces,The following statement contains a magic number: if (this.GetBound().Overlap(compareObject.GetBound()))  			{  				//for each object1 face...  				for (int thisFaceIndex = 0; thisFaceIndex < this.GetNumFaces(); thisFaceIndex++)  				{  					//if object1 face bound and object2 bound overlap ...  					thisFace = GetFace(thisFaceIndex);    					if (thisFace.GetBound().Overlap(compareObject.GetBound()))  					{  						//for each object2 face...  						for (int compareFaceIndex = 0; compareFaceIndex < compareObject.GetNumFaces(); compareFaceIndex++)  						{  							//if object1 face bound and object2 face bound overlap...  							compareFace = compareObject.GetFace(compareFaceIndex);  							if (thisFace.GetBound().Overlap(compareFace.GetBound()))  							{  								//PART I - DO TWO POLIGONS INTERSECT?  								//POSSIBLE RESULTS: INTERSECT' NOT_INTERSECT' COPLANAR    								//distance from the face1 vertices to the face2 plane  								v1DistToCompareFace = ComputeDistance(thisFace.v1' compareFace);  								distFace1Vert2 = ComputeDistance(thisFace.v2' compareFace);  								distFace1Vert3 = ComputeDistance(thisFace.v3' compareFace);    								//distances signs from the face1 vertices to the face2 plane  								signFace1Vert1 = (v1DistToCompareFace > EqualityTolerance ? 1 : (v1DistToCompareFace < -EqualityTolerance ? -1 : 0));  								signFace1Vert2 = (distFace1Vert2 > EqualityTolerance ? 1 : (distFace1Vert2 < -EqualityTolerance ? -1 : 0));  								signFace1Vert3 = (distFace1Vert3 > EqualityTolerance ? 1 : (distFace1Vert3 < -EqualityTolerance ? -1 : 0));    								//if all the signs are zero' the planes are coplanar  								//if all the signs are positive or negative' the planes do not intersect  								//if the signs are not equal...  								if (!(signFace1Vert1 == signFace1Vert2 && signFace1Vert2 == signFace1Vert3))  								{  									//distance from the face2 vertices to the face1 plane  									distFace2Vert1 = ComputeDistance(compareFace.v1' thisFace);  									distFace2Vert2 = ComputeDistance(compareFace.v2' thisFace);  									distFace2Vert3 = ComputeDistance(compareFace.v3' thisFace);    									//distances signs from the face2 vertices to the face1 plane  									signFace2Vert1 = (distFace2Vert1 > EqualityTolerance ? 1 : (distFace2Vert1 < -EqualityTolerance ? -1 : 0));  									signFace2Vert2 = (distFace2Vert2 > EqualityTolerance ? 1 : (distFace2Vert2 < -EqualityTolerance ? -1 : 0));  									signFace2Vert3 = (distFace2Vert3 > EqualityTolerance ? 1 : (distFace2Vert3 < -EqualityTolerance ? -1 : 0));    									//if the signs are not equal...  									if (!(signFace2Vert1 == signFace2Vert2 && signFace2Vert2 == signFace2Vert3))  									{  										line = new Line(thisFace' compareFace);    										//intersection of the face1 and the plane of face2  										segment1 = new Segment(line' thisFace' signFace1Vert1' signFace1Vert2' signFace1Vert3);    										//intersection of the face2 and the plane of face1  										segment2 = new Segment(line' compareFace' signFace2Vert1' signFace2Vert2' signFace2Vert3);    										//if the two segments intersect...  										if (segment1.Intersect(segment2))  										{  											//PART II - SUBDIVIDING NON-COPLANAR POLYGONS  											int lastNumFaces = GetNumFaces();  											bool splitOccured = this.SplitFace(thisFaceIndex' segment1' segment2);    											//prevent from infinite loop (with a loss of faces...)  											if (GetNumFaces() > numFacesStart * 100)  											{  												//System.out.println("possible infinite loop situation: terminating faces split");  												//return;  												Console.WriteLine("possible infinite loop situation: terminating faces split");  											}    											//if the face in the position isn't the same' there was a break  											if (splitOccured  												&& thisFace != GetFace(thisFaceIndex))  											{  												//if the generated solid is equal the origin...  												if (thisFace.Equals(GetFace(GetNumFaces() - 1)))  												{  													//return it to its position and jump it  													if (thisFaceIndex != (GetNumFaces() - 1))  													{  														faces.RemoveAt(GetNumFaces() - 1);  														faces.Insert(thisFaceIndex' thisFace);  													}  													else  													{  														continue;  													}  												}  												//else: test next face  												else  												{  													thisFaceIndex--;  													break;  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,BreakFaceInFive,The following statement contains a magic number: if (linedVertex == 1)  			{  				AddFace(face.v2' face.v3' faceVertex1);  				AddFace(face.v2' faceVertex1' faceVertex2);  				AddFace(face.v3' faceVertex2' faceVertex1);  				AddFace(face.v2' faceVertex2' face.v1);  				AddFace(face.v3' face.v1' faceVertex2);  			}  			else if (linedVertex == 2)  			{  				AddFace(face.v3' face.v1' faceVertex1);  				AddFace(face.v3' faceVertex1' faceVertex2);  				AddFace(face.v1' faceVertex2' faceVertex1);  				AddFace(face.v3' faceVertex2' face.v2);  				AddFace(face.v1' face.v2' faceVertex2);  			}  			else  			{  				AddFace(face.v1' face.v2' faceVertex1);  				AddFace(face.v1' faceVertex1' faceVertex2);  				AddFace(face.v2' faceVertex2' faceVertex1);  				AddFace(face.v1' faceVertex2' face.v3);  				AddFace(face.v2' face.v3' faceVertex2);  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,BreakFaceInThree,The following statement contains a magic number: if (splitEdge == 1) // vertex 3  			{  				Face face = faces[faceIndex];  				bool willMakeExistingFace = (vertex1 == face.v1 && vertex2 == face.v2) || (vertex1 == face.v2 || vertex2 == face.v1);  				if (!willMakeExistingFace)  				{  					faces.RemoveAt(faceIndex);  					AddFace(face.v1' vertex1' face.v3);  					AddFace(vertex1' vertex2' face.v3);  					AddFace(vertex2' face.v2' face.v3);  					return true;  				}  			}  			else if (splitEdge == 2) // vertex 1  			{  				Face face = faces[faceIndex];  				bool willMakeExistingFace = (vertex1 == face.v2 && vertex2 == face.v3) || (vertex1 == face.v3 || vertex2 == face.v2);  				if (!willMakeExistingFace)  				{  					faces.RemoveAt(faceIndex);  					AddFace(face.v2' vertex1' face.v1);  					AddFace(vertex1' vertex2' face.v1);  					AddFace(vertex2' face.v3' face.v1);  					return true;  				}  			}  			else // vertex 2  			{  				Face face = faces[faceIndex];  				bool willMakeExistingFace = (vertex1 == face.v1 && vertex2 == face.v3) || (vertex1 == face.v3 || vertex2 == face.v1);  				if (!willMakeExistingFace)  				{  					faces.RemoveAt(faceIndex);  					AddFace(face.v3' vertex1' face.v2);  					AddFace(vertex1' vertex2' face.v2);  					AddFace(vertex2' face.v1' face.v2);  					return true;  				}  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,BreakFaceInTwo,The following statement contains a magic number: if (splitEdge == 1)  			{  				AddFace(face.v1' vertex' face.v3);  				AddFace(vertex' face.v2' face.v3);  			}  			else if (splitEdge == 2)  			{  				if (!face.v3.Equals(vertex))  				{  					AddFace(face.v2' vertex' face.v1);  				}  				AddFace(vertex' face.v3' face.v1);  			}  			else  			{  				AddFace(face.v3' vertex' face.v2);  				AddFace(vertex' face.v1' face.v2);  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The following statement contains a magic number: if (startType == Segment.VERTEX && endType == Segment.VERTEX)  			{  				//VERTEX-_______-VERTEX  				return false;  			}  			else if (middleType == Segment.EDGE)  			{  				//______-EDGE-______  				//gets the edge  				int splitEdge;  				if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1))  				{  					splitEdge = 1;  				}  				else if ((startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2))  				{  					splitEdge = 2;  				}  				else  				{  					splitEdge = 3;  				}    				if (startType == Segment.VERTEX)  				{  					//VERTEX-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else if (endType == Segment.VERTEX)  				{  					//EDGE-EDGE-VERTEX  					return BreakFaceInTwo(faceIndex' startPos' splitEdge);  				}  				else if (startDist == endDist)  				{  					// EDGE-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else  				{  					if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1))  					{  						return BreakFaceInThree(faceIndex' startPos' endPos' splitEdge);  					}  					else  					{  						return BreakFaceInThree(faceIndex' endPos' startPos' splitEdge);  					}  				}  			}  			//______-FACE-______  			else if (startType == Segment.VERTEX && endType == Segment.EDGE)  			{  				//VERTEX-FACE-EDGE  				return BreakFaceInTwo(faceIndex' endPos' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.VERTEX)  			{  				//EDGE-FACE-VERTEX  				return BreakFaceInTwo(faceIndex' startPos' startVertex);  			}  			else if (startType == Segment.VERTEX && endType == Segment.FACE)  			{  				//VERTEX-FACE-FACE  				return BreakFaceInThree(faceIndex' endPos);  			}  			else if (startType == Segment.FACE && endType == Segment.VERTEX)  			{  				//FACE-FACE-VERTEX  				return BreakFaceInThree(faceIndex' startPos);  			}  			else if (startType == Segment.EDGE && endType == Segment.EDGE)  			{  				//EDGE-FACE-EDGE  				return BreakFaceInThree(faceIndex' startPos' endPos' startVertex' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.FACE)  			{  				//EDGE-FACE-FACE  				return BreakFaceInFour(faceIndex' startPos' endPos' startVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.EDGE)  			{  				//FACE-FACE-EDGE  				return BreakFaceInFour(faceIndex' endPos' startPos' endVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.FACE)  			{  				//FACE-FACE-FACE  				Vector3 segmentVector = new Vector3(startPos.x - endPos.x' startPos.y - endPos.y' startPos.z - endPos.z);    				//if the intersection segment is a point only...  				if (Math.Abs(segmentVector.x) < EqualityTolerance && Math.Abs(segmentVector.y) < EqualityTolerance && Math.Abs(segmentVector.z) < EqualityTolerance)  				{  					return BreakFaceInThree(faceIndex' startPos);  				}    				//gets the vertex more lined with the intersection segment  				int linedVertex;  				Vector3 linedVertexPos;  				Vector3 vertexVector = new Vector3(endPos.x - face.v1.Position.x' endPos.y - face.v1.Position.y' endPos.z - face.v1.Position.z);  				vertexVector.Normalize();  				double dot1 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v2.Position.x' endPos.y - face.v2.Position.y' endPos.z - face.v2.Position.z);  				vertexVector.Normalize();  				double dot2 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v3.Position.x' endPos.y - face.v3.Position.y' endPos.z - face.v3.Position.z);  				vertexVector.Normalize();  				double dot3 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				if (dot1 > dot2 && dot1 > dot3)  				{  					linedVertex = 1;  					linedVertexPos = face.v1.GetPosition();  				}  				else if (dot2 > dot3 && dot2 > dot1)  				{  					linedVertex = 2;  					linedVertexPos = face.v2.GetPosition();  				}  				else  				{  					linedVertex = 3;  					linedVertexPos = face.v3.GetPosition();  				}    				// Now find which of the intersection endpoints is nearest to that vertex.  				if ((linedVertexPos - startPos).Length > (linedVertexPos - endPos).Length)  				{  					return BreakFaceInFive(faceIndex' startPos' endPos' linedVertex);  				}  				else  				{  					return BreakFaceInFive(faceIndex' endPos' startPos' linedVertex);  				}  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The following statement contains a magic number: if (startType == Segment.VERTEX && endType == Segment.VERTEX)  			{  				//VERTEX-_______-VERTEX  				return false;  			}  			else if (middleType == Segment.EDGE)  			{  				//______-EDGE-______  				//gets the edge  				int splitEdge;  				if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1))  				{  					splitEdge = 1;  				}  				else if ((startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2))  				{  					splitEdge = 2;  				}  				else  				{  					splitEdge = 3;  				}    				if (startType == Segment.VERTEX)  				{  					//VERTEX-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else if (endType == Segment.VERTEX)  				{  					//EDGE-EDGE-VERTEX  					return BreakFaceInTwo(faceIndex' startPos' splitEdge);  				}  				else if (startDist == endDist)  				{  					// EDGE-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else  				{  					if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1))  					{  						return BreakFaceInThree(faceIndex' startPos' endPos' splitEdge);  					}  					else  					{  						return BreakFaceInThree(faceIndex' endPos' startPos' splitEdge);  					}  				}  			}  			//______-FACE-______  			else if (startType == Segment.VERTEX && endType == Segment.EDGE)  			{  				//VERTEX-FACE-EDGE  				return BreakFaceInTwo(faceIndex' endPos' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.VERTEX)  			{  				//EDGE-FACE-VERTEX  				return BreakFaceInTwo(faceIndex' startPos' startVertex);  			}  			else if (startType == Segment.VERTEX && endType == Segment.FACE)  			{  				//VERTEX-FACE-FACE  				return BreakFaceInThree(faceIndex' endPos);  			}  			else if (startType == Segment.FACE && endType == Segment.VERTEX)  			{  				//FACE-FACE-VERTEX  				return BreakFaceInThree(faceIndex' startPos);  			}  			else if (startType == Segment.EDGE && endType == Segment.EDGE)  			{  				//EDGE-FACE-EDGE  				return BreakFaceInThree(faceIndex' startPos' endPos' startVertex' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.FACE)  			{  				//EDGE-FACE-FACE  				return BreakFaceInFour(faceIndex' startPos' endPos' startVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.EDGE)  			{  				//FACE-FACE-EDGE  				return BreakFaceInFour(faceIndex' endPos' startPos' endVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.FACE)  			{  				//FACE-FACE-FACE  				Vector3 segmentVector = new Vector3(startPos.x - endPos.x' startPos.y - endPos.y' startPos.z - endPos.z);    				//if the intersection segment is a point only...  				if (Math.Abs(segmentVector.x) < EqualityTolerance && Math.Abs(segmentVector.y) < EqualityTolerance && Math.Abs(segmentVector.z) < EqualityTolerance)  				{  					return BreakFaceInThree(faceIndex' startPos);  				}    				//gets the vertex more lined with the intersection segment  				int linedVertex;  				Vector3 linedVertexPos;  				Vector3 vertexVector = new Vector3(endPos.x - face.v1.Position.x' endPos.y - face.v1.Position.y' endPos.z - face.v1.Position.z);  				vertexVector.Normalize();  				double dot1 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v2.Position.x' endPos.y - face.v2.Position.y' endPos.z - face.v2.Position.z);  				vertexVector.Normalize();  				double dot2 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v3.Position.x' endPos.y - face.v3.Position.y' endPos.z - face.v3.Position.z);  				vertexVector.Normalize();  				double dot3 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				if (dot1 > dot2 && dot1 > dot3)  				{  					linedVertex = 1;  					linedVertexPos = face.v1.GetPosition();  				}  				else if (dot2 > dot3 && dot2 > dot1)  				{  					linedVertex = 2;  					linedVertexPos = face.v2.GetPosition();  				}  				else  				{  					linedVertex = 3;  					linedVertexPos = face.v3.GetPosition();  				}    				// Now find which of the intersection endpoints is nearest to that vertex.  				if ((linedVertexPos - startPos).Length > (linedVertexPos - endPos).Length)  				{  					return BreakFaceInFive(faceIndex' startPos' endPos' linedVertex);  				}  				else  				{  					return BreakFaceInFive(faceIndex' endPos' startPos' linedVertex);  				}  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The following statement contains a magic number: if (startType == Segment.VERTEX && endType == Segment.VERTEX)  			{  				//VERTEX-_______-VERTEX  				return false;  			}  			else if (middleType == Segment.EDGE)  			{  				//______-EDGE-______  				//gets the edge  				int splitEdge;  				if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1))  				{  					splitEdge = 1;  				}  				else if ((startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2))  				{  					splitEdge = 2;  				}  				else  				{  					splitEdge = 3;  				}    				if (startType == Segment.VERTEX)  				{  					//VERTEX-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else if (endType == Segment.VERTEX)  				{  					//EDGE-EDGE-VERTEX  					return BreakFaceInTwo(faceIndex' startPos' splitEdge);  				}  				else if (startDist == endDist)  				{  					// EDGE-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else  				{  					if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1))  					{  						return BreakFaceInThree(faceIndex' startPos' endPos' splitEdge);  					}  					else  					{  						return BreakFaceInThree(faceIndex' endPos' startPos' splitEdge);  					}  				}  			}  			//______-FACE-______  			else if (startType == Segment.VERTEX && endType == Segment.EDGE)  			{  				//VERTEX-FACE-EDGE  				return BreakFaceInTwo(faceIndex' endPos' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.VERTEX)  			{  				//EDGE-FACE-VERTEX  				return BreakFaceInTwo(faceIndex' startPos' startVertex);  			}  			else if (startType == Segment.VERTEX && endType == Segment.FACE)  			{  				//VERTEX-FACE-FACE  				return BreakFaceInThree(faceIndex' endPos);  			}  			else if (startType == Segment.FACE && endType == Segment.VERTEX)  			{  				//FACE-FACE-VERTEX  				return BreakFaceInThree(faceIndex' startPos);  			}  			else if (startType == Segment.EDGE && endType == Segment.EDGE)  			{  				//EDGE-FACE-EDGE  				return BreakFaceInThree(faceIndex' startPos' endPos' startVertex' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.FACE)  			{  				//EDGE-FACE-FACE  				return BreakFaceInFour(faceIndex' startPos' endPos' startVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.EDGE)  			{  				//FACE-FACE-EDGE  				return BreakFaceInFour(faceIndex' endPos' startPos' endVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.FACE)  			{  				//FACE-FACE-FACE  				Vector3 segmentVector = new Vector3(startPos.x - endPos.x' startPos.y - endPos.y' startPos.z - endPos.z);    				//if the intersection segment is a point only...  				if (Math.Abs(segmentVector.x) < EqualityTolerance && Math.Abs(segmentVector.y) < EqualityTolerance && Math.Abs(segmentVector.z) < EqualityTolerance)  				{  					return BreakFaceInThree(faceIndex' startPos);  				}    				//gets the vertex more lined with the intersection segment  				int linedVertex;  				Vector3 linedVertexPos;  				Vector3 vertexVector = new Vector3(endPos.x - face.v1.Position.x' endPos.y - face.v1.Position.y' endPos.z - face.v1.Position.z);  				vertexVector.Normalize();  				double dot1 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v2.Position.x' endPos.y - face.v2.Position.y' endPos.z - face.v2.Position.z);  				vertexVector.Normalize();  				double dot2 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v3.Position.x' endPos.y - face.v3.Position.y' endPos.z - face.v3.Position.z);  				vertexVector.Normalize();  				double dot3 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				if (dot1 > dot2 && dot1 > dot3)  				{  					linedVertex = 1;  					linedVertexPos = face.v1.GetPosition();  				}  				else if (dot2 > dot3 && dot2 > dot1)  				{  					linedVertex = 2;  					linedVertexPos = face.v2.GetPosition();  				}  				else  				{  					linedVertex = 3;  					linedVertexPos = face.v3.GetPosition();  				}    				// Now find which of the intersection endpoints is nearest to that vertex.  				if ((linedVertexPos - startPos).Length > (linedVertexPos - endPos).Length)  				{  					return BreakFaceInFive(faceIndex' startPos' endPos' linedVertex);  				}  				else  				{  					return BreakFaceInFive(faceIndex' endPos' startPos' linedVertex);  				}  			}
Magic Number,Net3dBool,Object3D,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Object3D.cs,SplitFace,The following statement contains a magic number: if (startType == Segment.VERTEX && endType == Segment.VERTEX)  			{  				//VERTEX-_______-VERTEX  				return false;  			}  			else if (middleType == Segment.EDGE)  			{  				//______-EDGE-______  				//gets the edge  				int splitEdge;  				if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1))  				{  					splitEdge = 1;  				}  				else if ((startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2))  				{  					splitEdge = 2;  				}  				else  				{  					splitEdge = 3;  				}    				if (startType == Segment.VERTEX)  				{  					//VERTEX-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else if (endType == Segment.VERTEX)  				{  					//EDGE-EDGE-VERTEX  					return BreakFaceInTwo(faceIndex' startPos' splitEdge);  				}  				else if (startDist == endDist)  				{  					// EDGE-EDGE-EDGE  					return BreakFaceInTwo(faceIndex' endPos' splitEdge);  				}  				else  				{  					if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1))  					{  						return BreakFaceInThree(faceIndex' startPos' endPos' splitEdge);  					}  					else  					{  						return BreakFaceInThree(faceIndex' endPos' startPos' splitEdge);  					}  				}  			}  			//______-FACE-______  			else if (startType == Segment.VERTEX && endType == Segment.EDGE)  			{  				//VERTEX-FACE-EDGE  				return BreakFaceInTwo(faceIndex' endPos' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.VERTEX)  			{  				//EDGE-FACE-VERTEX  				return BreakFaceInTwo(faceIndex' startPos' startVertex);  			}  			else if (startType == Segment.VERTEX && endType == Segment.FACE)  			{  				//VERTEX-FACE-FACE  				return BreakFaceInThree(faceIndex' endPos);  			}  			else if (startType == Segment.FACE && endType == Segment.VERTEX)  			{  				//FACE-FACE-VERTEX  				return BreakFaceInThree(faceIndex' startPos);  			}  			else if (startType == Segment.EDGE && endType == Segment.EDGE)  			{  				//EDGE-FACE-EDGE  				return BreakFaceInThree(faceIndex' startPos' endPos' startVertex' endVertex);  			}  			else if (startType == Segment.EDGE && endType == Segment.FACE)  			{  				//EDGE-FACE-FACE  				return BreakFaceInFour(faceIndex' startPos' endPos' startVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.EDGE)  			{  				//FACE-FACE-EDGE  				return BreakFaceInFour(faceIndex' endPos' startPos' endVertex);  			}  			else if (startType == Segment.FACE && endType == Segment.FACE)  			{  				//FACE-FACE-FACE  				Vector3 segmentVector = new Vector3(startPos.x - endPos.x' startPos.y - endPos.y' startPos.z - endPos.z);    				//if the intersection segment is a point only...  				if (Math.Abs(segmentVector.x) < EqualityTolerance && Math.Abs(segmentVector.y) < EqualityTolerance && Math.Abs(segmentVector.z) < EqualityTolerance)  				{  					return BreakFaceInThree(faceIndex' startPos);  				}    				//gets the vertex more lined with the intersection segment  				int linedVertex;  				Vector3 linedVertexPos;  				Vector3 vertexVector = new Vector3(endPos.x - face.v1.Position.x' endPos.y - face.v1.Position.y' endPos.z - face.v1.Position.z);  				vertexVector.Normalize();  				double dot1 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v2.Position.x' endPos.y - face.v2.Position.y' endPos.z - face.v2.Position.z);  				vertexVector.Normalize();  				double dot2 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				vertexVector = new Vector3(endPos.x - face.v3.Position.x' endPos.y - face.v3.Position.y' endPos.z - face.v3.Position.z);  				vertexVector.Normalize();  				double dot3 = Math.Abs(Vector3.Dot(segmentVector' vertexVector));  				if (dot1 > dot2 && dot1 > dot3)  				{  					linedVertex = 1;  					linedVertexPos = face.v1.GetPosition();  				}  				else if (dot2 > dot3 && dot2 > dot1)  				{  					linedVertex = 2;  					linedVertexPos = face.v2.GetPosition();  				}  				else  				{  					linedVertex = 3;  					linedVertexPos = face.v3.GetPosition();  				}    				// Now find which of the intersection endpoints is nearest to that vertex.  				if ((linedVertexPos - startPos).Length > (linedVertexPos - endPos).Length)  				{  					return BreakFaceInFive(faceIndex' startPos' endPos' linedVertex);  				}  				else  				{  					return BreakFaceInFive(faceIndex' endPos' startPos' linedVertex);  				}  			}
Magic Number,Net3dBool,Segment,C:\repos\MatterHackers_agg-sharp\PolygonMesh\Net3dBool\Segment.cs,Segment,The following statement contains a magic number: if (GetNumEndsSet() != 2)  			{  				//EDGE is an end  				if ((sign1 == 1 && sign2 == -1) || (sign1 == -1 && sign2 == 1))  				{  					SetEdge(face.v1' face.v2);  				}  				//EDGE is an end  				if ((sign2 == 1 && sign3 == -1) || (sign2 == -1 && sign3 == 1))  				{  					SetEdge(face.v2' face.v3);  				}  				//EDGE is an end  				if ((sign3 == 1 && sign1 == -1) || (sign3 == -1 && sign1 == 1))  				{  					SetEdge(face.v3' face.v1);  				}  			}
