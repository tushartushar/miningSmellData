Implementation smell,Namespace,Class,File,Method,Description
Long Method,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseMLine,The method has 132 lines of code.
Long Method,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseGLine,The method has 107 lines of code.
Long Method,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render3D,The method has 114 lines of code.
Complex Method,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseFileContents,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,AnalyzeGCodeLines,Cyclomatic complexity of the method is 9
Complex Method,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFilamentDiameter,Cyclomatic complexity of the method is 8
Complex Method,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,Cyclomatic complexity of the method is 12
Complex Method,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render3D,Cyclomatic complexity of the method is 21
Long Parameter List,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetFirstNumberAfter,The method has 5 parameters. Parameters: stringToCheckAfter' stringWithNumber' readValue' startIndex' stopCheckingString
Long Parameter List,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetFirstNumberAfter,The method has 5 parameters. Parameters: stringToCheckAfter' stringWithNumber' readValue' startIndex' stopCheckingString
Long Parameter List,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetFirstStringAfter,The method has 5 parameters. Parameters: stringToCheckAfter' fullStringToLookIn' separatorString' nextString' startIndex
Long Parameter List,MatterHackers.GCodeVisualizer,GCodeRenderInfo,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderInfo.cs,GCodeRenderInfo,The method has 8 parameters. Parameters: startLayerIndex' endLayerIndex' transform' layerScale' renderType' featureToStartOnRatio0To1' featureToEndOnRatio0To1' extruderOffsets
Long Parameter List,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,RenderFeatureExtrusion,The method has 8 parameters. Parameters: start' end' extruderIndex' travelSpeed' totalExtrusionMm' filamentDiameterMm' layerHeight' color
Long Parameter List,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The method has 8 parameters. Parameters: colorVertexData' indexData' startPos' endPos' radius' steps' color' layerHeight
Long Parameter List,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreatePointer,The method has 7 parameters. Parameters: colorVertexData' indexData' startPos' endPos' radius' steps' color
Long Identifier,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GCodeFileLoaded,The length of the parameter gcodeHasExplicitLayerChangeInfo is 31.
Long Identifier,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GCodeFileLoaded,The length of the parameter gcodeHasExplicitLayerChangeInfo is 31.
Long Identifier,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseFileContents,The length of the parameter gcodeHasExplicitLayerChangeInfo is 31.
Long Identifier,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,,The length of the parameter amountOfAccumulatedEWhileParsing is 32.
Long Identifier,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,,The length of the parameter gcodeHasExplicitLayerChangeInfo is 31.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileStreamed,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileStreamed.cs,GetWeightedCenter,The length of the statement  "			throw new NotImplementedException("A streamed GCode file should not need to do this. Please validate the code that is calling this."); " is 134.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileStreamed,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileStreamed.cs,GetBounds,The length of the statement  "			throw new NotImplementedException("A streamed GCode file should not need to do this. Please validate the code that is calling this."); " is 134.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileStreamed,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileStreamed.cs,GetFilamentCubicMm,The length of the statement  "			throw new NotImplementedException("A streamed GCode file should not need to do this. Please validate the code that is calling this."); " is 134.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileStreamed,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileStreamed.cs,Instruction,The length of the statement  "						instruction.secondsThisLine = (float)GetSecondsThisLine(deltaPositionThisLine' deltaEPositionThisLine' feedRateMmPerMin); " is 121.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,Load,The length of the statement  "				using (FileStream fileStream = new FileStream(gcodePathAndFileName' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) " is 121.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,AnalyzeGCodeLines,The length of the statement  "					instruction.secondsThisLine = (float)GetSecondsThisLine(deltaPositionThisLine' deltaEPositionThisLine' feedRateMmPerMin); " is 121.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,IsExtruding,The length of the statement  "				double extrusionLengeth = GCodeCommandQueue[instructionIndexToCheck].EPosition - GCodeCommandQueue[instructionIndexToCheck - 1].EPosition; " is 138.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetFirstStringAfter,The length of the statement  "					nextString = fullStringToLookIn.Substring(stringPos + stringToCheckAfter.Length' separatorPos - (stringPos + stringToCheckAfter.Length)); " is 137.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,ReplaceNumberAfter,The length of the statement  "					string newString = string.Format("{0}{1:0.#####}{2}"' stringWithNumber.Substring(0' charPos + 1)' numberToPutIn' stringWithNumber.Substring(spacePos)); " is 151.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The length of the statement  "			double distanceToMaxVelocity = GetDistanceToReachEndingVelocity(startingVelocityMmPerS' maxVelocityMmPerS' acceleration); " is 121.
Long Statement,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The length of the statement  "				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' lengthOfThisMoveMm / 2' acceleration) * 2; " is 120.
Long Statement,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,The length of the statement  "					if (instruction.EPosition > prevInstruction.EPosition && (instruction.Line.IndexOf('X') != -1 || instruction.Line.IndexOf('Y') != -1)) " is 134.
Long Statement,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,The length of the statement  "						renderFeaturesForLayer.Add(new RenderFeatureRetract(currentInstruction.Position' currentInstruction.EPosition - previousInstruction.EPosition' currentInstruction.ExtruderIndex' currentInstruction.FeedRate)); " is 207.
Long Statement,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,The length of the statement  "						renderFeaturesForLayer.Add(new RenderFeatureRetract(currentInstruction.Position' -1' currentInstruction.ExtruderIndex' currentInstruction.FeedRate)); " is 149.
Long Statement,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,The length of the statement  "						renderFeaturesForLayer.Add(new RenderFeatureRetract(currentInstruction.Position' 1' currentInstruction.ExtruderIndex' currentInstruction.FeedRate)); " is 148.
Long Statement,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,The length of the statement  "                        renderFeaturesForLayer.Add(new RenderFeatureExtrusion(previousInstruction.Position' currentInstruction.Position' currentInstruction.ExtruderIndex' currentInstruction.FeedRate' currentInstruction.EPosition - previousInstruction.EPosition' gCodeFileToDraw.GetFilamentDiameter()' layerThickness' extrusionColor)); " is 310.
Long Statement,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,CreateFeaturesForLayerIfRequired,The length of the statement  "						renderFeaturesForLayer.Add(new RenderFeatureTravel(previousInstruction.Position' currentInstruction.Position' currentInstruction.ExtruderIndex' currentInstruction.FeedRate)); " is 174.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,CreateRender3DData,The length of the statement  "						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' GCodeRenderer.ExtrusionColor' layerHeight); " is 135.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,CreateRender3DData,The length of the statement  "						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' MeshViewerWidget.GetMaterialColor(extruderIndex + 1)' layerHeight); " is 159.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The length of the statement  "					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color); " is 132.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The length of the statement  "					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color); " is 132.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The length of the statement  "				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i)); " is 158.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The length of the statement  "				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i)); " is 163.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The length of the statement  "				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8)); " is 123.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The length of the statement  "				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i)); " is 149.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The length of the statement  "				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8)); " is 122.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The length of the statement  "				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i)); " is 145.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreatePointer,The length of the statement  "				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i)); " is 158.
Long Statement,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreatePointer,The length of the statement  "				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i)); " is 163.
Long Statement,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,SetIndexData,The length of the statement  "					GL.BufferData(BufferTarget.ElementArrayBuffer' data.Length * sizeof(int)' (IntPtr)dataPointer' BufferUsageHint.StaticDraw); " is 123.
Long Statement,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,SetVertexData,The length of the statement  "					GL.BufferData(BufferTarget.ArrayBuffer' data.Length * ColorVertexData.Stride' (IntPtr)dataPointer' BufferUsageHint.StaticDraw); " is 127.
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Virtual Method Call from Constructor,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The constructor "GCodeViewerApplication" calls a virtual method "AddChild".
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileStreamed,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileStreamed.cs,PercentComplete,The following statement contains a magic number: lock(locker)  			{  				if (openGcodeStream != null  					&& openGcodeStream.BaseStream.Length > 0)  				{  					return (double)openGcodeStream.BaseStream.Position / (double)openGcodeStream.BaseStream.Length * 100.0;  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileStreamed,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileStreamed.cs,PercentComplete,The following statement contains a magic number: return 100;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseFileContents,The following statement contains a magic number: foreach (string outputString in CustomSplit(gCodeString' '\n'))  			{  				string lineString = outputString.Trim();  				machineInstructionForLine = new PrinterMachineInstruction(lineString' machineInstructionForLine' false);    				if (lineString.Length > 0)  				{  					switch (lineString[0])  					{  						case 'G':  							loadedGCodeFile.ParseGLine(lineString' machineInstructionForLine);  							break;    						case 'M':  							loadedGCodeFile.ParseMLine(lineString' machineInstructionForLine);  							break;    						case 'T':  							double extruderIndex = 0;  							if (GetFirstNumberAfter("T"' lineString' ref extruderIndex))  							{  								machineInstructionForLine.ExtruderIndex = (int)extruderIndex;  							}  							break;    						case ';':  							if (gcodeHasExplicitLayerChangeInfo && IsLayerChange(lineString))  							{  								loadedGCodeFile.IndexOfChangeInZ.Add(loadedGCodeFile.GCodeCommandQueue.Count);  							}  							if (lineString.StartsWith("; layerThickness"))  							{  								loadedGCodeFile.layerThickness = double.Parse(lineString.Split('=')[1]);  							}  							else if (lineString.StartsWith("; firstLayerThickness") && loadedGCodeFile.firstLayerThickness == 0)  							{  								loadedGCodeFile.firstLayerThickness = double.Parse(lineString.Split('=')[1]);  							}  							break;    						case '@':  							break;    						default:  #if DEBUG  							throw new NotImplementedException();  #else                              break;  #endif  					}  				}    				loadedGCodeFile.GCodeCommandQueue.Add(machineInstructionForLine);    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / crCount / 2);  						maxProgressReport.Restart();  					}  				}    				lineIndex++;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseFileContents,The following statement contains a magic number: foreach (string outputString in CustomSplit(gCodeString' '\n'))  			{  				string lineString = outputString.Trim();  				machineInstructionForLine = new PrinterMachineInstruction(lineString' machineInstructionForLine' false);    				if (lineString.Length > 0)  				{  					switch (lineString[0])  					{  						case 'G':  							loadedGCodeFile.ParseGLine(lineString' machineInstructionForLine);  							break;    						case 'M':  							loadedGCodeFile.ParseMLine(lineString' machineInstructionForLine);  							break;    						case 'T':  							double extruderIndex = 0;  							if (GetFirstNumberAfter("T"' lineString' ref extruderIndex))  							{  								machineInstructionForLine.ExtruderIndex = (int)extruderIndex;  							}  							break;    						case ';':  							if (gcodeHasExplicitLayerChangeInfo && IsLayerChange(lineString))  							{  								loadedGCodeFile.IndexOfChangeInZ.Add(loadedGCodeFile.GCodeCommandQueue.Count);  							}  							if (lineString.StartsWith("; layerThickness"))  							{  								loadedGCodeFile.layerThickness = double.Parse(lineString.Split('=')[1]);  							}  							else if (lineString.StartsWith("; firstLayerThickness") && loadedGCodeFile.firstLayerThickness == 0)  							{  								loadedGCodeFile.firstLayerThickness = double.Parse(lineString.Split('=')[1]);  							}  							break;    						case '@':  							break;    						default:  #if DEBUG  							throw new NotImplementedException();  #else                              break;  #endif  					}  				}    				loadedGCodeFile.GCodeCommandQueue.Add(machineInstructionForLine);    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / crCount / 2);  						maxProgressReport.Restart();  					}  				}    				lineIndex++;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,ParseFileContents,The following statement contains a magic number: foreach (string outputString in CustomSplit(gCodeString' '\n'))  			{  				string lineString = outputString.Trim();  				machineInstructionForLine = new PrinterMachineInstruction(lineString' machineInstructionForLine' false);    				if (lineString.Length > 0)  				{  					switch (lineString[0])  					{  						case 'G':  							loadedGCodeFile.ParseGLine(lineString' machineInstructionForLine);  							break;    						case 'M':  							loadedGCodeFile.ParseMLine(lineString' machineInstructionForLine);  							break;    						case 'T':  							double extruderIndex = 0;  							if (GetFirstNumberAfter("T"' lineString' ref extruderIndex))  							{  								machineInstructionForLine.ExtruderIndex = (int)extruderIndex;  							}  							break;    						case ';':  							if (gcodeHasExplicitLayerChangeInfo && IsLayerChange(lineString))  							{  								loadedGCodeFile.IndexOfChangeInZ.Add(loadedGCodeFile.GCodeCommandQueue.Count);  							}  							if (lineString.StartsWith("; layerThickness"))  							{  								loadedGCodeFile.layerThickness = double.Parse(lineString.Split('=')[1]);  							}  							else if (lineString.StartsWith("; firstLayerThickness") && loadedGCodeFile.firstLayerThickness == 0)  							{  								loadedGCodeFile.firstLayerThickness = double.Parse(lineString.Split('=')[1]);  							}  							break;    						case '@':  							break;    						default:  #if DEBUG  							throw new NotImplementedException();  #else                              break;  #endif  					}  				}    				loadedGCodeFile.GCodeCommandQueue.Add(machineInstructionForLine);    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / crCount / 2);  						maxProgressReport.Restart();  					}  				}    				lineIndex++;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,AnalyzeGCodeLines,The following statement contains a magic number: for (int lineIndex = 0; lineIndex < GCodeCommandQueue.Count; lineIndex++)  			{  				PrinterMachineInstruction instruction = GCodeCommandQueue[lineIndex];  				string line = instruction.Line;  				Vector3 deltaPositionThisLine = new Vector3();  				double deltaEPositionThisLine = 0;  				string lineToParse = line.ToUpper().Trim();  				if (lineToParse.StartsWith("G0") || lineToParse.StartsWith("G1"))  				{  					double newFeedRateMmPerMin = 0;  					if (GetFirstNumberAfter("F"' lineToParse' ref newFeedRateMmPerMin))  					{  						feedRateMmPerMin = newFeedRateMmPerMin;  					}    					Vector3 attemptedDestination = lastPrinterPosition;  					GetFirstNumberAfter("X"' lineToParse' ref attemptedDestination.x);  					GetFirstNumberAfter("Y"' lineToParse' ref attemptedDestination.y);  					GetFirstNumberAfter("Z"' lineToParse' ref attemptedDestination.z);    					double ePosition = lastEPosition;  					GetFirstNumberAfter("E"' lineToParse' ref ePosition);    					deltaPositionThisLine = attemptedDestination - lastPrinterPosition;  					deltaEPositionThisLine = Math.Abs(ePosition - lastEPosition);    					lastPrinterPosition = attemptedDestination;  					lastEPosition = ePosition;  				}  				else if (lineToParse.StartsWith("G92"))  				{  					double ePosition = 0;  					if (GetFirstNumberAfter("E"' lineToParse' ref ePosition))  					{  						lastEPosition = ePosition;  					}  				}    				if (feedRateMmPerMin > 0)   				{  					instruction.secondsThisLine = (float)GetSecondsThisLine(deltaPositionThisLine' deltaEPositionThisLine' feedRateMmPerMin);  				}    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / GCodeCommandQueue.Count / 2 + 50);  						maxProgressReport.Restart();  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,AnalyzeGCodeLines,The following statement contains a magic number: for (int lineIndex = 0; lineIndex < GCodeCommandQueue.Count; lineIndex++)  			{  				PrinterMachineInstruction instruction = GCodeCommandQueue[lineIndex];  				string line = instruction.Line;  				Vector3 deltaPositionThisLine = new Vector3();  				double deltaEPositionThisLine = 0;  				string lineToParse = line.ToUpper().Trim();  				if (lineToParse.StartsWith("G0") || lineToParse.StartsWith("G1"))  				{  					double newFeedRateMmPerMin = 0;  					if (GetFirstNumberAfter("F"' lineToParse' ref newFeedRateMmPerMin))  					{  						feedRateMmPerMin = newFeedRateMmPerMin;  					}    					Vector3 attemptedDestination = lastPrinterPosition;  					GetFirstNumberAfter("X"' lineToParse' ref attemptedDestination.x);  					GetFirstNumberAfter("Y"' lineToParse' ref attemptedDestination.y);  					GetFirstNumberAfter("Z"' lineToParse' ref attemptedDestination.z);    					double ePosition = lastEPosition;  					GetFirstNumberAfter("E"' lineToParse' ref ePosition);    					deltaPositionThisLine = attemptedDestination - lastPrinterPosition;  					deltaEPositionThisLine = Math.Abs(ePosition - lastEPosition);    					lastPrinterPosition = attemptedDestination;  					lastEPosition = ePosition;  				}  				else if (lineToParse.StartsWith("G92"))  				{  					double ePosition = 0;  					if (GetFirstNumberAfter("E"' lineToParse' ref ePosition))  					{  						lastEPosition = ePosition;  					}  				}    				if (feedRateMmPerMin > 0)   				{  					instruction.secondsThisLine = (float)GetSecondsThisLine(deltaPositionThisLine' deltaEPositionThisLine' feedRateMmPerMin);  				}    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / GCodeCommandQueue.Count / 2 + 50);  						maxProgressReport.Restart();  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,AnalyzeGCodeLines,The following statement contains a magic number: for (int lineIndex = 0; lineIndex < GCodeCommandQueue.Count; lineIndex++)  			{  				PrinterMachineInstruction instruction = GCodeCommandQueue[lineIndex];  				string line = instruction.Line;  				Vector3 deltaPositionThisLine = new Vector3();  				double deltaEPositionThisLine = 0;  				string lineToParse = line.ToUpper().Trim();  				if (lineToParse.StartsWith("G0") || lineToParse.StartsWith("G1"))  				{  					double newFeedRateMmPerMin = 0;  					if (GetFirstNumberAfter("F"' lineToParse' ref newFeedRateMmPerMin))  					{  						feedRateMmPerMin = newFeedRateMmPerMin;  					}    					Vector3 attemptedDestination = lastPrinterPosition;  					GetFirstNumberAfter("X"' lineToParse' ref attemptedDestination.x);  					GetFirstNumberAfter("Y"' lineToParse' ref attemptedDestination.y);  					GetFirstNumberAfter("Z"' lineToParse' ref attemptedDestination.z);    					double ePosition = lastEPosition;  					GetFirstNumberAfter("E"' lineToParse' ref ePosition);    					deltaPositionThisLine = attemptedDestination - lastPrinterPosition;  					deltaEPositionThisLine = Math.Abs(ePosition - lastEPosition);    					lastPrinterPosition = attemptedDestination;  					lastEPosition = ePosition;  				}  				else if (lineToParse.StartsWith("G92"))  				{  					double ePosition = 0;  					if (GetFirstNumberAfter("E"' lineToParse' ref ePosition))  					{  						lastEPosition = ePosition;  					}  				}    				if (feedRateMmPerMin > 0)   				{  					instruction.secondsThisLine = (float)GetSecondsThisLine(deltaPositionThisLine' deltaEPositionThisLine' feedRateMmPerMin);  				}    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / GCodeCommandQueue.Count / 2 + 50);  						maxProgressReport.Restart();  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,AnalyzeGCodeLines,The following statement contains a magic number: for (int lineIndex = 0; lineIndex < GCodeCommandQueue.Count; lineIndex++)  			{  				PrinterMachineInstruction instruction = GCodeCommandQueue[lineIndex];  				string line = instruction.Line;  				Vector3 deltaPositionThisLine = new Vector3();  				double deltaEPositionThisLine = 0;  				string lineToParse = line.ToUpper().Trim();  				if (lineToParse.StartsWith("G0") || lineToParse.StartsWith("G1"))  				{  					double newFeedRateMmPerMin = 0;  					if (GetFirstNumberAfter("F"' lineToParse' ref newFeedRateMmPerMin))  					{  						feedRateMmPerMin = newFeedRateMmPerMin;  					}    					Vector3 attemptedDestination = lastPrinterPosition;  					GetFirstNumberAfter("X"' lineToParse' ref attemptedDestination.x);  					GetFirstNumberAfter("Y"' lineToParse' ref attemptedDestination.y);  					GetFirstNumberAfter("Z"' lineToParse' ref attemptedDestination.z);    					double ePosition = lastEPosition;  					GetFirstNumberAfter("E"' lineToParse' ref ePosition);    					deltaPositionThisLine = attemptedDestination - lastPrinterPosition;  					deltaEPositionThisLine = Math.Abs(ePosition - lastEPosition);    					lastPrinterPosition = attemptedDestination;  					lastEPosition = ePosition;  				}  				else if (lineToParse.StartsWith("G92"))  				{  					double ePosition = 0;  					if (GetFirstNumberAfter("E"' lineToParse' ref ePosition))  					{  						lastEPosition = ePosition;  					}  				}    				if (feedRateMmPerMin > 0)   				{  					instruction.secondsThisLine = (float)GetSecondsThisLine(deltaPositionThisLine' deltaEPositionThisLine' feedRateMmPerMin);  				}    				if (backgroundWorker != null)  				{  					if (backgroundWorker.CancellationPending)  					{  						return;  					}    					if (backgroundWorker.WorkerReportsProgress && maxProgressReport.ElapsedMilliseconds > 200)  					{  						backgroundWorker.ReportProgress(lineIndex * 100 / GCodeCommandQueue.Count / 2 + 50);  						maxProgressReport.Restart();  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,PercentComplete,The following statement contains a magic number: if (GCodeCommandQueue.Count > 0)  			{  				return Math.Min(99.9' (double)instructionIndex / (double)GCodeCommandQueue.Count * 100);  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,PercentComplete,The following statement contains a magic number: if (GCodeCommandQueue.Count > 0)  			{  				return Math.Min(99.9' (double)instructionIndex / (double)GCodeCommandQueue.Count * 100);  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,PercentComplete,The following statement contains a magic number: return 100;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFilamentCubicMm,The following statement contains a magic number: double fillamentRadius = filamentDiameterMm / 2;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFilamentWeightGrams,The following statement contains a magic number: double cubicMmPerCubicCm = 1000;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFilamentDiameter,The following statement contains a magic number: if (filamentDiameterCache == 0)  			{  				for (int i = 0; i < Math.Min(20' GCodeCommandQueue.Count); i++)  				{  					if (GetFirstNumberAfter("filamentDiameter ="' GCodeCommandQueue[i].Line' ref filamentDiameterCache))  					{  						break;  					}  				}    				if (filamentDiameterCache == 0)  				{  					// didn't find it' so look at the end of the file for filament_diameter =  					string lookFor = "; filament_diameter =";// 2.85  					for (int i = GCodeCommandQueue.Count - 1; i > Math.Max(0' GCodeCommandQueue.Count - 100); i--)  					{  						if (GetFirstNumberAfter(lookFor' GCodeCommandQueue[i].Line' ref filamentDiameterCache))  						{  						}  					}  				}    				if(filamentDiameterCache == 0)  				{  					// it is still 0 so set it to something so we render  					filamentDiameterCache = 1.75;  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFilamentDiameter,The following statement contains a magic number: if (filamentDiameterCache == 0)  			{  				for (int i = 0; i < Math.Min(20' GCodeCommandQueue.Count); i++)  				{  					if (GetFirstNumberAfter("filamentDiameter ="' GCodeCommandQueue[i].Line' ref filamentDiameterCache))  					{  						break;  					}  				}    				if (filamentDiameterCache == 0)  				{  					// didn't find it' so look at the end of the file for filament_diameter =  					string lookFor = "; filament_diameter =";// 2.85  					for (int i = GCodeCommandQueue.Count - 1; i > Math.Max(0' GCodeCommandQueue.Count - 100); i--)  					{  						if (GetFirstNumberAfter(lookFor' GCodeCommandQueue[i].Line' ref filamentDiameterCache))  						{  						}  					}  				}    				if(filamentDiameterCache == 0)  				{  					// it is still 0 so set it to something so we render  					filamentDiameterCache = 1.75;  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFilamentDiameter,The following statement contains a magic number: if (filamentDiameterCache == 0)  			{  				for (int i = 0; i < Math.Min(20' GCodeCommandQueue.Count); i++)  				{  					if (GetFirstNumberAfter("filamentDiameter ="' GCodeCommandQueue[i].Line' ref filamentDiameterCache))  					{  						break;  					}  				}    				if (filamentDiameterCache == 0)  				{  					// didn't find it' so look at the end of the file for filament_diameter =  					string lookFor = "; filament_diameter =";// 2.85  					for (int i = GCodeCommandQueue.Count - 1; i > Math.Max(0' GCodeCommandQueue.Count - 100); i--)  					{  						if (GetFirstNumberAfter(lookFor' GCodeCommandQueue[i].Line' ref filamentDiameterCache))  						{  						}  					}  				}    				if(filamentDiameterCache == 0)  				{  					// it is still 0 so set it to something so we render  					filamentDiameterCache = 1.75;  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetLayerHeight,The following statement contains a magic number: if (indexOfChangeInZ.Count > 2)  			{  				return GCodeCommandQueue[IndexOfChangeInZ[2]].Z - GCodeCommandQueue[IndexOfChangeInZ[1]].Z;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetLayerHeight,The following statement contains a magic number: if (indexOfChangeInZ.Count > 2)  			{  				return GCodeCommandQueue[IndexOfChangeInZ[2]].Z - GCodeCommandQueue[IndexOfChangeInZ[1]].Z;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetLayerHeight,The following statement contains a magic number: return .5;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFileLoaded,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFileLoaded.cs,GetFirstLayerHeight,The following statement contains a magic number: return .5;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The following statement contains a magic number: double maxVelocityMmPerS = Math.Min(feedRateMmPerMin / 60' MaxVelocityMmPerS.x);
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The following statement contains a magic number: if (distanceToMaxVelocity <= lengthOfThisMoveMm / 2)  			{  				// we will reach max velocity then run at it and then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' distanceToMaxVelocity' acceleration) * 2;  				double runningTime = (lengthOfThisMoveMm - (distanceToMaxVelocity * 2)) / maxVelocityMmPerS;  				return accelerationTime + runningTime;  			}  			else  			{  				// we will accelerate to the center then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' lengthOfThisMoveMm / 2' acceleration) * 2;  				return accelerationTime;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The following statement contains a magic number: if (distanceToMaxVelocity <= lengthOfThisMoveMm / 2)  			{  				// we will reach max velocity then run at it and then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' distanceToMaxVelocity' acceleration) * 2;  				double runningTime = (lengthOfThisMoveMm - (distanceToMaxVelocity * 2)) / maxVelocityMmPerS;  				return accelerationTime + runningTime;  			}  			else  			{  				// we will accelerate to the center then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' lengthOfThisMoveMm / 2' acceleration) * 2;  				return accelerationTime;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The following statement contains a magic number: if (distanceToMaxVelocity <= lengthOfThisMoveMm / 2)  			{  				// we will reach max velocity then run at it and then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' distanceToMaxVelocity' acceleration) * 2;  				double runningTime = (lengthOfThisMoveMm - (distanceToMaxVelocity * 2)) / maxVelocityMmPerS;  				return accelerationTime + runningTime;  			}  			else  			{  				// we will accelerate to the center then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' lengthOfThisMoveMm / 2' acceleration) * 2;  				return accelerationTime;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The following statement contains a magic number: if (distanceToMaxVelocity <= lengthOfThisMoveMm / 2)  			{  				// we will reach max velocity then run at it and then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' distanceToMaxVelocity' acceleration) * 2;  				double runningTime = (lengthOfThisMoveMm - (distanceToMaxVelocity * 2)) / maxVelocityMmPerS;  				return accelerationTime + runningTime;  			}  			else  			{  				// we will accelerate to the center then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' lengthOfThisMoveMm / 2' acceleration) * 2;  				return accelerationTime;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetSecondsThisLine,The following statement contains a magic number: if (distanceToMaxVelocity <= lengthOfThisMoveMm / 2)  			{  				// we will reach max velocity then run at it and then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' distanceToMaxVelocity' acceleration) * 2;  				double runningTime = (lengthOfThisMoveMm - (distanceToMaxVelocity * 2)) / maxVelocityMmPerS;  				return accelerationTime + runningTime;  			}  			else  			{  				// we will accelerate to the center then decelerate  				double accelerationTime = GetTimeToAccelerateDistance(startingVelocityMmPerS' lengthOfThisMoveMm / 2' acceleration) * 2;  				return accelerationTime;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetDistanceToReachEndingVelocity,The following statement contains a magic number: return (endingVelocityMmPerS2 - startingVelocityMmPerS2) / (2.0 * accelerationMmPerS2);
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,GetTimeToAccelerateDistance,The following statement contains a magic number: double distanceAcceleration2 = 2 * accelerationMmPerS2 * distanceMm;
Magic Number,MatterHackers.GCodeVisualizer,GCodeFile,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeFile.cs,RunningIn32Bit,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  return true;              }
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,ExtrusionColors,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\ExtrusionColors.cs,GetColorForSpeed,The following statement contains a magic number: if (speed > 0)  			{  				lock(speedColorLookup)  				{  					double startColor = 223.0 / 360.0;  					double endColor = 5.0 / 360.0;  					double delta = startColor - endColor;    					if (!speedColorLookup.ContainsKey(speed))  					{  						RGBA_Bytes color = RGBA_Floats.FromHSL(startColor' .99' .49).GetAsRGBA_Bytes();  						speedColorLookup.Add(speed' color);    						if (speedColorLookup.Count > 1)  						{  							double step = delta / (speedColorLookup.Count - 1);  							for (int index = 0; index < speedColorLookup.Count; index++)  							{  								double offset = step * index;  								double fixedColor = startColor - offset;  								KeyValuePair<float' RGBA_Bytes> keyValue = speedColorLookup.ElementAt(index);  								speedColorLookup[keyValue.Key] = RGBA_Floats.FromHSL(fixedColor' .99' .49).GetAsRGBA_Bytes();  							}  						}  					}    					return speedColorLookup[speed];  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render,The following statement contains a magic number: if (renderFeatures.Count > 0)  			{  				CreateFeaturesForLayerIfRequired(renderInfo.EndLayerIndex);    				int featuresOnLayer = renderFeatures[renderInfo.EndLayerIndex].Count;  				int endFeature = (int)(featuresOnLayer * renderInfo.FeatureToEndOnRatio0To1 + .5);  				endFeature = Math.Max(0' Math.Min(endFeature' featuresOnLayer));    				int startFeature = (int)(featuresOnLayer * renderInfo.FeatureToStartOnRatio0To1 + .5);  				startFeature = Math.Max(0' Math.Min(startFeature' featuresOnLayer));    				// try to make sure we always draw at least one feature  				if (endFeature <= startFeature)  				{  					endFeature = Math.Min(startFeature + 1' featuresOnLayer);  				}  				if (startFeature >= endFeature)  				{  					// This can only happen if the start and end are set to the last feature  					// Try to set the start feature to one from the end  					startFeature = Math.Max(endFeature - 1' 0);  				}    				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					graphics2DGl.PreRender();  					GL.Begin(BeginMode.Triangles);  					for (int i = startFeature; i < endFeature; i++)  					{  						RenderFeatureBase feature = renderFeatures[renderInfo.EndLayerIndex][i];  						if (feature != null)  						{  							feature.Render(graphics2DGl' renderInfo);  						}  					}  					GL.End();  					graphics2DGl.PopOrthoProjection();  				}  				else  				{  					for (int i = startFeature; i < endFeature; i++)  					{  						RenderFeatureBase feature = renderFeatures[renderInfo.EndLayerIndex][i];  						if (feature != null)  						{  							feature.Render(graphics2D' renderInfo);  						}  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render,The following statement contains a magic number: if (renderFeatures.Count > 0)  			{  				CreateFeaturesForLayerIfRequired(renderInfo.EndLayerIndex);    				int featuresOnLayer = renderFeatures[renderInfo.EndLayerIndex].Count;  				int endFeature = (int)(featuresOnLayer * renderInfo.FeatureToEndOnRatio0To1 + .5);  				endFeature = Math.Max(0' Math.Min(endFeature' featuresOnLayer));    				int startFeature = (int)(featuresOnLayer * renderInfo.FeatureToStartOnRatio0To1 + .5);  				startFeature = Math.Max(0' Math.Min(startFeature' featuresOnLayer));    				// try to make sure we always draw at least one feature  				if (endFeature <= startFeature)  				{  					endFeature = Math.Min(startFeature + 1' featuresOnLayer);  				}  				if (startFeature >= endFeature)  				{  					// This can only happen if the start and end are set to the last feature  					// Try to set the start feature to one from the end  					startFeature = Math.Max(endFeature - 1' 0);  				}    				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					graphics2DGl.PreRender();  					GL.Begin(BeginMode.Triangles);  					for (int i = startFeature; i < endFeature; i++)  					{  						RenderFeatureBase feature = renderFeatures[renderInfo.EndLayerIndex][i];  						if (feature != null)  						{  							feature.Render(graphics2DGl' renderInfo);  						}  					}  					GL.End();  					graphics2DGl.PopOrthoProjection();  				}  				else  				{  					for (int i = startFeature; i < endFeature; i++)  					{  						RenderFeatureBase feature = renderFeatures[renderInfo.EndLayerIndex][i];  						if (feature != null)  						{  							feature.Render(graphics2D' renderInfo);  						}  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Is32Bit,The following statement contains a magic number: if (IntPtr.Size == 4)  			{  				return true;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render3D,The following statement contains a magic number: if (renderFeatures.Count > 0)  			{  				if (Is32Bit() && !GL.GlHasBufferObjects)  				{  					int maxFeaturesForThisSystem = 125000;  					int totalFeaturesToRunder = 0;  					bool cleanUnusedLayers = false;  					// if on 32 bit system make sure we don't run out of memory rendering too many features  					for (int i = renderInfo.EndLayerIndex - 1; i >= renderInfo.StartLayerIndex; i--)  					{  						if (totalFeaturesToRunder + renderFeatures[i].Count < maxFeaturesForThisSystem)  						{  							totalFeaturesToRunder += renderFeatures[i].Count;  						}  						else // don't render any of the layers below this and in fact remove them from memory if possible  						{  							renderInfo.startLayerIndex = i + 1;  							cleanUnusedLayers = true;   							break;  						}  					}    					if (cleanUnusedLayers)  					{  						// no remove any layers that are set that we are not going to render  						for (int removeIndex = 0; removeIndex < layerVertexBuffer.Count; removeIndex++)  						{  							if (removeIndex < renderInfo.StartLayerIndex || removeIndex >= renderInfo.EndLayerIndex)  							{  								if (layerVertexBuffer[removeIndex] != null)  								{  									layerVertexBuffer[removeIndex].Dispose();  									layerVertexBuffer[removeIndex] = null;  								}  							}  						}  					}  				}    				for (int i = renderInfo.EndLayerIndex - 1; i >= renderInfo.StartLayerIndex; i--)  				{  					// If its the first render or we change what we are trying to render then create vertex data.  					if (layerVertexBuffer[i] == null)  					{  						VectorPOD<ColorVertexData> colorVertexData = new VectorPOD<ColorVertexData>();  						VectorPOD<int> vertexIndexArray = new VectorPOD<int>();    						Create3DDataForLayer(i' colorVertexData' vertexIndexArray' renderInfo);    						layerVertexBuffer[i] = new GCodeVertexBuffer();  						layerVertexBuffer[i].SetVertexData(colorVertexData.Array);  						layerVertexBuffer[i].SetIndexData(vertexIndexArray.Array);  					}  				}    				GL.Disable(EnableCap.Texture2D);  				GL.PushAttrib(AttribMask.EnableBit);  				GL.DisableClientState(ArrayCap.TextureCoordArray);  				GL.Enable(EnableCap.PolygonSmooth);    				if (renderInfo.EndLayerIndex - 1 > renderInfo.StartLayerIndex)  				{  					for (int i = renderInfo.StartLayerIndex; i < renderInfo.EndLayerIndex - 1; i++)  					{  						int featuresOnLayer = renderFeatures[i].Count;  						if (featuresOnLayer > 1)  						{  							layerVertexBuffer[i].renderRange(0' featureEndIndex[i][featuresOnLayer - 1]);  						}  					}  				}    				// draw the partial layer of end-1 from startRatio to endRatio  				{  					int layerIndex = renderInfo.EndLayerIndex - 1;  					int featuresOnLayer = renderFeatures[layerIndex].Count;  					int startFeature = (int)(featuresOnLayer * renderInfo.FeatureToStartOnRatio0To1 + .5);  					startFeature = Math.Max(0' Math.Min(startFeature' featuresOnLayer));    					int endFeature = (int)(featuresOnLayer * renderInfo.FeatureToEndOnRatio0To1 + .5);  					endFeature = Math.Max(0' Math.Min(endFeature' featuresOnLayer));    					// try to make sure we always draw at least one feature  					if (endFeature <= startFeature)  					{  						endFeature = Math.Min(startFeature + 1' featuresOnLayer);  					}  					if (startFeature >= endFeature)  					{  						// This can only happen if the start and end are set to the last feature  						// Try to set the start feature to one from the end  						startFeature = Math.Max(endFeature - 1' 0);  					}    					if (endFeature > startFeature)  					{  						int ellementCount = featureEndIndex[layerIndex][endFeature - 1] - featureStartIndex[layerIndex][startFeature];    						layerVertexBuffer[layerIndex].renderRange(featureStartIndex[layerIndex][startFeature]' ellementCount);  					}  				}  				GL.PopAttrib();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render3D,The following statement contains a magic number: if (renderFeatures.Count > 0)  			{  				if (Is32Bit() && !GL.GlHasBufferObjects)  				{  					int maxFeaturesForThisSystem = 125000;  					int totalFeaturesToRunder = 0;  					bool cleanUnusedLayers = false;  					// if on 32 bit system make sure we don't run out of memory rendering too many features  					for (int i = renderInfo.EndLayerIndex - 1; i >= renderInfo.StartLayerIndex; i--)  					{  						if (totalFeaturesToRunder + renderFeatures[i].Count < maxFeaturesForThisSystem)  						{  							totalFeaturesToRunder += renderFeatures[i].Count;  						}  						else // don't render any of the layers below this and in fact remove them from memory if possible  						{  							renderInfo.startLayerIndex = i + 1;  							cleanUnusedLayers = true;   							break;  						}  					}    					if (cleanUnusedLayers)  					{  						// no remove any layers that are set that we are not going to render  						for (int removeIndex = 0; removeIndex < layerVertexBuffer.Count; removeIndex++)  						{  							if (removeIndex < renderInfo.StartLayerIndex || removeIndex >= renderInfo.EndLayerIndex)  							{  								if (layerVertexBuffer[removeIndex] != null)  								{  									layerVertexBuffer[removeIndex].Dispose();  									layerVertexBuffer[removeIndex] = null;  								}  							}  						}  					}  				}    				for (int i = renderInfo.EndLayerIndex - 1; i >= renderInfo.StartLayerIndex; i--)  				{  					// If its the first render or we change what we are trying to render then create vertex data.  					if (layerVertexBuffer[i] == null)  					{  						VectorPOD<ColorVertexData> colorVertexData = new VectorPOD<ColorVertexData>();  						VectorPOD<int> vertexIndexArray = new VectorPOD<int>();    						Create3DDataForLayer(i' colorVertexData' vertexIndexArray' renderInfo);    						layerVertexBuffer[i] = new GCodeVertexBuffer();  						layerVertexBuffer[i].SetVertexData(colorVertexData.Array);  						layerVertexBuffer[i].SetIndexData(vertexIndexArray.Array);  					}  				}    				GL.Disable(EnableCap.Texture2D);  				GL.PushAttrib(AttribMask.EnableBit);  				GL.DisableClientState(ArrayCap.TextureCoordArray);  				GL.Enable(EnableCap.PolygonSmooth);    				if (renderInfo.EndLayerIndex - 1 > renderInfo.StartLayerIndex)  				{  					for (int i = renderInfo.StartLayerIndex; i < renderInfo.EndLayerIndex - 1; i++)  					{  						int featuresOnLayer = renderFeatures[i].Count;  						if (featuresOnLayer > 1)  						{  							layerVertexBuffer[i].renderRange(0' featureEndIndex[i][featuresOnLayer - 1]);  						}  					}  				}    				// draw the partial layer of end-1 from startRatio to endRatio  				{  					int layerIndex = renderInfo.EndLayerIndex - 1;  					int featuresOnLayer = renderFeatures[layerIndex].Count;  					int startFeature = (int)(featuresOnLayer * renderInfo.FeatureToStartOnRatio0To1 + .5);  					startFeature = Math.Max(0' Math.Min(startFeature' featuresOnLayer));    					int endFeature = (int)(featuresOnLayer * renderInfo.FeatureToEndOnRatio0To1 + .5);  					endFeature = Math.Max(0' Math.Min(endFeature' featuresOnLayer));    					// try to make sure we always draw at least one feature  					if (endFeature <= startFeature)  					{  						endFeature = Math.Min(startFeature + 1' featuresOnLayer);  					}  					if (startFeature >= endFeature)  					{  						// This can only happen if the start and end are set to the last feature  						// Try to set the start feature to one from the end  						startFeature = Math.Max(endFeature - 1' 0);  					}    					if (endFeature > startFeature)  					{  						int ellementCount = featureEndIndex[layerIndex][endFeature - 1] - featureStartIndex[layerIndex][startFeature];    						layerVertexBuffer[layerIndex].renderRange(featureStartIndex[layerIndex][startFeature]' ellementCount);  					}  				}  				GL.PopAttrib();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeRenderer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeRenderer.cs,Render3D,The following statement contains a magic number: if (renderFeatures.Count > 0)  			{  				if (Is32Bit() && !GL.GlHasBufferObjects)  				{  					int maxFeaturesForThisSystem = 125000;  					int totalFeaturesToRunder = 0;  					bool cleanUnusedLayers = false;  					// if on 32 bit system make sure we don't run out of memory rendering too many features  					for (int i = renderInfo.EndLayerIndex - 1; i >= renderInfo.StartLayerIndex; i--)  					{  						if (totalFeaturesToRunder + renderFeatures[i].Count < maxFeaturesForThisSystem)  						{  							totalFeaturesToRunder += renderFeatures[i].Count;  						}  						else // don't render any of the layers below this and in fact remove them from memory if possible  						{  							renderInfo.startLayerIndex = i + 1;  							cleanUnusedLayers = true;   							break;  						}  					}    					if (cleanUnusedLayers)  					{  						// no remove any layers that are set that we are not going to render  						for (int removeIndex = 0; removeIndex < layerVertexBuffer.Count; removeIndex++)  						{  							if (removeIndex < renderInfo.StartLayerIndex || removeIndex >= renderInfo.EndLayerIndex)  							{  								if (layerVertexBuffer[removeIndex] != null)  								{  									layerVertexBuffer[removeIndex].Dispose();  									layerVertexBuffer[removeIndex] = null;  								}  							}  						}  					}  				}    				for (int i = renderInfo.EndLayerIndex - 1; i >= renderInfo.StartLayerIndex; i--)  				{  					// If its the first render or we change what we are trying to render then create vertex data.  					if (layerVertexBuffer[i] == null)  					{  						VectorPOD<ColorVertexData> colorVertexData = new VectorPOD<ColorVertexData>();  						VectorPOD<int> vertexIndexArray = new VectorPOD<int>();    						Create3DDataForLayer(i' colorVertexData' vertexIndexArray' renderInfo);    						layerVertexBuffer[i] = new GCodeVertexBuffer();  						layerVertexBuffer[i].SetVertexData(colorVertexData.Array);  						layerVertexBuffer[i].SetIndexData(vertexIndexArray.Array);  					}  				}    				GL.Disable(EnableCap.Texture2D);  				GL.PushAttrib(AttribMask.EnableBit);  				GL.DisableClientState(ArrayCap.TextureCoordArray);  				GL.Enable(EnableCap.PolygonSmooth);    				if (renderInfo.EndLayerIndex - 1 > renderInfo.StartLayerIndex)  				{  					for (int i = renderInfo.StartLayerIndex; i < renderInfo.EndLayerIndex - 1; i++)  					{  						int featuresOnLayer = renderFeatures[i].Count;  						if (featuresOnLayer > 1)  						{  							layerVertexBuffer[i].renderRange(0' featureEndIndex[i][featuresOnLayer - 1]);  						}  					}  				}    				// draw the partial layer of end-1 from startRatio to endRatio  				{  					int layerIndex = renderInfo.EndLayerIndex - 1;  					int featuresOnLayer = renderFeatures[layerIndex].Count;  					int startFeature = (int)(featuresOnLayer * renderInfo.FeatureToStartOnRatio0To1 + .5);  					startFeature = Math.Max(0' Math.Min(startFeature' featuresOnLayer));    					int endFeature = (int)(featuresOnLayer * renderInfo.FeatureToEndOnRatio0To1 + .5);  					endFeature = Math.Max(0' Math.Min(endFeature' featuresOnLayer));    					// try to make sure we always draw at least one feature  					if (endFeature <= startFeature)  					{  						endFeature = Math.Min(startFeature + 1' featuresOnLayer);  					}  					if (startFeature >= endFeature)  					{  						// This can only happen if the start and end are set to the last feature  						// Try to set the start feature to one from the end  						startFeature = Math.Max(endFeature - 1' 0);  					}    					if (endFeature > startFeature)  					{  						int ellementCount = featureEndIndex[layerIndex][endFeature - 1] - featureStartIndex[layerIndex][startFeature];    						layerVertexBuffer[layerIndex].renderRange(featureStartIndex[layerIndex][startFeature]' ellementCount);  					}  				}  				GL.PopAttrib();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,GCodeViewWidget,The following statement contains a magic number: LocalBounds = new RectangleDouble(0' 0' 100' 100);
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,GCodeViewWidget,The following statement contains a magic number: LocalBounds = new RectangleDouble(0' 0' 100' 100);
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,OnDraw,The following statement contains a magic number: if (loadedGCode != null)  			{  				Affine transform = TotalTransform;    				CreateGrid(transform);    				double gridLineWidths = 0.2 * layerScale;  				Stroke stroke = new Stroke(grid' gridLineWidths);    				if (RenderGrid)  				{  					graphics2D.Render(stroke' RGBA_Bytes.DarkGray);  				}    				RenderType renderType = RenderType.Extrusions;  				if (RenderMoves)  				{  					renderType |= RenderType.Moves;  				}  				if (RenderRetractions)  				{  					renderType |= RenderType.Retractions;  				}    				GCodeRenderInfo renderInfo = new GCodeRenderInfo(activeLayerIndex' activeLayerIndex' transform' layerScale' renderType'  					FeatureToStartOnRatio0To1' FeatureToEndOnRatio0To1' null);  				gCodeRenderer.Render(graphics2D' renderInfo);  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: Vector2 gridOffset = gridCenterMm - gridSizeMm / 2;
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,CreateGrid,The following statement contains a magic number: if (gridSizeMm.x > 0 && gridSizeMm.y > 0)  			{  				grid.remove_all();  				for (int y = 0; y <= gridSizeMm.y; y += 10)  				{  					Vector2 start = new Vector2(0' y) + gridOffset;  					Vector2 end = new Vector2(gridSizeMm.x' y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5)' (int)(start.y + .5) + .5);  					grid.LineTo((int)(int)(end.x + .5)' (int)(end.y + .5) + .5);  				}    				for (int x = 0; x <= gridSizeMm.x; x += 10)  				{  					Vector2 start = new Vector2(x' 0) + gridOffset;  					Vector2 end = new Vector2(x' gridSizeMm.y) + gridOffset;  					transform.transform(ref start);  					transform.transform(ref end);  					grid.MoveTo((int)(start.x + .5) + .5' (int)(start.y + .5));  					grid.LineTo((int)(end.x + .5) + .5' (int)(end.y + .5));  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,OnMouseWheel,The following statement contains a magic number: if (FirstWidgetUnderMouse) // TODO: find a good way to decide if you are what the wheel is trying to do  			{  				Vector2 mousePreScale = new Vector2(mouseEvent.X' mouseEvent.Y);  				TotalTransform.inverse_transform(ref mousePreScale);    				const double deltaFor1Click = 120;  				layerScale = layerScale + layerScale * (mouseEvent.WheelDelta / deltaFor1Click) * .1;    				Vector2 mousePostScale = new Vector2(mouseEvent.X' mouseEvent.Y);  				TotalTransform.inverse_transform(ref mousePostScale);    				unscaledRenderOffset += (mousePostScale - mousePreScale);    				Invalidate();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,OnMouseWheel,The following statement contains a magic number: if (FirstWidgetUnderMouse) // TODO: find a good way to decide if you are what the wheel is trying to do  			{  				Vector2 mousePreScale = new Vector2(mouseEvent.X' mouseEvent.Y);  				TotalTransform.inverse_transform(ref mousePreScale);    				const double deltaFor1Click = 120;  				layerScale = layerScale + layerScale * (mouseEvent.WheelDelta / deltaFor1Click) * .1;    				Vector2 mousePostScale = new Vector2(mouseEvent.X' mouseEvent.Y);  				TotalTransform.inverse_transform(ref mousePostScale);    				unscaledRenderOffset += (mousePostScale - mousePreScale);    				Invalidate();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,OnMouseMove,The following statement contains a magic number: if (MouseCaptured)  			{  				Vector2 mouseDelta = mousePos - lastMousePosition;  				switch (TransformState)  				{  					case ETransformState.Move:  						ScalingTransform.inverse_transform(ref mouseDelta);    						unscaledRenderOffset += mouseDelta;  						break;    					case ETransformState.Scale:  						double zoomDelta = 1;  						if (mouseDelta.y < 0)  						{  							zoomDelta = 1 - (-1 * mouseDelta.y / 100);  						}  						else if (mouseDelta.y > 0)  						{  							zoomDelta = 1 + (1 * mouseDelta.y / 100);  						}    						Vector2 mousePreScale = mouseDownPosition;  						TotalTransform.inverse_transform(ref mousePreScale);    						layerScale *= zoomDelta;    						Vector2 mousePostScale = mouseDownPosition;  						TotalTransform.inverse_transform(ref mousePostScale);    						unscaledRenderOffset += (mousePostScale - mousePreScale);  						break;    					default:  						throw new NotImplementedException();  				}    				Invalidate();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewWidget,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewWidget.cs,OnMouseMove,The following statement contains a magic number: if (MouseCaptured)  			{  				Vector2 mouseDelta = mousePos - lastMousePosition;  				switch (TransformState)  				{  					case ETransformState.Move:  						ScalingTransform.inverse_transform(ref mouseDelta);    						unscaledRenderOffset += mouseDelta;  						break;    					case ETransformState.Scale:  						double zoomDelta = 1;  						if (mouseDelta.y < 0)  						{  							zoomDelta = 1 - (-1 * mouseDelta.y / 100);  						}  						else if (mouseDelta.y > 0)  						{  							zoomDelta = 1 + (1 * mouseDelta.y / 100);  						}    						Vector2 mousePreScale = mouseDownPosition;  						TotalTransform.inverse_transform(ref mousePreScale);    						layerScale *= zoomDelta;    						Vector2 mousePostScale = mouseDownPosition;  						TotalTransform.inverse_transform(ref mousePostScale);    						unscaledRenderOffset += (mousePostScale - mousePreScale);  						break;    					default:  						throw new NotImplementedException();  				}    				Invalidate();  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The following statement contains a magic number: MinimumSize = new VectorMath.Vector2(200' 200);
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The following statement contains a magic number: MinimumSize = new VectorMath.Vector2(200' 200);
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The following statement contains a magic number: gCodeViewWidget = new GCodeViewWidget(new Vector2()' new Vector2(100' 100));
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The following statement contains a magic number: gCodeViewWidget = new GCodeViewWidget(new Vector2()' new Vector2(100' 100));
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The following statement contains a magic number: currentLayerIndex = new NumberEdit(1' pixelWidth: 40);
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GCodeViewerApplication,The following statement contains a magic number: layerCountTextWidget = new TextWidget("/1____"' 12);
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,OnDraw,The following statement contains a magic number: this.NewGraphics2D().Clear(new RGBA_Bytes(255' 255' 255));
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,OnDraw,The following statement contains a magic number: this.NewGraphics2D().Clear(new RGBA_Bytes(255' 255' 255));
Magic Number,MatterHackers.GCodeVisualizer,GCodeViewerApplication,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,OnDraw,The following statement contains a magic number: this.NewGraphics2D().Clear(new RGBA_Bytes(255' 255' 255));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVisualizerFactory,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  			"Other"'  			"G Code Visualizer"'  			"A sample application to visualize the g-code created for a rep-rap type FDM machine."'  			600'  			400);
Magic Number,MatterHackers.GCodeVisualizer,GCodeVisualizerFactory,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\GCodeViewerApplication.cs,GetAppParameters,The following statement contains a magic number: AppWidgetInfo appWidgetInfo = new AppWidgetInfo(  			"Other"'  			"G Code Visualizer"'  			"A sample application to visualize the g-code created for a rep-rap type FDM machine."'  			600'  			400);
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,RenderFeatureExtrusion,The following statement contains a magic number: double fillamentRadius = filamentDiameterMm / 2;
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,GetRadius,The following statement contains a magic number: return GetExtrusionWidth(renderType) / 2;
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,GetExtrusionWidth,The following statement contains a magic number: if ((renderType & RenderType.SimulateExtrusion) == RenderType.SimulateExtrusion)              {  				double moveLength = (end - start).Length;    				if (moveLength > .1) // we get truncation errors from the slice engine when the length is very small' so don't do them  				{  					double area = extrusionVolumeMm3 / moveLength;  					width = area / layerHeight;  				}              }
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Extrusions) == RenderType.Extrusions)  			{  				Vector3Float start = this.GetStart(renderInfo);  				Vector3Float end = this.GetEnd(renderInfo);  				double radius = GetRadius(renderInfo.CurrentRenderType);  				if ((renderInfo.CurrentRenderType & RenderType.SpeedColors) == RenderType.SpeedColors)  				{  					CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' color' layerHeight);  				}  				else  				{  					if (extruderIndex == 0)  					{  						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' GCodeRenderer.ExtrusionColor' layerHeight);  					}  					else  					{  						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' MeshViewerWidget.GetMaterialColor(extruderIndex + 1)' layerHeight);  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Extrusions) == RenderType.Extrusions)  			{  				Vector3Float start = this.GetStart(renderInfo);  				Vector3Float end = this.GetEnd(renderInfo);  				double radius = GetRadius(renderInfo.CurrentRenderType);  				if ((renderInfo.CurrentRenderType & RenderType.SpeedColors) == RenderType.SpeedColors)  				{  					CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' color' layerHeight);  				}  				else  				{  					if (extruderIndex == 0)  					{  						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' GCodeRenderer.ExtrusionColor' layerHeight);  					}  					else  					{  						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' MeshViewerWidget.GetMaterialColor(extruderIndex + 1)' layerHeight);  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Extrusions) == RenderType.Extrusions)  			{  				Vector3Float start = this.GetStart(renderInfo);  				Vector3Float end = this.GetEnd(renderInfo);  				double radius = GetRadius(renderInfo.CurrentRenderType);  				if ((renderInfo.CurrentRenderType & RenderType.SpeedColors) == RenderType.SpeedColors)  				{  					CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' color' layerHeight);  				}  				else  				{  					if (extruderIndex == 0)  					{  						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' GCodeRenderer.ExtrusionColor' layerHeight);  					}  					else  					{  						CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' radius' 6' MeshViewerWidget.GetMaterialColor(extruderIndex + 1)' layerHeight);  					}  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,Render,The following statement contains a magic number: if (renderInfo.CurrentRenderType.HasFlag(RenderType.Extrusions))  			{  				double extrusionLineWidths = GetExtrusionWidth(renderInfo.CurrentRenderType) * 2 * renderInfo.LayerScale;    				RGBA_Bytes extrusionColor = RGBA_Bytes.Black;  				if (extruderIndex > 0)  				{  					extrusionColor = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				}  				if (renderInfo.CurrentRenderType.HasFlag(RenderType.SpeedColors))  				{  					extrusionColor = color;  				}                    if (renderInfo.CurrentRenderType.HasFlag(RenderType.TransparentExtrusion))                  {                      extrusionColor = new RGBA_Bytes(extrusionColor' 200);                  }                    // render the part using opengl                  Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' extrusionLineWidths/2' extrusionColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' extrusionLineWidths/2);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);    					graphics2D.Render(stroke' 0' extrusionColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,Render,The following statement contains a magic number: if (renderInfo.CurrentRenderType.HasFlag(RenderType.Extrusions))  			{  				double extrusionLineWidths = GetExtrusionWidth(renderInfo.CurrentRenderType) * 2 * renderInfo.LayerScale;    				RGBA_Bytes extrusionColor = RGBA_Bytes.Black;  				if (extruderIndex > 0)  				{  					extrusionColor = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				}  				if (renderInfo.CurrentRenderType.HasFlag(RenderType.SpeedColors))  				{  					extrusionColor = color;  				}                    if (renderInfo.CurrentRenderType.HasFlag(RenderType.TransparentExtrusion))                  {                      extrusionColor = new RGBA_Bytes(extrusionColor' 200);                  }                    // render the part using opengl                  Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' extrusionLineWidths/2' extrusionColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' extrusionLineWidths/2);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);    					graphics2D.Render(stroke' 0' extrusionColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,Render,The following statement contains a magic number: if (renderInfo.CurrentRenderType.HasFlag(RenderType.Extrusions))  			{  				double extrusionLineWidths = GetExtrusionWidth(renderInfo.CurrentRenderType) * 2 * renderInfo.LayerScale;    				RGBA_Bytes extrusionColor = RGBA_Bytes.Black;  				if (extruderIndex > 0)  				{  					extrusionColor = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				}  				if (renderInfo.CurrentRenderType.HasFlag(RenderType.SpeedColors))  				{  					extrusionColor = color;  				}                    if (renderInfo.CurrentRenderType.HasFlag(RenderType.TransparentExtrusion))                  {                      extrusionColor = new RGBA_Bytes(extrusionColor' 200);                  }                    // render the part using opengl                  Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' extrusionLineWidths/2' extrusionColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' extrusionLineWidths/2);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);    					graphics2D.Render(stroke' 0' extrusionColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureExtrusion,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureExtrusion.cs,Render,The following statement contains a magic number: if (renderInfo.CurrentRenderType.HasFlag(RenderType.Extrusions))  			{  				double extrusionLineWidths = GetExtrusionWidth(renderInfo.CurrentRenderType) * 2 * renderInfo.LayerScale;    				RGBA_Bytes extrusionColor = RGBA_Bytes.Black;  				if (extruderIndex > 0)  				{  					extrusionColor = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				}  				if (renderInfo.CurrentRenderType.HasFlag(RenderType.SpeedColors))  				{  					extrusionColor = color;  				}                    if (renderInfo.CurrentRenderType.HasFlag(RenderType.TransparentExtrusion))                  {                      extrusionColor = new RGBA_Bytes(extrusionColor' 200);                  }                    // render the part using opengl                  Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' extrusionLineWidths/2' extrusionColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' extrusionLineWidths/2);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);    					graphics2D.Render(stroke' 0' extrusionColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				Vector3Float start = this.GetStart(renderInfo);  				Vector3Float end = this.GetEnd(renderInfo);  				CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' .1' 6' GCodeRenderer.TravelColor' .2);  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				Vector3Float start = this.GetStart(renderInfo);  				Vector3Float end = this.GetEnd(renderInfo);  				CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' .1' 6' GCodeRenderer.TravelColor' .2);  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				Vector3Float start = this.GetStart(renderInfo);  				Vector3Float end = this.GetEnd(renderInfo);  				CreateCylinder(colorVertexData' indexData' new Vector3(start)' new Vector3(end)' .1' 6' GCodeRenderer.TravelColor' .2);  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				double movementLineWidth = 0.35 * renderInfo.LayerScale;  				RGBA_Bytes movementColor = new RGBA_Bytes(10' 190' 15);    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' movementLineWidth' movementColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' movementLineWidth);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					if (end.x != start.x || end.y != start.y)  					{  						pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}  					else  					{  						pathStorage.Add(end.x + .01' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}    					graphics2D.Render(stroke' 0' movementColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				double movementLineWidth = 0.35 * renderInfo.LayerScale;  				RGBA_Bytes movementColor = new RGBA_Bytes(10' 190' 15);    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' movementLineWidth' movementColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' movementLineWidth);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					if (end.x != start.x || end.y != start.y)  					{  						pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}  					else  					{  						pathStorage.Add(end.x + .01' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}    					graphics2D.Render(stroke' 0' movementColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				double movementLineWidth = 0.35 * renderInfo.LayerScale;  				RGBA_Bytes movementColor = new RGBA_Bytes(10' 190' 15);    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' movementLineWidth' movementColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' movementLineWidth);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					if (end.x != start.x || end.y != start.y)  					{  						pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}  					else  					{  						pathStorage.Add(end.x + .01' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}    					graphics2D.Render(stroke' 0' movementColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				double movementLineWidth = 0.35 * renderInfo.LayerScale;  				RGBA_Bytes movementColor = new RGBA_Bytes(10' 190' 15);    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' movementLineWidth' movementColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' movementLineWidth);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					if (end.x != start.x || end.y != start.y)  					{  						pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}  					else  					{  						pathStorage.Add(end.x + .01' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}    					graphics2D.Render(stroke' 0' movementColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureTravel,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureTravel.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Moves) == RenderType.Moves)  			{  				double movementLineWidth = 0.35 * renderInfo.LayerScale;  				RGBA_Bytes movementColor = new RGBA_Bytes(10' 190' 15);    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					Vector3Float startF = this.GetStart(renderInfo);  					Vector3Float endF = this.GetEnd(renderInfo);  					Vector2 start = new Vector2(startF.x' startF.y);  					renderInfo.Transform.transform(ref start);    					Vector2 end = new Vector2(endF.x' endF.y);  					renderInfo.Transform.transform(ref end);    					graphics2DGl.DrawAALineRounded(start' end' movementLineWidth' movementColor);  				}  				else  				{  					PathStorage pathStorage = new PathStorage();  					VertexSourceApplyTransform transformedPathStorage = new VertexSourceApplyTransform(pathStorage' renderInfo.Transform);  					Stroke stroke = new Stroke(transformedPathStorage' movementLineWidth);    					stroke.line_cap(LineCap.Round);  					stroke.line_join(LineJoin.Round);    					Vector3Float start = this.GetStart(renderInfo);  					Vector3Float end = this.GetEnd(renderInfo);    					pathStorage.Add(start.x' start.y' ShapePath.FlagsAndCommand.CommandMoveTo);  					if (end.x != start.x || end.y != start.y)  					{  						pathStorage.Add(end.x' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}  					else  					{  						pathStorage.Add(end.x + .01' end.y' ShapePath.FlagsAndCommand.CommandLineTo);  					}    					graphics2D.Render(stroke' 0' movementColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				Vector3 position = new Vector3(this.position);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + new Vector3(offset);  				}    				RGBA_Bytes color = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				if (extruderIndex == 0)  				{  					if (extrusionAmount > 0)  					{  						color = RGBA_Bytes.Blue;  					}  					else  					{  						color = RGBA_Bytes.Red;  					}  				}  				if (extrusionAmount > 0)  				{  					// unretraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color);  				}  				else  				{  					// retraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				Vector3 position = new Vector3(this.position);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + new Vector3(offset);  				}    				RGBA_Bytes color = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				if (extruderIndex == 0)  				{  					if (extrusionAmount > 0)  					{  						color = RGBA_Bytes.Blue;  					}  					else  					{  						color = RGBA_Bytes.Red;  					}  				}  				if (extrusionAmount > 0)  				{  					// unretraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color);  				}  				else  				{  					// retraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				Vector3 position = new Vector3(this.position);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + new Vector3(offset);  				}    				RGBA_Bytes color = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				if (extruderIndex == 0)  				{  					if (extrusionAmount > 0)  					{  						color = RGBA_Bytes.Blue;  					}  					else  					{  						color = RGBA_Bytes.Red;  					}  				}  				if (extrusionAmount > 0)  				{  					// unretraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color);  				}  				else  				{  					// retraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				Vector3 position = new Vector3(this.position);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + new Vector3(offset);  				}    				RGBA_Bytes color = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				if (extruderIndex == 0)  				{  					if (extrusionAmount > 0)  					{  						color = RGBA_Bytes.Blue;  					}  					else  					{  						color = RGBA_Bytes.Red;  					}  				}  				if (extrusionAmount > 0)  				{  					// unretraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color);  				}  				else  				{  					// retraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				Vector3 position = new Vector3(this.position);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + new Vector3(offset);  				}    				RGBA_Bytes color = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				if (extruderIndex == 0)  				{  					if (extrusionAmount > 0)  					{  						color = RGBA_Bytes.Blue;  					}  					else  					{  						color = RGBA_Bytes.Red;  					}  				}  				if (extrusionAmount > 0)  				{  					// unretraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color);  				}  				else  				{  					// retraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,CreateRender3DData,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				Vector3 position = new Vector3(this.position);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + new Vector3(offset);  				}    				RGBA_Bytes color = MeshViewerWidget.GetMaterialColor(extruderIndex + 1);  				if (extruderIndex == 0)  				{  					if (extrusionAmount > 0)  					{  						color = RGBA_Bytes.Blue;  					}  					else  					{  						color = RGBA_Bytes.Red;  					}  				}  				if (extrusionAmount > 0)  				{  					// unretraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' 1.3)' position + new Vector3(0' 0' .3)' Radius(1)' 5' color);  				}  				else  				{  					// retraction  					CreatePointer(colorVertexData' indexData' position + new Vector3(0' 0' .3)' position + new Vector3(0' 0' 1.3)' Radius(1)' 5' color);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				double radius = Radius(renderInfo.LayerScale);  				Vector2 position = new Vector2(this.position.x' this.position.y);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + offset;  				}    				renderInfo.Transform.transform(ref position);    				RGBA_Bytes retractionColor = new RGBA_Bytes(RGBA_Bytes.Red' 200);  				if (extrusionAmount > 0)  				{  					// unretraction  					retractionColor = new RGBA_Bytes(RGBA_Bytes.Blue' 200);  				}    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					graphics2DGl.DrawAACircle(position' radius' retractionColor);  				}  				else  				{  					Ellipse extrusion = new Ellipse(position' radius);  					graphics2D.Render(extrusion' retractionColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureRetract,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureRetract.cs,Render,The following statement contains a magic number: if ((renderInfo.CurrentRenderType & RenderType.Retractions) == RenderType.Retractions)  			{  				double radius = Radius(renderInfo.LayerScale);  				Vector2 position = new Vector2(this.position.x' this.position.y);    				if (renderInfo.CurrentRenderType.HasFlag(RenderType.HideExtruderOffsets))  				{  					Vector2 offset = renderInfo.GetExtruderOffset(extruderIndex);  					position = position + offset;  				}    				renderInfo.Transform.transform(ref position);    				RGBA_Bytes retractionColor = new RGBA_Bytes(RGBA_Bytes.Red' 200);  				if (extrusionAmount > 0)  				{  					// unretraction  					retractionColor = new RGBA_Bytes(RGBA_Bytes.Blue' 200);  				}    				// render the part using opengl  				Graphics2DOpenGL graphics2DGl = graphics2D as Graphics2DOpenGL;  				if (graphics2DGl != null)  				{  					graphics2DGl.DrawAACircle(position' radius' retractionColor);  				}  				else  				{  					Ellipse extrusion = new Ellipse(position' radius);  					graphics2D.Render(extrusion' retractionColor);  				}  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: double halfHeight = layerHeight / 2 + (layerHeight * .1);
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: double halfHeight = layerHeight / 2 + (layerHeight * .1);
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				offset *= scale;    				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));    				Vector3 tubeEnd = endPos + offset;  				tubeEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeEnd' tubeNormal' color));    				// create cap verts  				Vector3 rotateAngle = Vector3.Cross(direction' startSweepDirection);  				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8));  				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capStartNormal = (capStartNormal * scale).GetNormal();  				Vector3 capStartOffset = capStartNormal * radius;  				capStartOffset *= scale;  				Vector3 capStart = startPos + capStartOffset;  				capStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capStart' capStartNormal' color));    				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8));  				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capEndNormal = (capEndNormal * scale).GetNormal();  				Vector3 capEndOffset = capEndNormal * radius;  				capEndOffset *= scale;  				Vector3 capEnd = endPos + capEndOffset;  				capEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capEnd' capEndNormal' color));  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				offset *= scale;    				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));    				Vector3 tubeEnd = endPos + offset;  				tubeEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeEnd' tubeNormal' color));    				// create cap verts  				Vector3 rotateAngle = Vector3.Cross(direction' startSweepDirection);  				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8));  				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capStartNormal = (capStartNormal * scale).GetNormal();  				Vector3 capStartOffset = capStartNormal * radius;  				capStartOffset *= scale;  				Vector3 capStart = startPos + capStartOffset;  				capStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capStart' capStartNormal' color));    				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8));  				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capEndNormal = (capEndNormal * scale).GetNormal();  				Vector3 capEndOffset = capEndNormal * radius;  				capEndOffset *= scale;  				Vector3 capEnd = endPos + capEndOffset;  				capEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capEnd' capEndNormal' color));  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				offset *= scale;    				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));    				Vector3 tubeEnd = endPos + offset;  				tubeEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeEnd' tubeNormal' color));    				// create cap verts  				Vector3 rotateAngle = Vector3.Cross(direction' startSweepDirection);  				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8));  				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capStartNormal = (capStartNormal * scale).GetNormal();  				Vector3 capStartOffset = capStartNormal * radius;  				capStartOffset *= scale;  				Vector3 capStart = startPos + capStartOffset;  				capStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capStart' capStartNormal' color));    				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8));  				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capEndNormal = (capEndNormal * scale).GetNormal();  				Vector3 capEndOffset = capEndNormal * radius;  				capEndOffset *= scale;  				Vector3 capEnd = endPos + capEndOffset;  				capEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capEnd' capEndNormal' color));  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				offset *= scale;    				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));    				Vector3 tubeEnd = endPos + offset;  				tubeEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeEnd' tubeNormal' color));    				// create cap verts  				Vector3 rotateAngle = Vector3.Cross(direction' startSweepDirection);  				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8));  				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capStartNormal = (capStartNormal * scale).GetNormal();  				Vector3 capStartOffset = capStartNormal * radius;  				capStartOffset *= scale;  				Vector3 capStart = startPos + capStartOffset;  				capStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capStart' capStartNormal' color));    				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8));  				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capEndNormal = (capEndNormal * scale).GetNormal();  				Vector3 capEndOffset = capEndNormal * radius;  				capEndOffset *= scale;  				Vector3 capEnd = endPos + capEndOffset;  				capEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capEnd' capEndNormal' color));  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				offset *= scale;    				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));    				Vector3 tubeEnd = endPos + offset;  				tubeEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeEnd' tubeNormal' color));    				// create cap verts  				Vector3 rotateAngle = Vector3.Cross(direction' startSweepDirection);  				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8));  				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capStartNormal = (capStartNormal * scale).GetNormal();  				Vector3 capStartOffset = capStartNormal * radius;  				capStartOffset *= scale;  				Vector3 capStart = startPos + capStartOffset;  				capStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capStart' capStartNormal' color));    				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8));  				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capEndNormal = (capEndNormal * scale).GetNormal();  				Vector3 capEndOffset = capEndNormal * radius;  				capEndOffset *= scale;  				Vector3 capEnd = endPos + capEndOffset;  				capEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capEnd' capEndNormal' color));  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreateCylinder,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				offset *= scale;    				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));    				Vector3 tubeEnd = endPos + offset;  				tubeEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeEnd' tubeNormal' color));    				// create cap verts  				Vector3 rotateAngle = Vector3.Cross(direction' startSweepDirection);  				Vector3 capStartNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(rotateAngle' MathHelper.Tau / 8));  				capStartNormal = Vector3.Transform(capStartNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capStartNormal = (capStartNormal * scale).GetNormal();  				Vector3 capStartOffset = capStartNormal * radius;  				capStartOffset *= scale;  				Vector3 capStart = startPos + capStartOffset;  				capStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capStart' capStartNormal' color));    				Vector3 capEndNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(-rotateAngle' MathHelper.Tau / 8));  				capEndNormal = Vector3.Transform(capEndNormal' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				capEndNormal = (capEndNormal * scale).GetNormal();  				Vector3 capEndOffset = capEndNormal * radius;  				capEndOffset *= scale;  				Vector3 capEnd = endPos + capEndOffset;  				capEndIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(capEnd' capEndNormal' color));  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreatePointer,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));  				Vector3 tubeEnd = endPos + offset;  			}
Magic Number,MatterHackers.GCodeVisualizer,RenderFeatureBase,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\RenderFeatures\RenderFeatureBase.cs,CreatePointer,The following statement contains a magic number: for (int i = 0; i < steps; i++)  			{  				// create tube ends verts  				Vector3 tubeNormal = Vector3.Transform(startSweepDirection' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 offset = Vector3.Transform(startSweepDirection * radius' Matrix4X4.CreateRotation(direction' MathHelper.Tau / (steps * 2) + MathHelper.Tau / (steps) * i));  				Vector3 tubeStart = startPos + offset;  				tubeStartIndices[i] = colorVertexData.Count;  				colorVertexData.Add(new ColorVertexData(tubeStart' tubeNormal' color));  				Vector3 tubeEnd = endPos + offset;  			}
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' ColorVertexData.Stride' new IntPtr(0));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.NormalPointer(NormalPointerType.Float' ColorVertexData.Stride' new IntPtr(4));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' ColorVertexData.Stride' new IntPtr(4 + 3 * 4));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' ColorVertexData.Stride' new IntPtr(4 + 3 * 4));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' ColorVertexData.Stride' new IntPtr(4 + 3 * 4));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' ColorVertexData.Stride' new IntPtr(4 + 3 * 4));
Magic Number,MatterHackers.GCodeVisualizer,GCodeVertexBuffer,C:\repos\MatterHackers_agg-sharp\examples\GCodeVisualizer\Renderer\GCodeVertexBuffer.cs,renderRange,The following statement contains a magic number: GL.DrawRangeElements(myMode' 0' myIndexLength' count' DrawElementsType.UnsignedInt' new IntPtr(offset * 4));
