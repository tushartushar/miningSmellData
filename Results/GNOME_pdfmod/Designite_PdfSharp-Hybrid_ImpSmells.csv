Implementation smell,Namespace,Class,File,Method,Description
Long Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The method has 111 lines of code.
Long Method,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,The method has 116 lines of code.
Long Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,XGraphics,The method has 104 lines of code.
Long Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 126 lines of code.
Long Method,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 150 lines of code.
Long Method,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,Initialize,The method has 100 lines of code.
Long Method,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The method has 288 lines of code.
Long Method,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,RenderPage,The method has 199 lines of code.
Long Method,PdfSharp.Pdf.Advanced,PdfFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFontTable.cs,GetFont,The method has 100 lines of code.
Long Method,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,The method has 151 lines of code.
Long Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The method has 133 lines of code.
Long Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The method has 310 lines of code.
Long Method,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The method has 167 lines of code.
Long Method,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The method has 107 lines of code.
Long Method,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The method has 103 lines of code.
Long Method,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The method has 308 lines of code.
Long Method,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadObject,The method has 152 lines of code.
Long Method,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,Open,The method has 131 lines of code.
Long Method,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 110 lines of code.
Long Method,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The method has 108 lines of code.
Complex Method,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,Cyclomatic complexity of the method is 17
Complex Method,PdfSharp.Internal,TokenizerHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\TokenizerHelper.cs,NextToken,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Internal,TokenizerHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\TokenizerHelper.cs,ScanToNextToken,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,CreateEncoding,Cyclomatic complexity of the method is 18
Complex Method,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,DataMatrix,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,DrawString,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,CreateBlocks,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,AlignLine,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,Cyclomatic complexity of the method is 34
Complex Method,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeBrush,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,Cyclomatic complexity of the method is 36
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,SetClip,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,Cyclomatic complexity of the method is 25
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,Cyclomatic complexity of the method is 15
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,Cyclomatic complexity of the method is 23
Complex Method,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,Cyclomatic complexity of the method is 13
Complex Method,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,Cyclomatic complexity of the method is 21
Complex Method,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Drawing,ImageHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\ImageHelper.cs,CreateBitmapSource,Cyclomatic complexity of the method is 45
Complex Method,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetHue,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightStringToKnownWeight,Cyclomatic complexity of the method is 33
Complex Method,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,Cyclomatic complexity of the method is 20
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,XGraphics,Cyclomatic complexity of the method is 18
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,XGraphics,Cyclomatic complexity of the method is 18
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,XGraphics,Cyclomatic complexity of the method is 29
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,Initialize,Cyclomatic complexity of the method is 32
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangles,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPath,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,Cyclomatic complexity of the method is 40
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,Initialize,Cyclomatic complexity of the method is 42
Complex Method,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,Invert,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,MultiplyPoint,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.Drawing,XPdfForm,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPdfForm.cs,ExtractPageNumber,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,Cyclomatic complexity of the method is 17
Complex Method,PdfSharp.Drawing,XPrivateFontCollection,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPrivateFontCollection.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Drawing,XUnit,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XUnit.cs,ConvertType,Cyclomatic complexity of the method is 22
Complex Method,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,AddTable,Cyclomatic complexity of the method is 45
Complex Method,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Read,Cyclomatic complexity of the method is 20
Complex Method,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,CreateFontSubSet,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.Fonts.OpenType,HorizontalMetricsTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Fonts.OpenType,VerticalMetricsTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,OnPaintBackground,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,LayoutChildren,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,Cyclomatic complexity of the method is 20
Complex Method,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,PdfImage,Cyclomatic complexity of the method is 15
Complex Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeJpeg,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,Cyclomatic complexity of the method is 29
Complex Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,Cyclomatic complexity of the method is 17
Complex Method,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,Cyclomatic complexity of the method is 44
Complex Method,PdfSharp.Pdf.Advanced,PdfResources,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfResources.cs,ExistsResourceNames,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf.Advanced,PdfShading,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfShading.cs,SetupFromBrush,Cyclomatic complexity of the method is 27
Complex Method,PdfSharp.Pdf.Advanced,PdfTrueTypeFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrueTypeFont.cs,PdfTrueTypeFont,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Pdf.Advanced,PdfType0Font,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfType0Font.cs,PdfType0Font,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Pdf.Annotations,PdfLinkAnnotation,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Annotations\PdfLinkAnnotation.cs,WriteObject,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.Pdf.Content.Objects,CString,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content.Objects\CObjects.cs,ToString,Cyclomatic complexity of the method is 28
Complex Method,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNextToken,Cyclomatic complexity of the method is 15
Complex Method,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,Cyclomatic complexity of the method is 92
Complex Method,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,MoveToNonWhiteSpace,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,IsDelimiter,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Pdf.Content,CParser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CParser.cs,ParseObject,Cyclomatic complexity of the method is 41
Complex Method,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,Cyclomatic complexity of the method is 20
Complex Method,PdfSharp.Pdf.Filters,Filter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\Filter.cs,RemoveWhiteSpace,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.Pdf.Filters,Filtering,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\Filtering.cs,GetFilter,Cyclomatic complexity of the method is 24
Complex Method,PdfSharp.Pdf.Internal,AnsiEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\AnsiEncoding.cs,IsAnsi1252Char,Cyclomatic complexity of the method is 32
Complex Method,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToStringLiteral,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToHexStringLiteral,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,Cyclomatic complexity of the method is 39
Complex Method,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanNextToken,Cyclomatic complexity of the method is 20
Complex Method,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanKeyword,Cyclomatic complexity of the method is 13
Complex Method,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,Cyclomatic complexity of the method is 89
Complex Method,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,MoveToNonWhiteSpace,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,IsDelimiter,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadObject,Cyclomatic complexity of the method is 50
Complex Method,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,Cyclomatic complexity of the method is 53
Complex Method,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadXRefTableAndTrailer,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,Open,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteBeginObject,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEndObject,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteSeparator,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.Pdf.Printing,PdfFilePrinter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Printing\PdfFilePrinter.cs,Print,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Pdf,KeyDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\KeysMeta.cs,GetValueType,Cyclomatic complexity of the method is 44
Complex Method,PdfSharp.Pdf,PdfObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfObject.cs,FixUpObject,Cyclomatic complexity of the method is 13
Complex Method,PdfSharp.Pdf,PdfOutline,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfOutline.cs,PrepareForSave,Cyclomatic complexity of the method is 13
Complex Method,PdfSharp.Pdf,PdfPage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPage.cs,InheritValues,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Pdf,PdfPages,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPages.cs,CloneElement,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,Cyclomatic complexity of the method is 15
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 15
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,Cyclomatic complexity of the method is 18
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,Deflate,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 40
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Complex Method,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,Cyclomatic complexity of the method is 39
Complex Method,PdfSharp,PSSR,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PSSR.cs,InappropriateColorSpace,Cyclomatic complexity of the method is 20
Long Parameter List,PdfSharp.Internal,NativeMethods,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\NativeMethods.cs,GetFontData,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,CodeDataMatrix,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,CodeDataMatrix,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,Iec16022Ecc200,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing.BarCodes,Ecc200Block,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,Ecc200Block,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing.BarCodes,MatrixCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\MatrixCode.cs,MatrixCode,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawLine,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBezier,The method has 9 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawArc,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawRectangle,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawRoundedRectangle,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawEllipse,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawPie,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawImage,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendCurveSegment,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateCurveSegment,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The method has 9 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,The method has 10 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawLine,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawBezier,The method has 9 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawArc,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawRectangle,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawRoundedRectangle,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawEllipse,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawPie,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawClosedCurve,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,IXGraphicsRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\IXGraphicsRenderer.cs,DrawImage,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,XColor,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromCmyk,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XFontMetrics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontMetrics.cs,XFontMetrics,The method has 11 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLine,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLine,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The method has 9 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawArc,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawArc,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangle,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangle,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangle,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangle,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangle,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangle,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 7 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,The method has 5 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBezier,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBezier,The method has 8 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddArc,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddArc,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddArc,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddPie,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddPie,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,XMatrix,The method has 6 parameters.
Long Parameter List,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SetMatrix,The method has 7 parameters.
Long Parameter List,PdfSharp.Pdf.Content.Objects,OpCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content.Objects\Operators.cs,OpCode,The method has 6 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,AnsiEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\AnsiEncoding.cs,GetBytes,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,AnsiEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\AnsiEncoding.cs,GetChars,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,DocEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\DocEncoding.cs,GetBytes,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,DocEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\DocEncoding.cs,GetChars,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,RawEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawEncoding.cs,GetBytes,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,RawEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawEncoding.cs,GetChars,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetBytes,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetChars,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitWidhUserPassword,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitWidhOwnerPassword,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The method has 5 parameters.
Long Parameter List,PdfSharp.Pdf,PdfOutline,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfOutline.cs,PdfOutline,The method has 5 parameters.
Long Parameter List,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters.
Long Statement,PdfSharp.Internal,DoubleUtil,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\DoubleUtil.cs,AreClose,The length of the statement  "	return !rect2.IsEmpty && AreClose (rect1.X' rect2.X) && AreClose (rect1.Y' rect2.Y) && AreClose (rect1.Height' rect2.Height) && AreClose (rect1.Width' rect2.Width); " is 164.
Long Statement,PdfSharp.Drawing.BarCodes,BcgSR,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\BcgSR.cs,Invalid2Of5Code,The length of the statement  "	return String.Format ("'{0}' is not a valid code for an interleave 2 of 5 bar code. It can only represent an even number of digits."' code); " is 140.
Long Statement,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The length of the statement  "		this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]); " is 186.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The length of the statement  "		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y); " is 199.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawEllipse,The length of the statement  "	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' x0 + δx' y0 + fy' x0 + fx' y0 + δy' x0' y0 + δy); " is 136.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawEllipse,The length of the statement  "	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' x0 - fx' y0 + δy' x0 - δx' y0 + fy' x0 - δx' y0); " is 136.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawEllipse,The length of the statement  "	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' x0 - δx' y0 - fy' x0 - fx' y0 - δy' x0' y0 - δy); " is 136.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawEllipse,The length of the statement  "	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' x0 + fx' y0 - δy' x0 + δx' y0 - fy' x0 + δx' y0); " is 136.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawImage,The length of the statement  "			AppendFormat ("q {2:0.####} 0 0 -{3:0.####} {0:0.####} {4:0.####} cm {5} Do Q\n"' x' y' width' height' y + height' name); " is 121.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawImage,The length of the statement  "				AppendFormat ("q {2:0.####} 0 0 -{3:0.####} {0:0.####} {4:0.####} cm 100 Tz {5} Do Q\n"' x' y' cx' cy' y + height' name); " is 121.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawImage,The length of the statement  "			AppendFormat ("q {2:0.####} 0 0 -{3:0.####} {0:0.####} {4:0.####} cm {5} Do\nQ\n"' x' y' width' height' y + height' name); " is 122.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawImage,The length of the statement  "				AppendFormat ("q {2:0.####} 0 0 -{3:0.####} {0:0.####} {4:0.####} cm 100 Tz {5} Do Q\n"' x' y' cx' cy' y + height' name); " is 121.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The length of the statement  "		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} c\n"' pt1.x' pt1.y' pt2.x' pt2.y' pt3.x' pt3.y); " is 123.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The length of the statement  "		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} c\n"' pt1.x' pt1.y' pt2.x' pt2.y' pt3.x' pt3.y); " is 123.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The length of the statement  "	//AppendPartialArc(currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st); " is 130.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The length of the statement  "	PointCollection points = GeometryHelper.ArcToBezier (point1.X' point1.Y' size.Width' size.Height' rotationAngle' isLargeArc' sweepDirection == SweepDirection.Clockwise' point2.X' point2.Y' out pieces); " is 201.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The length of the statement  "		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y); " is 199.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendCurveSegment,The length of the statement  "	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' pt1.X + tension3 * (pt2.X - pt0.X)' pt1.Y + tension3 * (pt2.Y - pt0.Y)' pt2.X - tension3 * (pt3.X - pt1.X)' pt2.Y - tension3 * (pt3.Y - pt1.Y)' pt2.X' pt2.Y); " is 245.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The length of the statement  "			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [++idx].X' points [idx].Y' points [++idx].X' points [idx].Y); " is 187.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The length of the statement  "				AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y); " is 147.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The length of the statement  "						AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y); " is 147.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The length of the statement  "				AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st); " is 129.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The length of the statement  "		// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had) " is 128.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The length of the statement  "					Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi."); " is 127.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The length of the statement  "				AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]); " is 129.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The length of the statement  "			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]); " is 129.
Long Statement,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DumpPathData,The length of the statement  "		string info = PdfEncoders.Format ("{0:X}   {1:####0.000} {2:####0.000}"' pathData.Types [idx]' pathData.Points [idx].X' pathData.Points [idx].Y); " is 145.
Long Statement,PdfSharp.Drawing,FontHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\FontHelper.cs,CreateFormattedText,The length of the statement  "	FormattedText formattedText = new FormattedText (text' new CultureInfo ("en-us")' FlowDirection.LeftToRight' typeface' emSize' brush); " is 134.
Long Statement,PdfSharp.Drawing,FontHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\FontHelper.cs,GetWpfValue,The length of the statement  "	//  style &= XFontStyle.Regular | XFontStyle.Bold | XFontStyle.Italic | XFontStyle.BoldItalic; // same as XFontStyle.BoldItalic " is 127.
Long Statement,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateCurveSegment,The length of the statement  "	return new BezierSegment (new System.Windows.Point (pt1.X + tension3 * (pt2.X - pt0.X)' pt1.Y + tension3 * (pt2.Y - pt0.Y))' new System.Windows.Point (pt2.X - tension3 * (pt3.X - pt1.X)' pt2.Y - tension3 * (pt3.Y - pt1.Y))' new System.Windows.Point (pt2.X' pt2.Y)' true); " is 271.
Long Statement,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The length of the statement  "	return BezierCurveFromArc (center.X - δx * factor' center.Y - δy' 2 * δx * factor' 2 * δy' α / Calc.Deg2Rad' sweepAngle / Calc.Deg2Rad' pathStart' ref matrix); " is 159.
Long Statement,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,The length of the statement  "	matToEllipse = new XMatrix (cos * xRadius' -sin * xRadius' sin * yRadius' cos * yRadius' (xEnd + xStart) / 2' (yEnd + yStart) / 2); " is 131.
Long Statement,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,The length of the statement  "		XPoint ptPieceEnd = new XPoint (ptStart.X * cosArcAngle - ptStart.Y * sinArcAngle' ptStart.X * sinArcAngle + ptStart.Y * cosArcAngle); " is 134.
Long Statement,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,Equals,The length of the statement  "		if (this.r == color.r && this.g == color.g && this.b == color.b && this.c == color.c && this.m == color.m && this.y == color.y && this.k == color.k && this.gs == color.gs) { " is 173.
Long Statement,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,Initialize,The length of the statement  "			this.font = XPrivateFontCollection.TryFindPrivateFont (this.familyName' this.emSize' (System.Drawing.FontStyle)this.style) ?? new Font (this.familyName' (float)this.emSize' (System.Drawing.FontStyle)this.style' GraphicsUnit.World); " is 231.
Long Statement,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,Initialize,The length of the statement  "	//Debug.Assert(this.cellSpace == fm.Ascent + Math.Abs(fm.Descent) + fm.Leading' "Value differs from information retrieved from font image."); " is 141.
Long Statement,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,Initialize,The length of the statement  "	//!!!delTHHO 14.08.2008 Debug.Assert(this.cellAscent == fm.Ascent' "Value differs from information retrieved from font image."); " is 128.
Long Statement,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,FontStyleFrom,The length of the statement  "	return (font.Bold ? XFontStyle.Bold : 0) | (font.Italic ? XFontStyle.Italic : 0) | (font.Strikeout ? XFontStyle.Strikeout : 0) | (font.Underline ? XFontStyle.Underline : 0); " is 173.
Long Statement,PdfSharp.Drawing,XForm,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XForm.cs,DrawingFinished,The length of the statement  "		throw new InvalidOperationException ("This object is an imported PDF page and you cannot finish drawing on it because you must not draw on it at all."); " is 152.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The length of the statement  "	DrawBezier (pen' (double)pt1.X' (double)pt1.Y' (double)pt2.X' (double)pt2.Y' (double)pt3.X' (double)pt3.Y' (double)pt4.X' (double)pt4.Y); " is 137.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The length of the statement  "	DrawBezier (pen' (double)pt1.X' (double)pt1.Y' (double)pt2.X' (double)pt2.Y' (double)pt3.X' (double)pt3.Y' (double)pt4.X' (double)pt4.Y); " is 137.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The length of the statement  "			this.gfx.DrawBezier (pen.RealizeGdiPen ()' (float)x1' (float)y1' (float)x2' (float)y2' (float)x3' (float)y3' (float)x4' (float)y4); " is 131.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The length of the statement  "			BezierSegment seg = new BezierSegment (new System.Windows.Point (x2' y2)' new System.Windows.Point (x3' y3)' new System.Windows.Point (x4' y4)' true); " is 150.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The length of the statement  "				BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true); " is 238.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The length of the statement  "					figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension)); " is 134.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The length of the statement  "				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension)); " is 146.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawArc,The length of the statement  "				this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle); " is 127.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRectangles,The length of the statement  "				this.dc.DrawRectangle (wpfBrush' wpfPen' new System.Windows.Rect (new System.Windows.Point (rect.x' rect.y)' new System.Windows.Size (rect.width' rect.height))); " is 161.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (pen' (double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 155.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (pen' (double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 155.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (pen' (double)x' (double)y' (double)width' (double)height' (double)ellipseWidth' (double)ellipseHeight); " is 125.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (brush' (double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 157.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (brush' (double)x' (double)y' (double)width' (double)height' (double)ellipseWidth' (double)ellipseHeight); " is 127.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (pen' brush' (double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 162.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "	DrawRoundedRectangle (pen' brush' (double)x' (double)y' (double)width' (double)height' (double)ellipseWidth' (double)ellipseHeight); " is 132.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The length of the statement  "			this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2); " is 191.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The length of the statement  "			this.dc.DrawEllipse (null' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY); " is 120.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The length of the statement  "			this.dc.DrawEllipse (brush.RealizeWpfBrush ()' null' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY); " is 124.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The length of the statement  "			this.dc.DrawEllipse (brush.RealizeWpfBrush ()' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY); " is 140.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The length of the statement  "			this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' GeometryHelper.CreatePolygonGeometry (MakePointArray (points)' XFillMode.Alternate' true)); " is 141.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The length of the statement  "			this.dc.DrawGeometry (brush.RealizeWpfBrush ()' null' GeometryHelper.CreatePolygonGeometry (MakePointArray (points)' fillmode' true)); " is 134.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The length of the statement  "			this.dc.DrawGeometry (wpfBrush' wpfPen' GeometryHelper.CreatePolygonGeometry (MakePointArray (points)' fillmode' true)); " is 120.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The length of the statement  "			this.gfx.DrawPie (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle); " is 127.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The length of the statement  "			this.gfx.FillPie (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle); " is 131.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The length of the statement  "			this.gfx.FillPie (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle); " is 131.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The length of the statement  "			this.gfx.DrawPie (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle); " is 127.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The length of the statement  "	//          this.gfx.FillClosedCurve(brush.RealizeGdiBrush()' MakePointFArray(points)' (FillMode)fillmode' (float)tension); " is 123.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The length of the statement  "				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension)); " is 122.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The length of the statement  "					figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension)); " is 134.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The length of the statement  "				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension)); " is 138.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The length of the statement  "				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension)); " is 130.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The length of the statement  "		throw new InvalidOperationException ("DrawString: With XLineAlignment.BaseLine the height of the layout rectangle must be 0."); " is 127.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The length of the statement  "			this.gfx.DrawString (text' font.RealizeGdiFont ()' brush.RealizeGdiBrush ()' rect' format != null ? format.RealizeGdiStringFormat () : null); " is 141.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The length of the statement  "			FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ()); " is 120.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The length of the statement  "					//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2; " is 121.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,MeasureString,The length of the statement  "	      return XSize.FromSizeF(this.gfx.MeasureString(text' font.RealizeGdiFont()' new PointF(0' 0)' stringFormat.RealizeGdiStringFormat()));" is 133.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,MeasureString,The length of the statement  "      FormattedText formattedText = FontHelper.CreateFormattedText(text' font.typeface' font.Size' System.Windows.Media.Brushes.Black);" is 129.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,MeasureString,The length of the statement  "		XSize gdiSize = XSize.FromSizeF (this.gfx.MeasureString (text' font.RealizeGdiFont ()' new PointF (0' 0)' stringFormat.RealizeGdiStringFormat ())); " is 147.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,MeasureString,The length of the statement  "		FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' System.Windows.Media.Brushes.Black); " is 130.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,The length of the statement  "				RectangleF destRectF = new RectangleF ((float)destRect.X' (float)destRect.Y' (float)destRect.Width' (float)destRect.Height); " is 124.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,The length of the statement  "				//this.gfx.DrawLine(Pens.Red' (float)destRect.X' (float)destRect.Y' (float)(destRect.X + destRect.Width)' (float)(destRect.Y + destRect.Height)); " is 145.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawImage,The length of the statement  "				//this.gfx.DrawLine(Pens.Red' (float)(destRect.X + destRect.Width)' (float)destRect.Y' (float)destRect.X' (float)(destRect.Y + destRect.Height)); " is 145.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,CheckXPdfFormConsistence,The length of the statement  "				throw new InvalidOperationException ("A XPdfForm object is always bound to the document it was created for and cannot be drawn in the context of another document."); " is 165.
Long Statement,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,SetClip,The length of the statement  "	//        throw new ArgumentException("Only XCombineMode.Replace and XCombineMode.Intersect are currently supported by PDFsharp."' "combineMode"); " is 146.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBezier,The length of the statement  "	AddBezier ((double)pt1.X' (double)pt1.Y' (double)pt2.X' (double)pt2.Y' (double)pt3.X' (double)pt3.Y' (double)pt4.X' (double)pt4.Y); " is 131.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBezier,The length of the statement  "	AddBezier ((double)pt1.X' (double)pt1.Y' (double)pt2.X' (double)pt2.Y' (double)pt3.X' (double)pt3.Y' (double)pt4.X' (double)pt4.Y); " is 131.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBezier,The length of the statement  "	BezierSegment bezierSegment = new BezierSegment (new System.Windows.Point (x2' y2)' new System.Windows.Point (x3' y3)' new System.Windows.Point (x4' y4)' true); " is 160.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The length of the statement  "		BezierSegment bezierSegment = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true); " is 248.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The length of the statement  "			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension)); " is 134.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The length of the statement  "		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension)); " is 146.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddArc,The length of the statement  "	// figure.Segments.Add(new ArcSegment(point2.ToPoint()' size.ToSize()' rotationAngle' isLargeArg' sweepDirection' true)); " is 121.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddArc,The length of the statement  "	ArcSegment arcSegment = new ArcSegment (point2.ToPoint ()' size.ToSize ()' rotationAngle' isLargeArg' sweepDirection' true); " is 124.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRectangle,The length of the statement  "	LineSegment lineSegment2 = new LineSegment (new System.Windows.Point (rect.x + rect.width' rect.y + rect.height)' true); " is 120.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRectangles,The length of the statement  "		LineSegment lineSegment2 = new LineSegment (new System.Windows.Point (rect.x + rect.width' rect.y + rect.height)' true); " is 120.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	AddRoundedRectangle ((double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 149.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	AddRoundedRectangle ((double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 149.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	AddRoundedRectangle ((double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 149.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	AddRoundedRectangle ((double)rect.X' (double)rect.Y' (double)rect.Width' (double)rect.Height' (double)ellipseSize.Width' (double)ellipseSize.Height); " is 149.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	this.gdipPath.AddArc ((float)(x + width - ellipseWidth)' (float)(y + height - ellipseHeight)' (float)ellipseWidth' (float)ellipseHeight' 0' 90); " is 144.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	this.gdipPath.AddArc ((float)x' (float)(y + height - ellipseHeight)' (float)ellipseWidth' (float)ellipseHeight' 90' 90); " is 120.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	figure.Segments.Add (new ArcSegment (new System.Windows.Point (x + width' y + ey)' new System.Windows.Size (ex' ey)' 0' false' SweepDirection.Clockwise' true)); " is 160.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	figure.Segments.Add (new ArcSegment (new System.Windows.Point (x + width - ex' y + height)' new System.Windows.Size (ex' ey)' 0' false' SweepDirection.Clockwise' true)); " is 169.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	figure.Segments.Add (new ArcSegment (new System.Windows.Point (x' y + height - ey)' new System.Windows.Size (ex' ey)' 0' false' SweepDirection.Clockwise' true)); " is 161.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The length of the statement  "	figure.Segments.Add (new ArcSegment (new System.Windows.Point (x + ex' y)' new System.Windows.Size (ex' ey)' 0' false' SweepDirection.Clockwise' true)); " is 152.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddPolygon,The length of the statement  "	this.pathGeometry.AddGeometry (GeometryHelper.CreatePolygonGeometry (XGraphics.MakePointArray (points)' XFillMode.Alternate' true)); " is 132.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The length of the statement  "		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension)); " is 122.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The length of the statement  "			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension)); " is 134.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The length of the statement  "		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension)); " is 138.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The length of the statement  "		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension)); " is 130.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The length of the statement  "		this.gdipPath.AddString (s' family.gdiFamily' (int)style' (float)emSize' origin.ToPointF ()' format.RealizeGdiStringFormat ()); " is 127.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The length of the statement  "		//FormattedText ft = new FormattedText(s' CultureInfo.CurrentCulture' FlowDirection.LeftToRight' typeface' emSize' System.Windows.Media.Brushes.Black); " is 151.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The length of the statement  "	//this.gdip Path.AddString(s' family.gdiFamily' (int)style' (float)emSize' layoutRect' format.RealizeGdiStringFormat()); " is 120.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The length of the statement  "		throw new InvalidOperationException ("DrawString: With XLineAlignment.BaseLine the height of the layout rectangle must be 0."); " is 127.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The length of the statement  "      //double cyAscent = family.GetCellAscent(style) * family.GetLineSpacing(style) / family.getl; //fontlineSpace * font.cellAscent / font.cellSpace;" is 145.
Long Statement,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The length of the statement  "      //FormattedText formattedText = new FormattedText(s' CultureInfo.CurrentCulture' FlowDirection.LeftToRight' typeface' emSize' System.Windows.Media.Brushes.Black);" is 162.
Long Statement,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The length of the statement  "		if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) { " is 228.
Long Statement,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,InitializeGdiHelper,The length of the statement  "				isCmyk = (image.Flags & ((int)System.Drawing.Imaging.ImageFlags.ColorSpaceCmyk | (int)System.Drawing.Imaging.ImageFlags.ColorSpaceYcck)) != 0; " is 142.
Long Statement,PdfSharp.Drawing,XLinearGradientBrush,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XLinearGradientBrush.cs,RealizeGdiBrush,The length of the statement  "		brush = new System.Drawing.Drawing2D.LinearGradientBrush (this.rect.ToRectangleF ()' this.color1.ToGdiColor ()' this.color2.ToGdiColor ()' (LinearGradientMode)this.linearGradientMode); " is 184.
Long Statement,PdfSharp.Drawing,XLinearGradientBrush,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XLinearGradientBrush.cs,RealizeGdiBrush,The length of the statement  "		brush = new System.Drawing.Drawing2D.LinearGradientBrush (this.point1.ToPointF ()' this.point2.ToPointF ()' this.color1.ToGdiColor ()' this.color2.ToGdiColor ()); " is 162.
Long Statement,PdfSharp.Drawing,XLinearGradientBrush,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XLinearGradientBrush.cs,RealizeWpfBrush,The length of the statement  "		brush = new System.Windows.Media.LinearGradientBrush (this.color1.ToWpfColor ()' this.color2.ToWpfColor ()' new System.Windows.Point (0' 0)' new System.Windows.Point (1' 1)); " is 174.
Long Statement,PdfSharp.Drawing,XLinearGradientBrush,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XLinearGradientBrush.cs,RealizeWpfBrush,The length of the statement  "		brush = new System.Windows.Media.LinearGradientBrush (this.color1.ToWpfColor ()' this.color2.ToWpfColor ()' this.point1' this.point2); " is 134.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,Invert,The length of the statement  "		SetMatrix (this.m22 * detInvers' -this.m12 * detInvers' -this.m21 * detInvers' this.m11 * detInvers' (this.m21 * this.offsetY - this.offsetX * this.m22) * detInvers' (this.offsetX * this.m12 - this.m11 * this.offsetY) * detInvers' XMatrixTypes.Unknown); " is 253.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,ToGdiMatrix,The length of the statement  "	return new System.Drawing.Drawing2D.Matrix ((float)this.m11' (float)this.m12' (float)this.m21' (float)this.m22' (float)this.offsetX' (float)this.offsetY); " is 154.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,ToGdipMatrix,The length of the statement  "	return new System.Drawing.Drawing2D.Matrix ((float)this.m11' (float)this.m12' (float)this.m21' (float)this.m22' (float)this.offsetX' (float)this.offsetY); " is 154.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,Equals,The length of the statement  "	return matrix1.M11.Equals (matrix2.M11) && matrix1.M12.Equals (matrix2.M12) && matrix1.M21.Equals (matrix2.M21) && matrix1.M22.Equals (matrix2.M22) && matrix1.OffsetX.Equals (matrix2.OffsetX) && matrix1.OffsetY.Equals (matrix2.OffsetY); " is 236.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,GetHashCode,The length of the statement  "	return M11.GetHashCode () ^ M12.GetHashCode () ^ M21.GetHashCode () ^ M22.GetHashCode () ^ OffsetX.GetHashCode () ^ OffsetY.GetHashCode (); " is 139.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,Parse,The length of the statement  "	identity = str == "Identity" ? Identity : new XMatrix (Convert.ToDouble (str' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)); " is 397.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,ConvertToString,The length of the statement  "	return string.Format (provider' "{1:" + format + "}{0}{2:" + format + "}{0}{3:" + format + "}{0}{4:" + format + "}{0}{5:" + format + "}{0}{6:" + format + "}"' new object[] { " is 173.
Long Statement,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,CreateScaling,The length of the statement  "	matrix.SetMatrix (scaleX' 0' 0' scaleY' centerX - scaleX * centerX' centerY - scaleY * centerY' XMatrixTypes.Scaling | XMatrixTypes.Translation); " is 145.
Long Statement,PdfSharp.Drawing,XPdfForm,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPdfForm.cs,Finish,The length of the statement  "	//  this.pdfForm.Stream = new PdfDictionary.PdfStream(PdfEncoders.RawEncoding.GetBytes(this.pdfRenderer.GetContent())' this.pdfForm); " is 133.
Long Statement,PdfSharp.Drawing,XPoint,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPoint.cs,Parse,The length of the statement  "	XPoint point = new XPoint (Convert.ToDouble (str' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)); " is 125.
Long Statement,PdfSharp.Drawing,XPrivateFontCollection,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPrivateFontCollection.cs,Add,The length of the statement  "		//Debug.WriteLine(String.Format("{0}' {1}' {2}' {3}"' typeFace.FaceNames.Values.First()' typeFace.Style' typeFace.Weight' typeFace.Stretch)); " is 141.
Long Statement,PdfSharp.Drawing,XRect,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XRect.cs,Equals,The length of the statement  "	return rect1.X.Equals (rect2.X) && rect1.Y.Equals (rect2.Y) && rect1.Width.Equals (rect2.Width) && rect1.Height.Equals (rect2.Height); " is 134.
Long Statement,PdfSharp.Drawing,XRect,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XRect.cs,Parse,The length of the statement  "		empty = new XRect (Convert.ToDouble (str' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)' Convert.ToDouble (helper.NextTokenRequired ()' cultureInfo)); " is 239.
Long Statement,PdfSharp.Drawing,XRect,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XRect.cs,ConvertToString,The length of the statement  "	return string.Format (provider' "{1:" + format + "}{0}{2:" + format + "}{0}{3:" + format + "}{0}{4:" + format + "}"' new object[] { " is 131.
Long Statement,PdfSharp.Drawing,XRect,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XRect.cs,Contains,The length of the statement  "	return !IsEmpty && !rect.IsEmpty && this.x <= rect.x && this.y <= rect.y && this.x + this.width >= rect.x + rect.width && this.y + this.height >= rect.y + rect.height; " is 167.
Long Statement,PdfSharp.Drawing,XRect,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XRect.cs,IntersectsWith,The length of the statement  "	return !IsEmpty && !rect.IsEmpty && rect.Left <= Right && rect.Right >= Left && rect.Top <= Bottom && rect.Bottom >= Top; " is 121.
Long Statement,PdfSharp.Drawing,XSolidBrush,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XSolidBrush.cs,RealizeWpfBrush,The length of the statement  "      System.Windows.Media.SolidColorBrush brush1 = new System.Windows.Media.SolidColorBrush(clr); //System.Drawing.Color.FromArgb(128' 128' 0' 0));" is 142.
Long Statement,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,CreateGdiFontImage,The length of the statement  "	//  //XPrivateFont privateFont = privateFontCollection.FindFont(logFont.lfFaceName' logFont.lfWeight >= 700' logFont.lfItalic > 0); " is 131.
Long Statement,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The length of the statement  "		        Debug.WriteLine(String.Format("  Write Table '{0}'' offset={1}' length={2}' checksum={3}' "' entry.Tag' entry.Offset' entry.Length' entry.CheckSum));" is 149.
Long Statement,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The length of the statement  "	return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3])); " is 121.
Long Statement,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The length of the statement  "	return (uint)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3])); " is 122.
Long Statement,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The length of the statement  "	return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3])); " is 121.
Long Statement,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The length of the statement  "	return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7])); " is 236.
Long Statement,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The length of the statement  "			Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion."); " is 155.
Long Statement,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The length of the statement  "			Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion."); " is 155.
Long Statement,PdfSharp.Fonts.OpenType,IRefFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IRefFontTable.cs,PrepareForCompilation,The length of the statement  "		Buffer.BlockCopy (this.irefDirectoryEntry.FontTable.fontData.Data' this.irefDirectoryEntry.Offset' bytes' 0' DirectoryEntry.PaddedLength); " is 138.
Long Statement,PdfSharp.Fonts.OpenType,IRefFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IRefFontTable.cs,Write,The length of the statement  "	writer.Write (this.irefDirectoryEntry.FontTable.fontData.Data' this.irefDirectoryEntry.Offset' this.irefDirectoryEntry.PaddedLength); " is 133.
Long Statement,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,Initialize,The length of the statement  "          "os2.usWinDescent={0}' hhea.descender={1}' os2.sTypoDescender={2}"' fontData.os2.usWinDescent' fontData.hhea.descender' fontData.os2.sTypoDescender));" is 150.
Long Statement,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,OnPaintBackground,The length of the statement  "		gfx.FillRectangle (new SolidBrush (BackColor)' clientRect.Width - cxScrollbar - d' clientRect.Height - cyScrollbar - d' cxScrollbar' cyScrollbar); " is 146.
Long Statement,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The length of the statement  "		//this.zoomPercent = Convert.ToInt32(25400.0 * (rcCanvas.Width - (leftBorder + rightBorder)) / (this.pageSize.Width * xdpiScreen)); " is 131.
Long Statement,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,RenderPage,The length of the statement  "	gfx.SetClip (new Rectangle (this.virtualPage.X + 1' this.virtualPage.Y + 1' this.virtualPage.Width - 1' this.virtualPage.Height - 1)); " is 134.
Long Statement,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The length of the statement  "	gfx.SetClip (new Rectangle (virtualPage.X' virtualPage.Y' virtualPage.Width + 3' virtualPage.Height + 3)' CombineMode.Exclude); " is 127.
Long Statement,PdfSharp.Pdf.AcroForms,PdfTextField,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.AcroForms\PdfTextField.cs,RenderAppearance,The length of the statement  "		gfx.DrawString (Text' Font' new XSolidBrush (ForeColor)' rect.ToXRect () - rect.Location + new XPoint (2' 0)' XStringFormats.TopLeft); " is 134.
Long Statement,PdfSharp.Pdf.Advanced,PdfCIDFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfCIDFont.cs,PrepareForSave,The length of the statement  "	      TrueTypeFontSubSet fss = new TrueTypeFontSubSet(""' this.cmapInfo.descriptor.fontData' this.cmapInfo.GlyphIndices' 0' false' false);" is 132.
Long Statement,PdfSharp.Pdf.Advanced,PdfFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFontTable.cs,GetFont,The length of the statement  "	//      pdfFont.descriptor = new PdfFontDescriptor((TrueTypeDescriptor)FontDescriptorStock.Global.CreateDescriptor(font)); " is 122.
Long Statement,PdfSharp.Pdf.Advanced,PdfFormXObjectTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObjectTable.cs,GetForm,The length of the statement  "		//throw new InvalidOperationException("Because of a current limitation of PDFsharp an XPdfForm object can be used only within one single PdfDocument."); " is 152.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The length of the statement  "		if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) { " is 201.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The length of the statement  "				isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2]; " is 122.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The length of the statement  "				if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255) " is 151.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The length of the statement  "				if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255) " is 151.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The length of the statement  "			if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value) " is 137.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The length of the statement  "			//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp); " is 125.
Long Statement,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The length of the statement  "		if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) { " is 136.
Long Statement,PdfSharp.Pdf.Advanced,PdfInternals,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfInternals.cs,CreateIndirectObject,The length of the statement  "	ConstructorInfo ctorInfo = typeof(T).GetConstructor (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.ExactBinding' null' new Type[] { " is 169.
Long Statement,PdfSharp.Pdf.Advanced,PdfResourceMap,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfResourceMap.cs,CollectResourceNames,The length of the statement  "	// ?TODO: Imported resources (e.g. fonts) can be reused' but I think this is rather difficult. Will be an issue in PDFsharp 2.0. " is 128.
Long Statement,PdfSharp.Pdf.Advanced,PdfToUnicodeMap,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfToUnicodeMap.cs,PrepareForSave,The length of the statement  "	string prefix = "/CIDInit /ProcSet findresource begin\n" + "12 dict begin\n" + "begincmap\n" + "/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n" + "/CMapName /Adobe-Identity-UCS def /CMapType 2 def\n"; " is 225.
Long Statement,PdfSharp.Pdf.Advanced,PdfTrueTypeFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrueTypeFont.cs,PrepareForSave,The length of the statement  "		        TrueTypeFontSubSet fss = new TrueTypeFontSubSet(""' this.cmapInfo.descriptor.fontData' this.cmapInfo.GlyphIndices' 0' true' false);" is 131.
Long Statement,PdfSharp.Pdf.Annotations,PdfLinkAnnotation,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Annotations\PdfLinkAnnotation.cs,WriteObject,The length of the statement  "		Elements [Keys.A] = new PdfLiteral ("<</Type/Action/S/Launch/F<</Type/Filespec/F{0}>> >>"' //PdfEncoders.EncodeAsLiteral(this.url)); " is 132.
Long Statement,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The length of the statement  "			uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!'); " is 210.
Long Statement,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The length of the statement  "		uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85); " is 147.
Long Statement,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The length of the statement  "		uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85; " is 181.
Long Statement,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The length of the statement  "		return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###} {3:0.###}"' color.C' color.M' color.Y' color.K); " is 131.
Long Statement,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The length of the statement  "		return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0); " is 136.
Long Statement,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The length of the statement  "	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###}"' matrix.M11' matrix.M12' matrix.M21' matrix.M22' matrix.OffsetX' matrix.OffsetY); " is 195.
Long Statement,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEndObject,The length of the statement  "			this.WriteRaw ("%--------------------------------------------------------------------------------------------------\n"); " is 120.
Long Statement,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteObjectAddress,The length of the statement  "		this.WriteRaw (String.Format ("{0} {1} obj   % {2}\n"' value.ObjectID.ObjectNumber' value.ObjectID.GenerationNumber' value.GetType ().FullName)); " is 145.
Long Statement,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteFileHeader,The length of the statement  "		this.WriteRaw ("%--------------------------------------------------------------------------------------------------\n"); " is 120.
Long Statement,PdfSharp.Pdf.Printing,PdfFilePrinter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Printing\PdfFilePrinter.cs,DoSomeVeryDirtyHacksToMakeItWork,The length of the statement  "			if (String.Compare (Path.GetFileName (module.FileName)' Path.GetFileName (PdfFilePrinter.adobeReaderPath)' true) == 0) { " is 120.
Long Statement,PdfSharp.Pdf.Security,PdfSecuritySettings,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfSecuritySettings.cs,CanSave,The length of the statement  "		if ((SecurityHandler.userPassword == null || SecurityHandler.userPassword.Length == 0) && (SecurityHandler.ownerPassword == null || SecurityHandler.ownerPassword.Length == 0)) { " is 177.
Long Statement,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The length of the statement  "	bool strongEncryption = this.document.securitySettings.DocumentSecurityLevel == PdfDocumentSecurityLevel.Encrypted128Bit; " is 121.
Long Statement,PdfSharp.Pdf,PdfObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfObject.cs,ImportClosure,The length of the statement  "	Debug.Assert (ReferenceEquals (importedObjectTable.ExternalDocument' externalObject.Owner)' "The ExternalDocument of the importedObjectTable does not belong to the owner of object to be imported."); " is 198.
Long Statement,PdfSharp.Pdf,PdfPage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPage.cs,WriteObject,The length of the statement  "	//#warning THHO4STLA: warum nicht new PdfRectangle(mediaBox.Y1' mediaBox.X1' mediaBox.Y2' mediaBox.X2)? - siehe auch Orientation " is 128.
Long Statement,PdfSharp.Pdf,PdfPage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPage.cs,PrepareForSave,The length of the statement  "		PdfRectangle rect = new PdfRectangle (this.trimMargins.Left.Point' this.trimMargins.Top.Point' width - this.trimMargins.Right.Point' height - this.trimMargins.Bottom.Point); " is 173.
Long Statement,PdfSharp.Pdf,PdfPages,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPages.cs,ImportExternalPage,The length of the statement  "		throw new InvalidOperationException ("A PDF document must be opened with PdfDocumentOpenMode.Import to import pages from it."); " is 127.
Long Statement,PdfSharp.Pdf,PdfRectangle,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfRectangle.cs,GetHashCode,The length of the statement  "	return (int)(((((uint)this.x1) ^ ((((uint)this.y1) << 13) | (((uint)this.y1) >> 0x13))) ^ ((((uint)this.x2) << 0x1a) | (((uint)this.x2) >> 6))) ^ ((((uint)this.y2) << 7) | (((uint)this.y2) >> 0x19))); " is 200.
Long Statement,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The length of the statement  "					Debug.Assert (Object.ReferenceEquals (iref.Document' this.document) || iref.Document == null' "External object detected!"); " is 123.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "		if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) { " is 180.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend) " is 335.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The length of the statement  "	if ((storedLen >= DeflaterConstants.MAX_BLOCK_SIZE) || /* Block is full */(blockStart < WSIZE && storedLen >= MAX_DIST) || /* Block may move out of window */flush) { " is 165.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The length of the statement  "		if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 175.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "			if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 129.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "				/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) { " is 220.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The length of the statement  "	int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength () + literalTree.GetEncodedLength () + distTree.GetEncodedLength () + extra_bits; " is 142.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The length of the statement  "		/* bits_in_buffer may only be 0 or a multiple of 8 */throw new InvalidOperationException ("Bit buffer is not byte aligned!"); " is 125.
Long Statement,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The length of the statement  "		/* We always want an even number of bytes in input' see peekBits */buffer |= (uint)((buf [off++] & 0xff) << bits_in_buffer); " is 124.
Long Statement,PdfSharp,PSSR,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PSSR.cs,InvalidValue,The length of the statement  "	return Format ("{0} is not a valid value for {1}. {1} should be greater than or equal to {2} and less than or equal to {3}."' val' name' min' max); " is 147.
Long Statement,PdfSharp,PSSR,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PSSR.cs,ImportPageNumberOutOfRange,The length of the statement  "	return String.Format ("The page cannot be imported from document '{2}'' because the page number is out of range. " + "The specified page number is {0}' but it must be in the range from 1 to {1}."' pageNumber' maxPage' path); " is 224.
Long Statement,PdfSharp,PSSR,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PSSR.cs,InappropriateColorSpace,The length of the statement  "	return String.Format ("The document requires color mode {0}' but a color is defined using {1}. " + "Use only colors that match the color mode of the PDF document"' mode' space); " is 177.
Complex Conditional,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The conditional expression  "(start && !clockwise) || (!start && clockwise)"  is complex.
Complex Conditional,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The conditional expression  "(start && !clockwise) || (!start && clockwise)"  is complex.
Complex Conditional,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,Equals,The conditional expression  "this.r == color.r && this.g == color.g && this.b == color.b && this.c == color.c && this.m == color.m && this.y == color.y && this.k == color.k && this.gs == color.gs"  is complex.
Complex Conditional,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The conditional expression  "((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))"  is complex.
Complex Conditional,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The conditional expression  "imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0"  is complex.
Complex Conditional,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The conditional expression  "imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1"  is complex.
Complex Conditional,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The conditional expression  "ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height"  is complex.
Complex Conditional,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The conditional expression  "ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0"  is complex.
Complex Conditional,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The conditional expression  "ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  #if WPF  // TODOWPF: bug with height and width??? With which files???  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height"  is complex.
Complex Conditional,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The conditional expression  "paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255"  is complex.
Complex Conditional,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The conditional expression  "paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255"  is complex.
Complex Conditional,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The conditional expression  "(usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)"  is complex.
Complex Conditional,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The conditional expression  "c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]"  is complex.
Complex Conditional,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The conditional expression  "major >= '1' && major < '2' && minor >= '0' && minor <= '9'"  is complex.
Complex Conditional,PdfSharp.Pdf.Security,PdfSecuritySettings,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfSecuritySettings.cs,CanSave,The conditional expression  "(SecurityHandler.userPassword == null || SecurityHandler.userPassword.Length == 0) && (SecurityHandler.ownerPassword == null || SecurityHandler.ownerPassword.Length == 0)"  is complex.
Complex Conditional,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]"  is complex.
Complex Conditional,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLen >= DeflaterConstants.MAX_BLOCK_SIZE) || /* Block is full */(blockStart < WSIZE && storedLen >= MAX_DIST) || /* Block may move out of window */flush"  is complex.
Complex Conditional,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))"  is complex.
Empty Catch Block,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromName,The method has an empty catch block.
Empty Catch Block,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddString,The method has an empty catch block.
Empty Catch Block,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,InitializeGdiHelper,The method has an empty catch block.
Empty Catch Block,PdfSharp.Drawing,XPrivateFontCollection,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPrivateFontCollection.cs,TryFindPrivateFont,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The method has an empty catch block.
Empty Catch Block,PdfSharp.Pdf.Printing,PdfFilePrinter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Printing\PdfFilePrinter.cs,DoSomeVeryDirtyHacksToMakeItWork,The method has an empty catch block.
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (2380' 3368);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (2380' 3368);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (1684' 2380);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (1684' 2380);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (1190' 1684);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (1190' 1684);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (842' 1190);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (842' 1190);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (595' 842);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (595' 842);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (420' 595);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (420' 595);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (729' 1032);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (729' 1032);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (516' 729);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (516' 729);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (612' 792);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (612' 792);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (612' 1008);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (612' 1008);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (792' 1224);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (792' 1224);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (1224' 792);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (1224' 792);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (396' 612);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (396' 612);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (540' 720);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (540' 720);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (612' 936);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (612' 936);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (610' 780);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (610' 780);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (720' 1008);  
Magic Number,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following statement contains a magic number: return new XSize (720' 1008);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: if (num <= 0.04045)  	return (num / 12.92f);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: if (num < 1f)  	return (float)Math.Pow ((num + 0.055) / 1.055' 2.4);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: if (num < 1f)  	return (float)Math.Pow ((num + 0.055) / 1.055' 2.4);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: if (num < 1f)  	return (float)Math.Pow ((num + 0.055) / 1.055' 2.4);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: return (float)Math.Pow ((num + 0.055) / 1.055' 2.4);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: return (float)Math.Pow ((num + 0.055) / 1.055' 2.4);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,sRgbToScRgb,The following statement contains a magic number: return (float)Math.Pow ((num + 0.055) / 1.055' 2.4);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,ScRgbTosRgb,The following statement contains a magic number: if (val <= 0.0031308)  	return (byte)(((255f * val) * 12.92f) + 0.5f);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,ScRgbTosRgb,The following statement contains a magic number: if (val < 1.0)  	return (byte)((255f * ((1.055f * ((float)Math.Pow ((double)val' 0.41666666666666669))) - 0.055f)) + 0.5f);  
Magic Number,PdfSharp.Internal,ColorHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\ColorHelper.cs,ScRgbTosRgb,The following statement contains a magic number: return (byte)((255f * ((1.055f * ((float)Math.Pow ((double)val' 0.41666666666666669))) - 0.055f)) + 0.5f);  
Magic Number,PdfSharp.Internal,DoubleUtil,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\DoubleUtil.cs,IsOne,The following statement contains a magic number: return Math.Abs (value - 1.0) < 10.0 * Epsilon;  
Magic Number,PdfSharp.Internal,DoubleUtil,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\DoubleUtil.cs,IsZero,The following statement contains a magic number: return Math.Abs (value) < 10.0 * Epsilon;  
Magic Number,PdfSharp.Internal,DoubleUtil,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\DoubleUtil.cs,DoubleToInt,The following statement contains a magic number: return 0 < value ? (int)(value + 0.5) : (int)(value - 0.5);  
Magic Number,PdfSharp.Internal,DoubleUtil,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\DoubleUtil.cs,DoubleToInt,The following statement contains a magic number: return 0 < value ? (int)(value + 0.5) : (int)(value - 0.5);  
Magic Number,PdfSharp.Drawing.BarCodes,Code2of5Interleaved,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code2of5Interleaved.cs,RenderNextPair,The following statement contains a magic number: for (int idx = 0; idx < 5; ++idx) {  	RenderBar (info' linesArray [idx]);  	RenderGap (info' gapsArray [idx]);  }  
Magic Number,PdfSharp.Drawing.BarCodes,Code2of5Interleaved,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code2of5Interleaved.cs,RenderNextPair,The following statement contains a magic number: info.CurrPosInString += 2;  
Magic Number,PdfSharp.Drawing.BarCodes,Code3of9Standard,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code3of9Standard.cs,RenderChar,The following statement contains a magic number: while (idx < 9) {  	RenderBar (info' thickThinLines [idx]);  	if (idx < 8)  		RenderGap (info' thickThinLines [idx + 1]);  	idx += 2;  }  
Magic Number,PdfSharp.Drawing.BarCodes,Code3of9Standard,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code3of9Standard.cs,RenderChar,The following statement contains a magic number: while (idx < 9) {  	RenderBar (info' thickThinLines [idx]);  	if (idx < 8)  		RenderGap (info' thickThinLines [idx + 1]);  	idx += 2;  }  
Magic Number,PdfSharp.Drawing.BarCodes,Code3of9Standard,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code3of9Standard.cs,RenderChar,The following statement contains a magic number: while (idx < 9) {  	RenderBar (info' thickThinLines [idx]);  	if (idx < 8)  		RenderGap (info' thickThinLines [idx + 1]);  	idx += 2;  }  
Magic Number,PdfSharp.Drawing.BarCodes,Code3of9Standard,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code3of9Standard.cs,RenderChar,The following statement contains a magic number: if (idx < 8)  	RenderGap (info' thickThinLines [idx + 1]);  
Magic Number,PdfSharp.Drawing.BarCodes,Code3of9Standard,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\Code3of9Standard.cs,RenderChar,The following statement contains a magic number: idx += 2;  
Magic Number,PdfSharp.Drawing.BarCodes,CodeBase,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeBase.cs,CalcDistance,The following statement contains a magic number: result = new XVector (size.width / 2 * delta.x' size.height / 2 * delta.y);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeBase,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeBase.cs,CalcDistance,The following statement contains a magic number: result = new XVector (size.width / 2 * delta.x' size.height / 2 * delta.y);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: gfx.RotateAtTransform (180' position);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: gfx.RotateAtTransform (90' position);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: gfx.RotateAtTransform (-90' position);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: if (QuietZone > 0) {  	XSize sizeWithZone = new XSize (this.size.width' this.size.height);  	sizeWithZone.width = sizeWithZone.width / (Columns + 2 * QuietZone) * Columns;  	sizeWithZone.height = sizeWithZone.height / (Rows + 2 * QuietZone) * Rows;  	XPoint posWithZone = new XPoint (pos.X' pos.Y);  	posWithZone.X += size.width / (Columns + 2 * QuietZone) * QuietZone;  	posWithZone.Y += size.height / (Rows + 2 * QuietZone) * QuietZone;  	gfx.DrawRectangle (XBrushes.White' pos.x' pos.y' size.width' size.height);  	gfx.DrawImage (matrixImage' posWithZone.x' posWithZone.y' sizeWithZone.width' sizeWithZone.height);  }  else  	gfx.DrawImage (matrixImage' pos.x' pos.y' this.size.width' this.size.height);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: if (QuietZone > 0) {  	XSize sizeWithZone = new XSize (this.size.width' this.size.height);  	sizeWithZone.width = sizeWithZone.width / (Columns + 2 * QuietZone) * Columns;  	sizeWithZone.height = sizeWithZone.height / (Rows + 2 * QuietZone) * Rows;  	XPoint posWithZone = new XPoint (pos.X' pos.Y);  	posWithZone.X += size.width / (Columns + 2 * QuietZone) * QuietZone;  	posWithZone.Y += size.height / (Rows + 2 * QuietZone) * QuietZone;  	gfx.DrawRectangle (XBrushes.White' pos.x' pos.y' size.width' size.height);  	gfx.DrawImage (matrixImage' posWithZone.x' posWithZone.y' sizeWithZone.width' sizeWithZone.height);  }  else  	gfx.DrawImage (matrixImage' pos.x' pos.y' this.size.width' this.size.height);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: if (QuietZone > 0) {  	XSize sizeWithZone = new XSize (this.size.width' this.size.height);  	sizeWithZone.width = sizeWithZone.width / (Columns + 2 * QuietZone) * Columns;  	sizeWithZone.height = sizeWithZone.height / (Rows + 2 * QuietZone) * Rows;  	XPoint posWithZone = new XPoint (pos.X' pos.Y);  	posWithZone.X += size.width / (Columns + 2 * QuietZone) * QuietZone;  	posWithZone.Y += size.height / (Rows + 2 * QuietZone) * QuietZone;  	gfx.DrawRectangle (XBrushes.White' pos.x' pos.y' size.width' size.height);  	gfx.DrawImage (matrixImage' posWithZone.x' posWithZone.y' sizeWithZone.width' sizeWithZone.height);  }  else  	gfx.DrawImage (matrixImage' pos.x' pos.y' this.size.width' this.size.height);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: if (QuietZone > 0) {  	XSize sizeWithZone = new XSize (this.size.width' this.size.height);  	sizeWithZone.width = sizeWithZone.width / (Columns + 2 * QuietZone) * Columns;  	sizeWithZone.height = sizeWithZone.height / (Rows + 2 * QuietZone) * Rows;  	XPoint posWithZone = new XPoint (pos.X' pos.Y);  	posWithZone.X += size.width / (Columns + 2 * QuietZone) * QuietZone;  	posWithZone.Y += size.height / (Rows + 2 * QuietZone) * QuietZone;  	gfx.DrawRectangle (XBrushes.White' pos.x' pos.y' size.width' size.height);  	gfx.DrawImage (matrixImage' posWithZone.x' posWithZone.y' sizeWithZone.width' sizeWithZone.height);  }  else  	gfx.DrawImage (matrixImage' pos.x' pos.y' this.size.width' this.size.height);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: sizeWithZone.width = sizeWithZone.width / (Columns + 2 * QuietZone) * Columns;  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: sizeWithZone.height = sizeWithZone.height / (Rows + 2 * QuietZone) * Rows;  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: posWithZone.X += size.width / (Columns + 2 * QuietZone) * QuietZone;  
Magic Number,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following statement contains a magic number: posWithZone.Y += size.height / (Rows + 2 * QuietZone) * QuietZone;  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: gfx.RotateAtTransform (180' position);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: gfx.RotateAtTransform (90' position);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: gfx.RotateAtTransform (-90' position);  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: if (this.synchronizeCode) {  	XRect rect = new XRect (pt.x' pt.y' this.makerThickness' this.size.height);  	gfx.DrawRectangle (brush' rect);  	pt.x += 2 * this.makerDistance;  }  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: pt.x += 2 * this.makerDistance;  
Magic Number,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following statement contains a magic number: for (int idx = 0; idx < 32; idx++) {  	if ((value & 1) == 1) {  		XRect rect = new XRect (pt.x + idx * this.makerDistance' pt.y' this.makerThickness' this.size.height);  		gfx.DrawRectangle (brush' rect);  	}  	value = value >> 1;  }  
Magic Number,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,DataMatrix,The following statement contains a magic number: for (int rrows = 1; rrows < matrixRows; rrows++) {  	grid [rrows * matrixRows] = (char)1;  	for (int ccol = 1; ccol < matrixColumns; ccol++)  		grid [rrows * matrixRows + ccol] = (char)rand.Next (2);  }  
Magic Number,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,DataMatrix,The following statement contains a magic number: for (int ccol = 1; ccol < matrixColumns; ccol++)  	grid [rrows * matrixRows + ccol] = (char)rand.Next (2);  
Magic Number,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,DataMatrix,The following statement contains a magic number: grid [rrows * matrixRows + ccol] = (char)rand.Next (2);  
Magic Number,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,CreateImage,The following statement contains a magic number: return CreateImage (code' size' size' 10);  
Magic Number,PdfSharp.Drawing.BarCodes,DataMatrixImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\DataMatrixImage.cs,CreateImage,The following statement contains a magic number: return CreateImage (code' rows' columns' 10);  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: if (this.textLocation != TextLocation.None)  	info.BarHeight *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: if (this.textLocation != TextLocation.None)  	info.BarHeight *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: info.BarHeight *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: info.BarHeight *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	info.Gfx.RotateAtTransform (180' info.Position);  	break;  case CodeDirection.TopToBottom:  	info.Gfx.RotateAtTransform (90' info.Position);  	break;  case CodeDirection.BottomToTop:  	info.Gfx.RotateAtTransform (-90' info.Position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	info.Gfx.RotateAtTransform (180' info.Position);  	break;  case CodeDirection.TopToBottom:  	info.Gfx.RotateAtTransform (90' info.Position);  	break;  case CodeDirection.BottomToTop:  	info.Gfx.RotateAtTransform (-90' info.Position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: switch (this.direction) {  case CodeDirection.RightToLeft:  	info.Gfx.RotateAtTransform (180' info.Position);  	break;  case CodeDirection.TopToBottom:  	info.Gfx.RotateAtTransform (90' info.Position);  	break;  case CodeDirection.BottomToTop:  	info.Gfx.RotateAtTransform (-90' info.Position);  	break;  }  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: info.Gfx.RotateAtTransform (180' info.Position);  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: info.Gfx.RotateAtTransform (90' info.Position);  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following statement contains a magic number: info.Gfx.RotateAtTransform (-90' info.Position);  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderBar,The following statement contains a magic number: if (TextLocation != TextLocation.None)  	height *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderBar,The following statement contains a magic number: if (TextLocation != TextLocation.None)  	height *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderBar,The following statement contains a magic number: height *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderBar,The following statement contains a magic number: height *= 4.0 / 5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderTurboBit,The following statement contains a magic number: if (startBit)  	info.CurrPos.X -= 0.5 + GetBarWidth (info' true);  else  	info.CurrPos.X += 0.5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderTurboBit,The following statement contains a magic number: if (startBit)  	info.CurrPos.X -= 0.5 + GetBarWidth (info' true);  else  	info.CurrPos.X += 0.5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderTurboBit,The following statement contains a magic number: info.CurrPos.X -= 0.5 + GetBarWidth (info' true);  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderTurboBit,The following statement contains a magic number: info.CurrPos.X += 0.5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderTurboBit,The following statement contains a magic number: if (startBit)  	info.CurrPos.X += 0.5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderTurboBit,The following statement contains a magic number: info.CurrPos.X += 0.5;  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderText,The following statement contains a magic number: if (info.Font == null)  	info.Font = new XFont ("Courier New"' Size.Height / 6);  
Magic Number,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,RenderText,The following statement contains a magic number: info.Font = new XFont ("Courier New"' Size.Height / 6);  
Magic Number,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,AlignLine,The following statement contains a magic number: if (this.alignment != XParagraphAlignment.Justify) {  	if (this.alignment == XParagraphAlignment.Center)  		dx /= 2;  	for (int idx = firstIndex; idx <= lastIndex; idx++) {  		Block block = (Block)this.blocks [idx];  		block.Location += new XSize (dx' 0);  	}  }  else if (count > 1)// case: justify   {  	dx /= count - 1;  	for (int idx = firstIndex + 1' i = 1; idx <= lastIndex; idx++' i++) {  		Block block = (Block)this.blocks [idx];  		block.Location += new XSize (dx * i' 0);  	}  }  
Magic Number,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,AlignLine,The following statement contains a magic number: if (this.alignment == XParagraphAlignment.Center)  	dx /= 2;  
Magic Number,PdfSharp.Drawing.Layout,XTextFormatter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Layout\XTextFormatter.cs,AlignLine,The following statement contains a magic number: dx /= 2;  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (this.realizedDashStyle != pen.dashStyle || pen.dashStyle == XDashStyle.Custom) {  	double dot = pen.Width;  	double dash = 3 * dot;  	// Line width 0 is not recommended but valid  	XDashStyle dashStyle = pen.DashStyle;  	if (dot == 0)  		dashStyle = XDashStyle.Solid;  	switch (dashStyle) {  	case XDashStyle.Solid:  		this.renderer.Append ("[]0 d\n");  		break;  	case XDashStyle.Dash:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Dot:  		this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  		break;  	case XDashStyle.DashDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.DashDotDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Custom:  		{  			StringBuilder pdf = new StringBuilder ("["' 256);  			int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  			for (int idx = 0; idx < len; idx++) {  				if (idx > 0)  					pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  			}  			// Make an even number of values look like in GDI+  			if (len > 0 && len % 2 == 1) {  				pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  			}  			pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  			string pattern = pdf.ToString ();  			// BUG: drice2@ageone.de reported a realizing problem  			// HACK: I romove the if clause  			//if (this.realizedDashPattern != pattern)  			{  				this.realizedDashPattern = pattern;  				this.renderer.Append (pattern);  			}  		}  		break;  	}  	this.realizedDashStyle = dashStyle;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (this.realizedDashStyle != pen.dashStyle || pen.dashStyle == XDashStyle.Custom) {  	double dot = pen.Width;  	double dash = 3 * dot;  	// Line width 0 is not recommended but valid  	XDashStyle dashStyle = pen.DashStyle;  	if (dot == 0)  		dashStyle = XDashStyle.Solid;  	switch (dashStyle) {  	case XDashStyle.Solid:  		this.renderer.Append ("[]0 d\n");  		break;  	case XDashStyle.Dash:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Dot:  		this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  		break;  	case XDashStyle.DashDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.DashDotDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Custom:  		{  			StringBuilder pdf = new StringBuilder ("["' 256);  			int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  			for (int idx = 0; idx < len; idx++) {  				if (idx > 0)  					pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  			}  			// Make an even number of values look like in GDI+  			if (len > 0 && len % 2 == 1) {  				pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  			}  			pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  			string pattern = pdf.ToString ();  			// BUG: drice2@ageone.de reported a realizing problem  			// HACK: I romove the if clause  			//if (this.realizedDashPattern != pattern)  			{  				this.realizedDashPattern = pattern;  				this.renderer.Append (pattern);  			}  		}  		break;  	}  	this.realizedDashStyle = dashStyle;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (this.realizedDashStyle != pen.dashStyle || pen.dashStyle == XDashStyle.Custom) {  	double dot = pen.Width;  	double dash = 3 * dot;  	// Line width 0 is not recommended but valid  	XDashStyle dashStyle = pen.DashStyle;  	if (dot == 0)  		dashStyle = XDashStyle.Solid;  	switch (dashStyle) {  	case XDashStyle.Solid:  		this.renderer.Append ("[]0 d\n");  		break;  	case XDashStyle.Dash:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Dot:  		this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  		break;  	case XDashStyle.DashDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.DashDotDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Custom:  		{  			StringBuilder pdf = new StringBuilder ("["' 256);  			int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  			for (int idx = 0; idx < len; idx++) {  				if (idx > 0)  					pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  			}  			// Make an even number of values look like in GDI+  			if (len > 0 && len % 2 == 1) {  				pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  			}  			pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  			string pattern = pdf.ToString ();  			// BUG: drice2@ageone.de reported a realizing problem  			// HACK: I romove the if clause  			//if (this.realizedDashPattern != pattern)  			{  				this.realizedDashPattern = pattern;  				this.renderer.Append (pattern);  			}  		}  		break;  	}  	this.realizedDashStyle = dashStyle;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (this.realizedDashStyle != pen.dashStyle || pen.dashStyle == XDashStyle.Custom) {  	double dot = pen.Width;  	double dash = 3 * dot;  	// Line width 0 is not recommended but valid  	XDashStyle dashStyle = pen.DashStyle;  	if (dot == 0)  		dashStyle = XDashStyle.Solid;  	switch (dashStyle) {  	case XDashStyle.Solid:  		this.renderer.Append ("[]0 d\n");  		break;  	case XDashStyle.Dash:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Dot:  		this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  		break;  	case XDashStyle.DashDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.DashDotDot:  		this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  		break;  	case XDashStyle.Custom:  		{  			StringBuilder pdf = new StringBuilder ("["' 256);  			int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  			for (int idx = 0; idx < len; idx++) {  				if (idx > 0)  					pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  			}  			// Make an even number of values look like in GDI+  			if (len > 0 && len % 2 == 1) {  				pdf.Append (' ');  				pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  			}  			pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  			string pattern = pdf.ToString ();  			// BUG: drice2@ageone.de reported a realizing problem  			// HACK: I romove the if clause  			//if (this.realizedDashPattern != pattern)  			{  				this.realizedDashPattern = pattern;  				this.renderer.Append (pattern);  			}  		}  		break;  	}  	this.realizedDashStyle = dashStyle;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: switch (dashStyle) {  case XDashStyle.Solid:  	this.renderer.Append ("[]0 d\n");  	break;  case XDashStyle.Dash:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Dot:  	this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  	break;  case XDashStyle.DashDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.DashDotDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Custom:  	{  		StringBuilder pdf = new StringBuilder ("["' 256);  		int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  		for (int idx = 0; idx < len; idx++) {  			if (idx > 0)  				pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  		}  		// Make an even number of values look like in GDI+  		if (len > 0 && len % 2 == 1) {  			pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  		}  		pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  		string pattern = pdf.ToString ();  		// BUG: drice2@ageone.de reported a realizing problem  		// HACK: I romove the if clause  		//if (this.realizedDashPattern != pattern)  		{  			this.realizedDashPattern = pattern;  			this.renderer.Append (pattern);  		}  	}  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: switch (dashStyle) {  case XDashStyle.Solid:  	this.renderer.Append ("[]0 d\n");  	break;  case XDashStyle.Dash:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Dot:  	this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  	break;  case XDashStyle.DashDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.DashDotDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Custom:  	{  		StringBuilder pdf = new StringBuilder ("["' 256);  		int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  		for (int idx = 0; idx < len; idx++) {  			if (idx > 0)  				pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  		}  		// Make an even number of values look like in GDI+  		if (len > 0 && len % 2 == 1) {  			pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  		}  		pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  		string pattern = pdf.ToString ();  		// BUG: drice2@ageone.de reported a realizing problem  		// HACK: I romove the if clause  		//if (this.realizedDashPattern != pattern)  		{  			this.realizedDashPattern = pattern;  			this.renderer.Append (pattern);  		}  	}  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: switch (dashStyle) {  case XDashStyle.Solid:  	this.renderer.Append ("[]0 d\n");  	break;  case XDashStyle.Dash:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Dot:  	this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  	break;  case XDashStyle.DashDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.DashDotDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Custom:  	{  		StringBuilder pdf = new StringBuilder ("["' 256);  		int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  		for (int idx = 0; idx < len; idx++) {  			if (idx > 0)  				pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  		}  		// Make an even number of values look like in GDI+  		if (len > 0 && len % 2 == 1) {  			pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  		}  		pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  		string pattern = pdf.ToString ();  		// BUG: drice2@ageone.de reported a realizing problem  		// HACK: I romove the if clause  		//if (this.realizedDashPattern != pattern)  		{  			this.realizedDashPattern = pattern;  			this.renderer.Append (pattern);  		}  	}  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (len > 0 && len % 2 == 1) {  	pdf.Append (' ');  	pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (len > 0 && len % 2 == 1) {  	pdf.Append (' ');  	pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following statement contains a magic number: if (this.renderer.Owner.Version >= 14 && this.realizedStrokeColor.A != color.A) {  	PdfExtGState extGState = this.renderer.Owner.ExtGStateTable.GetExtGStateStroke (color.A);  	string gs = this.renderer.Resources.AddExtGState (extGState);  	this.renderer.AppendFormat ("{0} gs\n"' gs);  	// Must create transparany group  	if (this.renderer.page != null && color.A < 1)  		this.renderer.page.transparencyUsed = true;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeBrush,The following statement contains a magic number: if (brush is XSolidBrush) {  	XColor color = ((XSolidBrush)brush).Color;  	color = ColorSpaceHelper.EnsureColorMode (colorMode' color);  	if (colorMode != PdfColorMode.Cmyk) {  		if (this.realizedFillColor.Rgb != color.Rgb) {  			this.renderer.Append (PdfEncoders.ToString (color' PdfColorMode.Rgb));  			this.renderer.Append (" rg\n");  		}  	}  	else {  		if (!ColorSpaceHelper.IsEqualCmyk (this.realizedFillColor' color)) {  			this.renderer.Append (PdfEncoders.ToString (color' PdfColorMode.Cmyk));  			this.renderer.Append (" k\n");  		}  	}  	if (this.renderer.Owner.Version >= 14 && this.realizedFillColor.A != color.A) {  		PdfExtGState extGState = this.renderer.Owner.ExtGStateTable.GetExtGStateNonStroke (color.A);  		string gs = this.renderer.Resources.AddExtGState (extGState);  		this.renderer.AppendFormat ("{0} gs\n"' gs);  		// Must create transparany group  		if (this.renderer.page != null && color.A < 1)  			this.renderer.page.transparencyUsed = true;  	}  	this.realizedFillColor = color;  }  else if (brush is XLinearGradientBrush) {  	XMatrix matrix = this.renderer.defaultViewMatrix;  	matrix.Prepend (this.Transform);  	PdfShadingPattern pattern = new PdfShadingPattern (this.renderer.Owner);  	pattern.SetupFromBrush ((XLinearGradientBrush)brush' matrix);  	string name = this.renderer.Resources.AddPattern (pattern);  	this.renderer.AppendFormat ("/Pattern cs\n"' name);  	this.renderer.AppendFormat ("{0} scn\n"' name);  	// Invalidate fill color  	this.realizedFillColor = XColor.Empty;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeBrush,The following statement contains a magic number: if (this.renderer.Owner.Version >= 14 && this.realizedFillColor.A != color.A) {  	PdfExtGState extGState = this.renderer.Owner.ExtGStateTable.GetExtGStateNonStroke (color.A);  	string gs = this.renderer.Resources.AddExtGState (extGState);  	this.renderer.AppendFormat ("{0} gs\n"' gs);  	// Must create transparany group  	if (this.renderer.page != null && color.A < 1)  		this.renderer.page.transparencyUsed = true;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: if (this.MustRealizeCtm) {  	Debug.Assert (!this.unrealizedCtm.IsIdentity' "mrCtm is unnecessarily set.");  	double[] matrix = this.unrealizedCtm.GetElements ();  	// Up to six decimal digits to prevent round up problems  	this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  	this.realizedCtm.Prepend (this.unrealizedCtm);  	this.unrealizedCtm = new XMatrix ();  	//XMatrix.Identity;  	this.MustRealizeCtm = false;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: if (this.MustRealizeCtm) {  	Debug.Assert (!this.unrealizedCtm.IsIdentity' "mrCtm is unnecessarily set.");  	double[] matrix = this.unrealizedCtm.GetElements ();  	// Up to six decimal digits to prevent round up problems  	this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  	this.realizedCtm.Prepend (this.unrealizedCtm);  	this.unrealizedCtm = new XMatrix ();  	//XMatrix.Identity;  	this.MustRealizeCtm = false;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: if (this.MustRealizeCtm) {  	Debug.Assert (!this.unrealizedCtm.IsIdentity' "mrCtm is unnecessarily set.");  	double[] matrix = this.unrealizedCtm.GetElements ();  	// Up to six decimal digits to prevent round up problems  	this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  	this.realizedCtm.Prepend (this.unrealizedCtm);  	this.unrealizedCtm = new XMatrix ();  	//XMatrix.Identity;  	this.MustRealizeCtm = false;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: if (this.MustRealizeCtm) {  	Debug.Assert (!this.unrealizedCtm.IsIdentity' "mrCtm is unnecessarily set.");  	double[] matrix = this.unrealizedCtm.GetElements ();  	// Up to six decimal digits to prevent round up problems  	this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  	this.realizedCtm.Prepend (this.unrealizedCtm);  	this.unrealizedCtm = new XMatrix ();  	//XMatrix.Identity;  	this.MustRealizeCtm = false;  }  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  
Magic Number,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizeCtm,The following statement contains a magic number: this.renderer.AppendFormat ("{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} cm\n"' matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawLine,The following statement contains a magic number: DrawLines (pen' new XPoint[2] {  	new XPoint (x1' y1)'  	new XPoint (x2' y2)  });  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBezier,The following statement contains a magic number: DrawBeziers (pen' new XPoint[4] {  	new XPoint (x1' y1)'  	new XPoint (x2' y2)'  	new XPoint (x3' y3)'  	new XPoint (x4' y4)  });  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: if ((count - 1) % 3 != 0)  	throw new ArgumentException ("Invalid number of points for bezier curves. Number must fulfil 4+3n."' "points");  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3)  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3)  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3)  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: idx += 3
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawBeziers,The following statement contains a magic number: AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count < 2)  	throw new ArgumentException ("Not enough points"' "points");  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: tension /= 3;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: AppendCurveSegment (points [0]' points [0]' points [1]' points [2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawCurve,The following statement contains a magic number: AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawPolygon,The following statement contains a magic number: throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawPie,The following statement contains a magic number: AppendFormat ("{0:0.####} {1:0.####} m\n"' x + width / 2' y + height / 2);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawPie,The following statement contains a magic number: AppendFormat ("{0:0.####} {1:0.####} m\n"' x + width / 2' y + height / 2);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count < 2)  	throw new ArgumentException ("Not enough points"' "points");  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: tension /= 3;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	// Just draws a line...  	AppendCurveSegment (points [0]' points [0]' points [1]' points [1]' tension);  }  else {  	AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  	for (int idx = 1; idx < count - 2; idx++)  		AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  	AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  	AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: AppendCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: AppendCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: AppendCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawClosedCurve,The following statement contains a magic number: AppendCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.Alignment) {  case XStringAlignment.Near:  	// nothing to do  	break;  case XStringAlignment.Center:  	x += (rect.Width - width) / 2;  	break;  case XStringAlignment.Far:  	x += rect.Width - width;  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: x += (rect.Width - width) / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: if (Gfx.PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyDescent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  else {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyDescent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyDescent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyDescent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyDescent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyDescent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyAscent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyDescent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyAscent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyDescent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyAscent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyDescent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyAscent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following statement contains a magic number: y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: Debug.Assert (α >= 0 && α <= 360);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: β = -360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: β = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α == 0 && β < 0)  	α = 360;  else if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α == 0 && β < 0)  	α = 360;  else if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: α = 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		else  			smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	else  		smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (clockwise)  	currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  else  	currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: if (clockwise)  	currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  else  	currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (φ > 360)  	φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (φ > 360)  	φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (φ > 360)  	φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: if ((start && !clockwise) || (!start && clockwise))  	quadrant = quadrant == 0 ? 3 : quadrant - 1;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: quadrant = quadrant == 0 ? 3 : quadrant - 1;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,Quatrant,The following statement contains a magic number: quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: Debug.Assert (α >= 0 && α <= 360);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: Debug.Assert (Math.Abs (α - β) <= 90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: α -= 180;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: β -= 180;  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10)  		α = Calc.πHalf - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10)  		β = Calc.πHalf - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10)  		α = Calc.πHalf - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10)  		β = Calc.πHalf - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (Math.Abs (sinα) > 1E-10)  	α = Calc.πHalf - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (Math.Abs (sinβ) > 1E-10)  	β = Calc.πHalf - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: for (int idx = start; idx < count; idx += 3)  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: for (int idx = start; idx < count; idx += 3)  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: for (int idx = start; idx < count; idx += 3)  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: idx += 3
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArc,The following statement contains a magic number: AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [idx + 1].X' points [idx + 1].Y' points [idx + 2].X' points [idx + 2].Y);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	// From GDI+ documentation:  	const byte PathPointTypeStart = 0;  	// move  	const byte PathPointTypeLine = 1;  	// line  	const byte PathPointTypeBezier = 3;  	// default Bezier (= cubic Bezier)  	const byte PathPointTypePathTypeMask = 0x07;  	// type mask (lowest 3 bits).  	//const byte PathPointTypeDashMode = 0x10; // currently in dash mode.  	//const byte PathPointTypePathMarker = 0x20; // a marker for the path.  	const byte PathPointTypeCloseSubpath = 0x80;  	// closed flag  	byte type = types [idx];  	switch (type & PathPointTypePathTypeMask) {  	case PathPointTypeStart:  		//PDF_moveto(pdf' points[idx].X' points[idx].Y);  		AppendFormat ("{0:0.####} {1:0.####} m\n"' points [idx].X' points [idx].Y);  		break;  	case PathPointTypeLine:  		//PDF_lineto(pdf' points[idx].X' points[idx].Y);  		AppendFormat ("{0:0.####} {1:0.####} l\n"' points [idx].X' points [idx].Y);  		if ((type & PathPointTypeCloseSubpath) != 0)  			Append ("h\n");  		break;  	case PathPointTypeBezier:  		Debug.Assert (idx + 2 < count);  		//PDF_curveto(pdf' points[idx].X' points[idx].Y'   		//                 points[idx + 1].X' points[idx + 1].Y'   		//                 points[idx + 2].X' points[idx + 2].Y);  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [++idx].X' points [idx].Y' points [++idx].X' points [idx].Y);  		if ((types [idx] & PathPointTypeCloseSubpath) != 0)  			Append ("h\n");  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	// From GDI+ documentation:  	const byte PathPointTypeStart = 0;  	// move  	const byte PathPointTypeLine = 1;  	// line  	const byte PathPointTypeBezier = 3;  	// default Bezier (= cubic Bezier)  	const byte PathPointTypePathTypeMask = 0x07;  	// type mask (lowest 3 bits).  	//const byte PathPointTypeDashMode = 0x10; // currently in dash mode.  	//const byte PathPointTypePathMarker = 0x20; // a marker for the path.  	const byte PathPointTypeCloseSubpath = 0x80;  	// closed flag  	byte type = types [idx];  	switch (type & PathPointTypePathTypeMask) {  	case PathPointTypeStart:  		//PDF_moveto(pdf' points[idx].X' points[idx].Y);  		AppendFormat ("{0:0.####} {1:0.####} m\n"' points [idx].X' points [idx].Y);  		break;  	case PathPointTypeLine:  		//PDF_lineto(pdf' points[idx].X' points[idx].Y);  		AppendFormat ("{0:0.####} {1:0.####} l\n"' points [idx].X' points [idx].Y);  		if ((type & PathPointTypeCloseSubpath) != 0)  			Append ("h\n");  		break;  	case PathPointTypeBezier:  		Debug.Assert (idx + 2 < count);  		//PDF_curveto(pdf' points[idx].X' points[idx].Y'   		//                 points[idx + 1].X' points[idx + 1].Y'   		//                 points[idx + 2].X' points[idx + 2].Y);  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [++idx].X' points [idx].Y' points [++idx].X' points [idx].Y);  		if ((types [idx] & PathPointTypeCloseSubpath) != 0)  			Append ("h\n");  		break;  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: switch (type & PathPointTypePathTypeMask) {  case PathPointTypeStart:  	//PDF_moveto(pdf' points[idx].X' points[idx].Y);  	AppendFormat ("{0:0.####} {1:0.####} m\n"' points [idx].X' points [idx].Y);  	break;  case PathPointTypeLine:  	//PDF_lineto(pdf' points[idx].X' points[idx].Y);  	AppendFormat ("{0:0.####} {1:0.####} l\n"' points [idx].X' points [idx].Y);  	if ((type & PathPointTypeCloseSubpath) != 0)  		Append ("h\n");  	break;  case PathPointTypeBezier:  	Debug.Assert (idx + 2 < count);  	//PDF_curveto(pdf' points[idx].X' points[idx].Y'   	//                 points[idx + 1].X' points[idx + 1].Y'   	//                 points[idx + 2].X' points[idx + 2].Y);  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [++idx].X' points [idx].Y' points [++idx].X' points [idx].Y);  	if ((types [idx] & PathPointTypeCloseSubpath) != 0)  		Append ("h\n");  	break;  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: Debug.Assert (idx + 2 < count);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathFigure figure in geometry.Figures) {  	System.Windows.Point currentPoint = new System.Windows.Point ();  	// Move to start point  	currentPoint = figure.StartPoint;  	AppendFormat ("{0:0.####} {1:0.####} m\n"' currentPoint.X' currentPoint.Y);  	foreach (PathSegment segment in figure.Segments) {  		Type type = segment.GetType ();  		if (type == typeof(LineSegment)) {  			// Draw a single line  			System.Windows.Point point = ((LineSegment)segment).Point;  			currentPoint = point;  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  		else if (type == typeof(PolyLineSegment)) {  			// Draw connected lines  			PointCollection points = ((PolyLineSegment)segment).Points;  			foreach (System.Windows.Point point in points) {  				currentPoint = point;  				// I forced myself not to optimize this assignment  				AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  			}  		}  		else if (type == typeof(BezierSegment)) {  			// Draw Bézier curve  			BezierSegment seg = (BezierSegment)segment;  			System.Windows.Point point1 = seg.Point1;  			System.Windows.Point point2 = seg.Point2;  			System.Windows.Point point3 = seg.Point3;  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			currentPoint = point3;  		}  		else if (type == typeof(PolyBezierSegment)) {  			// Draw connected Bézier curves  			PointCollection points = ((PolyBezierSegment)segment).Points;  			int count = points.Count;  			if (count > 0) {  				Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  				for (int idx = 0; idx < count - 2; idx += 3) {  					System.Windows.Point point1 = points [idx];  					System.Windows.Point point2 = points [idx + 1];  					System.Windows.Point point3 = points [idx + 2];  					AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  				}  				currentPoint = points [count - 1];  			}  		}  		else if (type == typeof(ArcSegment)) {  			// Draw arc  			ArcSegment seg = (ArcSegment)segment;  			AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  			currentPoint = seg.Point;  		}  		else if (type == typeof(QuadraticBezierSegment)) {  			QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  			currentPoint = seg.Point2;  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  		}  		else if (type == typeof(PolyQuadraticBezierSegment)) {  			PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  			currentPoint = seg.Points [seg.Points.Count - 1];  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  		}  	}  	if (figure.IsClosed)  		Append ("h\n");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathFigure figure in geometry.Figures) {  	System.Windows.Point currentPoint = new System.Windows.Point ();  	// Move to start point  	currentPoint = figure.StartPoint;  	AppendFormat ("{0:0.####} {1:0.####} m\n"' currentPoint.X' currentPoint.Y);  	foreach (PathSegment segment in figure.Segments) {  		Type type = segment.GetType ();  		if (type == typeof(LineSegment)) {  			// Draw a single line  			System.Windows.Point point = ((LineSegment)segment).Point;  			currentPoint = point;  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  		else if (type == typeof(PolyLineSegment)) {  			// Draw connected lines  			PointCollection points = ((PolyLineSegment)segment).Points;  			foreach (System.Windows.Point point in points) {  				currentPoint = point;  				// I forced myself not to optimize this assignment  				AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  			}  		}  		else if (type == typeof(BezierSegment)) {  			// Draw Bézier curve  			BezierSegment seg = (BezierSegment)segment;  			System.Windows.Point point1 = seg.Point1;  			System.Windows.Point point2 = seg.Point2;  			System.Windows.Point point3 = seg.Point3;  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			currentPoint = point3;  		}  		else if (type == typeof(PolyBezierSegment)) {  			// Draw connected Bézier curves  			PointCollection points = ((PolyBezierSegment)segment).Points;  			int count = points.Count;  			if (count > 0) {  				Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  				for (int idx = 0; idx < count - 2; idx += 3) {  					System.Windows.Point point1 = points [idx];  					System.Windows.Point point2 = points [idx + 1];  					System.Windows.Point point3 = points [idx + 2];  					AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  				}  				currentPoint = points [count - 1];  			}  		}  		else if (type == typeof(ArcSegment)) {  			// Draw arc  			ArcSegment seg = (ArcSegment)segment;  			AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  			currentPoint = seg.Point;  		}  		else if (type == typeof(QuadraticBezierSegment)) {  			QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  			currentPoint = seg.Point2;  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  		}  		else if (type == typeof(PolyQuadraticBezierSegment)) {  			PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  			currentPoint = seg.Points [seg.Points.Count - 1];  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  		}  	}  	if (figure.IsClosed)  		Append ("h\n");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathFigure figure in geometry.Figures) {  	System.Windows.Point currentPoint = new System.Windows.Point ();  	// Move to start point  	currentPoint = figure.StartPoint;  	AppendFormat ("{0:0.####} {1:0.####} m\n"' currentPoint.X' currentPoint.Y);  	foreach (PathSegment segment in figure.Segments) {  		Type type = segment.GetType ();  		if (type == typeof(LineSegment)) {  			// Draw a single line  			System.Windows.Point point = ((LineSegment)segment).Point;  			currentPoint = point;  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  		else if (type == typeof(PolyLineSegment)) {  			// Draw connected lines  			PointCollection points = ((PolyLineSegment)segment).Points;  			foreach (System.Windows.Point point in points) {  				currentPoint = point;  				// I forced myself not to optimize this assignment  				AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  			}  		}  		else if (type == typeof(BezierSegment)) {  			// Draw Bézier curve  			BezierSegment seg = (BezierSegment)segment;  			System.Windows.Point point1 = seg.Point1;  			System.Windows.Point point2 = seg.Point2;  			System.Windows.Point point3 = seg.Point3;  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			currentPoint = point3;  		}  		else if (type == typeof(PolyBezierSegment)) {  			// Draw connected Bézier curves  			PointCollection points = ((PolyBezierSegment)segment).Points;  			int count = points.Count;  			if (count > 0) {  				Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  				for (int idx = 0; idx < count - 2; idx += 3) {  					System.Windows.Point point1 = points [idx];  					System.Windows.Point point2 = points [idx + 1];  					System.Windows.Point point3 = points [idx + 2];  					AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  				}  				currentPoint = points [count - 1];  			}  		}  		else if (type == typeof(ArcSegment)) {  			// Draw arc  			ArcSegment seg = (ArcSegment)segment;  			AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  			currentPoint = seg.Point;  		}  		else if (type == typeof(QuadraticBezierSegment)) {  			QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  			currentPoint = seg.Point2;  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  		}  		else if (type == typeof(PolyQuadraticBezierSegment)) {  			PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  			currentPoint = seg.Points [seg.Points.Count - 1];  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  		}  	}  	if (figure.IsClosed)  		Append ("h\n");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathFigure figure in geometry.Figures) {  	System.Windows.Point currentPoint = new System.Windows.Point ();  	// Move to start point  	currentPoint = figure.StartPoint;  	AppendFormat ("{0:0.####} {1:0.####} m\n"' currentPoint.X' currentPoint.Y);  	foreach (PathSegment segment in figure.Segments) {  		Type type = segment.GetType ();  		if (type == typeof(LineSegment)) {  			// Draw a single line  			System.Windows.Point point = ((LineSegment)segment).Point;  			currentPoint = point;  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  		else if (type == typeof(PolyLineSegment)) {  			// Draw connected lines  			PointCollection points = ((PolyLineSegment)segment).Points;  			foreach (System.Windows.Point point in points) {  				currentPoint = point;  				// I forced myself not to optimize this assignment  				AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  			}  		}  		else if (type == typeof(BezierSegment)) {  			// Draw Bézier curve  			BezierSegment seg = (BezierSegment)segment;  			System.Windows.Point point1 = seg.Point1;  			System.Windows.Point point2 = seg.Point2;  			System.Windows.Point point3 = seg.Point3;  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			currentPoint = point3;  		}  		else if (type == typeof(PolyBezierSegment)) {  			// Draw connected Bézier curves  			PointCollection points = ((PolyBezierSegment)segment).Points;  			int count = points.Count;  			if (count > 0) {  				Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  				for (int idx = 0; idx < count - 2; idx += 3) {  					System.Windows.Point point1 = points [idx];  					System.Windows.Point point2 = points [idx + 1];  					System.Windows.Point point3 = points [idx + 2];  					AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  				}  				currentPoint = points [count - 1];  			}  		}  		else if (type == typeof(ArcSegment)) {  			// Draw arc  			ArcSegment seg = (ArcSegment)segment;  			AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  			currentPoint = seg.Point;  		}  		else if (type == typeof(QuadraticBezierSegment)) {  			QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  			currentPoint = seg.Point2;  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  		}  		else if (type == typeof(PolyQuadraticBezierSegment)) {  			PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  			currentPoint = seg.Points [seg.Points.Count - 1];  			// TODOWPF: Undone because XGraphics has no such curve type  			throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  		}  	}  	if (figure.IsClosed)  		Append ("h\n");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathSegment segment in figure.Segments) {  	Type type = segment.GetType ();  	if (type == typeof(LineSegment)) {  		// Draw a single line  		System.Windows.Point point = ((LineSegment)segment).Point;  		currentPoint = point;  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  	else if (type == typeof(PolyLineSegment)) {  		// Draw connected lines  		PointCollection points = ((PolyLineSegment)segment).Points;  		foreach (System.Windows.Point point in points) {  			currentPoint = point;  			// I forced myself not to optimize this assignment  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  	}  	else if (type == typeof(BezierSegment)) {  		// Draw Bézier curve  		BezierSegment seg = (BezierSegment)segment;  		System.Windows.Point point1 = seg.Point1;  		System.Windows.Point point2 = seg.Point2;  		System.Windows.Point point3 = seg.Point3;  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		currentPoint = point3;  	}  	else if (type == typeof(PolyBezierSegment)) {  		// Draw connected Bézier curves  		PointCollection points = ((PolyBezierSegment)segment).Points;  		int count = points.Count;  		if (count > 0) {  			Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  			for (int idx = 0; idx < count - 2; idx += 3) {  				System.Windows.Point point1 = points [idx];  				System.Windows.Point point2 = points [idx + 1];  				System.Windows.Point point3 = points [idx + 2];  				AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			}  			currentPoint = points [count - 1];  		}  	}  	else if (type == typeof(ArcSegment)) {  		// Draw arc  		ArcSegment seg = (ArcSegment)segment;  		AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  		currentPoint = seg.Point;  	}  	else if (type == typeof(QuadraticBezierSegment)) {  		QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  		currentPoint = seg.Point2;  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  	}  	else if (type == typeof(PolyQuadraticBezierSegment)) {  		PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  		currentPoint = seg.Points [seg.Points.Count - 1];  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathSegment segment in figure.Segments) {  	Type type = segment.GetType ();  	if (type == typeof(LineSegment)) {  		// Draw a single line  		System.Windows.Point point = ((LineSegment)segment).Point;  		currentPoint = point;  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  	else if (type == typeof(PolyLineSegment)) {  		// Draw connected lines  		PointCollection points = ((PolyLineSegment)segment).Points;  		foreach (System.Windows.Point point in points) {  			currentPoint = point;  			// I forced myself not to optimize this assignment  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  	}  	else if (type == typeof(BezierSegment)) {  		// Draw Bézier curve  		BezierSegment seg = (BezierSegment)segment;  		System.Windows.Point point1 = seg.Point1;  		System.Windows.Point point2 = seg.Point2;  		System.Windows.Point point3 = seg.Point3;  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		currentPoint = point3;  	}  	else if (type == typeof(PolyBezierSegment)) {  		// Draw connected Bézier curves  		PointCollection points = ((PolyBezierSegment)segment).Points;  		int count = points.Count;  		if (count > 0) {  			Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  			for (int idx = 0; idx < count - 2; idx += 3) {  				System.Windows.Point point1 = points [idx];  				System.Windows.Point point2 = points [idx + 1];  				System.Windows.Point point3 = points [idx + 2];  				AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			}  			currentPoint = points [count - 1];  		}  	}  	else if (type == typeof(ArcSegment)) {  		// Draw arc  		ArcSegment seg = (ArcSegment)segment;  		AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  		currentPoint = seg.Point;  	}  	else if (type == typeof(QuadraticBezierSegment)) {  		QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  		currentPoint = seg.Point2;  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  	}  	else if (type == typeof(PolyQuadraticBezierSegment)) {  		PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  		currentPoint = seg.Points [seg.Points.Count - 1];  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathSegment segment in figure.Segments) {  	Type type = segment.GetType ();  	if (type == typeof(LineSegment)) {  		// Draw a single line  		System.Windows.Point point = ((LineSegment)segment).Point;  		currentPoint = point;  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  	else if (type == typeof(PolyLineSegment)) {  		// Draw connected lines  		PointCollection points = ((PolyLineSegment)segment).Points;  		foreach (System.Windows.Point point in points) {  			currentPoint = point;  			// I forced myself not to optimize this assignment  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  	}  	else if (type == typeof(BezierSegment)) {  		// Draw Bézier curve  		BezierSegment seg = (BezierSegment)segment;  		System.Windows.Point point1 = seg.Point1;  		System.Windows.Point point2 = seg.Point2;  		System.Windows.Point point3 = seg.Point3;  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		currentPoint = point3;  	}  	else if (type == typeof(PolyBezierSegment)) {  		// Draw connected Bézier curves  		PointCollection points = ((PolyBezierSegment)segment).Points;  		int count = points.Count;  		if (count > 0) {  			Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  			for (int idx = 0; idx < count - 2; idx += 3) {  				System.Windows.Point point1 = points [idx];  				System.Windows.Point point2 = points [idx + 1];  				System.Windows.Point point3 = points [idx + 2];  				AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			}  			currentPoint = points [count - 1];  		}  	}  	else if (type == typeof(ArcSegment)) {  		// Draw arc  		ArcSegment seg = (ArcSegment)segment;  		AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  		currentPoint = seg.Point;  	}  	else if (type == typeof(QuadraticBezierSegment)) {  		QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  		currentPoint = seg.Point2;  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  	}  	else if (type == typeof(PolyQuadraticBezierSegment)) {  		PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  		currentPoint = seg.Points [seg.Points.Count - 1];  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: foreach (PathSegment segment in figure.Segments) {  	Type type = segment.GetType ();  	if (type == typeof(LineSegment)) {  		// Draw a single line  		System.Windows.Point point = ((LineSegment)segment).Point;  		currentPoint = point;  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  	else if (type == typeof(PolyLineSegment)) {  		// Draw connected lines  		PointCollection points = ((PolyLineSegment)segment).Points;  		foreach (System.Windows.Point point in points) {  			currentPoint = point;  			// I forced myself not to optimize this assignment  			AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  		}  	}  	else if (type == typeof(BezierSegment)) {  		// Draw Bézier curve  		BezierSegment seg = (BezierSegment)segment;  		System.Windows.Point point1 = seg.Point1;  		System.Windows.Point point2 = seg.Point2;  		System.Windows.Point point3 = seg.Point3;  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		currentPoint = point3;  	}  	else if (type == typeof(PolyBezierSegment)) {  		// Draw connected Bézier curves  		PointCollection points = ((PolyBezierSegment)segment).Points;  		int count = points.Count;  		if (count > 0) {  			Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  			for (int idx = 0; idx < count - 2; idx += 3) {  				System.Windows.Point point1 = points [idx];  				System.Windows.Point point2 = points [idx + 1];  				System.Windows.Point point3 = points [idx + 2];  				AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  			}  			currentPoint = points [count - 1];  		}  	}  	else if (type == typeof(ArcSegment)) {  		// Draw arc  		ArcSegment seg = (ArcSegment)segment;  		AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  		currentPoint = seg.Point;  	}  	else if (type == typeof(QuadraticBezierSegment)) {  		QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  		currentPoint = seg.Point2;  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  	}  	else if (type == typeof(PolyQuadraticBezierSegment)) {  		PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  		currentPoint = seg.Points [seg.Points.Count - 1];  		// TODOWPF: Undone because XGraphics has no such curve type  		throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(LineSegment)) {  	// Draw a single line  	System.Windows.Point point = ((LineSegment)segment).Point;  	currentPoint = point;  	AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  }  else if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(LineSegment)) {  	// Draw a single line  	System.Windows.Point point = ((LineSegment)segment).Point;  	currentPoint = point;  	AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  }  else if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(LineSegment)) {  	// Draw a single line  	System.Windows.Point point = ((LineSegment)segment).Point;  	currentPoint = point;  	AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  }  else if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(LineSegment)) {  	// Draw a single line  	System.Windows.Point point = ((LineSegment)segment).Point;  	currentPoint = point;  	AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  }  else if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyLineSegment)) {  	// Draw connected lines  	PointCollection points = ((PolyLineSegment)segment).Points;  	foreach (System.Windows.Point point in points) {  		currentPoint = point;  		// I forced myself not to optimize this assignment  		AppendFormat ("{0:0.####} {1:0.####} l\n"' point.X' point.Y);  	}  }  else if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(BezierSegment)) {  	// Draw Bézier curve  	BezierSegment seg = (BezierSegment)segment;  	System.Windows.Point point1 = seg.Point1;  	System.Windows.Point point2 = seg.Point2;  	System.Windows.Point point3 = seg.Point3;  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	currentPoint = point3;  }  else if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (type == typeof(PolyBezierSegment)) {  	// Draw connected Bézier curves  	PointCollection points = ((PolyBezierSegment)segment).Points;  	int count = points.Count;  	if (count > 0) {  		Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  		for (int idx = 0; idx < count - 2; idx += 3) {  			System.Windows.Point point1 = points [idx];  			System.Windows.Point point2 = points [idx + 1];  			System.Windows.Point point3 = points [idx + 2];  			AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  		}  		currentPoint = points [count - 1];  	}  }  else if (type == typeof(ArcSegment)) {  	// Draw arc  	ArcSegment seg = (ArcSegment)segment;  	AppendPartialArc (currentPoint' seg.Point' seg.RotationAngle' seg.Size' seg.IsLargeArc' seg.SweepDirection' PathStart.Ignore1st);  	currentPoint = seg.Point;  }  else if (type == typeof(QuadraticBezierSegment)) {  	QuadraticBezierSegment seg = (QuadraticBezierSegment)segment;  	currentPoint = seg.Point2;  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with QuadraticBezierSegment.");  }  else if (type == typeof(PolyQuadraticBezierSegment)) {  	PolyQuadraticBezierSegment seg = (PolyQuadraticBezierSegment)segment;  	currentPoint = seg.Points [seg.Points.Count - 1];  	// TODOWPF: Undone because XGraphics has no such curve type  	throw new NotImplementedException ("AppendPath with PolyQuadraticBezierSegment.");  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (count > 0) {  	Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  	for (int idx = 0; idx < count - 2; idx += 3) {  		System.Windows.Point point1 = points [idx];  		System.Windows.Point point2 = points [idx + 1];  		System.Windows.Point point3 = points [idx + 2];  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	}  	currentPoint = points [count - 1];  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (count > 0) {  	Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  	for (int idx = 0; idx < count - 2; idx += 3) {  		System.Windows.Point point1 = points [idx];  		System.Windows.Point point2 = points [idx + 1];  		System.Windows.Point point3 = points [idx + 2];  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	}  	currentPoint = points [count - 1];  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (count > 0) {  	Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  	for (int idx = 0; idx < count - 2; idx += 3) {  		System.Windows.Point point1 = points [idx];  		System.Windows.Point point2 = points [idx + 1];  		System.Windows.Point point3 = points [idx + 2];  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	}  	currentPoint = points [count - 1];  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: if (count > 0) {  	Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  	for (int idx = 0; idx < count - 2; idx += 3) {  		System.Windows.Point point1 = points [idx];  		System.Windows.Point point2 = points [idx + 1];  		System.Windows.Point point3 = points [idx + 2];  		AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  	}  	currentPoint = points [count - 1];  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: Debug.Assert (count % 3 == 0' "Number of Points in PolyBezierSegment are not a multiple of 3.");  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: for (int idx = 0; idx < count - 2; idx += 3) {  	System.Windows.Point point1 = points [idx];  	System.Windows.Point point2 = points [idx + 1];  	System.Windows.Point point3 = points [idx + 2];  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: for (int idx = 0; idx < count - 2; idx += 3) {  	System.Windows.Point point1 = points [idx];  	System.Windows.Point point2 = points [idx + 1];  	System.Windows.Point point3 = points [idx + 2];  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: for (int idx = 0; idx < count - 2; idx += 3) {  	System.Windows.Point point1 = points [idx];  	System.Windows.Point point2 = points [idx + 1];  	System.Windows.Point point3 = points [idx + 2];  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' point1.X' point1.Y' point2.X' point2.Y' point3.X' point3.Y);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following statement contains a magic number: idx += 3
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfxState.Level == GraphicsStackLevelInitial) {  	// Flip page horizontaly and mirror text.  	// TODO: Is PageOriging and PageScale (== Viewport) useful? Or just public DefaultViewMatrix (like Presentation Manager has had)  	this.defaultViewMatrix = new XMatrix ();  	//XMatrix.Identity;  	if (this.gfx.PageDirection == XPageDirection.Downwards) {  		#if MIGRADOC  		          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  		{  			// Take TrimBox into account  			double pageHeight = Size.Height;  			XPoint trimOffset = new XPoint ();  			if (this.page != null && this.page.TrimMargins.AreSet) {  				pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  				trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  			}  			if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  			 {  				defaultViewMatrix.RotatePrepend (90);  				defaultViewMatrix.ScalePrepend (1' -1);  			}  			else {  				// Recall that the value of Height depends on Orientation.  				defaultViewMatrix.TranslatePrepend (0' pageHeight);  				defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  			}  			// Scale with page units  			switch (this.gfx.PageUnit) {  			case XGraphicsUnit.Inch:  				defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  				break;  			case XGraphicsUnit.Millimeter:  				defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  				break;  			case XGraphicsUnit.Centimeter:  				defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  				break;  			}  			if (trimOffset != new XPoint ()) {  				Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  				defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  			}  			// Save initial graphic state  			SaveState ();  			// Set page transformation  			double[] cm = defaultViewMatrix.GetElements ();  			AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  			AppendFormat ("-100 Tz\n");  		}  	}  	else {  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  	}  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.gfx.PageDirection == XPageDirection.Downwards) {  	#if MIGRADOC  	          if (this.pdflibHack)           {             // MigraDoc 1.1 (written in C++) based on PDFlib and our RenderContext for GDI+. To keep it running             // on PDFlib (and PGL) I need this hack here in the MigraDoc build of PDFsharp.             // The new and more flexible MigraDoc Rendering (written in C) doesn't need it anymore.             SaveState();             defaultViewMatrix.Translate(0' this.page.Height);             defaultViewMatrix.Scale(1' -1);           }           else #endif  	{  		// Take TrimBox into account  		double pageHeight = Size.Height;  		XPoint trimOffset = new XPoint ();  		if (this.page != null && this.page.TrimMargins.AreSet) {  			pageHeight += this.page.TrimMargins.Top.Point + this.page.TrimMargins.Bottom.Point;  			trimOffset = new XPoint (this.page.TrimMargins.Left.Point' this.page.TrimMargins.Top.Point);  		}  		if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer  		 {  			defaultViewMatrix.RotatePrepend (90);  			defaultViewMatrix.ScalePrepend (1' -1);  		}  		else {  			// Recall that the value of Height depends on Orientation.  			defaultViewMatrix.TranslatePrepend (0' pageHeight);  			defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  		}  		// Scale with page units  		switch (this.gfx.PageUnit) {  		case XGraphicsUnit.Inch:  			defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  			break;  		case XGraphicsUnit.Millimeter:  			defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  			break;  		case XGraphicsUnit.Centimeter:  			defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  			break;  		}  		if (trimOffset != new XPoint ()) {  			Debug.Assert (this.gfx.PageUnit == XGraphicsUnit.Point' "With TrimMargins set the page units must be Point. Ohter cases nyi.");  			defaultViewMatrix.TranslatePrepend (trimOffset.x' trimOffset.y);  		}  		// Save initial graphic state  		SaveState ();  		// Set page transformation  		double[] cm = defaultViewMatrix.GetElements ();  		AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  		AppendFormat ("-100 Tz\n");  	}  }  else {  	// Scale with page units  	switch (this.gfx.PageUnit) {  	case XGraphicsUnit.Inch:  		defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  		break;  	case XGraphicsUnit.Millimeter:  		defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  		break;  	case XGraphicsUnit.Centimeter:  		defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  		break;  	}  	// Save initial graphic state  	SaveState ();  	// Set page transformation  	double[] cm = defaultViewMatrix.GetElements ();  	AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer   {  	defaultViewMatrix.RotatePrepend (90);  	defaultViewMatrix.ScalePrepend (1' -1);  }  else {  	// Recall that the value of Height depends on Orientation.  	defaultViewMatrix.TranslatePrepend (0' pageHeight);  	defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: if (this.page != null && this.page.Elements.GetInteger ("/Rotate") == 90)// HACK for InDesign flyer   {  	defaultViewMatrix.RotatePrepend (90);  	defaultViewMatrix.ScalePrepend (1' -1);  }  else {  	// Recall that the value of Height depends on Orientation.  	defaultViewMatrix.TranslatePrepend (0' pageHeight);  	defaultViewMatrix.Scale (1' -1' XMatrixOrder.Prepend);  }  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: defaultViewMatrix.RotatePrepend (90);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following statement contains a magic number: AppendFormat ("{0:0.###} {1:0.###} {2:0.###} {3:0.###} {4:0.###} {5:0.###} cm "' cm [0]' cm [1]' cm [2]' cm [3]' cm [4]' cm [5]);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: Debug.Assert (α >= 0 && α <= 360);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sweepAngle) >= 360)  	sweepAngle = Math.Sign (sweepAngle) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sweepAngle) >= 360)  	sweepAngle = Math.Sign (sweepAngle) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: sweepAngle = Math.Sign (sweepAngle) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  else if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  else if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  else if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  else if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  else if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α == 0 && β < 0)  	α = 360;  else if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α == 0 && β < 0)  	α = 360;  else if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10) {  		if (α < Math.PI)  			α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  		else  			α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	}  	//α = Calc.πHalf - Math.Atan(δy * Math.Cos(α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10) {  		if (β < Math.PI)  			β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  		else  			β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	}  	//β = Calc.πHalf - Math.Atan(δy * Math.Cos(β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinα) > 1E-10) {  	if (α < Math.PI)  		α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	else  		α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinα) > 1E-10) {  	if (α < Math.PI)  		α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	else  		α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinα) > 1E-10) {  	if (α < Math.PI)  		α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	else  		α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinα) > 1E-10) {  	if (α < Math.PI)  		α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	else  		α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < Math.PI)  	α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  else  	α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < Math.PI)  	α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  else  	α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (α < Math.PI)  	α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  else  	α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: α = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinβ) > 1E-10) {  	if (β < Math.PI)  		β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	else  		β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinβ) > 1E-10) {  	if (β < Math.PI)  		β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	else  		β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinβ) > 1E-10) {  	if (β < Math.PI)  		β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	else  		β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (Math.Abs (sinβ) > 1E-10) {  	if (β < Math.PI)  		β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  	else  		β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < Math.PI)  	β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  else  	β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < Math.PI)  	β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  else  	β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: if (β < Math.PI)  	β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  else  	β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,CreateArcSegment,The following statement contains a magic number: β = 3 * Math.PI / 2 - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < 0)  	α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  else if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: α = α + (1 + Math.Floor ((Math.Abs (α) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α > 360)  	α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: α = α - Math.Floor (α / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: Debug.Assert (α >= 0 && α <= 360);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β < -360)  	β = -360;  else if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: β = -360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β > 360)  	β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: β = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α == 0 && β < 0)  	α = 360;  else if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α == 0 && β < 0)  	α = 360;  else if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: α = 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α == 360 && β > 0)  	α = 0;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (β < 0)  	β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: β = β + (1 + Math.Floor ((Math.Abs (β) / 360))) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (startQuadrant == endQuadrant && smallAngle)  	AppendPartialArcQuadrant (points' x' y' width' height' α' β' pathStart' matrix);  else {  	int currentQuadrant = startQuadrant;  	bool firstLoop = true;  	do {  		if (currentQuadrant == startQuadrant && firstLoop) {  			double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  		}  		else if (currentQuadrant == endQuadrant) {  			double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  		}  		else {  			double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  			double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  			AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  		}  		// Don't stop immediately if arc is greater than 270 degrees  		if (currentQuadrant == endQuadrant && smallAngle)  			break;  		smallAngle = true;  		if (clockwise)  			currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  		else  			currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  		firstLoop = false;  	}  	while (true);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: do {  	if (currentQuadrant == startQuadrant && firstLoop) {  		double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  	}  	else if (currentQuadrant == endQuadrant) {  		double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  	}  	else {  		double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  		double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  		AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  	}  	// Don't stop immediately if arc is greater than 270 degrees  	if (currentQuadrant == endQuadrant && smallAngle)  		break;  	smallAngle = true;  	if (clockwise)  		currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  	else  		currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  	firstLoop = false;  }  while (true);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == startQuadrant && firstLoop) {  	double ξ = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' α' ξ' pathStart' matrix);  }  else if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (currentQuadrant == endQuadrant) {  	double ξ = currentQuadrant * 90 + (clockwise ? 0 : 90);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ' β' PathStart.Ignore1st' matrix);  }  else {  	double ξ1 = currentQuadrant * 90 + (clockwise ? 0 : 90);  	double ξ2 = currentQuadrant * 90 + (clockwise ? 90 : 0);  	AppendPartialArcQuadrant (points' x' y' width' height' ξ1' ξ2' PathStart.Ignore1st' matrix);  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (clockwise)  	currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  else  	currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (clockwise)  	currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  else  	currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: currentQuadrant = currentQuadrant == 3 ? 0 : currentQuadrant + 1;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: currentQuadrant = currentQuadrant == 0 ? 3 : currentQuadrant - 1;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (φ > 360)  	φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (φ > 360)  	φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (φ > 360)  	φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: φ = φ - Math.Floor (φ / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if (quadrant * 90 == φ) {  	if ((start && !clockwise) || (!start && clockwise))  		quadrant = quadrant == 0 ? 3 : quadrant - 1;  }  else  	quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: if ((start && !clockwise) || (!start && clockwise))  	quadrant = quadrant == 0 ? 3 : quadrant - 1;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: quadrant = quadrant == 0 ? 3 : quadrant - 1;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,Quatrant,The following statement contains a magic number: quadrant = clockwise ? ((int)Math.Floor (φ / 90)) % 4 : (int)Math.Floor (φ / 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: Debug.Assert (α >= 0 && α <= 360);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (β > 360)  	β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: β = β - Math.Floor (β / 360) * 360;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: Debug.Assert (Math.Abs (α - β) <= 90);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (α >= 180 && β >= 180) {  	α -= 180;  	β -= 180;  	reflect = true;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: α -= 180;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: β -= 180;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10)  		α = Calc.πHalf - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10)  		β = Calc.πHalf - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (width == height) {  	// Circular arc needs no correction.  	α = α * Calc.Deg2Rad;  	β = β * Calc.Deg2Rad;  }  else {  	// Elliptic arc needs the angles to be adjusted such that the scaling transformation is compensated.  	α = α * Calc.Deg2Rad;  	sinα = Math.Sin (α);  	if (Math.Abs (sinα) > 1E-10)  		α = Calc.πHalf - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  	β = β * Calc.Deg2Rad;  	sinβ = Math.Sin (β);  	if (Math.Abs (sinβ) > 1E-10)  		β = Calc.πHalf - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (Math.Abs (sinα) > 1E-10)  	α = Calc.πHalf - Math.Atan (δy * Math.Cos (α) / (δx * sinα));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following statement contains a magic number: if (Math.Abs (sinβ) > 1E-10)  	β = Calc.πHalf - Math.Atan (δy * Math.Cos (β) / (δx * sinβ));  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (isLargeArc == (Math.Abs (β - α) < Math.PI)) {  	if (α < β)  		α += 2 * Math.PI;  	else  		β += 2 * Math.PI;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (isLargeArc == (Math.Abs (β - α) < Math.PI)) {  	if (α < β)  		α += 2 * Math.PI;  	else  		β += 2 * Math.PI;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < β)  	α += 2 * Math.PI;  else  	β += 2 * Math.PI;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: if (α < β)  	α += 2 * Math.PI;  else  	β += 2 * Math.PI;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: α += 2 * Math.PI;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: β += 2 * Math.PI;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: return BezierCurveFromArc (center.X - δx * factor' center.Y - δy' 2 * δx * factor' 2 * δy' α / Calc.Deg2Rad' sweepAngle / Calc.Deg2Rad' pathStart' ref matrix);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,BezierCurveFromArc,The following statement contains a magic number: return BezierCurveFromArc (center.X - δx * factor' center.Y - δy' 2 * δx * factor' 2 * δy' α / Calc.Deg2Rad' sweepAngle / Calc.Deg2Rad' pathStart' ref matrix);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (cosArcAngle >= 0) {  	if (isLargeArc) {  		// The angle is between 270 and 360 degrees' so   		pieces = 4;  	}  	else {  		// The angle is between 0 and 90 degrees' so  		pieces = 1;  		return;  		// We already have the cosine and sine of the angle  	}  }  else {  	if (isLargeArc) {  		// The angle is between 180 and 270 degrees' so  		pieces = 3;  	}  	else {  		// The angle is between 90 and 180 degrees' so  		pieces = 2;  	}  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (cosArcAngle >= 0) {  	if (isLargeArc) {  		// The angle is between 270 and 360 degrees' so   		pieces = 4;  	}  	else {  		// The angle is between 0 and 90 degrees' so  		pieces = 1;  		return;  		// We already have the cosine and sine of the angle  	}  }  else {  	if (isLargeArc) {  		// The angle is between 180 and 270 degrees' so  		pieces = 3;  	}  	else {  		// The angle is between 90 and 180 degrees' so  		pieces = 2;  	}  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (cosArcAngle >= 0) {  	if (isLargeArc) {  		// The angle is between 270 and 360 degrees' so   		pieces = 4;  	}  	else {  		// The angle is between 0 and 90 degrees' so  		pieces = 1;  		return;  		// We already have the cosine and sine of the angle  	}  }  else {  	if (isLargeArc) {  		// The angle is between 180 and 270 degrees' so  		pieces = 3;  	}  	else {  		// The angle is between 90 and 180 degrees' so  		pieces = 2;  	}  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (isLargeArc) {  	// The angle is between 270 and 360 degrees' so   	pieces = 4;  }  else {  	// The angle is between 0 and 90 degrees' so  	pieces = 1;  	return;  	// We already have the cosine and sine of the angle  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: pieces = 4;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (isLargeArc) {  	// The angle is between 180 and 270 degrees' so  	pieces = 3;  }  else {  	// The angle is between 90 and 180 degrees' so  	pieces = 2;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (isLargeArc) {  	// The angle is between 180 and 270 degrees' so  	pieces = 3;  }  else {  	// The angle is between 90 and 180 degrees' so  	pieces = 2;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: pieces = 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: pieces = 2;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (isClockwise) {  	if (angle < 0)  		angle += Math.PI * 2;  }  else {  	if (angle > 0)  		angle -= Math.PI * 2;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (isClockwise) {  	if (angle < 0)  		angle += Math.PI * 2;  }  else {  	if (angle > 0)  		angle -= Math.PI * 2;  }  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (angle < 0)  	angle += Math.PI * 2;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: angle += Math.PI * 2;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: if (angle > 0)  	angle -= Math.PI * 2;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetArcAngle,The following statement contains a magic number: angle -= Math.PI * 2;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: Debug.Assert (dot >= -radSquared * .1);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: Debug.Assert (dot <= radSquared * 1.1);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: dist = 4 * (radius - cos) / 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: dist = 4 * (radius - cos) / 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: if (dist <= sin * FUZZ)  	dist = 0;  else  	dist = 4 * (radius - cos) / sin / 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: if (dist <= sin * FUZZ)  	dist = 0;  else  	dist = 4 * (radius - cos) / sin / 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: dist = 4 * (radius - cos) / sin / 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,GetBezierDistance,The following statement contains a magic number: dist = 4 * (radius - cos) / sin / 3;  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,The following statement contains a magic number: matToEllipse = new XMatrix (cos * xRadius' -sin * xRadius' sin * yRadius' cos * yRadius' (xEnd + xStart) / 2' (yEnd + yStart) / 2);  
Magic Number,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,ArcToBezier,The following statement contains a magic number: matToEllipse = new XMatrix (cos * xRadius' -sin * xRadius' sin * yRadius' cos * yRadius' (xEnd + xStart) / 2' (yEnd + yStart) / 2);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,XColor,The following statement contains a magic number: this.a = (byte)((argb >> 24) & 0xff) / 255f;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,XColor,The following statement contains a magic number: this.r = (byte)((argb >> 16) & 0xff);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,XColor,The following statement contains a magic number: this.g = (byte)((argb >> 8) & 0xff);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor ((byte)(argb >> 24)' (byte)(argb >> 16)' (byte)(argb >> 8)' (byte)(argb));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor ((byte)(argb >> 24)' (byte)(argb >> 16)' (byte)(argb >> 8)' (byte)(argb));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor ((byte)(argb >> 24)' (byte)(argb >> 16)' (byte)(argb >> 8)' (byte)(argb));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor ((byte)(argb >> 24)' (byte)(argb >> 16)' (byte)(argb >> 8)' (byte)(argb));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor ((byte)(argb >> 24)' (byte)(argb >> 16)' (byte)(argb >> 8)' (byte)(argb));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor ((byte)(argb >> 24)' (byte)(argb >> 16)' (byte)(argb >> 8)' (byte)(argb));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: return new XColor (255' (byte)red' (byte)green' (byte)blue);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,FromArgb,The following statement contains a magic number: color.A = ((byte)alpha) / 255.0;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,ToGdiColor,The following statement contains a magic number: return System.Drawing.Color.FromArgb ((int)(this.a * 255)' this.r' this.g' this.b);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,ToWpfColor,The following statement contains a magic number: return System.Windows.Media.Color.FromArgb ((byte)(this.a * 255)' this.r' this.g' this.b);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetHashCode,The following statement contains a magic number: return ((byte)(this.a * 255)) ^ this.r ^ this.g ^ this.b;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetHue,The following statement contains a magic number: value7 *= 60;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetHue,The following statement contains a magic number: if (value7 < 0)  	value7 += 360;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetHue,The following statement contains a magic number: value7 += 360;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetSaturation,The following statement contains a magic number: if (value6 <= 0.5)  	return (value4 - value5) / (value4 + value5);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GetBrightness,The following statement contains a magic number: return (value4 + value5) / 2;  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,RgbChanged,The following statement contains a magic number: if (k == 255)  	this.c = this.m = this.y = 0;  else {  	float black = 255f - k;  	this.c = (c - k) / black;  	this.m = (m - k) / black;  	this.y = (y - k) / black;  }  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,CmykChanged,The following statement contains a magic number: this.r = (byte)(255 - Math.Min (255f' this.c * factor + black));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,CmykChanged,The following statement contains a magic number: this.g = (byte)(255 - Math.Min (255f' this.m * factor + black));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,CmykChanged,The following statement contains a magic number: this.b = (byte)(255 - Math.Min (255f' this.y * factor + black));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,CmykChanged,The following statement contains a magic number: this.gs = (float)(1 - Math.Min (1.0' 0.3f * this.c + 0.59f * this.m + 0.11 * this.y + this.k));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GrayChanged,The following statement contains a magic number: this.r = (byte)(this.gs * 255);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GrayChanged,The following statement contains a magic number: this.g = (byte)(this.gs * 255);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,GrayChanged,The following statement contains a magic number: this.b = (byte)(this.gs * 255);  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,CheckByte,The following statement contains a magic number: if (val < 0 || val > 0xFF)  	throw new ArgumentException (PSSR.InvalidValue (val' name' 0' 255));  
Magic Number,PdfSharp.Drawing,XColor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColor.cs,CheckByte,The following statement contains a magic number: throw new ArgumentException (PSSR.InvalidValue (val' name' 0' 255));  
Magic Number,PdfSharp.Drawing,XColorResourceManager,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColorResourceManager.cs,ToColorName,The following statement contains a magic number: if (color.IsKnownColor)  	name = ToColorName (XKnownColorTable.GetKnownColor (color.Argb));  else  	name = String.Format ("{0}' {1}' {2}' {3}"' (int)(255 * color.A)' color.R' color.G' color.B);  
Magic Number,PdfSharp.Drawing,XColorResourceManager,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XColorResourceManager.cs,ToColorName,The following statement contains a magic number: name = String.Format ("{0}' {1}' {2}' {3}"' (int)(255 * color.A)' color.R' color.G' color.B);  
Magic Number,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,GetHeight,The following statement contains a magic number: Debug.Assert (DoubleUtil.AreRoughlyEqual (gdiValue' myValue' 5)' "Check formula.");  
Magic Number,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,GetHeight,The following statement contains a magic number: if (graphics.targetContext == XGraphicTargetContext.GDI) {  	RealizeGdiFont ();  	#if DEBUG  	double value = this.font.GetHeight (graphics.gfx);  	// 2355*(0.3/2048)*96 = 33.11719   	double myValue = this.cellSpace * (this.emSize / (96 * this.unitsPerEm)) * 96;  	myValue = this.cellSpace * this.emSize / this.unitsPerEm;  	//Debug.Assert(value == myValue' "??");  	//Debug.Assert(value - myValue < 1e-3' "??");  	#endif  	return this.font.GetHeight (graphics.gfx);  }  else if (graphics.targetContext == XGraphicTargetContext.WPF) {  	double value = this.cellSpace * this.emSize / this.unitsPerEm;  	return value;  }  
Magic Number,PdfSharp.Drawing,XFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFont.cs,GetHeight,The following statement contains a magic number: if (graphics.targetContext == XGraphicTargetContext.GDI) {  	RealizeGdiFont ();  	#if DEBUG  	double value = this.font.GetHeight (graphics.gfx);  	// 2355*(0.3/2048)*96 = 33.11719   	double myValue = this.cellSpace * (this.emSize / (96 * this.unitsPerEm)) * 96;  	myValue = this.cellSpace * this.emSize / this.unitsPerEm;  	//Debug.Assert(value == myValue' "??");  	//Debug.Assert(value - myValue < 1e-3' "??");  	#endif  	return this.font.GetHeight (graphics.gfx);  }  else if (graphics.targetContext == XGraphicTargetContext.WPF) {  	double value = this.cellSpace * this.emSize / this.unitsPerEm;  	return value;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following statement contains a magic number: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,Clear,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.Clear (color.ToGdiColor ());  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		Rect rc = new Rect ();  		rc.Width = rc.Height = 10000;  		this.dc.DrawRectangle (new SolidColorBrush (color.ToWpfColor ())' null' rc);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,Clear,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	Rect rc = new Rect ();  	rc.Width = rc.Height = 10000;  	this.dc.DrawRectangle (new SolidColorBrush (color.ToWpfColor ())' null' rc);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,Clear,The following statement contains a magic number: rc.Width = rc.Height = 10000;  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLine,The following statement contains a magic number: if (this.renderer != null)  	this.renderer.DrawLines (pen' new XPoint[2] {  		new XPoint (x1' y1)'  		new XPoint (x2' y2)  	});  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLine,The following statement contains a magic number: this.renderer.DrawLines (pen' new XPoint[2] {  	new XPoint (x1' y1)'  	new XPoint (x2' y2)  });  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: for (int idx = 0; idx < length / 2; idx++) {  	points [idx + 1].X = value [2 * idx];  	points [idx + 1].Y = value [2 * idx + 1];  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: for (int idx = 0; idx < length / 2; idx++) {  	points [idx + 1].X = value [2 * idx];  	points [idx + 1].Y = value [2 * idx + 1];  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: for (int idx = 0; idx < length / 2; idx++) {  	points [idx + 1].X = value [2 * idx];  	points [idx + 1].Y = value [2 * idx + 1];  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: points [idx + 1].X = value [2 * idx];  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawLines,The following statement contains a magic number: points [idx + 1].Y = value [2 * idx + 1];  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The following statement contains a magic number: if (this.renderer != null)  	this.renderer.DrawBeziers (pen' new XPoint[4] {  		new XPoint (x1' y1)'  		new XPoint (x2' y2)'  		new XPoint (x3' y3)'  		new XPoint (x4' y4)  	});  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBezier,The following statement contains a magic number: this.renderer.DrawBeziers (pen' new XPoint[4] {  	new XPoint (x1' y1)'  	new XPoint (x2' y2)'  	new XPoint (x3' y3)'  	new XPoint (x4' y4)  });  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if ((count - 1) % 3 != 0)  	throw new ArgumentException ("Invalid number of points for bezier curves. Number must fulfil 4+3n."' "points");  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawBeziers (pen.RealizeGdiPen ()' MakePointFArray (points));  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		for (int idx = 1; idx < count; idx += 3) {  			BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  			figure.Segments.Add (seg);  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawBeziers (pen.RealizeGdiPen ()' MakePointFArray (points));  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		for (int idx = 1; idx < count; idx += 3) {  			BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  			figure.Segments.Add (seg);  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawBeziers (pen.RealizeGdiPen ()' MakePointFArray (points));  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		for (int idx = 1; idx < count; idx += 3) {  			BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  			figure.Segments.Add (seg);  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	for (int idx = 1; idx < count; idx += 3) {  		BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  		figure.Segments.Add (seg);  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	for (int idx = 1; idx < count; idx += 3) {  		BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  		figure.Segments.Add (seg);  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	for (int idx = 1; idx < count; idx += 3) {  		BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  		figure.Segments.Add (seg);  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3) {  	BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  	figure.Segments.Add (seg);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3) {  	BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  	figure.Segments.Add (seg);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3) {  	BezierSegment seg = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  	figure.Segments.Add (seg);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawBeziers,The following statement contains a magic number: idx += 3
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: DrawCurve (pen' MakePointFArray (points)' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: DrawCurve (pen' MakeXPointArray (points)' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: DrawCurve (pen' MakeXPointArray (points)' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: DrawCurve (pen' points' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count < 2)  	throw new ArgumentException ("DrawCurve requires two or more points."' "points");  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		tension /= 3;  		PathFigure figure = new PathFigure ();  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	tension /= 3;  	PathFigure figure = new PathFigure ();  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: tension /= 3;  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawArc,The following statement contains a magic number: if (Math.Abs (sweepAngle) >= 360) {  	DrawEllipse (pen' x' y' width' height);  }  else {  	if (this.drawGraphics) {  		#if GDI  		if (this.targetContext == XGraphicTargetContext.GDI)  			this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle);  		#endif  		#if WPF  		if (this.targetContext == XGraphicTargetContext.WPF) {  			System.Windows.Point startPoint;  			ArcSegment seg = GeometryHelper.CreateArcSegment (x' y' width' height' startAngle' sweepAngle' out startPoint);  			PathFigure figure = new PathFigure ();  			figure.StartPoint = startPoint;  			figure.Segments.Add (seg);  			PathGeometry geo = new PathGeometry ();  			geo.Figures.Add (figure);  			this.dc.DrawGeometry (null' pen.RealizeWpfPen ()' geo);  		}  		#endif  	}  	if (this.renderer != null)  		this.renderer.DrawArc (pen' x' y' width' height' startAngle' sweepAngle);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		XGraphicsPath path = new XGraphicsPath ();  		path.AddRoundedRectangle (x' y' width' height' ellipseWidth' ellipseHeight);  		DrawPath (pen' brush' path);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		XGraphicsPath path = new XGraphicsPath ();  		path.AddRoundedRectangle (x' y' width' height' ellipseWidth' ellipseHeight);  		DrawPath (pen' brush' path);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The following statement contains a magic number: this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawRoundedRectangle,The following statement contains a magic number: this.dc.DrawRoundedRectangle (brush != null ? brush.RealizeWpfBrush () : null' pen != null ? pen.RealizeWpfPen () : null' new Rect (x' y' width' height)' ellipseWidth / 2' ellipseHeight / 2);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (null' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (null' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (null' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.GDI)  	this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	double radiusX = width / 2;  	double radiusY = height / 2;  	this.dc.DrawEllipse (null' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	double radiusX = width / 2;  	double radiusY = height / 2;  	this.dc.DrawEllipse (null' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.FillEllipse (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (brush.RealizeWpfBrush ()' null' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI)  		this.gfx.FillEllipse (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height);  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (brush.RealizeWpfBrush ()' null' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	double radiusX = width / 2;  	double radiusY = height / 2;  	this.dc.DrawEllipse (brush.RealizeWpfBrush ()' null' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	double radiusX = width / 2;  	double radiusY = height / 2;  	this.dc.DrawEllipse (brush.RealizeWpfBrush ()' null' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		this.gfx.FillEllipse (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height);  		this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (brush.RealizeWpfBrush ()' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		this.gfx.FillEllipse (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height);  		this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (brush.RealizeWpfBrush ()' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		this.gfx.FillEllipse (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height);  		this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		double radiusX = width / 2;  		double radiusY = height / 2;  		this.dc.DrawEllipse (brush.RealizeWpfBrush ()' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.GDI) {  	this.gfx.FillEllipse (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height);  	this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: this.gfx.DrawArc (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' 0' 360);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	double radiusX = width / 2;  	double radiusY = height / 2;  	this.dc.DrawEllipse (brush.RealizeWpfBrush ()' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawEllipse,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	double radiusX = width / 2;  	double radiusY = height / 2;  	this.dc.DrawEllipse (brush.RealizeWpfBrush ()' pen.RealizeWpfPen ()' new System.Windows.Point (x + radiusX' y + radiusY)' radiusX' radiusY);  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: if (points.Length < 2)  	throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPolygon,The following statement contains a magic number: throw new ArgumentException ("points"' PSSR.PointArrayAtLeast (2));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		this.gfx.FillPie (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle);  		this.gfx.DrawPie (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		System.Windows.Point center = new System.Windows.Point (x + width / 2' y + height / 2);  		System.Windows.Point startArc;  		ArcSegment arc = GeometryHelper.CreateArcSegment (x' y' width' height' startAngle' sweepAngle' out startArc);  		PathFigure figure = new PathFigure ();  		figure.StartPoint = center;  		figure.Segments.Add (new LineSegment (startArc' true));  		figure.Segments.Add (arc);  		figure.IsClosed = true;  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		this.gfx.FillPie (brush.RealizeGdiBrush ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle);  		this.gfx.DrawPie (pen.RealizeGdiPen ()' (float)x' (float)y' (float)width' (float)height' (float)startAngle' (float)sweepAngle);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		System.Windows.Point center = new System.Windows.Point (x + width / 2' y + height / 2);  		System.Windows.Point startArc;  		ArcSegment arc = GeometryHelper.CreateArcSegment (x' y' width' height' startAngle' sweepAngle' out startArc);  		PathFigure figure = new PathFigure ();  		figure.StartPoint = center;  		figure.Segments.Add (new LineSegment (startArc' true));  		figure.Segments.Add (arc);  		figure.IsClosed = true;  		PathGeometry geo = new PathGeometry ();  		geo.Figures.Add (figure);  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	System.Windows.Point center = new System.Windows.Point (x + width / 2' y + height / 2);  	System.Windows.Point startArc;  	ArcSegment arc = GeometryHelper.CreateArcSegment (x' y' width' height' startAngle' sweepAngle' out startArc);  	PathFigure figure = new PathFigure ();  	figure.StartPoint = center;  	figure.Segments.Add (new LineSegment (startArc' true));  	figure.Segments.Add (arc);  	figure.IsClosed = true;  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawPie,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	System.Windows.Point center = new System.Windows.Point (x + width / 2' y + height / 2);  	System.Windows.Point startArc;  	ArcSegment arc = GeometryHelper.CreateArcSegment (x' y' width' height' startAngle' sweepAngle' out startArc);  	PathFigure figure = new PathFigure ();  	figure.StartPoint = center;  	figure.Segments.Add (new LineSegment (startArc' true));  	figure.Segments.Add (arc);  	figure.IsClosed = true;  	PathGeometry geo = new PathGeometry ();  	geo.Figures.Add (figure);  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' null' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' null' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' null' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' null' points' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' points' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' MakeXPointArray (points)' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' MakeXPointArray (points)' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' MakeXPointArray (points)' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (null' brush' points' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' MakeXPointArray (points)' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' points' XFillMode.Alternate' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' MakeXPointArray (points)' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' MakeXPointArray (points)' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' MakeXPointArray (points)' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: DrawClosedCurve (pen' brush' points' fillmode' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count < 2)  	throw new ArgumentException ("Not enough points."' "points");  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		if (brush != null)  			this.gfx.FillClosedCurve (brush.RealizeGdiBrush ()' MakePointFArray (points)' (FillMode)fillmode' (float)tension);  		if (pen != null) {  			// The fillmode is not used by DrawClosedCurve  			this.gfx.DrawClosedCurve (pen.RealizeGdiPen ()' MakePointFArray (points)' (float)tension' (FillMode)fillmode);  		}  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		tension /= 3;  		// Simply tried out. Not proofed why it is correct.  		PathFigure figure = new PathFigure ();  		figure.IsClosed = true;  		figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  		if (count == 2) {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  		}  		else {  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  			for (int idx = 1; idx < count - 2; idx++)  				figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  		}  		PathGeometry geo = new PathGeometry ();  		geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  		geo.Figures.Add (figure);  		System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  		System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  		this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  		#else  		          // AGHACK #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	tension /= 3;  	// Simply tried out. Not proofed why it is correct.  	PathFigure figure = new PathFigure ();  	figure.IsClosed = true;  	figure.StartPoint = new System.Windows.Point (points [0].x' points [0].y);  	if (count == 2) {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  	}  	else {  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  		for (int idx = 1; idx < count - 2; idx++)  			figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  	}  	PathGeometry geo = new PathGeometry ();  	geo.FillRule = fillmode == XFillMode.Alternate ? FillRule.EvenOdd : FillRule.Nonzero;  	geo.Figures.Add (figure);  	System.Windows.Media.Brush wpfBrush = brush != null ? brush.RealizeWpfBrush () : null;  	System.Windows.Media.Pen wpfPen = pen != null ? pen.RealizeWpfPen () : null;  	this.dc.DrawGeometry (wpfBrush' wpfPen' geo);  	#else  	          // AGHACK #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: tension /= 3;  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		RectangleF rect = layoutRectangle.ToRectangleF ();  		if (format.LineAlignment == XLineAlignment.BaseLine) {  			double lineSpace = font.GetHeight (this);  			int cellSpace = font.FontFamily.GetLineSpacing (font.Style);  			int cellAscent = font.FontFamily.GetCellAscent (font.Style);  			int cellDescent = font.FontFamily.GetCellDescent (font.Style);  			double cyAscent = lineSpace * cellAscent / cellSpace;  			cyAscent = lineSpace * font.cellAscent / font.cellSpace;  			rect.Offset (0' (float)-cyAscent);  		}  		this.gfx.DrawString (text' font.RealizeGdiFont ()' brush.RealizeGdiBrush ()' rect' format != null ? format.RealizeGdiStringFormat () : null);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		double x = layoutRectangle.X;  		double y = layoutRectangle.Y;  		double lineSpace = font.GetHeight (this);  		double cyAscent = lineSpace * font.cellAscent / font.cellSpace;  		double cyDescent = lineSpace * font.cellDescent / font.cellSpace;  		bool bold = (font.Style & XFontStyle.Bold) != 0;  		bool italic = (font.Style & XFontStyle.Italic) != 0;  		bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;  		bool underline = (font.Style & XFontStyle.Underline) != 0;  		//FormattedText formattedText = new FormattedText(text' new CultureInfo("en-us")' // WPFHACK  		//  FlowDirection.LeftToRight' font.typeface' font.Size' brush.RealizeWpfBrush());  		FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ());  		//formattedText.SetTextDecorations(TextDecorations.OverLine);  		switch (format.Alignment) {  		case XStringAlignment.Near:  			// nothing to do' this is the default  			//formattedText.TextAlignment = TextAlignment.Left;  			break;  		case XStringAlignment.Center:  			x += layoutRectangle.Width / 2;  			formattedText.TextAlignment = TextAlignment.Center;  			break;  		case XStringAlignment.Far:  			x += layoutRectangle.Width;  			formattedText.TextAlignment = TextAlignment.Right;  			break;  		}  		if (PageDirection == XPageDirection.Downwards) {  			switch (format.LineAlignment) {  			case XLineAlignment.Near:  				//y += cyAscent;  				break;  			case XLineAlignment.Center:  				// TODO use CapHeight. PDFlib also uses 3/4 of ascent  				y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  				//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  				break;  			case XLineAlignment.Far:  				y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  				break;  			case XLineAlignment.BaseLine:  				y -= formattedText.Baseline;  				break;  			}  		}  		else {  			// TODOWPF: make unit test  			switch (format.LineAlignment) {  			case XLineAlignment.Near:  				//y += cyDescent;  				break;  			case XLineAlignment.Center:  				// TODO use CapHeight. PDFlib also uses 3/4 of ascent  				//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  				break;  			case XLineAlignment.Far:  				//y += -cyAscent + rect.Height;  				break;  			case XLineAlignment.BaseLine:  				// nothing to do  				break;  			}  		}  		//if (bold && !descriptor.IsBoldFace)  		//{  		//  // TODO: emulate bold by thicker outline  		//}  		//if (italic && !descriptor.IsBoldFace)  		//{  		//  // TODO: emulate italic by shearing transformation  		//}  		if (underline) {  			formattedText.SetTextDecorations (TextDecorations.Underline);  			//double underlinePosition = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlinePosition / font.cellSpace;  			//double underlineThickness = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlineThickness / font.cellSpace;  			//DrawRectangle(null' brush' x' y - underlinePosition' width' underlineThickness);  		}  		if (strikeout) {  			formattedText.SetTextDecorations (TextDecorations.Strikethrough);  			//double strikeoutPosition = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutPosition / font.cellSpace;  			//double strikeoutSize = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutSize / font.cellSpace;  			//DrawRectangle(null' brush' x' y - strikeoutPosition - strikeoutSize' width' strikeoutSize);  		}  		//this.dc.DrawText(formattedText' layoutRectangle.Location.ToPoint());  		this.dc.DrawText (formattedText' new System.Windows.Point (x' y));  		#else  		          dc.DrawString(this' text' font' brush' layoutRectangle' format); #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		RectangleF rect = layoutRectangle.ToRectangleF ();  		if (format.LineAlignment == XLineAlignment.BaseLine) {  			double lineSpace = font.GetHeight (this);  			int cellSpace = font.FontFamily.GetLineSpacing (font.Style);  			int cellAscent = font.FontFamily.GetCellAscent (font.Style);  			int cellDescent = font.FontFamily.GetCellDescent (font.Style);  			double cyAscent = lineSpace * cellAscent / cellSpace;  			cyAscent = lineSpace * font.cellAscent / font.cellSpace;  			rect.Offset (0' (float)-cyAscent);  		}  		this.gfx.DrawString (text' font.RealizeGdiFont ()' brush.RealizeGdiBrush ()' rect' format != null ? format.RealizeGdiStringFormat () : null);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		double x = layoutRectangle.X;  		double y = layoutRectangle.Y;  		double lineSpace = font.GetHeight (this);  		double cyAscent = lineSpace * font.cellAscent / font.cellSpace;  		double cyDescent = lineSpace * font.cellDescent / font.cellSpace;  		bool bold = (font.Style & XFontStyle.Bold) != 0;  		bool italic = (font.Style & XFontStyle.Italic) != 0;  		bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;  		bool underline = (font.Style & XFontStyle.Underline) != 0;  		//FormattedText formattedText = new FormattedText(text' new CultureInfo("en-us")' // WPFHACK  		//  FlowDirection.LeftToRight' font.typeface' font.Size' brush.RealizeWpfBrush());  		FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ());  		//formattedText.SetTextDecorations(TextDecorations.OverLine);  		switch (format.Alignment) {  		case XStringAlignment.Near:  			// nothing to do' this is the default  			//formattedText.TextAlignment = TextAlignment.Left;  			break;  		case XStringAlignment.Center:  			x += layoutRectangle.Width / 2;  			formattedText.TextAlignment = TextAlignment.Center;  			break;  		case XStringAlignment.Far:  			x += layoutRectangle.Width;  			formattedText.TextAlignment = TextAlignment.Right;  			break;  		}  		if (PageDirection == XPageDirection.Downwards) {  			switch (format.LineAlignment) {  			case XLineAlignment.Near:  				//y += cyAscent;  				break;  			case XLineAlignment.Center:  				// TODO use CapHeight. PDFlib also uses 3/4 of ascent  				y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  				//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  				break;  			case XLineAlignment.Far:  				y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  				break;  			case XLineAlignment.BaseLine:  				y -= formattedText.Baseline;  				break;  			}  		}  		else {  			// TODOWPF: make unit test  			switch (format.LineAlignment) {  			case XLineAlignment.Near:  				//y += cyDescent;  				break;  			case XLineAlignment.Center:  				// TODO use CapHeight. PDFlib also uses 3/4 of ascent  				//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  				break;  			case XLineAlignment.Far:  				//y += -cyAscent + rect.Height;  				break;  			case XLineAlignment.BaseLine:  				// nothing to do  				break;  			}  		}  		//if (bold && !descriptor.IsBoldFace)  		//{  		//  // TODO: emulate bold by thicker outline  		//}  		//if (italic && !descriptor.IsBoldFace)  		//{  		//  // TODO: emulate italic by shearing transformation  		//}  		if (underline) {  			formattedText.SetTextDecorations (TextDecorations.Underline);  			//double underlinePosition = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlinePosition / font.cellSpace;  			//double underlineThickness = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlineThickness / font.cellSpace;  			//DrawRectangle(null' brush' x' y - underlinePosition' width' underlineThickness);  		}  		if (strikeout) {  			formattedText.SetTextDecorations (TextDecorations.Strikethrough);  			//double strikeoutPosition = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutPosition / font.cellSpace;  			//double strikeoutSize = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutSize / font.cellSpace;  			//DrawRectangle(null' brush' x' y - strikeoutPosition - strikeoutSize' width' strikeoutSize);  		}  		//this.dc.DrawText(formattedText' layoutRectangle.Location.ToPoint());  		this.dc.DrawText (formattedText' new System.Windows.Point (x' y));  		#else  		          dc.DrawString(this' text' font' brush' layoutRectangle' format); #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (this.drawGraphics) {  	#if GDI  	if (this.targetContext == XGraphicTargetContext.GDI) {  		RectangleF rect = layoutRectangle.ToRectangleF ();  		if (format.LineAlignment == XLineAlignment.BaseLine) {  			double lineSpace = font.GetHeight (this);  			int cellSpace = font.FontFamily.GetLineSpacing (font.Style);  			int cellAscent = font.FontFamily.GetCellAscent (font.Style);  			int cellDescent = font.FontFamily.GetCellDescent (font.Style);  			double cyAscent = lineSpace * cellAscent / cellSpace;  			cyAscent = lineSpace * font.cellAscent / font.cellSpace;  			rect.Offset (0' (float)-cyAscent);  		}  		this.gfx.DrawString (text' font.RealizeGdiFont ()' brush.RealizeGdiBrush ()' rect' format != null ? format.RealizeGdiStringFormat () : null);  	}  	#endif  	#if WPF  	if (this.targetContext == XGraphicTargetContext.WPF) {  		#if !SILVERLIGHT  		double x = layoutRectangle.X;  		double y = layoutRectangle.Y;  		double lineSpace = font.GetHeight (this);  		double cyAscent = lineSpace * font.cellAscent / font.cellSpace;  		double cyDescent = lineSpace * font.cellDescent / font.cellSpace;  		bool bold = (font.Style & XFontStyle.Bold) != 0;  		bool italic = (font.Style & XFontStyle.Italic) != 0;  		bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;  		bool underline = (font.Style & XFontStyle.Underline) != 0;  		//FormattedText formattedText = new FormattedText(text' new CultureInfo("en-us")' // WPFHACK  		//  FlowDirection.LeftToRight' font.typeface' font.Size' brush.RealizeWpfBrush());  		FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ());  		//formattedText.SetTextDecorations(TextDecorations.OverLine);  		switch (format.Alignment) {  		case XStringAlignment.Near:  			// nothing to do' this is the default  			//formattedText.TextAlignment = TextAlignment.Left;  			break;  		case XStringAlignment.Center:  			x += layoutRectangle.Width / 2;  			formattedText.TextAlignment = TextAlignment.Center;  			break;  		case XStringAlignment.Far:  			x += layoutRectangle.Width;  			formattedText.TextAlignment = TextAlignment.Right;  			break;  		}  		if (PageDirection == XPageDirection.Downwards) {  			switch (format.LineAlignment) {  			case XLineAlignment.Near:  				//y += cyAscent;  				break;  			case XLineAlignment.Center:  				// TODO use CapHeight. PDFlib also uses 3/4 of ascent  				y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  				//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  				break;  			case XLineAlignment.Far:  				y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  				break;  			case XLineAlignment.BaseLine:  				y -= formattedText.Baseline;  				break;  			}  		}  		else {  			// TODOWPF: make unit test  			switch (format.LineAlignment) {  			case XLineAlignment.Near:  				//y += cyDescent;  				break;  			case XLineAlignment.Center:  				// TODO use CapHeight. PDFlib also uses 3/4 of ascent  				//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  				break;  			case XLineAlignment.Far:  				//y += -cyAscent + rect.Height;  				break;  			case XLineAlignment.BaseLine:  				// nothing to do  				break;  			}  		}  		//if (bold && !descriptor.IsBoldFace)  		//{  		//  // TODO: emulate bold by thicker outline  		//}  		//if (italic && !descriptor.IsBoldFace)  		//{  		//  // TODO: emulate italic by shearing transformation  		//}  		if (underline) {  			formattedText.SetTextDecorations (TextDecorations.Underline);  			//double underlinePosition = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlinePosition / font.cellSpace;  			//double underlineThickness = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlineThickness / font.cellSpace;  			//DrawRectangle(null' brush' x' y - underlinePosition' width' underlineThickness);  		}  		if (strikeout) {  			formattedText.SetTextDecorations (TextDecorations.Strikethrough);  			//double strikeoutPosition = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutPosition / font.cellSpace;  			//double strikeoutSize = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutSize / font.cellSpace;  			//DrawRectangle(null' brush' x' y - strikeoutPosition - strikeoutSize' width' strikeoutSize);  		}  		//this.dc.DrawText(formattedText' layoutRectangle.Location.ToPoint());  		this.dc.DrawText (formattedText' new System.Windows.Point (x' y));  		#else  		          dc.DrawString(this' text' font' brush' layoutRectangle' format); #endif  	}  	#endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	double x = layoutRectangle.X;  	double y = layoutRectangle.Y;  	double lineSpace = font.GetHeight (this);  	double cyAscent = lineSpace * font.cellAscent / font.cellSpace;  	double cyDescent = lineSpace * font.cellDescent / font.cellSpace;  	bool bold = (font.Style & XFontStyle.Bold) != 0;  	bool italic = (font.Style & XFontStyle.Italic) != 0;  	bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;  	bool underline = (font.Style & XFontStyle.Underline) != 0;  	//FormattedText formattedText = new FormattedText(text' new CultureInfo("en-us")' // WPFHACK  	//  FlowDirection.LeftToRight' font.typeface' font.Size' brush.RealizeWpfBrush());  	FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ());  	//formattedText.SetTextDecorations(TextDecorations.OverLine);  	switch (format.Alignment) {  	case XStringAlignment.Near:  		// nothing to do' this is the default  		//formattedText.TextAlignment = TextAlignment.Left;  		break;  	case XStringAlignment.Center:  		x += layoutRectangle.Width / 2;  		formattedText.TextAlignment = TextAlignment.Center;  		break;  	case XStringAlignment.Far:  		x += layoutRectangle.Width;  		formattedText.TextAlignment = TextAlignment.Right;  		break;  	}  	if (PageDirection == XPageDirection.Downwards) {  		switch (format.LineAlignment) {  		case XLineAlignment.Near:  			//y += cyAscent;  			break;  		case XLineAlignment.Center:  			// TODO use CapHeight. PDFlib also uses 3/4 of ascent  			y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  			//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  			break;  		case XLineAlignment.Far:  			y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  			break;  		case XLineAlignment.BaseLine:  			y -= formattedText.Baseline;  			break;  		}  	}  	else {  		// TODOWPF: make unit test  		switch (format.LineAlignment) {  		case XLineAlignment.Near:  			//y += cyDescent;  			break;  		case XLineAlignment.Center:  			// TODO use CapHeight. PDFlib also uses 3/4 of ascent  			//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  			break;  		case XLineAlignment.Far:  			//y += -cyAscent + rect.Height;  			break;  		case XLineAlignment.BaseLine:  			// nothing to do  			break;  		}  	}  	//if (bold && !descriptor.IsBoldFace)  	//{  	//  // TODO: emulate bold by thicker outline  	//}  	//if (italic && !descriptor.IsBoldFace)  	//{  	//  // TODO: emulate italic by shearing transformation  	//}  	if (underline) {  		formattedText.SetTextDecorations (TextDecorations.Underline);  		//double underlinePosition = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlinePosition / font.cellSpace;  		//double underlineThickness = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlineThickness / font.cellSpace;  		//DrawRectangle(null' brush' x' y - underlinePosition' width' underlineThickness);  	}  	if (strikeout) {  		formattedText.SetTextDecorations (TextDecorations.Strikethrough);  		//double strikeoutPosition = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutPosition / font.cellSpace;  		//double strikeoutSize = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutSize / font.cellSpace;  		//DrawRectangle(null' brush' x' y - strikeoutPosition - strikeoutSize' width' strikeoutSize);  	}  	//this.dc.DrawText(formattedText' layoutRectangle.Location.ToPoint());  	this.dc.DrawText (formattedText' new System.Windows.Point (x' y));  	#else  	          dc.DrawString(this' text' font' brush' layoutRectangle' format); #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	double x = layoutRectangle.X;  	double y = layoutRectangle.Y;  	double lineSpace = font.GetHeight (this);  	double cyAscent = lineSpace * font.cellAscent / font.cellSpace;  	double cyDescent = lineSpace * font.cellDescent / font.cellSpace;  	bool bold = (font.Style & XFontStyle.Bold) != 0;  	bool italic = (font.Style & XFontStyle.Italic) != 0;  	bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;  	bool underline = (font.Style & XFontStyle.Underline) != 0;  	//FormattedText formattedText = new FormattedText(text' new CultureInfo("en-us")' // WPFHACK  	//  FlowDirection.LeftToRight' font.typeface' font.Size' brush.RealizeWpfBrush());  	FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ());  	//formattedText.SetTextDecorations(TextDecorations.OverLine);  	switch (format.Alignment) {  	case XStringAlignment.Near:  		// nothing to do' this is the default  		//formattedText.TextAlignment = TextAlignment.Left;  		break;  	case XStringAlignment.Center:  		x += layoutRectangle.Width / 2;  		formattedText.TextAlignment = TextAlignment.Center;  		break;  	case XStringAlignment.Far:  		x += layoutRectangle.Width;  		formattedText.TextAlignment = TextAlignment.Right;  		break;  	}  	if (PageDirection == XPageDirection.Downwards) {  		switch (format.LineAlignment) {  		case XLineAlignment.Near:  			//y += cyAscent;  			break;  		case XLineAlignment.Center:  			// TODO use CapHeight. PDFlib also uses 3/4 of ascent  			y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  			//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  			break;  		case XLineAlignment.Far:  			y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  			break;  		case XLineAlignment.BaseLine:  			y -= formattedText.Baseline;  			break;  		}  	}  	else {  		// TODOWPF: make unit test  		switch (format.LineAlignment) {  		case XLineAlignment.Near:  			//y += cyDescent;  			break;  		case XLineAlignment.Center:  			// TODO use CapHeight. PDFlib also uses 3/4 of ascent  			//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  			break;  		case XLineAlignment.Far:  			//y += -cyAscent + rect.Height;  			break;  		case XLineAlignment.BaseLine:  			// nothing to do  			break;  		}  	}  	//if (bold && !descriptor.IsBoldFace)  	//{  	//  // TODO: emulate bold by thicker outline  	//}  	//if (italic && !descriptor.IsBoldFace)  	//{  	//  // TODO: emulate italic by shearing transformation  	//}  	if (underline) {  		formattedText.SetTextDecorations (TextDecorations.Underline);  		//double underlinePosition = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlinePosition / font.cellSpace;  		//double underlineThickness = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlineThickness / font.cellSpace;  		//DrawRectangle(null' brush' x' y - underlinePosition' width' underlineThickness);  	}  	if (strikeout) {  		formattedText.SetTextDecorations (TextDecorations.Strikethrough);  		//double strikeoutPosition = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutPosition / font.cellSpace;  		//double strikeoutSize = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutSize / font.cellSpace;  		//DrawRectangle(null' brush' x' y - strikeoutPosition - strikeoutSize' width' strikeoutSize);  	}  	//this.dc.DrawText(formattedText' layoutRectangle.Location.ToPoint());  	this.dc.DrawText (formattedText' new System.Windows.Point (x' y));  	#else  	          dc.DrawString(this' text' font' brush' layoutRectangle' format); #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (this.targetContext == XGraphicTargetContext.WPF) {  	#if !SILVERLIGHT  	double x = layoutRectangle.X;  	double y = layoutRectangle.Y;  	double lineSpace = font.GetHeight (this);  	double cyAscent = lineSpace * font.cellAscent / font.cellSpace;  	double cyDescent = lineSpace * font.cellDescent / font.cellSpace;  	bool bold = (font.Style & XFontStyle.Bold) != 0;  	bool italic = (font.Style & XFontStyle.Italic) != 0;  	bool strikeout = (font.Style & XFontStyle.Strikeout) != 0;  	bool underline = (font.Style & XFontStyle.Underline) != 0;  	//FormattedText formattedText = new FormattedText(text' new CultureInfo("en-us")' // WPFHACK  	//  FlowDirection.LeftToRight' font.typeface' font.Size' brush.RealizeWpfBrush());  	FormattedText formattedText = FontHelper.CreateFormattedText (text' font.typeface' font.Size' brush.RealizeWpfBrush ());  	//formattedText.SetTextDecorations(TextDecorations.OverLine);  	switch (format.Alignment) {  	case XStringAlignment.Near:  		// nothing to do' this is the default  		//formattedText.TextAlignment = TextAlignment.Left;  		break;  	case XStringAlignment.Center:  		x += layoutRectangle.Width / 2;  		formattedText.TextAlignment = TextAlignment.Center;  		break;  	case XStringAlignment.Far:  		x += layoutRectangle.Width;  		formattedText.TextAlignment = TextAlignment.Right;  		break;  	}  	if (PageDirection == XPageDirection.Downwards) {  		switch (format.LineAlignment) {  		case XLineAlignment.Near:  			//y += cyAscent;  			break;  		case XLineAlignment.Center:  			// TODO use CapHeight. PDFlib also uses 3/4 of ascent  			y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  			//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  			break;  		case XLineAlignment.Far:  			y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  			break;  		case XLineAlignment.BaseLine:  			y -= formattedText.Baseline;  			break;  		}  	}  	else {  		// TODOWPF: make unit test  		switch (format.LineAlignment) {  		case XLineAlignment.Near:  			//y += cyDescent;  			break;  		case XLineAlignment.Center:  			// TODO use CapHeight. PDFlib also uses 3/4 of ascent  			//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  			break;  		case XLineAlignment.Far:  			//y += -cyAscent + rect.Height;  			break;  		case XLineAlignment.BaseLine:  			// nothing to do  			break;  		}  	}  	//if (bold && !descriptor.IsBoldFace)  	//{  	//  // TODO: emulate bold by thicker outline  	//}  	//if (italic && !descriptor.IsBoldFace)  	//{  	//  // TODO: emulate italic by shearing transformation  	//}  	if (underline) {  		formattedText.SetTextDecorations (TextDecorations.Underline);  		//double underlinePosition = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlinePosition / font.cellSpace;  		//double underlineThickness = lineSpace * realizedFont.FontDescriptor.descriptor.UnderlineThickness / font.cellSpace;  		//DrawRectangle(null' brush' x' y - underlinePosition' width' underlineThickness);  	}  	if (strikeout) {  		formattedText.SetTextDecorations (TextDecorations.Strikethrough);  		//double strikeoutPosition = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutPosition / font.cellSpace;  		//double strikeoutSize = lineSpace * realizedFont.FontDescriptor.descriptor.StrikeoutSize / font.cellSpace;  		//DrawRectangle(null' brush' x' y - strikeoutPosition - strikeoutSize' width' strikeoutSize);  	}  	//this.dc.DrawText(formattedText' layoutRectangle.Location.ToPoint());  	this.dc.DrawText (formattedText' new System.Windows.Point (x' y));  	#else  	          dc.DrawString(this' text' font' brush' layoutRectangle' format); #endif  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: switch (format.Alignment) {  case XStringAlignment.Near:  	// nothing to do' this is the default  	//formattedText.TextAlignment = TextAlignment.Left;  	break;  case XStringAlignment.Center:  	x += layoutRectangle.Width / 2;  	formattedText.TextAlignment = TextAlignment.Center;  	break;  case XStringAlignment.Far:  	x += layoutRectangle.Width;  	formattedText.TextAlignment = TextAlignment.Right;  	break;  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: x += layoutRectangle.Width / 2;  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		//y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  		//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  		break;  	case XLineAlignment.BaseLine:  		y -= formattedText.Baseline;  		break;  	}  }  else {  	// TODOWPF: make unit test  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		//y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		//y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: if (PageDirection == XPageDirection.Downwards) {  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		//y += cyAscent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  		//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  		break;  	case XLineAlignment.Far:  		y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  		break;  	case XLineAlignment.BaseLine:  		y -= formattedText.Baseline;  		break;  	}  }  else {  	// TODOWPF: make unit test  	switch (format.LineAlignment) {  	case XLineAlignment.Near:  		//y += cyDescent;  		break;  	case XLineAlignment.Center:  		// TODO use CapHeight. PDFlib also uses 3/4 of ascent  		//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  		break;  	case XLineAlignment.Far:  		//y += -cyAscent + rect.Height;  		break;  	case XLineAlignment.BaseLine:  		// nothing to do  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	//y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  	//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  	break;  case XLineAlignment.Far:  	y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  	break;  case XLineAlignment.BaseLine:  	y -= formattedText.Baseline;  	break;  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: switch (format.LineAlignment) {  case XLineAlignment.Near:  	//y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  	//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  	break;  case XLineAlignment.Far:  	y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  	break;  case XLineAlignment.BaseLine:  	y -= formattedText.Baseline;  	break;  }  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  
Magic Number,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following statement contains a magic number: y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The following statement contains a magic number: if (points.Length < 4)  	throw new ArgumentException ("At least four points required for bezier curve."' "points");  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The following statement contains a magic number: if ((points.Length - 1) % 3 != 0)  	throw new ArgumentException ("Invalid number of points for bezier curve. Number must fulfil 4+3n."' "points");  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3) {  	//figure.Segments.Add(new BezierSegment(  	//                      new System.Windows.Point(points[idx].x' points[idx].y)'  	//                      new System.Windows.Point(points[idx + 1].x' points[idx + 1].y)'  	//                      new System.Windows.Point(points[idx + 2].x' points[idx + 2].y)' true));  	#if !SILVERLIGHT  	BezierSegment bezierSegment = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  	#else  	        BezierSegment bezierSegment = new BezierSegment();         bezierSegment.Point1 = new Point(points[idx].x' points[idx].y);         bezierSegment.Point2 = new Point(points[idx + 1].x' points[idx + 1].y);         bezierSegment.Point3 = new Point(points[idx + 2].x' points[idx + 2].y); #endif  	figure.Segments.Add (bezierSegment);  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3) {  	//figure.Segments.Add(new BezierSegment(  	//                      new System.Windows.Point(points[idx].x' points[idx].y)'  	//                      new System.Windows.Point(points[idx + 1].x' points[idx + 1].y)'  	//                      new System.Windows.Point(points[idx + 2].x' points[idx + 2].y)' true));  	#if !SILVERLIGHT  	BezierSegment bezierSegment = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  	#else  	        BezierSegment bezierSegment = new BezierSegment();         bezierSegment.Point1 = new Point(points[idx].x' points[idx].y);         bezierSegment.Point2 = new Point(points[idx + 1].x' points[idx + 1].y);         bezierSegment.Point3 = new Point(points[idx + 2].x' points[idx + 2].y); #endif  	figure.Segments.Add (bezierSegment);  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The following statement contains a magic number: for (int idx = 1; idx < count; idx += 3) {  	//figure.Segments.Add(new BezierSegment(  	//                      new System.Windows.Point(points[idx].x' points[idx].y)'  	//                      new System.Windows.Point(points[idx + 1].x' points[idx + 1].y)'  	//                      new System.Windows.Point(points[idx + 2].x' points[idx + 2].y)' true));  	#if !SILVERLIGHT  	BezierSegment bezierSegment = new BezierSegment (new System.Windows.Point (points [idx].x' points [idx].y)' new System.Windows.Point (points [idx + 1].x' points [idx + 1].y)' new System.Windows.Point (points [idx + 2].x' points [idx + 2].y)' true);  	#else  	        BezierSegment bezierSegment = new BezierSegment();         bezierSegment.Point1 = new Point(points[idx].x' points[idx].y);         bezierSegment.Point2 = new Point(points[idx + 1].x' points[idx + 1].y);         bezierSegment.Point3 = new Point(points[idx + 2].x' points[idx + 2].y); #endif  	figure.Segments.Add (bezierSegment);  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddBeziers,The following statement contains a magic number: idx += 3
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: AddCurve (points' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count < 2)  	throw new ArgumentException ("AddCurve requires two or more points."' "points");  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: tension /= 3;  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [count - 1]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)(x + width - ellipseWidth)' (float)y' (float)ellipseWidth' (float)ellipseHeight' -90' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)(x + width - ellipseWidth)' (float)y' (float)ellipseWidth' (float)ellipseHeight' -90' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)(x + width - ellipseWidth)' (float)(y + height - ellipseHeight)' (float)ellipseWidth' (float)ellipseHeight' 0' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)x' (float)(y + height - ellipseHeight)' (float)ellipseWidth' (float)ellipseHeight' 90' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)x' (float)(y + height - ellipseHeight)' (float)ellipseWidth' (float)ellipseHeight' 90' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)x' (float)y' (float)ellipseWidth' (float)ellipseHeight' 180' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddRoundedRectangle,The following statement contains a magic number: this.gdipPath.AddArc ((float)x' (float)y' (float)ellipseWidth' (float)ellipseHeight' 180' 90);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: AddClosedCurve (XGraphics.MakeXPointArray (points)' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: AddClosedCurve (XGraphics.MakeXPointArray (points)' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: AddClosedCurve (XGraphics.MakeXPointArray (points)' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: AddClosedCurve (points' 0.5);  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count < 2)  	throw new ArgumentException ("Not enough points."' "points");  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: tension /= 3;  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: if (count == 2) {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [0]' points [0]' points [1]' points [1]' tension));  }  else {  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  	for (int idx = 1; idx < count - 2; idx++)  		figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  }  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 1]' points [0]' points [1]' points [2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: for (int idx = 1; idx < count - 2; idx++)  	figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [idx - 1]' points [idx]' points [idx + 1]' points [idx + 2]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 3]' points [count - 2]' points [count - 1]' points [0]' tension));  
Magic Number,PdfSharp.Drawing,XGraphicsPath,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphicsPath.cs,AddClosedCurve,The following statement contains a magic number: figure.Segments.Add (GeometryHelper.CreateCurveSegment (points [count - 2]' points [count - 1]' points [0]' points [1]' tension));  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,GetImageFilename,The following statement contains a magic number: if (filename.StartsWith ("file:///"))  	filename = filename.Substring (8);  // Remove all 3 slashes!  else if (filename.StartsWith ("file://"))  	filename = filename.Substring (5);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,GetImageFilename,The following statement contains a magic number: if (filename.StartsWith ("file:///"))  	filename = filename.Substring (8);  // Remove all 3 slashes!  else if (filename.StartsWith ("file://"))  	filename = filename.Substring (5);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,GetImageFilename,The following statement contains a magic number: filename = filename.Substring (8);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,GetImageFilename,The following statement contains a magic number: if (filename.StartsWith ("file://"))  	filename = filename.Substring (5);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,GetImageFilename,The following statement contains a magic number: filename = filename.Substring (5);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	char ch = s [i];  	if (ch == '+') {  		ch = ' ';  	}  	else if ((ch == '%') && (i < (length - 2))) {  		if ((s [i + 1] == 'u') && (i < (length - 5))) {  			int num3 = HexToInt (s [i + 2]);  			int num4 = HexToInt (s [i + 3]);  			int num5 = HexToInt (s [i + 4]);  			int num6 = HexToInt (s [i + 5]);  			if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  				goto AddByte;  			}  			ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  			i += 5;  			result += ch;  			continue;  		}  		int num7 = HexToInt (s [i + 1]);  		int num8 = HexToInt (s [i + 2]);  		if ((num7 >= 0) && (num8 >= 0)) {  			byte b = (byte)((num7 << 4) | num8);  			i += 2;  			result += (char)b;  			continue;  		}  	}  	AddByte:  	if ((ch & 0xff80) == 0) {  		result += ch;  	}  	else {  		result += ch;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if (ch == '+') {  	ch = ' ';  }  else if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((ch == '%') && (i < (length - 2))) {  	if ((s [i + 1] == 'u') && (i < (length - 5))) {  		int num3 = HexToInt (s [i + 2]);  		int num4 = HexToInt (s [i + 3]);  		int num5 = HexToInt (s [i + 4]);  		int num6 = HexToInt (s [i + 5]);  		if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  			goto AddByte;  		}  		ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  		i += 5;  		result += ch;  		continue;  	}  	int num7 = HexToInt (s [i + 1]);  	int num8 = HexToInt (s [i + 2]);  	if ((num7 >= 0) && (num8 >= 0)) {  		byte b = (byte)((num7 << 4) | num8);  		i += 2;  		result += (char)b;  		continue;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((s [i + 1] == 'u') && (i < (length - 5))) {  	int num3 = HexToInt (s [i + 2]);  	int num4 = HexToInt (s [i + 3]);  	int num5 = HexToInt (s [i + 4]);  	int num6 = HexToInt (s [i + 5]);  	if (((num3 < 0) || (num4 < 0)) || ((num5 < 0) || (num6 < 0))) {  		goto AddByte;  	}  	ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  	i += 5;  	result += ch;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: ch = (char)((((num3 << 12) | (num4 << 8)) | (num5 << 4)) | num6);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: i += 5;  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((num7 >= 0) && (num8 >= 0)) {  	byte b = (byte)((num7 << 4) | num8);  	i += 2;  	result += (char)b;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: if ((num7 >= 0) && (num8 >= 0)) {  	byte b = (byte)((num7 << 4) | num8);  	i += 2;  	result += (char)b;  	continue;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,UrlDecodeStringFromStringInternal,The following statement contains a magic number: i += 2;  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,HexToInt,The following statement contains a magic number: if ((h >= 'a') && (h <= 'f')) {  	return ((h - 'a') + 10);  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,HexToInt,The following statement contains a magic number: return ((h - 'a') + 10);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,HexToInt,The following statement contains a magic number: if ((h >= 'A') && (h <= 'F')) {  	return ((h - 'A') + 10);  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,HexToInt,The following statement contains a magic number: return ((h - 'A') + 10);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,TestJpeg,The following statement contains a magic number: return ReadJpegFile (filename' 16' ref imageBits);  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (File.Exists (filename)) {  	FileStream fs = null;  	try {  		fs = new FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	}  	catch {  		return false;  	}  	if (fs.Length < 16) {  		fs.Close ();  		return false;  	}  	int len = maxRead == -1 ? (int)fs.Length : maxRead;  	imageBits = new byte[len];  	fs.Read (imageBits' 0' len);  	fs.Close ();  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  		return true;  	}  	// TODO: Exif: find JFIF header  	if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  		// Hack: store the file in PDF if extension matches ...  		string str = filename.ToLower ();  		if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  			return true;  	}  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (fs.Length < 16) {  	fs.Close ();  	return false;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe0 && imageBits [6] == 0x4a && imageBits [7] == 0x46 && imageBits [8] == 0x49 && imageBits [9] == 0x46 && imageBits [10] == 0x0) {  	return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  	// Hack: store the file in PDF if extension matches ...  	string str = filename.ToLower ();  	if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  		return true;  }  
Magic Number,PdfSharp.Drawing,XImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XImage.cs,ReadJpegFile,The following statement contains a magic number: if (imageBits [0] == 0xff && imageBits [1] == 0xd8 && imageBits [2] == 0xff && imageBits [3] == 0xe1/*&&             imageBits[6] == 0x4a &&             imageBits[7] == 0x46 &&             imageBits[8] == 0x49 &&             imageBits[9] == 0x46 &&             imageBits[10] == 0x0*/) {  	// Hack: store the file in PDF if extension matches ...  	string str = filename.ToLower ();  	if (str.EndsWith (".jpg") || str.EndsWith (".jpeg"))  		return true;  }  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [2] = 0xFF00FFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [3] = 0xFF7FFFD4;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [4] = 0xFFF0FFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [5] = 0xFFF5F5DC;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [6] = 0xFFFFE4C4;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [7] = 0xFF000000;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [8] = 0xFFFFEBCD;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [9] = 0xFF0000FF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [10] = 0xFF8A2BE2;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [11] = 0xFFA52A2A;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [12] = 0xFFDEB887;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [13] = 0xFF5F9EA0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [14] = 0xFF7FFF00;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [15] = 0xFFD2691E;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [16] = 0xFFFF7F50;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [17] = 0xFF6495ED;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [18] = 0xFFFFF8DC;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [19] = 0xFFDC143C;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [20] = 0xFF00FFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [21] = 0xFF00008B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [22] = 0xFF008B8B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [23] = 0xFFB8860B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [24] = 0xFFA9A9A9;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [25] = 0xFF006400;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [26] = 0xFFBDB76B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [27] = 0xFF8B008B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [28] = 0xFF556B2F;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [29] = 0xFFFF8C00;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [30] = 0xFF9932CC;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [31] = 0xFF8B0000;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [32] = 0xFFE9967A;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [33] = 0xFF8FBC8B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [34] = 0xFF483D8B;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [35] = 0xFF2F4F4F;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [36] = 0xFF00CED1;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [37] = 0xFF9400D3;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [38] = 0xFFFF1493;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [39] = 0xFF00BFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [40] = 0xFF696969;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [41] = 0xFF1E90FF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [42] = 0xFFB22222;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [43] = 0xFFFFFAF0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [44] = 0xFF228B22;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [45] = 0xFFFF00FF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [46] = 0xFFDCDCDC;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [47] = 0xFFF8F8FF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [48] = 0xFFFFD700;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [49] = 0xFFDAA520;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [50] = 0xFF808080;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [51] = 0xFF008000;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [52] = 0xFFADFF2F;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [53] = 0xFFF0FFF0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [54] = 0xFFFF69B4;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [55] = 0xFFCD5C5C;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [56] = 0xFF4B0082;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [57] = 0xFFFFFFF0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [58] = 0xFFF0E68C;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [59] = 0xFFE6E6FA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [60] = 0xFFFFF0F5;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [61] = 0xFF7CFC00;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [62] = 0xFFFFFACD;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [63] = 0xFFADD8E6;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [64] = 0xFFF08080;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [65] = 0xFFE0FFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [66] = 0xFFFAFAD2;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [67] = 0xFFD3D3D3;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [68] = 0xFF90EE90;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [69] = 0xFFFFB6C1;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [70] = 0xFFFFA07A;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [71] = 0xFF20B2AA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [72] = 0xFF87CEFA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [73] = 0xFF778899;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [74] = 0xFFB0C4DE;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [75] = 0xFFFFFFE0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [76] = 0xFF00FF00;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [77] = 0xFF32CD32;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [78] = 0xFFFAF0E6;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [79] = 0xFFFF00FF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [80] = 0xFF800000;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [81] = 0xFF66CDAA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [82] = 0xFF0000CD;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [83] = 0xFFBA55D3;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [84] = 0xFF9370DB;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [85] = 0xFF3CB371;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [86] = 0xFF7B68EE;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [87] = 0xFF00FA9A;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [88] = 0xFF48D1CC;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [89] = 0xFFC71585;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [90] = 0xFF191970;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [91] = 0xFFF5FFFA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [92] = 0xFFFFE4E1;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [93] = 0xFFFFE4B5;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [94] = 0xFFFFDEAD;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [95] = 0xFF000080;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [96] = 0xFFFDF5E6;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [97] = 0xFF808000;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [98] = 0xFF6B8E23;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [99] = 0xFFFFA500;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [100] = 0xFFFF4500;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [101] = 0xFFDA70D6;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [102] = 0xFFEEE8AA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [103] = 0xFF98FB98;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [104] = 0xFFAFEEEE;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [105] = 0xFFDB7093;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [106] = 0xFFFFEFD5;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [107] = 0xFFFFDAB9;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [108] = 0xFFCD853F;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [109] = 0xFFFFC0CB;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [110] = 0xFFDDA0DD;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [111] = 0xFFB0E0E6;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [112] = 0xFF800080;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [113] = 0xFFFF0000;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [114] = 0xFFBC8F8F;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [115] = 0xFF4169E1;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [116] = 0xFF8B4513;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [117] = 0xFFFA8072;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [118] = 0xFFF4A460;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [119] = 0xFF2E8B57;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [120] = 0xFFFFF5EE;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [121] = 0xFFA0522D;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [122] = 0xFFC0C0C0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [123] = 0xFF87CEEB;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [124] = 0xFF6A5ACD;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [125] = 0xFF708090;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [126] = 0xFFFFFAFA;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [127] = 0xFF00FF7F;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [128] = 0xFF4682B4;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [129] = 0xFFD2B48C;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [130] = 0xFF008080;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [131] = 0xFFD8BFD8;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [132] = 0xFFFF6347;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [133] = 0x00FFFFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [134] = 0xFF40E0D0;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [135] = 0xFFEE82EE;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [136] = 0xFFF5DEB3;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [137] = 0xFFFFFFFF;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [138] = 0xFFF5F5F5;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [139] = 0xFFFFFF00;  
Magic Number,PdfSharp.Drawing,XKnownColorTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XKnownColorTable.cs,InitColorTable,The following statement contains a magic number: colors [140] = 0xFF9ACD32;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAppend,The following statement contains a magic number: angle = angle % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAppend,The following statement contains a magic number: this *= CreateRotationRadians (angle * 0.017453292519943295);  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotatePrepend,The following statement contains a magic number: angle = angle % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotatePrepend,The following statement contains a magic number: this = CreateRotationRadians (angle * 0.017453292519943295) * this;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAtAppend,The following statement contains a magic number: angle = angle % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAtAppend,The following statement contains a magic number: this *= CreateRotationRadians (angle * 0.017453292519943295' centerX' centerY);  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAtPrepend,The following statement contains a magic number: angle = angle % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAtPrepend,The following statement contains a magic number: this = CreateRotationRadians (angle * 0.017453292519943295' centerX' centerY) * this;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: if (order == XMatrixOrder.Append) {  	angle = angle % 360.0;  	this *= CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y);  	//this.Translate(point.X' point.Y' order);  	//this.Rotate(angle' order);  	//this.Translate(-point.X' -point.Y' order);  }  else {  	angle = angle % 360.0;  	this = CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y) * this;  }  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: if (order == XMatrixOrder.Append) {  	angle = angle % 360.0;  	this *= CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y);  	//this.Translate(point.X' point.Y' order);  	//this.Rotate(angle' order);  	//this.Translate(-point.X' -point.Y' order);  }  else {  	angle = angle % 360.0;  	this = CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y) * this;  }  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: if (order == XMatrixOrder.Append) {  	angle = angle % 360.0;  	this *= CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y);  	//this.Translate(point.X' point.Y' order);  	//this.Rotate(angle' order);  	//this.Translate(-point.X' -point.Y' order);  }  else {  	angle = angle % 360.0;  	this = CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y) * this;  }  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: if (order == XMatrixOrder.Append) {  	angle = angle % 360.0;  	this *= CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y);  	//this.Translate(point.X' point.Y' order);  	//this.Rotate(angle' order);  	//this.Translate(-point.X' -point.Y' order);  }  else {  	angle = angle % 360.0;  	this = CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y) * this;  }  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: angle = angle % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: this *= CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y);  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: angle = angle % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,RotateAt,The following statement contains a magic number: this = CreateRotationRadians (angle * 0.017453292519943295' point.x' point.y) * this;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewAppend,The following statement contains a magic number: skewX = skewX % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewAppend,The following statement contains a magic number: skewY = skewY % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewAppend,The following statement contains a magic number: this *= CreateSkewRadians (skewX * 0.017453292519943295' skewY * 0.017453292519943295);  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewAppend,The following statement contains a magic number: this *= CreateSkewRadians (skewX * 0.017453292519943295' skewY * 0.017453292519943295);  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewPrepend,The following statement contains a magic number: skewX = skewX % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewPrepend,The following statement contains a magic number: skewY = skewY % 360.0;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewPrepend,The following statement contains a magic number: this = CreateSkewRadians (skewX * 0.017453292519943295' skewY * 0.017453292519943295) * this;  
Magic Number,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,SkewPrepend,The following statement contains a magic number: this = CreateSkewRadians (skewX * 0.017453292519943295' skewY * 0.017453292519943295) * this;  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dirty || !this.dirty)// TODOWPF: XPen is frozen by design' WPF Pen can change   {  	//if (this.wpfPen == null)  	this.wpfPen = new System.Windows.Media.Pen (new SolidColorBrush (this.color.ToWpfColor ())' this.width);  	//else  	//{  	//  this.wpfPen.Brush = new SolidColorBrush(this.color.ToWpfColor());  	//  this.wpfPen.Thickness = this.width;  	//}  	PenLineCap lineCap = XConvert.ToPenLineCap (this.lineCap);  	this.wpfPen.StartLineCap = lineCap;  	this.wpfPen.EndLineCap = lineCap;  	this.wpfPen.LineJoin = XConvert.ToPenLineJoin (this.lineJoin);  	if (this.dashStyle == XDashStyle.Custom) {  		// TODOWPF: does not work in all cases  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  	}  	else {  		switch (this.dashStyle) {  		case XDashStyle.Solid:  			this.wpfPen.DashStyle = DashStyles.Solid;  			break;  		case XDashStyle.Dash:  			//this.wpfPen.DashStyle = DashStyles.Dash;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2  			}' 0);  			break;  		case XDashStyle.Dot:  			//this.wpfPen.DashStyle = DashStyles.Dot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				0'  				2  			}' 1.5);  			break;  		case XDashStyle.DashDot:  			//this.wpfPen.DashStyle = DashStyles.DashDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2  			}' 0);  			break;  		case XDashStyle.DashDotDot:  			//this.wpfPen.DashStyle = DashStyles.DashDotDot;  			this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  				2'  				2'  				0'  				2'  				0'  				2  			}' 0);  			break;  		}  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: if (this.dashStyle == XDashStyle.Custom) {  	// TODOWPF: does not work in all cases  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (this.dashPattern' this.dashOffset);  }  else {  	switch (this.dashStyle) {  	case XDashStyle.Solid:  		this.wpfPen.DashStyle = DashStyles.Solid;  		break;  	case XDashStyle.Dash:  		//this.wpfPen.DashStyle = DashStyles.Dash;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2  		}' 0);  		break;  	case XDashStyle.Dot:  		//this.wpfPen.DashStyle = DashStyles.Dot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			0'  			2  		}' 1.5);  		break;  	case XDashStyle.DashDot:  		//this.wpfPen.DashStyle = DashStyles.DashDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2  		}' 0);  		break;  	case XDashStyle.DashDotDot:  		//this.wpfPen.DashStyle = DashStyles.DashDotDot;  		this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  			2'  			2'  			0'  			2'  			0'  			2  		}' 0);  		break;  	}  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	0'  	2  }' 1.5);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	0'  	2  }' 1.5);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following statement contains a magic number: this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  	2'  	2'  	0'  	2'  	0'  	2  }' 0);  
Magic Number,PdfSharp.Drawing,XVector,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XVector.cs,AngleBetween,The following statement contains a magic number: return (Math.Atan2 (y' x) * 57.295779513082323);  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Read,The following statement contains a magic number: try {  	// Read offset table  	this.offsetTable.Version = ReadULong ();  	this.offsetTable.TableCount = ReadUShort ();  	this.offsetTable.SearchRange = ReadUShort ();  	this.offsetTable.EntrySelector = ReadUShort ();  	this.offsetTable.RangeShift = ReadUShort ();  	// Move to table dictionary at position 12  	Debug.Assert (this.pos == 12);  	//this.tableDictionary = (this.offsetTable.TableCount);  	// ReSharper disable InconsistentNaming  	// Determine font technology  	const uint OTTO = 0x4f54544f;  	// Adobe OpenType CFF data' tag: 'OTTO'  	const uint TTCF = 0x74746366;  	// TrueType Collection tag: 'ttcf'    	// ReSharper restore InconsistentNaming  	if (this.offsetTable.Version == TTCF) {  		this.fontTechnology = FontTechnology.TrueTypeCollection;  		throw new InvalidOperationException ("TrueType collection fonts are not supported by PDFsharp.");  	}  	else if (this.offsetTable.Version == OTTO)  		this.fontTechnology = FontTechnology.PostscriptOutlines;  	else  		this.fontTechnology = FontTechnology.TrueTypeOutlines;  	for (int idx = 0; idx < this.offsetTable.TableCount; idx++) {  		TableDirectoryEntry entry = TableDirectoryEntry.ReadFrom (this);  		this.tableDictionary.Add (entry.Tag' entry);  		#if VERBOSE  		          Debug.WriteLine(String.Format("Font table: {0}"' entry.Tag)); #endif  	}  	// PDFlib checks this' but it is not part of the OpenType spec anymore  	if (this.tableDictionary.ContainsKey ("bhed"))  		throw new NotSupportedException ("Bitmap fonts are not supported by PDFsharp.");  	// Read required tables  	if (Seek (CMapTable.Tag) != -1)  		this.cmap = new CMapTable (this);  	if (Seek (ControlValueTable.Tag) != -1)  		this.cvt = new ControlValueTable (this);  	if (Seek (FontProgram.Tag) != -1)  		this.fpgm = new FontProgram (this);  	if (Seek (MaximumProfileTable.Tag) != -1)  		this.maxp = new MaximumProfileTable (this);  	if (Seek (NameTable.Tag) != -1)  		this.name = new NameTable (this);  	if (Seek (FontHeaderTable.Tag) != -1)  		this.head = new FontHeaderTable (this);  	if (Seek (HorizontalHeaderTable.Tag) != -1)  		this.hhea = new HorizontalHeaderTable (this);  	if (Seek (HorizontalMetricsTable.Tag) != -1)  		this.hmtx = new HorizontalMetricsTable (this);  	if (Seek (OS2Table.Tag) != -1)  		this.os2 = new OS2Table (this);  	if (Seek (PostScriptTable.Tag) != -1)  		this.post = new PostScriptTable (this);  	if (Seek (GlyphDataTable.Tag) != -1)  		this.glyf = new GlyphDataTable (this);  	if (Seek (IndexToLocationTable.Tag) != -1)  		this.loca = new IndexToLocationTable (this);  	if (Seek (GlyphSubstitutionTable.Tag) != -1)  		this.gsub = new GlyphSubstitutionTable (this);  	if (Seek (ControlValueProgram.Tag) != -1)  		this.prep = new ControlValueProgram (this);  }  catch (Exception) {  	GetType ();  	throw;  }  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Read,The following statement contains a magic number: Debug.Assert (this.pos == 12);  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The following statement contains a magic number: this.offsetTable.SearchRange = (ushort)((1 << selector) * 16);  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The following statement contains a magic number: this.offsetTable.RangeShift = (ushort)((tableCount - (1 << selector)) * 16);  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The following statement contains a magic number: for (int idx = 0; idx < tableCount; idx++) {  	TableDirectoryEntry entry = this.tableDictionary [tags [idx]];  	#if DEBUG  	if (entry.Tag == "glyf" || entry.Tag == "loca")  		GetType ();  	#endif  	entry.FontTable.PrepareForCompilation ();  	entry.Offset = tablePosition;  	writer.Position = tablePosition;  	entry.FontTable.Write (writer);  	int endPosition = writer.Position;  	tablePosition = endPosition;  	writer.Position = 12 + 16 * idx;  	entry.Write (writer);  	#if VERBOSE  	        Debug.WriteLine(String.Format("  Write Table '{0}'' offset={1}' length={2}' checksum={3}' "' entry.Tag' entry.Offset' entry.Length' entry.CheckSum)); #endif  }  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The following statement contains a magic number: for (int idx = 0; idx < tableCount; idx++) {  	TableDirectoryEntry entry = this.tableDictionary [tags [idx]];  	#if DEBUG  	if (entry.Tag == "glyf" || entry.Tag == "loca")  		GetType ();  	#endif  	entry.FontTable.PrepareForCompilation ();  	entry.Offset = tablePosition;  	writer.Position = tablePosition;  	entry.FontTable.Write (writer);  	int endPosition = writer.Position;  	tablePosition = endPosition;  	writer.Position = 12 + 16 * idx;  	entry.Write (writer);  	#if VERBOSE  	        Debug.WriteLine(String.Format("  Write Table '{0}'' offset={1}' length={2}' checksum={3}' "' entry.Tag' entry.Offset' entry.Length' entry.CheckSum)); #endif  }  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The following statement contains a magic number: writer.Position = 12 + 16 * idx;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,Compile,The following statement contains a magic number: writer.Position = 12 + 16 * idx;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadShort,The following statement contains a magic number: this.pos += 2;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadShort,The following statement contains a magic number: return (short)((this.data [pos] << 8) | (this.data [pos + 1]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadUShort,The following statement contains a magic number: this.pos += 2;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadUShort,The following statement contains a magic number: return (ushort)((this.data [pos] << 8) | (this.data [pos + 1]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The following statement contains a magic number: this.pos += 4;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLong,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The following statement contains a magic number: this.pos += 4;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The following statement contains a magic number: return (uint)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The following statement contains a magic number: return (uint)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The following statement contains a magic number: return (uint)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The following statement contains a magic number: return (uint)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadULong,The following statement contains a magic number: return (uint)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The following statement contains a magic number: this.pos += 4;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFixed,The following statement contains a magic number: return (int)((this.data [pos] << 24) | (this.data [pos + 1] << 16) | (this.data [pos + 2] << 8) | (this.data [pos + 3]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFWord,The following statement contains a magic number: this.pos += 2;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadFWord,The following statement contains a magic number: return (short)((this.data [pos] << 8) | (this.data [pos + 1]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadUFWord,The following statement contains a magic number: this.pos += 2;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadUFWord,The following statement contains a magic number: return (ushort)((this.data [pos] << 8) | (this.data [pos + 1]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: this.pos += 8;  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadLongDate,The following statement contains a magic number: return (int)((this.data [pos] << 56) | (this.data [pos + 1] << 48) | (this.data [pos + 2] << 40) | (this.data [pos + 32]) | (this.data [pos + 4] << 24) | (this.data [pos + 5] << 16) | (this.data [pos + 5] << 8) | (this.data [pos + 7]));  
Magic Number,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,ReadTag,The following statement contains a magic number: return ReadString (4);  
Magic Number,PdfSharp.Fonts.OpenType,FontDataStock,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontDataStock.cs,CalcChecksum,The following statement contains a magic number: while (length > 0) {  	int n = 3800;  	if (n > length)  		n = length;  	length -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buffer [offset++] & 0xFF);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,PdfSharp.Fonts.OpenType,FontDataStock,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontDataStock.cs,CalcChecksum,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: this.fontData.SeekOffset (8);  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: for (; ;) {  	int flags = this.fontData.ReadUFWord ();  	int cGlyph = this.fontData.ReadUFWord ();  	if (!glyphs.ContainsKey (cGlyph))  		glyphs.Add (cGlyph' null);  	if ((flags & MORE_COMPONENTS) == 0)  		return;  	int offset = (flags & ARG_1_AND_2_ARE_WORDS) == 0 ? 2 : 4;  	if ((flags & WE_HAVE_A_SCALE) != 0)  		offset += 2;  	else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  		offset += 4;  	if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)  		offset += 8;  	this.fontData.SeekOffset (offset);  }  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: for (; ;) {  	int flags = this.fontData.ReadUFWord ();  	int cGlyph = this.fontData.ReadUFWord ();  	if (!glyphs.ContainsKey (cGlyph))  		glyphs.Add (cGlyph' null);  	if ((flags & MORE_COMPONENTS) == 0)  		return;  	int offset = (flags & ARG_1_AND_2_ARE_WORDS) == 0 ? 2 : 4;  	if ((flags & WE_HAVE_A_SCALE) != 0)  		offset += 2;  	else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  		offset += 4;  	if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)  		offset += 8;  	this.fontData.SeekOffset (offset);  }  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: for (; ;) {  	int flags = this.fontData.ReadUFWord ();  	int cGlyph = this.fontData.ReadUFWord ();  	if (!glyphs.ContainsKey (cGlyph))  		glyphs.Add (cGlyph' null);  	if ((flags & MORE_COMPONENTS) == 0)  		return;  	int offset = (flags & ARG_1_AND_2_ARE_WORDS) == 0 ? 2 : 4;  	if ((flags & WE_HAVE_A_SCALE) != 0)  		offset += 2;  	else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  		offset += 4;  	if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)  		offset += 8;  	this.fontData.SeekOffset (offset);  }  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: for (; ;) {  	int flags = this.fontData.ReadUFWord ();  	int cGlyph = this.fontData.ReadUFWord ();  	if (!glyphs.ContainsKey (cGlyph))  		glyphs.Add (cGlyph' null);  	if ((flags & MORE_COMPONENTS) == 0)  		return;  	int offset = (flags & ARG_1_AND_2_ARE_WORDS) == 0 ? 2 : 4;  	if ((flags & WE_HAVE_A_SCALE) != 0)  		offset += 2;  	else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  		offset += 4;  	if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)  		offset += 8;  	this.fontData.SeekOffset (offset);  }  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: for (; ;) {  	int flags = this.fontData.ReadUFWord ();  	int cGlyph = this.fontData.ReadUFWord ();  	if (!glyphs.ContainsKey (cGlyph))  		glyphs.Add (cGlyph' null);  	if ((flags & MORE_COMPONENTS) == 0)  		return;  	int offset = (flags & ARG_1_AND_2_ARE_WORDS) == 0 ? 2 : 4;  	if ((flags & WE_HAVE_A_SCALE) != 0)  		offset += 2;  	else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  		offset += 4;  	if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)  		offset += 8;  	this.fontData.SeekOffset (offset);  }  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: if ((flags & WE_HAVE_A_SCALE) != 0)  	offset += 2;  else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  	offset += 4;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: if ((flags & WE_HAVE_A_SCALE) != 0)  	offset += 2;  else if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  	offset += 4;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: offset += 2;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: if ((flags & WE_HAVE_AN_X_AND_Y_SCALE) != 0)  	offset += 4;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: offset += 4;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: if ((flags & WE_HAVE_A_TWO_BY_TWO) != 0)  	offset += 8;  
Magic Number,PdfSharp.Fonts.OpenType,GlyphDataTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\GlyphDataTable.cs,AddCompositeGlyphs,The following statement contains a magic number: offset += 8;  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: try {  	ShortIndex = this.fontData.head.indexToLocFormat == 0;  	this.fontData.Position = DirectoryEntry.Offset;  	if (ShortIndex) {  		int entries = DirectoryEntry.Length / 2;  		Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  		this.locaTable = new int[entries];  		for (int idx = 0; idx < entries; idx++)  			locaTable [idx] = 2 * this.fontData.ReadUFWord ();  	}  	else {  		int entries = DirectoryEntry.Length / 4;  		Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  		this.locaTable = new int[entries];  		for (int idx = 0; idx < entries; idx++)  			locaTable [idx] = this.fontData.ReadLong ();  	}  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: try {  	ShortIndex = this.fontData.head.indexToLocFormat == 0;  	this.fontData.Position = DirectoryEntry.Offset;  	if (ShortIndex) {  		int entries = DirectoryEntry.Length / 2;  		Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  		this.locaTable = new int[entries];  		for (int idx = 0; idx < entries; idx++)  			locaTable [idx] = 2 * this.fontData.ReadUFWord ();  	}  	else {  		int entries = DirectoryEntry.Length / 4;  		Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  		this.locaTable = new int[entries];  		for (int idx = 0; idx < entries; idx++)  			locaTable [idx] = this.fontData.ReadLong ();  	}  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: try {  	ShortIndex = this.fontData.head.indexToLocFormat == 0;  	this.fontData.Position = DirectoryEntry.Offset;  	if (ShortIndex) {  		int entries = DirectoryEntry.Length / 2;  		Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  		this.locaTable = new int[entries];  		for (int idx = 0; idx < entries; idx++)  			locaTable [idx] = 2 * this.fontData.ReadUFWord ();  	}  	else {  		int entries = DirectoryEntry.Length / 4;  		Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  		this.locaTable = new int[entries];  		for (int idx = 0; idx < entries; idx++)  			locaTable [idx] = this.fontData.ReadLong ();  	}  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: if (ShortIndex) {  	int entries = DirectoryEntry.Length / 2;  	Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  	this.locaTable = new int[entries];  	for (int idx = 0; idx < entries; idx++)  		locaTable [idx] = 2 * this.fontData.ReadUFWord ();  }  else {  	int entries = DirectoryEntry.Length / 4;  	Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  	this.locaTable = new int[entries];  	for (int idx = 0; idx < entries; idx++)  		locaTable [idx] = this.fontData.ReadLong ();  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: if (ShortIndex) {  	int entries = DirectoryEntry.Length / 2;  	Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  	this.locaTable = new int[entries];  	for (int idx = 0; idx < entries; idx++)  		locaTable [idx] = 2 * this.fontData.ReadUFWord ();  }  else {  	int entries = DirectoryEntry.Length / 4;  	Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  	this.locaTable = new int[entries];  	for (int idx = 0; idx < entries; idx++)  		locaTable [idx] = this.fontData.ReadLong ();  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: if (ShortIndex) {  	int entries = DirectoryEntry.Length / 2;  	Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  	this.locaTable = new int[entries];  	for (int idx = 0; idx < entries; idx++)  		locaTable [idx] = 2 * this.fontData.ReadUFWord ();  }  else {  	int entries = DirectoryEntry.Length / 4;  	Debug.Assert (this.fontData.maxp.numGlyphs + 1 == entries' "For your information only: Number of glyphs mismatch in font. You can ignore this assertion.");  	this.locaTable = new int[entries];  	for (int idx = 0; idx < entries; idx++)  		locaTable [idx] = this.fontData.ReadLong ();  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: for (int idx = 0; idx < entries; idx++)  	locaTable [idx] = 2 * this.fontData.ReadUFWord ();  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,Read,The following statement contains a magic number: locaTable [idx] = 2 * this.fontData.ReadUFWord ();  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex)  	DirectoryEntry.Length = this.locaTable.Length * 2;  else  	DirectoryEntry.Length = this.locaTable.Length * 4;  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex)  	DirectoryEntry.Length = this.locaTable.Length * 2;  else  	DirectoryEntry.Length = this.locaTable.Length * 4;  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: DirectoryEntry.Length = this.locaTable.Length * 2;  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: DirectoryEntry.Length = this.locaTable.Length * 4;  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex) {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx] / 2;  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)(value);  	}  }  else {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx];  		this.bytes [byteIdx++] = (byte)(value >> 24);  		this.bytes [byteIdx++] = (byte)(value >> 16);  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)value;  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex) {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx] / 2;  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)(value);  	}  }  else {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx];  		this.bytes [byteIdx++] = (byte)(value >> 24);  		this.bytes [byteIdx++] = (byte)(value >> 16);  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)value;  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex) {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx] / 2;  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)(value);  	}  }  else {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx];  		this.bytes [byteIdx++] = (byte)(value >> 24);  		this.bytes [byteIdx++] = (byte)(value >> 16);  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)value;  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex) {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx] / 2;  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)(value);  	}  }  else {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx];  		this.bytes [byteIdx++] = (byte)(value >> 24);  		this.bytes [byteIdx++] = (byte)(value >> 16);  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)value;  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: if (ShortIndex) {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx] / 2;  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)(value);  	}  }  else {  	for (int idx = 0; idx < length; idx++) {  		int value = this.locaTable [idx];  		this.bytes [byteIdx++] = (byte)(value >> 24);  		this.bytes [byteIdx++] = (byte)(value >> 16);  		this.bytes [byteIdx++] = (byte)(value >> 8);  		this.bytes [byteIdx++] = (byte)value;  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: for (int idx = 0; idx < length; idx++) {  	int value = this.locaTable [idx] / 2;  	this.bytes [byteIdx++] = (byte)(value >> 8);  	this.bytes [byteIdx++] = (byte)(value);  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: for (int idx = 0; idx < length; idx++) {  	int value = this.locaTable [idx] / 2;  	this.bytes [byteIdx++] = (byte)(value >> 8);  	this.bytes [byteIdx++] = (byte)(value);  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: this.bytes [byteIdx++] = (byte)(value >> 8);  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: for (int idx = 0; idx < length; idx++) {  	int value = this.locaTable [idx];  	this.bytes [byteIdx++] = (byte)(value >> 24);  	this.bytes [byteIdx++] = (byte)(value >> 16);  	this.bytes [byteIdx++] = (byte)(value >> 8);  	this.bytes [byteIdx++] = (byte)value;  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: for (int idx = 0; idx < length; idx++) {  	int value = this.locaTable [idx];  	this.bytes [byteIdx++] = (byte)(value >> 24);  	this.bytes [byteIdx++] = (byte)(value >> 16);  	this.bytes [byteIdx++] = (byte)(value >> 8);  	this.bytes [byteIdx++] = (byte)value;  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: for (int idx = 0; idx < length; idx++) {  	int value = this.locaTable [idx];  	this.bytes [byteIdx++] = (byte)(value >> 24);  	this.bytes [byteIdx++] = (byte)(value >> 16);  	this.bytes [byteIdx++] = (byte)(value >> 8);  	this.bytes [byteIdx++] = (byte)value;  }  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: this.bytes [byteIdx++] = (byte)(value >> 24);  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: this.bytes [byteIdx++] = (byte)(value >> 16);  
Magic Number,PdfSharp.Fonts.OpenType,IndexToLocationTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\IndexToLocationTable.cs,PrepareForCompilation,The following statement contains a magic number: this.bytes [byteIdx++] = (byte)(value >> 8);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: try {  	this.fontData = new FontData (fontData);  	// Try to get real name form name table  	if (idName.Contains ("XPS-Font-") && this.fontData.name != null && this.fontData.name.Name.Length != 0) {  		string tag = String.Empty;  		if (idName.IndexOf ('+') == 6)  			tag = idName.Substring (0' 6);  		idName = tag + "+" + this.fontData.name.Name;  		if (this.fontData.name.Style.Length != 0)  			idName += "'" + this.fontData.name.Style;  		idName = idName.Replace (" "' "");  	}  	this.fontName = idName;  	Initialize ();  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: try {  	this.fontData = new FontData (fontData);  	// Try to get real name form name table  	if (idName.Contains ("XPS-Font-") && this.fontData.name != null && this.fontData.name.Name.Length != 0) {  		string tag = String.Empty;  		if (idName.IndexOf ('+') == 6)  			tag = idName.Substring (0' 6);  		idName = tag + "+" + this.fontData.name.Name;  		if (this.fontData.name.Style.Length != 0)  			idName += "'" + this.fontData.name.Style;  		idName = idName.Replace (" "' "");  	}  	this.fontName = idName;  	Initialize ();  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: if (idName.Contains ("XPS-Font-") && this.fontData.name != null && this.fontData.name.Name.Length != 0) {  	string tag = String.Empty;  	if (idName.IndexOf ('+') == 6)  		tag = idName.Substring (0' 6);  	idName = tag + "+" + this.fontData.name.Name;  	if (this.fontData.name.Style.Length != 0)  		idName += "'" + this.fontData.name.Style;  	idName = idName.Replace (" "' "");  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: if (idName.Contains ("XPS-Font-") && this.fontData.name != null && this.fontData.name.Name.Length != 0) {  	string tag = String.Empty;  	if (idName.IndexOf ('+') == 6)  		tag = idName.Substring (0' 6);  	idName = tag + "+" + this.fontData.name.Name;  	if (this.fontData.name.Style.Length != 0)  		idName += "'" + this.fontData.name.Style;  	idName = idName.Replace (" "' "");  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: if (idName.IndexOf ('+') == 6)  	tag = idName.Substring (0' 6);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: if (idName.IndexOf ('+') == 6)  	tag = idName.Substring (0' 6);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,OpenTypeDescriptor,The following statement contains a magic number: tag = idName.Substring (0' 6);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,Initialize,The following statement contains a magic number: if (fontData.os2.version >= 2 && fontData.os2.sCapHeight != 0)  	this.capHeight = fontData.os2.sCapHeight;  else  	this.capHeight = fontData.hhea.ascender;  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,Initialize,The following statement contains a magic number: if (fontData.os2.version >= 2 && fontData.os2.sxHeight != 0)  	this.xHeight = fontData.os2.sxHeight;  else  	this.xHeight = (int)(0.66f * this.ascender);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,Initialize,The following statement contains a magic number: this.widths = new int[256];  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,Initialize,The following statement contains a magic number: for (int idx = 0; idx < 256; idx++) {  	bytes [idx] = (byte)idx;  	// PDFlib handles some font flaws here...  	// We wait for bug reports.  	char ch = (char)idx;  	string s = ansi.GetString (bytes' idx' 1);  	if (s.Length != 0) {  		if (s [0] != ch)  			ch = s [0];  	}  	#if DEBUG  	if (idx == 'S')  		GetType ();  	#endif  	int glyphIndex;  	if (symbol) {  		glyphIndex = idx + (this.fontData.os2.usFirstCharIndex & 0xFF00);  		glyphIndex = CharCodeToGlyphIndex ((char)glyphIndex);  	}  	else {  		//Debug.Assert(idx + (this.fontData.os2.usFirstCharIndex & 0xFF00) == idx);  		//glyphIndex = CharCodeToGlyphIndex((char)idx);  		glyphIndex = CharCodeToGlyphIndex (ch);  	}  	this.widths [idx] = GlyphIndexToPdfWidth (glyphIndex);  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,DesignUnitsToPdf,The following statement contains a magic number: return (int)Math.Round (value * 1000.0 / this.fontData.head.unitsPerEm);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,CharCodeToGlyphIndex,The following statement contains a magic number: try {  	CMap4 cmap = this.fontData.cmap.cmap4;  	int segCount = cmap.segCountX2 / 2;  	int seg;  	for (seg = 0; seg < segCount; seg++) {  		if (value <= cmap.endCount [seg])  			break;  	}  	Debug.Assert (seg < segCount);  	if (value < cmap.startCount [seg])  		return 0;  	if (cmap.idRangeOffs [seg] == 0)  		return (value + cmap.idDelta [seg]) & 0xFFFF;  	int idx = cmap.idRangeOffs [seg] / 2 + (value - cmap.startCount [seg]) - (segCount - seg);  	Debug.Assert (idx >= 0 && idx < cmap.glyphCount);  	if (cmap.glyphIdArray [idx] == 0)  		return 0;  	return (cmap.glyphIdArray [idx] + cmap.idDelta [seg]) & 0xFFFF;  }  catch {  	throw;  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,CharCodeToGlyphIndex,The following statement contains a magic number: try {  	CMap4 cmap = this.fontData.cmap.cmap4;  	int segCount = cmap.segCountX2 / 2;  	int seg;  	for (seg = 0; seg < segCount; seg++) {  		if (value <= cmap.endCount [seg])  			break;  	}  	Debug.Assert (seg < segCount);  	if (value < cmap.startCount [seg])  		return 0;  	if (cmap.idRangeOffs [seg] == 0)  		return (value + cmap.idDelta [seg]) & 0xFFFF;  	int idx = cmap.idRangeOffs [seg] / 2 + (value - cmap.startCount [seg]) - (segCount - seg);  	Debug.Assert (idx >= 0 && idx < cmap.glyphCount);  	if (cmap.glyphIdArray [idx] == 0)  		return 0;  	return (cmap.glyphIdArray [idx] + cmap.idDelta [seg]) & 0xFFFF;  }  catch {  	throw;  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,GlyphIndexToPdfWidth,The following statement contains a magic number: try {  	int numberOfHMetrics = this.fontData.hhea.numberOfHMetrics;  	int unitsPerEm = this.fontData.head.unitsPerEm;  	// glyphIndex >= numberOfHMetrics means the font is mono-spaced and all glyphs have the same width  	if (glyphIndex >= numberOfHMetrics)  		glyphIndex = numberOfHMetrics - 1;  	int width = this.fontData.hmtx.metrics [glyphIndex].advanceWidth;  	// Sometimes the unitsPerEm is 1000' sometimes a power of 2.  	if (unitsPerEm == 1000)  		return width;  	return width * 1000 / unitsPerEm;  	// normalize  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,GlyphIndexToPdfWidth,The following statement contains a magic number: try {  	int numberOfHMetrics = this.fontData.hhea.numberOfHMetrics;  	int unitsPerEm = this.fontData.head.unitsPerEm;  	// glyphIndex >= numberOfHMetrics means the font is mono-spaced and all glyphs have the same width  	if (glyphIndex >= numberOfHMetrics)  		glyphIndex = numberOfHMetrics - 1;  	int width = this.fontData.hmtx.metrics [glyphIndex].advanceWidth;  	// Sometimes the unitsPerEm is 1000' sometimes a power of 2.  	if (unitsPerEm == 1000)  		return width;  	return width * 1000 / unitsPerEm;  	// normalize  }  catch (Exception ex) {  	throw ex;  }  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,GlyphIndexToPdfWidth,The following statement contains a magic number: if (unitsPerEm == 1000)  	return width;  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeDescriptor,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeDescriptor.cs,GlyphIndexToPdfWidth,The following statement contains a magic number: return width * 1000 / unitsPerEm;  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontTable.cs,CalcChecksum,The following statement contains a magic number: Debug.Assert ((bytes.Length & 3) == 0);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontTable.cs,CalcChecksum,The following statement contains a magic number: return (byte3 << 24) + (byte2 << 16) + (byte1 << 8) + byte0;  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontTable.cs,CalcChecksum,The following statement contains a magic number: return (byte3 << 24) + (byte2 << 16) + (byte1 << 8) + byte0;  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontTable.cs,CalcChecksum,The following statement contains a magic number: return (byte3 << 24) + (byte2 << 16) + (byte1 << 8) + byte0;  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontWriter.cs,WriteTag,The following statement contains a magic number: Debug.Assert (tag.Length == 4);  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontWriter.cs,WriteTag,The following statement contains a magic number: WriteByte ((byte)(tag [2]));  
Magic Number,PdfSharp.Fonts.OpenType,OpenTypeFontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeFontWriter.cs,WriteTag,The following statement contains a magic number: WriteByte ((byte)(tag [3]));  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	// m_EncodingID = encID;  	this.format = this.fontData.ReadUShort ();  	Debug.Assert (this.format == 4' "Only format 4 expected.");  	this.length = this.fontData.ReadUShort ();  	this.language = this.fontData.ReadUShort ();  	// Always null in Windows  	this.segCountX2 = this.fontData.ReadUShort ();  	this.searchRange = this.fontData.ReadUShort ();  	this.entrySelector = this.fontData.ReadUShort ();  	this.rangeShift = this.fontData.ReadUShort ();  	int segCount = this.segCountX2 / 2;  	this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  	//ASSERT_CONDITION(0 <= m_NumGlyphIds && m_NumGlyphIds < m_Length' "Invalid Index");  	this.endCount = new ushort[segCount];  	this.startCount = new ushort[segCount];  	this.idDelta = new short[segCount];  	this.idRangeOffs = new ushort[segCount];  	this.glyphIdArray = new ushort[this.glyphCount];  	for (int idx = 0; idx < segCount; idx++)  		this.endCount [idx] = this.fontData.ReadUShort ();  	//ASSERT_CONDITION(m_EndCount[segs - 1] == 0xFFFF' "Out of Index");  	// Read reserved pad.  	this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.startCount [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idDelta [idx] = this.fontData.ReadShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idRangeOffs [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.glyphCount; idx++)  		this.glyphIdArray [idx] = this.fontData.ReadUShort ();  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	// m_EncodingID = encID;  	this.format = this.fontData.ReadUShort ();  	Debug.Assert (this.format == 4' "Only format 4 expected.");  	this.length = this.fontData.ReadUShort ();  	this.language = this.fontData.ReadUShort ();  	// Always null in Windows  	this.segCountX2 = this.fontData.ReadUShort ();  	this.searchRange = this.fontData.ReadUShort ();  	this.entrySelector = this.fontData.ReadUShort ();  	this.rangeShift = this.fontData.ReadUShort ();  	int segCount = this.segCountX2 / 2;  	this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  	//ASSERT_CONDITION(0 <= m_NumGlyphIds && m_NumGlyphIds < m_Length' "Invalid Index");  	this.endCount = new ushort[segCount];  	this.startCount = new ushort[segCount];  	this.idDelta = new short[segCount];  	this.idRangeOffs = new ushort[segCount];  	this.glyphIdArray = new ushort[this.glyphCount];  	for (int idx = 0; idx < segCount; idx++)  		this.endCount [idx] = this.fontData.ReadUShort ();  	//ASSERT_CONDITION(m_EndCount[segs - 1] == 0xFFFF' "Out of Index");  	// Read reserved pad.  	this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.startCount [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idDelta [idx] = this.fontData.ReadShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idRangeOffs [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.glyphCount; idx++)  		this.glyphIdArray [idx] = this.fontData.ReadUShort ();  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	// m_EncodingID = encID;  	this.format = this.fontData.ReadUShort ();  	Debug.Assert (this.format == 4' "Only format 4 expected.");  	this.length = this.fontData.ReadUShort ();  	this.language = this.fontData.ReadUShort ();  	// Always null in Windows  	this.segCountX2 = this.fontData.ReadUShort ();  	this.searchRange = this.fontData.ReadUShort ();  	this.entrySelector = this.fontData.ReadUShort ();  	this.rangeShift = this.fontData.ReadUShort ();  	int segCount = this.segCountX2 / 2;  	this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  	//ASSERT_CONDITION(0 <= m_NumGlyphIds && m_NumGlyphIds < m_Length' "Invalid Index");  	this.endCount = new ushort[segCount];  	this.startCount = new ushort[segCount];  	this.idDelta = new short[segCount];  	this.idRangeOffs = new ushort[segCount];  	this.glyphIdArray = new ushort[this.glyphCount];  	for (int idx = 0; idx < segCount; idx++)  		this.endCount [idx] = this.fontData.ReadUShort ();  	//ASSERT_CONDITION(m_EndCount[segs - 1] == 0xFFFF' "Out of Index");  	// Read reserved pad.  	this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.startCount [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idDelta [idx] = this.fontData.ReadShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idRangeOffs [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.glyphCount; idx++)  		this.glyphIdArray [idx] = this.fontData.ReadUShort ();  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	// m_EncodingID = encID;  	this.format = this.fontData.ReadUShort ();  	Debug.Assert (this.format == 4' "Only format 4 expected.");  	this.length = this.fontData.ReadUShort ();  	this.language = this.fontData.ReadUShort ();  	// Always null in Windows  	this.segCountX2 = this.fontData.ReadUShort ();  	this.searchRange = this.fontData.ReadUShort ();  	this.entrySelector = this.fontData.ReadUShort ();  	this.rangeShift = this.fontData.ReadUShort ();  	int segCount = this.segCountX2 / 2;  	this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  	//ASSERT_CONDITION(0 <= m_NumGlyphIds && m_NumGlyphIds < m_Length' "Invalid Index");  	this.endCount = new ushort[segCount];  	this.startCount = new ushort[segCount];  	this.idDelta = new short[segCount];  	this.idRangeOffs = new ushort[segCount];  	this.glyphIdArray = new ushort[this.glyphCount];  	for (int idx = 0; idx < segCount; idx++)  		this.endCount [idx] = this.fontData.ReadUShort ();  	//ASSERT_CONDITION(m_EndCount[segs - 1] == 0xFFFF' "Out of Index");  	// Read reserved pad.  	this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.startCount [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idDelta [idx] = this.fontData.ReadShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idRangeOffs [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.glyphCount; idx++)  		this.glyphIdArray [idx] = this.fontData.ReadUShort ();  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	// m_EncodingID = encID;  	this.format = this.fontData.ReadUShort ();  	Debug.Assert (this.format == 4' "Only format 4 expected.");  	this.length = this.fontData.ReadUShort ();  	this.language = this.fontData.ReadUShort ();  	// Always null in Windows  	this.segCountX2 = this.fontData.ReadUShort ();  	this.searchRange = this.fontData.ReadUShort ();  	this.entrySelector = this.fontData.ReadUShort ();  	this.rangeShift = this.fontData.ReadUShort ();  	int segCount = this.segCountX2 / 2;  	this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  	//ASSERT_CONDITION(0 <= m_NumGlyphIds && m_NumGlyphIds < m_Length' "Invalid Index");  	this.endCount = new ushort[segCount];  	this.startCount = new ushort[segCount];  	this.idDelta = new short[segCount];  	this.idRangeOffs = new ushort[segCount];  	this.glyphIdArray = new ushort[this.glyphCount];  	for (int idx = 0; idx < segCount; idx++)  		this.endCount [idx] = this.fontData.ReadUShort ();  	//ASSERT_CONDITION(m_EndCount[segs - 1] == 0xFFFF' "Out of Index");  	// Read reserved pad.  	this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.startCount [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idDelta [idx] = this.fontData.ReadShort ();  	for (int idx = 0; idx < segCount; idx++)  		this.idRangeOffs [idx] = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.glyphCount; idx++)  		this.glyphIdArray [idx] = this.fontData.ReadUShort ();  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: Debug.Assert (this.format == 4' "Only format 4 expected.");  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  
Magic Number,PdfSharp.Fonts.OpenType,CMap4,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: this.glyphCount = (this.length - (16 + 8 * segCount)) / 2;  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	#if DEBUG  	this.fontData.Position = DirectoryEntry.Offset;  	#endif  	this.bytes = new byte[DirectoryEntry.PaddedLength];  	Buffer.BlockCopy (this.fontData.Data' DirectoryEntry.Offset' bytes' 0' DirectoryEntry.Length);  	this.format = this.fontData.ReadUShort ();  	this.count = this.fontData.ReadUShort ();  	this.stringOffset = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.count; idx++) {  		NameRecord nrec = ReadNameRecord ();  		byte[] value = new byte[nrec.length];  		Buffer.BlockCopy (this.fontData.Data' DirectoryEntry.Offset + this.stringOffset + nrec.offset' value' 0' nrec.length);  		//Debug.WriteLine(nrec.platformID.ToString());  		// Read font name and style  		if (nrec.platformID == 0 || nrec.platformID == 3) {  			if (nrec.nameID == 1 && nrec.languageID == 0x0409) {  				if (String.IsNullOrEmpty (Name))  					Name = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  			}  			if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  				if (String.IsNullOrEmpty (Style))  					Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  			}  		}  		//string s1 = Encoding.Default.GetString(name);  		//string s2 = Encoding.BigEndianUnicode.GetString(name);  		//Debug.WriteLine(s1);  		//Debug.WriteLine(s2);  	}  	Debug.Assert (!String.IsNullOrEmpty (Name));  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	#if DEBUG  	this.fontData.Position = DirectoryEntry.Offset;  	#endif  	this.bytes = new byte[DirectoryEntry.PaddedLength];  	Buffer.BlockCopy (this.fontData.Data' DirectoryEntry.Offset' bytes' 0' DirectoryEntry.Length);  	this.format = this.fontData.ReadUShort ();  	this.count = this.fontData.ReadUShort ();  	this.stringOffset = this.fontData.ReadUShort ();  	for (int idx = 0; idx < this.count; idx++) {  		NameRecord nrec = ReadNameRecord ();  		byte[] value = new byte[nrec.length];  		Buffer.BlockCopy (this.fontData.Data' DirectoryEntry.Offset + this.stringOffset + nrec.offset' value' 0' nrec.length);  		//Debug.WriteLine(nrec.platformID.ToString());  		// Read font name and style  		if (nrec.platformID == 0 || nrec.platformID == 3) {  			if (nrec.nameID == 1 && nrec.languageID == 0x0409) {  				if (String.IsNullOrEmpty (Name))  					Name = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  			}  			if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  				if (String.IsNullOrEmpty (Style))  					Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  			}  		}  		//string s1 = Encoding.Default.GetString(name);  		//string s2 = Encoding.BigEndianUnicode.GetString(name);  		//Debug.WriteLine(s1);  		//Debug.WriteLine(s2);  	}  	Debug.Assert (!String.IsNullOrEmpty (Name));  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: for (int idx = 0; idx < this.count; idx++) {  	NameRecord nrec = ReadNameRecord ();  	byte[] value = new byte[nrec.length];  	Buffer.BlockCopy (this.fontData.Data' DirectoryEntry.Offset + this.stringOffset + nrec.offset' value' 0' nrec.length);  	//Debug.WriteLine(nrec.platformID.ToString());  	// Read font name and style  	if (nrec.platformID == 0 || nrec.platformID == 3) {  		if (nrec.nameID == 1 && nrec.languageID == 0x0409) {  			if (String.IsNullOrEmpty (Name))  				Name = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  		}  		if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  			if (String.IsNullOrEmpty (Style))  				Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  		}  	}  	//string s1 = Encoding.Default.GetString(name);  	//string s2 = Encoding.BigEndianUnicode.GetString(name);  	//Debug.WriteLine(s1);  	//Debug.WriteLine(s2);  }  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: for (int idx = 0; idx < this.count; idx++) {  	NameRecord nrec = ReadNameRecord ();  	byte[] value = new byte[nrec.length];  	Buffer.BlockCopy (this.fontData.Data' DirectoryEntry.Offset + this.stringOffset + nrec.offset' value' 0' nrec.length);  	//Debug.WriteLine(nrec.platformID.ToString());  	// Read font name and style  	if (nrec.platformID == 0 || nrec.platformID == 3) {  		if (nrec.nameID == 1 && nrec.languageID == 0x0409) {  			if (String.IsNullOrEmpty (Name))  				Name = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  		}  		if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  			if (String.IsNullOrEmpty (Style))  				Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  		}  	}  	//string s1 = Encoding.Default.GetString(name);  	//string s2 = Encoding.BigEndianUnicode.GetString(name);  	//Debug.WriteLine(s1);  	//Debug.WriteLine(s2);  }  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: if (nrec.platformID == 0 || nrec.platformID == 3) {  	if (nrec.nameID == 1 && nrec.languageID == 0x0409) {  		if (String.IsNullOrEmpty (Name))  			Name = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  	}  	if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  		if (String.IsNullOrEmpty (Style))  			Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: if (nrec.platformID == 0 || nrec.platformID == 3) {  	if (nrec.nameID == 1 && nrec.languageID == 0x0409) {  		if (String.IsNullOrEmpty (Name))  			Name = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  	}  	if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  		if (String.IsNullOrEmpty (Style))  			Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,NameTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: if (nrec.nameID == 2 && nrec.languageID == 0x0409) {  	if (String.IsNullOrEmpty (Style))  		Style = Encoding.BigEndianUnicode.GetString (value' 0' value.Length);  }  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	this.version = this.fontData.ReadUShort ();  	this.xAvgCharWidth = this.fontData.ReadShort ();  	this.usWeightClass = this.fontData.ReadUShort ();  	this.usWidthClass = this.fontData.ReadUShort ();  	this.fsType = this.fontData.ReadUShort ();  	this.ySubscriptXSize = this.fontData.ReadShort ();  	this.ySubscriptYSize = this.fontData.ReadShort ();  	this.ySubscriptXOffset = this.fontData.ReadShort ();  	this.ySubscriptYOffset = this.fontData.ReadShort ();  	this.ySuperscriptXSize = this.fontData.ReadShort ();  	this.ySuperscriptYSize = this.fontData.ReadShort ();  	this.ySuperscriptXOffset = this.fontData.ReadShort ();  	this.ySuperscriptYOffset = this.fontData.ReadShort ();  	this.yStrikeoutSize = this.fontData.ReadShort ();  	this.yStrikeoutPosition = this.fontData.ReadShort ();  	this.sFamilyClass = this.fontData.ReadShort ();  	this.panose = this.fontData.ReadBytes (10);  	this.ulUnicodeRange1 = this.fontData.ReadULong ();  	this.ulUnicodeRange2 = this.fontData.ReadULong ();  	this.ulUnicodeRange3 = this.fontData.ReadULong ();  	this.ulUnicodeRange4 = this.fontData.ReadULong ();  	this.achVendID = this.fontData.ReadString (4);  	this.fsSelection = this.fontData.ReadUShort ();  	this.usFirstCharIndex = this.fontData.ReadUShort ();  	this.usLastCharIndex = this.fontData.ReadUShort ();  	this.sTypoAscender = this.fontData.ReadShort ();  	this.sTypoDescender = this.fontData.ReadShort ();  	this.sTypoLineGap = this.fontData.ReadShort ();  	this.usWinAscent = this.fontData.ReadUShort ();  	this.usWinDescent = this.fontData.ReadUShort ();  	if (this.version >= 1) {  		this.ulCodePageRange1 = this.fontData.ReadULong ();  		this.ulCodePageRange2 = this.fontData.ReadULong ();  		if (this.version >= 2) {  			this.sxHeight = this.fontData.ReadShort ();  			this.sCapHeight = this.fontData.ReadShort ();  			this.usDefaultChar = this.fontData.ReadUShort ();  			this.usBreakChar = this.fontData.ReadUShort ();  			this.usMaxContext = this.fontData.ReadUShort ();  		}  	}  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	this.version = this.fontData.ReadUShort ();  	this.xAvgCharWidth = this.fontData.ReadShort ();  	this.usWeightClass = this.fontData.ReadUShort ();  	this.usWidthClass = this.fontData.ReadUShort ();  	this.fsType = this.fontData.ReadUShort ();  	this.ySubscriptXSize = this.fontData.ReadShort ();  	this.ySubscriptYSize = this.fontData.ReadShort ();  	this.ySubscriptXOffset = this.fontData.ReadShort ();  	this.ySubscriptYOffset = this.fontData.ReadShort ();  	this.ySuperscriptXSize = this.fontData.ReadShort ();  	this.ySuperscriptYSize = this.fontData.ReadShort ();  	this.ySuperscriptXOffset = this.fontData.ReadShort ();  	this.ySuperscriptYOffset = this.fontData.ReadShort ();  	this.yStrikeoutSize = this.fontData.ReadShort ();  	this.yStrikeoutPosition = this.fontData.ReadShort ();  	this.sFamilyClass = this.fontData.ReadShort ();  	this.panose = this.fontData.ReadBytes (10);  	this.ulUnicodeRange1 = this.fontData.ReadULong ();  	this.ulUnicodeRange2 = this.fontData.ReadULong ();  	this.ulUnicodeRange3 = this.fontData.ReadULong ();  	this.ulUnicodeRange4 = this.fontData.ReadULong ();  	this.achVendID = this.fontData.ReadString (4);  	this.fsSelection = this.fontData.ReadUShort ();  	this.usFirstCharIndex = this.fontData.ReadUShort ();  	this.usLastCharIndex = this.fontData.ReadUShort ();  	this.sTypoAscender = this.fontData.ReadShort ();  	this.sTypoDescender = this.fontData.ReadShort ();  	this.sTypoLineGap = this.fontData.ReadShort ();  	this.usWinAscent = this.fontData.ReadUShort ();  	this.usWinDescent = this.fontData.ReadUShort ();  	if (this.version >= 1) {  		this.ulCodePageRange1 = this.fontData.ReadULong ();  		this.ulCodePageRange2 = this.fontData.ReadULong ();  		if (this.version >= 2) {  			this.sxHeight = this.fontData.ReadShort ();  			this.sCapHeight = this.fontData.ReadShort ();  			this.usDefaultChar = this.fontData.ReadUShort ();  			this.usBreakChar = this.fontData.ReadUShort ();  			this.usMaxContext = this.fontData.ReadUShort ();  		}  	}  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	this.version = this.fontData.ReadUShort ();  	this.xAvgCharWidth = this.fontData.ReadShort ();  	this.usWeightClass = this.fontData.ReadUShort ();  	this.usWidthClass = this.fontData.ReadUShort ();  	this.fsType = this.fontData.ReadUShort ();  	this.ySubscriptXSize = this.fontData.ReadShort ();  	this.ySubscriptYSize = this.fontData.ReadShort ();  	this.ySubscriptXOffset = this.fontData.ReadShort ();  	this.ySubscriptYOffset = this.fontData.ReadShort ();  	this.ySuperscriptXSize = this.fontData.ReadShort ();  	this.ySuperscriptYSize = this.fontData.ReadShort ();  	this.ySuperscriptXOffset = this.fontData.ReadShort ();  	this.ySuperscriptYOffset = this.fontData.ReadShort ();  	this.yStrikeoutSize = this.fontData.ReadShort ();  	this.yStrikeoutPosition = this.fontData.ReadShort ();  	this.sFamilyClass = this.fontData.ReadShort ();  	this.panose = this.fontData.ReadBytes (10);  	this.ulUnicodeRange1 = this.fontData.ReadULong ();  	this.ulUnicodeRange2 = this.fontData.ReadULong ();  	this.ulUnicodeRange3 = this.fontData.ReadULong ();  	this.ulUnicodeRange4 = this.fontData.ReadULong ();  	this.achVendID = this.fontData.ReadString (4);  	this.fsSelection = this.fontData.ReadUShort ();  	this.usFirstCharIndex = this.fontData.ReadUShort ();  	this.usLastCharIndex = this.fontData.ReadUShort ();  	this.sTypoAscender = this.fontData.ReadShort ();  	this.sTypoDescender = this.fontData.ReadShort ();  	this.sTypoLineGap = this.fontData.ReadShort ();  	this.usWinAscent = this.fontData.ReadUShort ();  	this.usWinDescent = this.fontData.ReadUShort ();  	if (this.version >= 1) {  		this.ulCodePageRange1 = this.fontData.ReadULong ();  		this.ulCodePageRange2 = this.fontData.ReadULong ();  		if (this.version >= 2) {  			this.sxHeight = this.fontData.ReadShort ();  			this.sCapHeight = this.fontData.ReadShort ();  			this.usDefaultChar = this.fontData.ReadUShort ();  			this.usBreakChar = this.fontData.ReadUShort ();  			this.usMaxContext = this.fontData.ReadUShort ();  		}  	}  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: this.panose = this.fontData.ReadBytes (10);  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: this.achVendID = this.fontData.ReadString (4);  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: if (this.version >= 1) {  	this.ulCodePageRange1 = this.fontData.ReadULong ();  	this.ulCodePageRange2 = this.fontData.ReadULong ();  	if (this.version >= 2) {  		this.sxHeight = this.fontData.ReadShort ();  		this.sCapHeight = this.fontData.ReadShort ();  		this.usDefaultChar = this.fontData.ReadUShort ();  		this.usBreakChar = this.fontData.ReadUShort ();  		this.usMaxContext = this.fontData.ReadUShort ();  	}  }  
Magic Number,PdfSharp.Fonts.OpenType,OS2Table,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: if (this.version >= 2) {  	this.sxHeight = this.fontData.ReadShort ();  	this.sCapHeight = this.fontData.ReadShort ();  	this.usDefaultChar = this.fontData.ReadUShort ();  	this.usBreakChar = this.fontData.ReadUShort ();  	this.usMaxContext = this.fontData.ReadUShort ();  }  
Magic Number,PdfSharp.Fonts.OpenType,ControlValueTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\OpenTypeStructures.cs,Read,The following statement contains a magic number: try {  	int length = DirectoryEntry.Length / 2;  	this.array = new FWord[length];  	for (int idx = 0; idx < length; idx++)  		this.array [idx] = this.fontData.ReadFWord ();  }  catch (Exception ex) {  	throw new PdfSharpException (PSSR.ErrorReadingFontData' ex);  }  
Magic Number,PdfSharp.Fonts.OpenType,TableDirectoryEntry,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\TableDirectoryEntry.cs,TableDirectoryEntry,The following statement contains a magic number: Debug.Assert (tag.Length == 4);  
Magic Number,PdfSharp.Fonts.OpenType,TableDirectoryEntry,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\TableDirectoryEntry.cs,Write,The following statement contains a magic number: Debug.Assert (this.Tag.Length == 4);  
Magic Number,PdfSharp.Fonts,CMapInfo,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\CMapInfo.cs,AddAnsiChars,The following statement contains a magic number: for (int idx = 0; idx < 256 - 32; idx++)  	ansi [idx] = (byte)(idx + 32);  
Magic Number,PdfSharp.Fonts,CMapInfo,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\CMapInfo.cs,AddAnsiChars,The following statement contains a magic number: for (int idx = 0; idx < 256 - 32; idx++)  	ansi [idx] = (byte)(idx + 32);  
Magic Number,PdfSharp.Fonts,CMapInfo,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\CMapInfo.cs,AddAnsiChars,The following statement contains a magic number: for (int idx = 0; idx < 256 - 32; idx++)  	ansi [idx] = (byte)(idx + 32);  
Magic Number,PdfSharp.Fonts,CMapInfo,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\CMapInfo.cs,AddAnsiChars,The following statement contains a magic number: ansi [idx] = (byte)(idx + 32);  
Magic Number,PdfSharp.Fonts,FontDescriptorStock,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontDescriptorStock.cs,CreateDescriptor,The following statement contains a magic number: if (!this.table.TryGetValue (selector' out descriptor)) {  	lock (typeof(FontDescriptorStock)) {  		// may be created by other thread meanwhile  		if (!this.table.TryGetValue (selector' out descriptor)) {  			XFont font = new XFont (family.Name' 10' style);  			descriptor = new OpenTypeDescriptor (font);  			if (this.table.ContainsKey (selector))  				GetType ();  			else  				this.table.Add (selector' descriptor);  		}  	}  }  
Magic Number,PdfSharp.Fonts,FontDescriptorStock,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontDescriptorStock.cs,CreateDescriptor,The following statement contains a magic number: lock (typeof(FontDescriptorStock)) {  	// may be created by other thread meanwhile  	if (!this.table.TryGetValue (selector' out descriptor)) {  		XFont font = new XFont (family.Name' 10' style);  		descriptor = new OpenTypeDescriptor (font);  		if (this.table.ContainsKey (selector))  			GetType ();  		else  			this.table.Add (selector' descriptor);  	}  }  
Magic Number,PdfSharp.Fonts,FontDescriptorStock,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontDescriptorStock.cs,CreateDescriptor,The following statement contains a magic number: if (!this.table.TryGetValue (selector' out descriptor)) {  	XFont font = new XFont (family.Name' 10' style);  	descriptor = new OpenTypeDescriptor (font);  	if (this.table.ContainsKey (selector))  		GetType ();  	else  		this.table.Add (selector' descriptor);  }  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteShort,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 8));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteUShort,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 8));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteInt,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 24));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteInt,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 16));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteInt,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 8));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteUInt,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 24));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteUInt,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 16));  
Magic Number,PdfSharp.Fonts,FontWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts\FontWriter.cs,WriteUInt,The following statement contains a magic number: this.stream.WriteByte ((byte)(value >> 8));  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (obj is ColorItem) {  	ColorItem item = (ColorItem)obj;  	// Is custom color?  	if (idx == 0) {  		string name;  		if (this.color.IsEmpty)  			name = "custom";  		else  			name = this.crm.ToColorName (this.color);  		item = new ColorItem (this.color' name);  	}  	XColor clr = item.Color;  	Graphics gfx = e.Graphics;  	Rectangle rect = e.Bounds;  	Brush textbrush = SystemBrushes.ControlText;  	if ((e.State & DrawItemState.Selected) == 0) {  		gfx.FillRectangle (SystemBrushes.Window' rect);  		textbrush = SystemBrushes.ControlText;  	}  	else {  		gfx.FillRectangle (SystemBrushes.Highlight' rect);  		textbrush = SystemBrushes.HighlightText;  	}  	// Draw color box  	if (!clr.IsEmpty) {  		Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  		gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  		gfx.DrawRectangle (Pens.Black' box);  	}  	StringFormat format = new StringFormat (StringFormat.GenericDefault);  	format.Alignment = StringAlignment.Near;  	format.LineAlignment = StringAlignment.Center;  	rect.X += rect.Height * 2 + 3 + 3;  	gfx.DrawString (item.Name' Font' textbrush' rect' format);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (obj is ColorItem) {  	ColorItem item = (ColorItem)obj;  	// Is custom color?  	if (idx == 0) {  		string name;  		if (this.color.IsEmpty)  			name = "custom";  		else  			name = this.crm.ToColorName (this.color);  		item = new ColorItem (this.color' name);  	}  	XColor clr = item.Color;  	Graphics gfx = e.Graphics;  	Rectangle rect = e.Bounds;  	Brush textbrush = SystemBrushes.ControlText;  	if ((e.State & DrawItemState.Selected) == 0) {  		gfx.FillRectangle (SystemBrushes.Window' rect);  		textbrush = SystemBrushes.ControlText;  	}  	else {  		gfx.FillRectangle (SystemBrushes.Highlight' rect);  		textbrush = SystemBrushes.HighlightText;  	}  	// Draw color box  	if (!clr.IsEmpty) {  		Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  		gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  		gfx.DrawRectangle (Pens.Black' box);  	}  	StringFormat format = new StringFormat (StringFormat.GenericDefault);  	format.Alignment = StringAlignment.Near;  	format.LineAlignment = StringAlignment.Center;  	rect.X += rect.Height * 2 + 3 + 3;  	gfx.DrawString (item.Name' Font' textbrush' rect' format);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (obj is ColorItem) {  	ColorItem item = (ColorItem)obj;  	// Is custom color?  	if (idx == 0) {  		string name;  		if (this.color.IsEmpty)  			name = "custom";  		else  			name = this.crm.ToColorName (this.color);  		item = new ColorItem (this.color' name);  	}  	XColor clr = item.Color;  	Graphics gfx = e.Graphics;  	Rectangle rect = e.Bounds;  	Brush textbrush = SystemBrushes.ControlText;  	if ((e.State & DrawItemState.Selected) == 0) {  		gfx.FillRectangle (SystemBrushes.Window' rect);  		textbrush = SystemBrushes.ControlText;  	}  	else {  		gfx.FillRectangle (SystemBrushes.Highlight' rect);  		textbrush = SystemBrushes.HighlightText;  	}  	// Draw color box  	if (!clr.IsEmpty) {  		Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  		gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  		gfx.DrawRectangle (Pens.Black' box);  	}  	StringFormat format = new StringFormat (StringFormat.GenericDefault);  	format.Alignment = StringAlignment.Near;  	format.LineAlignment = StringAlignment.Center;  	rect.X += rect.Height * 2 + 3 + 3;  	gfx.DrawString (item.Name' Font' textbrush' rect' format);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (obj is ColorItem) {  	ColorItem item = (ColorItem)obj;  	// Is custom color?  	if (idx == 0) {  		string name;  		if (this.color.IsEmpty)  			name = "custom";  		else  			name = this.crm.ToColorName (this.color);  		item = new ColorItem (this.color' name);  	}  	XColor clr = item.Color;  	Graphics gfx = e.Graphics;  	Rectangle rect = e.Bounds;  	Brush textbrush = SystemBrushes.ControlText;  	if ((e.State & DrawItemState.Selected) == 0) {  		gfx.FillRectangle (SystemBrushes.Window' rect);  		textbrush = SystemBrushes.ControlText;  	}  	else {  		gfx.FillRectangle (SystemBrushes.Highlight' rect);  		textbrush = SystemBrushes.HighlightText;  	}  	// Draw color box  	if (!clr.IsEmpty) {  		Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  		gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  		gfx.DrawRectangle (Pens.Black' box);  	}  	StringFormat format = new StringFormat (StringFormat.GenericDefault);  	format.Alignment = StringAlignment.Near;  	format.LineAlignment = StringAlignment.Center;  	rect.X += rect.Height * 2 + 3 + 3;  	gfx.DrawString (item.Name' Font' textbrush' rect' format);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (obj is ColorItem) {  	ColorItem item = (ColorItem)obj;  	// Is custom color?  	if (idx == 0) {  		string name;  		if (this.color.IsEmpty)  			name = "custom";  		else  			name = this.crm.ToColorName (this.color);  		item = new ColorItem (this.color' name);  	}  	XColor clr = item.Color;  	Graphics gfx = e.Graphics;  	Rectangle rect = e.Bounds;  	Brush textbrush = SystemBrushes.ControlText;  	if ((e.State & DrawItemState.Selected) == 0) {  		gfx.FillRectangle (SystemBrushes.Window' rect);  		textbrush = SystemBrushes.ControlText;  	}  	else {  		gfx.FillRectangle (SystemBrushes.Highlight' rect);  		textbrush = SystemBrushes.HighlightText;  	}  	// Draw color box  	if (!clr.IsEmpty) {  		Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  		gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  		gfx.DrawRectangle (Pens.Black' box);  	}  	StringFormat format = new StringFormat (StringFormat.GenericDefault);  	format.Alignment = StringAlignment.Near;  	format.LineAlignment = StringAlignment.Center;  	rect.X += rect.Height * 2 + 3 + 3;  	gfx.DrawString (item.Name' Font' textbrush' rect' format);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (obj is ColorItem) {  	ColorItem item = (ColorItem)obj;  	// Is custom color?  	if (idx == 0) {  		string name;  		if (this.color.IsEmpty)  			name = "custom";  		else  			name = this.crm.ToColorName (this.color);  		item = new ColorItem (this.color' name);  	}  	XColor clr = item.Color;  	Graphics gfx = e.Graphics;  	Rectangle rect = e.Bounds;  	Brush textbrush = SystemBrushes.ControlText;  	if ((e.State & DrawItemState.Selected) == 0) {  		gfx.FillRectangle (SystemBrushes.Window' rect);  		textbrush = SystemBrushes.ControlText;  	}  	else {  		gfx.FillRectangle (SystemBrushes.Highlight' rect);  		textbrush = SystemBrushes.HighlightText;  	}  	// Draw color box  	if (!clr.IsEmpty) {  		Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  		gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  		gfx.DrawRectangle (Pens.Black' box);  	}  	StringFormat format = new StringFormat (StringFormat.GenericDefault);  	format.Alignment = StringAlignment.Near;  	format.LineAlignment = StringAlignment.Center;  	rect.X += rect.Height * 2 + 3 + 3;  	gfx.DrawString (item.Name' Font' textbrush' rect' format);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (!clr.IsEmpty) {  	Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  	gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  	gfx.DrawRectangle (Pens.Black' box);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (!clr.IsEmpty) {  	Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  	gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  	gfx.DrawRectangle (Pens.Black' box);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: if (!clr.IsEmpty) {  	Rectangle box = new Rectangle (rect.X + 3' rect.Y + 1' rect.Height * 2' rect.Height - 3);  	gfx.FillRectangle (new SolidBrush (clr.ToGdiColor ())' box);  	gfx.DrawRectangle (Pens.Black' box);  }  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: rect.X += rect.Height * 2 + 3 + 3;  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: rect.X += rect.Height * 2 + 3 + 3;  
Magic Number,PdfSharp.Forms,ColorComboBox,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\ColorComboBox.cs,OnDrawItem,The following statement contains a magic number: rect.X += rect.Height * 2 + 3 + 3;  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (228' 252);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (228' 252);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,OnPaintBackground,The following statement contains a magic number: switch (this.borderStyle) {  case BorderStyle.FixedSingle:  	gfx.DrawRectangle (SystemPens.WindowFrame' clientRect.X' clientRect.Y' clientRect.Width - 1' clientRect.Height - 1);  	d = 1;  	break;  case BorderStyle.Fixed3D:  	ControlPaint.DrawBorder3D (gfx' clientRect' Border3DStyle.Sunken);  	d = 2;  	break;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,OnPaintBackground,The following statement contains a magic number: d = 2;  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,LayoutChildren,The following statement contains a magic number: switch (this.borderStyle) {  case BorderStyle.FixedSingle:  	clientRect.Inflate (-1' -1);  	break;  case BorderStyle.Fixed3D:  	clientRect.Inflate (-2' -2);  	break;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,LayoutChildren,The following statement contains a magic number: switch (this.borderStyle) {  case BorderStyle.FixedSingle:  	clientRect.Inflate (-1' -1);  	break;  case BorderStyle.Fixed3D:  	clientRect.Inflate (-2' -2);  	break;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,LayoutChildren,The following statement contains a magic number: clientRect.Inflate (-2' -2);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,LayoutChildren,The following statement contains a magic number: clientRect.Inflate (-2' -2);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: switch (this.zoom) {  case Zoom.BestFit:  	BestFit:  	//this.zoomPercent = Convert.ToInt32(25400.0 * (rcCanvas.Width - (leftBorder + rightBorder)) / (this.pageSize.Width * xdpiScreen));  	this.zoomPercent = (int)(7200f * (rcCanvas.Width - horzBorders) / (this.pageSize.Width * xdpiScreen));  	//--this.zoomPercent;  // prevend round up errors  	break;  case Zoom.TextFit:  	// TODO: 'public Rectangle TextBox' property  	goto BestFit;  //this.zoomPercent = LongFromReal (25400.0 / (_cxUsedPage + 0) *   //                            (rcWnd.CX () - 2 * cxScrollbar) / xdpiScreen) - 3;  //break;  case Zoom.FullPage:  	{  		//int zoomX = Convert.ToInt32(25400.0 / (this.pageSize.Width) *  		//  (rcCanvas.Width - (leftBorder + rightBorder)) / xdpiScreen);  		//int zoomY = Convert.ToInt32(25400.0 / (this.pageSize.Height) *  		//  (rcCanvas.Height - (topBorder + bottomBorder)) / ydpiScreen);  		int zoomX = (int)(7200f * (rcCanvas.Width - horzBorders) / (this.pageSize.Width * xdpiScreen));  		int zoomY = (int)(7200f * (rcCanvas.Height - vertBorders) / (this.pageSize.Height * ydpiScreen));  		this.zoomPercent = Math.Min (zoomX' zoomY);  		//--this.zoomPercent;  // prevend round up errors  	}  	break;  case Zoom.OriginalSize:  	this.zoomPercent = (int)(0.5 + 200f / (devInfo.ScaleX + devInfo.ScaleY));  	this.zoomPercent = (int)(0.5 + 100f / devInfo.ScaleX);  	break;  default:  	this.zoomPercent = (int)this.zoom;  	break;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: switch (this.zoom) {  case Zoom.BestFit:  	BestFit:  	//this.zoomPercent = Convert.ToInt32(25400.0 * (rcCanvas.Width - (leftBorder + rightBorder)) / (this.pageSize.Width * xdpiScreen));  	this.zoomPercent = (int)(7200f * (rcCanvas.Width - horzBorders) / (this.pageSize.Width * xdpiScreen));  	//--this.zoomPercent;  // prevend round up errors  	break;  case Zoom.TextFit:  	// TODO: 'public Rectangle TextBox' property  	goto BestFit;  //this.zoomPercent = LongFromReal (25400.0 / (_cxUsedPage + 0) *   //                            (rcWnd.CX () - 2 * cxScrollbar) / xdpiScreen) - 3;  //break;  case Zoom.FullPage:  	{  		//int zoomX = Convert.ToInt32(25400.0 / (this.pageSize.Width) *  		//  (rcCanvas.Width - (leftBorder + rightBorder)) / xdpiScreen);  		//int zoomY = Convert.ToInt32(25400.0 / (this.pageSize.Height) *  		//  (rcCanvas.Height - (topBorder + bottomBorder)) / ydpiScreen);  		int zoomX = (int)(7200f * (rcCanvas.Width - horzBorders) / (this.pageSize.Width * xdpiScreen));  		int zoomY = (int)(7200f * (rcCanvas.Height - vertBorders) / (this.pageSize.Height * ydpiScreen));  		this.zoomPercent = Math.Min (zoomX' zoomY);  		//--this.zoomPercent;  // prevend round up errors  	}  	break;  case Zoom.OriginalSize:  	this.zoomPercent = (int)(0.5 + 200f / (devInfo.ScaleX + devInfo.ScaleY));  	this.zoomPercent = (int)(0.5 + 100f / devInfo.ScaleX);  	break;  default:  	this.zoomPercent = (int)this.zoom;  	break;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: this.zoomPercent = (int)(0.5 + 200f / (devInfo.ScaleX + devInfo.ScaleY));  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: this.zoomPercent = (int)(0.5 + 100f / devInfo.ScaleX);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: this.virtualPage.Width = (int)(this.pageSize.Width * xdpiScreen * this.zoomPercent / 7200);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: this.virtualPage.Height = (int)(this.pageSize.Height * ydpiScreen * this.zoomPercent / 7200);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: if (virtualCanvas.Width < rcCanvas.Width) {  	virtualCanvas.Width = rcCanvas.Width;  	this.virtualPage.X = leftBorder + (rcCanvas.Width - horzBorders - virtualPage.Width) / 2;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: this.virtualPage.X = leftBorder + (rcCanvas.Width - horzBorders - virtualPage.Width) / 2;  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: if (virtualCanvas.Height < rcCanvas.Height) {  	virtualCanvas.Height = rcCanvas.Height;  	this.virtualPage.Y = topBorder + (rcCanvas.Height - vertBorders - virtualPage.Height) / 2;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,CalculatePreviewDimension,The following statement contains a magic number: this.virtualPage.Y = topBorder + (rcCanvas.Height - vertBorders - virtualPage.Height) / 2;  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.SetClip (new Rectangle (virtualPage.X' virtualPage.Y' virtualPage.Width + 3' virtualPage.Height + 3)' CombineMode.Exclude);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.SetClip (new Rectangle (virtualPage.X' virtualPage.Y' virtualPage.Width + 3' virtualPage.Height + 3)' CombineMode.Exclude);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.SetClip (new Rectangle (virtualPage.X + virtualPage.Width + 1' virtualPage.Y' 2' 2)' CombineMode.Union);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.SetClip (new Rectangle (virtualPage.X + virtualPage.Width + 1' virtualPage.Y' 2' 2)' CombineMode.Union);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.SetClip (new Rectangle (virtualPage.X' virtualPage.Y + virtualPage.Height + 1' 2' 2)' CombineMode.Union);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.SetClip (new Rectangle (virtualPage.X' virtualPage.Y + virtualPage.Height + 1' 2' 2)' CombineMode.Union);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.FillRectangle (brushShadow' virtualPage.X + virtualPage.Width + 1' virtualPage.Y + 2' 2' virtualPage.Height + 1);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.FillRectangle (brushShadow' virtualPage.X + virtualPage.Width + 1' virtualPage.Y + 2' 2' virtualPage.Height + 1);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.FillRectangle (brushShadow' virtualPage.X + 2' virtualPage.Y + virtualPage.Height + 1' virtualPage.Width + 1' 2);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,PaintBackground,The following statement contains a magic number: gfx.FillRectangle (brushShadow' virtualPage.X + 2' virtualPage.Y + virtualPage.Height + 1' virtualPage.Width + 1' 2);  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,SetScrollBarRange,The following statement contains a magic number: if (ShowScrollbars && this.hScrollBar != null) {  	if (this.posOffset.X > dx)  		this.hScrollBar.Value = this.posOffset.X = dx;  	if (dx > 0) {  		this.hScrollBar.Minimum = 0;  		this.hScrollBar.Maximum = this.virtualCanvas.Width;  		this.hScrollBar.SmallChange = clientAreaSize.Width / 10;  		this.hScrollBar.LargeChange = clientAreaSize.Width;  		this.hScrollBar.Enabled = true;  	}  	else {  		this.hScrollBar.Minimum = 0;  		this.hScrollBar.Maximum = 0;  		this.hScrollBar.Enabled = false;  	}  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,SetScrollBarRange,The following statement contains a magic number: if (dx > 0) {  	this.hScrollBar.Minimum = 0;  	this.hScrollBar.Maximum = this.virtualCanvas.Width;  	this.hScrollBar.SmallChange = clientAreaSize.Width / 10;  	this.hScrollBar.LargeChange = clientAreaSize.Width;  	this.hScrollBar.Enabled = true;  }  else {  	this.hScrollBar.Minimum = 0;  	this.hScrollBar.Maximum = 0;  	this.hScrollBar.Enabled = false;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,SetScrollBarRange,The following statement contains a magic number: this.hScrollBar.SmallChange = clientAreaSize.Width / 10;  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,SetScrollBarRange,The following statement contains a magic number: if (ShowScrollbars && this.vScrollBar != null) {  	if (this.posOffset.Y > dy)  		this.vScrollBar.Value = this.posOffset.Y = dy;  	if (dy > 0) {  		this.vScrollBar.Minimum = 0;  		this.vScrollBar.Maximum = this.virtualCanvas.Height;  		this.vScrollBar.SmallChange = clientAreaSize.Height / 10;  		this.vScrollBar.LargeChange = clientAreaSize.Height;  		this.vScrollBar.Enabled = true;  	}  	else {  		this.vScrollBar.Minimum = 0;  		this.vScrollBar.Maximum = 0;  		this.vScrollBar.Enabled = false;  	}  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,SetScrollBarRange,The following statement contains a magic number: if (dy > 0) {  	this.vScrollBar.Minimum = 0;  	this.vScrollBar.Maximum = this.virtualCanvas.Height;  	this.vScrollBar.SmallChange = clientAreaSize.Height / 10;  	this.vScrollBar.LargeChange = clientAreaSize.Height;  	this.vScrollBar.Enabled = true;  }  else {  	this.vScrollBar.Minimum = 0;  	this.vScrollBar.Maximum = 0;  	this.vScrollBar.Enabled = false;  }  
Magic Number,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,SetScrollBarRange,The following statement contains a magic number: this.vScrollBar.SmallChange = clientAreaSize.Height / 10;  
Magic Number,PdfSharp.Pdf.AcroForms,PdfTextField,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.AcroForms\PdfTextField.cs,RenderAppearance,The following statement contains a magic number: if (text.Length > 0)  	gfx.DrawString (Text' Font' new XSolidBrush (ForeColor)' rect.ToXRect () - rect.Location + new XPoint (2' 0)' XStringFormats.TopLeft);  
Magic Number,PdfSharp.Pdf.AcroForms,PdfTextField,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.AcroForms\PdfTextField.cs,RenderAppearance,The following statement contains a magic number: gfx.DrawString (Text' Font' new XSolidBrush (ForeColor)' rect.ToXRect () - rect.Location + new XPoint (2' 0)' XStringFormats.TopLeft);  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (this.Stream != null) {  	byte[] value = Stream.Value;  	int length = value.Length;  	if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  		byte[] newValue = new byte[length + 2 + 3];  		newValue [0] = (byte)'q';  		newValue [1] = (byte)'\n';  		Array.Copy (value' 0' newValue' 2' length);  		newValue [length + 2] = (byte)' ';  		newValue [length + 3] = (byte)'Q';  		newValue [length + 4] = (byte)'\n';  		Stream.Value = newValue;  		Elements.SetInteger ("/Length"' Stream.Length);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (this.Stream != null) {  	byte[] value = Stream.Value;  	int length = value.Length;  	if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  		byte[] newValue = new byte[length + 2 + 3];  		newValue [0] = (byte)'q';  		newValue [1] = (byte)'\n';  		Array.Copy (value' 0' newValue' 2' length);  		newValue [length + 2] = (byte)' ';  		newValue [length + 3] = (byte)'Q';  		newValue [length + 4] = (byte)'\n';  		Stream.Value = newValue;  		Elements.SetInteger ("/Length"' Stream.Length);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (this.Stream != null) {  	byte[] value = Stream.Value;  	int length = value.Length;  	if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  		byte[] newValue = new byte[length + 2 + 3];  		newValue [0] = (byte)'q';  		newValue [1] = (byte)'\n';  		Array.Copy (value' 0' newValue' 2' length);  		newValue [length + 2] = (byte)' ';  		newValue [length + 3] = (byte)'Q';  		newValue [length + 4] = (byte)'\n';  		Stream.Value = newValue;  		Elements.SetInteger ("/Length"' Stream.Length);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (this.Stream != null) {  	byte[] value = Stream.Value;  	int length = value.Length;  	if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  		byte[] newValue = new byte[length + 2 + 3];  		newValue [0] = (byte)'q';  		newValue [1] = (byte)'\n';  		Array.Copy (value' 0' newValue' 2' length);  		newValue [length + 2] = (byte)' ';  		newValue [length + 3] = (byte)'Q';  		newValue [length + 4] = (byte)'\n';  		Stream.Value = newValue;  		Elements.SetInteger ("/Length"' Stream.Length);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (this.Stream != null) {  	byte[] value = Stream.Value;  	int length = value.Length;  	if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  		byte[] newValue = new byte[length + 2 + 3];  		newValue [0] = (byte)'q';  		newValue [1] = (byte)'\n';  		Array.Copy (value' 0' newValue' 2' length);  		newValue [length + 2] = (byte)' ';  		newValue [length + 3] = (byte)'Q';  		newValue [length + 4] = (byte)'\n';  		Stream.Value = newValue;  		Elements.SetInteger ("/Length"' Stream.Length);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (this.Stream != null) {  	byte[] value = Stream.Value;  	int length = value.Length;  	if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  		byte[] newValue = new byte[length + 2 + 3];  		newValue [0] = (byte)'q';  		newValue [1] = (byte)'\n';  		Array.Copy (value' 0' newValue' 2' length);  		newValue [length + 2] = (byte)' ';  		newValue [length + 3] = (byte)'Q';  		newValue [length + 4] = (byte)'\n';  		Stream.Value = newValue;  		Elements.SetInteger ("/Length"' Stream.Length);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  	byte[] newValue = new byte[length + 2 + 3];  	newValue [0] = (byte)'q';  	newValue [1] = (byte)'\n';  	Array.Copy (value' 0' newValue' 2' length);  	newValue [length + 2] = (byte)' ';  	newValue [length + 3] = (byte)'Q';  	newValue [length + 4] = (byte)'\n';  	Stream.Value = newValue;  	Elements.SetInteger ("/Length"' Stream.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  	byte[] newValue = new byte[length + 2 + 3];  	newValue [0] = (byte)'q';  	newValue [1] = (byte)'\n';  	Array.Copy (value' 0' newValue' 2' length);  	newValue [length + 2] = (byte)' ';  	newValue [length + 3] = (byte)'Q';  	newValue [length + 4] = (byte)'\n';  	Stream.Value = newValue;  	Elements.SetInteger ("/Length"' Stream.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  	byte[] newValue = new byte[length + 2 + 3];  	newValue [0] = (byte)'q';  	newValue [1] = (byte)'\n';  	Array.Copy (value' 0' newValue' 2' length);  	newValue [length + 2] = (byte)' ';  	newValue [length + 3] = (byte)'Q';  	newValue [length + 4] = (byte)'\n';  	Stream.Value = newValue;  	Elements.SetInteger ("/Length"' Stream.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  	byte[] newValue = new byte[length + 2 + 3];  	newValue [0] = (byte)'q';  	newValue [1] = (byte)'\n';  	Array.Copy (value' 0' newValue' 2' length);  	newValue [length + 2] = (byte)' ';  	newValue [length + 3] = (byte)'Q';  	newValue [length + 4] = (byte)'\n';  	Stream.Value = newValue;  	Elements.SetInteger ("/Length"' Stream.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  	byte[] newValue = new byte[length + 2 + 3];  	newValue [0] = (byte)'q';  	newValue [1] = (byte)'\n';  	Array.Copy (value' 0' newValue' 2' length);  	newValue [length + 2] = (byte)' ';  	newValue [length + 3] = (byte)'Q';  	newValue [length + 4] = (byte)'\n';  	Stream.Value = newValue;  	Elements.SetInteger ("/Length"' Stream.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: if (length != 0 && ((value [0] != (byte)'q' || value [1] != (byte)'\n'))) {  	byte[] newValue = new byte[length + 2 + 3];  	newValue [0] = (byte)'q';  	newValue [1] = (byte)'\n';  	Array.Copy (value' 0' newValue' 2' length);  	newValue [length + 2] = (byte)' ';  	newValue [length + 3] = (byte)'Q';  	newValue [length + 4] = (byte)'\n';  	Stream.Value = newValue;  	Elements.SetInteger ("/Length"' Stream.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: Array.Copy (value' 0' newValue' 2' length);  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: newValue [length + 2] = (byte)' ';  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: newValue [length + 3] = (byte)'Q';  
Magic Number,PdfSharp.Pdf.Advanced,PdfContent,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContent.cs,PreserveGraphicsState,The following statement contains a magic number: newValue [length + 4] = (byte)'\n';  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (!this.modified) {  	this.modified = true;  	int count = Elements.Count;  	if (count == 1) {  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		content.PreserveGraphicsState ();  	}  	else if (count > 1) {  		// Surround content streams with q/Q operations  		byte[] value;  		int length;  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 2];  			value [0] = (byte)'q';  			value [1] = (byte)'\n';  			Array.Copy (content.Stream.Value' 0' value' 2' length);  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 2);  		}  		content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 3];  			Array.Copy (content.Stream.Value' 0' value' 0' length);  			value [length] = (byte)' ';  			value [length + 1] = (byte)'Q';  			value [length + 2] = (byte)'\n';  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 3);  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (!this.modified) {  	this.modified = true;  	int count = Elements.Count;  	if (count == 1) {  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		content.PreserveGraphicsState ();  	}  	else if (count > 1) {  		// Surround content streams with q/Q operations  		byte[] value;  		int length;  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 2];  			value [0] = (byte)'q';  			value [1] = (byte)'\n';  			Array.Copy (content.Stream.Value' 0' value' 2' length);  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 2);  		}  		content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 3];  			Array.Copy (content.Stream.Value' 0' value' 0' length);  			value [length] = (byte)' ';  			value [length + 1] = (byte)'Q';  			value [length + 2] = (byte)'\n';  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 3);  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (!this.modified) {  	this.modified = true;  	int count = Elements.Count;  	if (count == 1) {  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		content.PreserveGraphicsState ();  	}  	else if (count > 1) {  		// Surround content streams with q/Q operations  		byte[] value;  		int length;  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 2];  			value [0] = (byte)'q';  			value [1] = (byte)'\n';  			Array.Copy (content.Stream.Value' 0' value' 2' length);  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 2);  		}  		content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 3];  			Array.Copy (content.Stream.Value' 0' value' 0' length);  			value [length] = (byte)' ';  			value [length + 1] = (byte)'Q';  			value [length + 2] = (byte)'\n';  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 3);  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (!this.modified) {  	this.modified = true;  	int count = Elements.Count;  	if (count == 1) {  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		content.PreserveGraphicsState ();  	}  	else if (count > 1) {  		// Surround content streams with q/Q operations  		byte[] value;  		int length;  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 2];  			value [0] = (byte)'q';  			value [1] = (byte)'\n';  			Array.Copy (content.Stream.Value' 0' value' 2' length);  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 2);  		}  		content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 3];  			Array.Copy (content.Stream.Value' 0' value' 0' length);  			value [length] = (byte)' ';  			value [length + 1] = (byte)'Q';  			value [length + 2] = (byte)'\n';  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 3);  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (!this.modified) {  	this.modified = true;  	int count = Elements.Count;  	if (count == 1) {  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		content.PreserveGraphicsState ();  	}  	else if (count > 1) {  		// Surround content streams with q/Q operations  		byte[] value;  		int length;  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 2];  			value [0] = (byte)'q';  			value [1] = (byte)'\n';  			Array.Copy (content.Stream.Value' 0' value' 2' length);  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 2);  		}  		content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 3];  			Array.Copy (content.Stream.Value' 0' value' 0' length);  			value [length] = (byte)' ';  			value [length + 1] = (byte)'Q';  			value [length + 2] = (byte)'\n';  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 3);  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (!this.modified) {  	this.modified = true;  	int count = Elements.Count;  	if (count == 1) {  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		content.PreserveGraphicsState ();  	}  	else if (count > 1) {  		// Surround content streams with q/Q operations  		byte[] value;  		int length;  		PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 2];  			value [0] = (byte)'q';  			value [1] = (byte)'\n';  			Array.Copy (content.Stream.Value' 0' value' 2' length);  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 2);  		}  		content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  		if (content != null && content.Stream != null) {  			length = content.Stream.Length;  			value = new byte[length + 3];  			Array.Copy (content.Stream.Value' 0' value' 0' length);  			value [length] = (byte)' ';  			value [length + 1] = (byte)'Q';  			value [length + 2] = (byte)'\n';  			content.Stream.Value = value;  			content.Elements.SetInteger ("/Length"' length + 3);  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count == 1) {  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	content.PreserveGraphicsState ();  }  else if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count == 1) {  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	content.PreserveGraphicsState ();  }  else if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count == 1) {  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	content.PreserveGraphicsState ();  }  else if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count == 1) {  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	content.PreserveGraphicsState ();  }  else if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count == 1) {  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	content.PreserveGraphicsState ();  }  else if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count == 1) {  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	content.PreserveGraphicsState ();  }  else if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (count > 1) {  	// Surround content streams with q/Q operations  	byte[] value;  	int length;  	PdfContent content = (PdfContent)((PdfReference)Elements [0]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 2];  		value [0] = (byte)'q';  		value [1] = (byte)'\n';  		Array.Copy (content.Stream.Value' 0' value' 2' length);  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 2);  	}  	content = (PdfContent)((PdfReference)Elements [count - 1]).Value;  	if (content != null && content.Stream != null) {  		length = content.Stream.Length;  		value = new byte[length + 3];  		Array.Copy (content.Stream.Value' 0' value' 0' length);  		value [length] = (byte)' ';  		value [length + 1] = (byte)'Q';  		value [length + 2] = (byte)'\n';  		content.Stream.Value = value;  		content.Elements.SetInteger ("/Length"' length + 3);  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (content != null && content.Stream != null) {  	length = content.Stream.Length;  	value = new byte[length + 2];  	value [0] = (byte)'q';  	value [1] = (byte)'\n';  	Array.Copy (content.Stream.Value' 0' value' 2' length);  	content.Stream.Value = value;  	content.Elements.SetInteger ("/Length"' length + 2);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (content != null && content.Stream != null) {  	length = content.Stream.Length;  	value = new byte[length + 2];  	value [0] = (byte)'q';  	value [1] = (byte)'\n';  	Array.Copy (content.Stream.Value' 0' value' 2' length);  	content.Stream.Value = value;  	content.Elements.SetInteger ("/Length"' length + 2);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (content != null && content.Stream != null) {  	length = content.Stream.Length;  	value = new byte[length + 2];  	value [0] = (byte)'q';  	value [1] = (byte)'\n';  	Array.Copy (content.Stream.Value' 0' value' 2' length);  	content.Stream.Value = value;  	content.Elements.SetInteger ("/Length"' length + 2);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: value = new byte[length + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: Array.Copy (content.Stream.Value' 0' value' 2' length);  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: content.Elements.SetInteger ("/Length"' length + 2);  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (content != null && content.Stream != null) {  	length = content.Stream.Length;  	value = new byte[length + 3];  	Array.Copy (content.Stream.Value' 0' value' 0' length);  	value [length] = (byte)' ';  	value [length + 1] = (byte)'Q';  	value [length + 2] = (byte)'\n';  	content.Stream.Value = value;  	content.Elements.SetInteger ("/Length"' length + 3);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (content != null && content.Stream != null) {  	length = content.Stream.Length;  	value = new byte[length + 3];  	Array.Copy (content.Stream.Value' 0' value' 0' length);  	value [length] = (byte)' ';  	value [length + 1] = (byte)'Q';  	value [length + 2] = (byte)'\n';  	content.Stream.Value = value;  	content.Elements.SetInteger ("/Length"' length + 3);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: if (content != null && content.Stream != null) {  	length = content.Stream.Length;  	value = new byte[length + 3];  	Array.Copy (content.Stream.Value' 0' value' 0' length);  	value [length] = (byte)' ';  	value [length + 1] = (byte)'Q';  	value [length + 2] = (byte)'\n';  	content.Stream.Value = value;  	content.Elements.SetInteger ("/Length"' length + 3);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: value = new byte[length + 3];  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: value [length + 2] = (byte)'\n';  
Magic Number,PdfSharp.Pdf.Advanced,PdfContents,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfContents.cs,SetModified,The following statement contains a magic number: content.Elements.SetInteger ("/Length"' length + 3);  
Magic Number,PdfSharp.Pdf.Advanced,PdfExtGStateTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfExtGStateTable.cs,MakeKey,The following statement contains a magic number: return ((int)(1000 * alpha)).ToString ();  
Magic Number,PdfSharp.Pdf.Advanced,PdfFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFont.cs,CreateEmbeddedFontSubsetName,The following statement contains a magic number: for (int idx = 0; idx < 6; idx++)  	s.Append ((char)('A' + bytes [idx] % 26));  
Magic Number,PdfSharp.Pdf.Advanced,PdfFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFont.cs,CreateEmbeddedFontSubsetName,The following statement contains a magic number: for (int idx = 0; idx < 6; idx++)  	s.Append ((char)('A' + bytes [idx] % 26));  
Magic Number,PdfSharp.Pdf.Advanced,PdfFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFont.cs,CreateEmbeddedFontSubsetName,The following statement contains a magic number: s.Append ((char)('A' + bytes [idx] % 26));  
Magic Number,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,The following statement contains a magic number: if (rotate == 0) {  	// Set bounding box to media box  	this.Elements ["/BBox"] = rect;  }  else {  	// TODO: Have to adjust bounding box? (I think not' but I'm not sure -> wait for problem)  	this.Elements ["/BBox"] = rect;  	// Rotate the image such that it is upright  	XMatrix matrix = new XMatrix ();  	//XMatrix.Identity;  	double width = rect.Width;  	double height = rect.Height;  	matrix.RotateAtPrepend (-rotate' new XPoint (width / 2' height / 2));  	// Translate the image such that its center lies on the center of the rotated bounding box  	double offset = (height - width) / 2;  	if (height > width)  		matrix.TranslatePrepend (offset' offset);  	else  		matrix.TranslatePrepend (-offset' -offset);  	//string item = "[" + PdfEncoders.ToString(matrix) + "]";  	//Elements[Keys.Matrix] = new PdfLiteral(item);  	Elements.SetMatrix (Keys.Matrix' matrix);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,The following statement contains a magic number: if (rotate == 0) {  	// Set bounding box to media box  	this.Elements ["/BBox"] = rect;  }  else {  	// TODO: Have to adjust bounding box? (I think not' but I'm not sure -> wait for problem)  	this.Elements ["/BBox"] = rect;  	// Rotate the image such that it is upright  	XMatrix matrix = new XMatrix ();  	//XMatrix.Identity;  	double width = rect.Width;  	double height = rect.Height;  	matrix.RotateAtPrepend (-rotate' new XPoint (width / 2' height / 2));  	// Translate the image such that its center lies on the center of the rotated bounding box  	double offset = (height - width) / 2;  	if (height > width)  		matrix.TranslatePrepend (offset' offset);  	else  		matrix.TranslatePrepend (-offset' -offset);  	//string item = "[" + PdfEncoders.ToString(matrix) + "]";  	//Elements[Keys.Matrix] = new PdfLiteral(item);  	Elements.SetMatrix (Keys.Matrix' matrix);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,The following statement contains a magic number: if (rotate == 0) {  	// Set bounding box to media box  	this.Elements ["/BBox"] = rect;  }  else {  	// TODO: Have to adjust bounding box? (I think not' but I'm not sure -> wait for problem)  	this.Elements ["/BBox"] = rect;  	// Rotate the image such that it is upright  	XMatrix matrix = new XMatrix ();  	//XMatrix.Identity;  	double width = rect.Width;  	double height = rect.Height;  	matrix.RotateAtPrepend (-rotate' new XPoint (width / 2' height / 2));  	// Translate the image such that its center lies on the center of the rotated bounding box  	double offset = (height - width) / 2;  	if (height > width)  		matrix.TranslatePrepend (offset' offset);  	else  		matrix.TranslatePrepend (-offset' -offset);  	//string item = "[" + PdfEncoders.ToString(matrix) + "]";  	//Elements[Keys.Matrix] = new PdfLiteral(item);  	Elements.SetMatrix (Keys.Matrix' matrix);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,The following statement contains a magic number: matrix.RotateAtPrepend (-rotate' new XPoint (width / 2' height / 2));  
Magic Number,PdfSharp.Pdf.Advanced,PdfFormXObject,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfFormXObject.cs,PdfFormXObject,The following statement contains a magic number: matrix.RotateAtPrepend (-rotate' new XPoint (width / 2' height / 2));  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeJpeg,The following statement contains a magic number: Elements [Keys.BitsPerComponent] = new PdfInteger (8);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: switch (format) {  case "Bgr24":  	//Format24bppRgb:  	ReadTrueColorMemoryBitmap (3' 8' false);  	break;  //case .PixelFormat.Format32bppRgb:  //  ReadTrueColorMemoryBitmap(4' 8' false);  //  break;  case "Bgra32":  	//PixelFormat.Format32bppArgb:  	//case PixelFormat.Format32bppPArgb:  	//hasMask = true;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Bgr32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Pbgra32":  	// StL: neu  	//hasMask = false;  	ReadTrueColorMemoryBitmap (3' 8' true);  	break;  case "Indexed8":  //Format8bppIndexed:  case "Gray8":  	ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  	break;  case "Indexed4":  //Format4bppIndexed:  case "Gray4":  	ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  	break;  case "Indexed2":  	ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  	break;  case "Indexed1":  //Format1bppIndexed:  case "BlackWhite":  	//Format1bppIndexed:  	ReadIndexedMemoryBitmap (1/*' ref hasMask*/);  	break;  default:  	#if DEBUGxxx  	          image.image.Save("$$$.bmp"' ImageFormat.Bmp); #endif  	throw new NotImplementedException ("Image format \"" + format + "\" not supported.");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' false);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' false);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' true);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' true);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' true);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' true);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' true);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadTrueColorMemoryBitmap (3' 8' true);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadIndexedMemoryBitmap (8/*' ref hasMask*/);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadIndexedMemoryBitmap (4/*' ref hasMask*/);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,InitializeNonJpeg,The following statement contains a magic number: ReadIndexedMemoryBitmap (2/*' ref hasMask*/);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadWord,The following statement contains a magic number: return ab [offset] + 256 * ab [offset + 1];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadDWord,The following statement contains a magic number: return ReadWord (ab' offset) + 0x10000 * ReadWord (ab' offset + 2);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	// TODO: we could define structures for  	//   BITMAPFILEHEADER  	//   { BITMAPINFO }  	//   BITMAPINFOHEADER  	// to avoid ReadWord and ReadDWord ... (but w/o pointers this doesn't help much)  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  	}  	if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  	}  	int nFileOffset = ReadDWord (imageBits' 10);  	int logicalComponents = components;  	if (components == 4)  		logicalComponents = 3;  	byte[] imageData = new byte[components * width * height];  	bool hasMask = false;  	bool hasAlphaMask = false;  	byte[] alphaMask = hasAlpha ? new byte[width * height] : null;  	MonochromeMask mask = hasAlpha ? new MonochromeMask (width' height) : null;  	int nOffsetRead = 0;  	if (logicalComponents == 3) {  		for (int y = 0; y < height; ++y) {  			int nOffsetWrite = 3 * (height - 1 - y) * width;  			int nOffsetWriteAlpha = 0;  			if (hasAlpha) {  				mask.StartLine (y);  				nOffsetWriteAlpha = (height - 1 - y) * width;  			}  			for (int x = 0; x < width; ++x) {  				imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  				imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  				imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  				if (hasAlpha) {  					mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  					alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  					if (!hasMask || !hasAlphaMask) {  						if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  							hasMask = true;  							if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  								hasAlphaMask = true;  						}  					}  					++nOffsetWriteAlpha;  				}  				nOffsetRead += hasAlpha ? 4 : components;  				nOffsetWrite += 3;  			}  			nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  			// Align to 32 bit boundary  		}  	}  	else if (components == 1) {  		// Grayscale  		throw new NotImplementedException ("Image format not supported (grayscales).");  	}  	FlateDecode fd = new FlateDecode ();  	if (hasMask) {  		// monochrome mask is either sufficient or  		// provided for compatibility with older reader versions  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  	if (hasMask && hasAlphaMask && pdfVersion >= 14) {  		// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  		byte[] alphaMaskCompressed = fd.Encode (alphaMask);  		PdfDictionary smask = new PdfDictionary (document);  		smask.Elements.SetName (Keys.Type' "/XObject");  		smask.Elements.SetName (Keys.Subtype' "/Image");  		Owner.irefTable.Add (smask);  		smask.Stream = new PdfStream (alphaMaskCompressed' smask);  		smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  		smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		smask.Elements [Keys.Width] = new PdfInteger (width);  		smask.Elements [Keys.Height] = new PdfInteger (height);  		smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  		smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  		Elements [Keys.SMask] = smask.Reference;  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	Stream = new PdfStream (imageDataCompressed' this);  	Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  	Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	// TODO: CMYK  	Elements [Keys.ColorSpace] = new PdfName ("/DeviceRGB");  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || (!hasAlpha && ReadWord (imageBits' 28) != components * bits || hasAlpha && ReadWord (imageBits' 28) != (components + 1) * bits) || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadTrueColorMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (components == 4)  	logicalComponents = 3;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (components == 4)  	logicalComponents = 3;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: logicalComponents = 3;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (logicalComponents == 3) {  	for (int y = 0; y < height; ++y) {  		int nOffsetWrite = 3 * (height - 1 - y) * width;  		int nOffsetWriteAlpha = 0;  		if (hasAlpha) {  			mask.StartLine (y);  			nOffsetWriteAlpha = (height - 1 - y) * width;  		}  		for (int x = 0; x < width; ++x) {  			imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  			imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  			imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  			if (hasAlpha) {  				mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  				alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  				if (!hasMask || !hasAlphaMask) {  					if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  						hasMask = true;  						if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  							hasAlphaMask = true;  					}  				}  				++nOffsetWriteAlpha;  			}  			nOffsetRead += hasAlpha ? 4 : components;  			nOffsetWrite += 3;  		}  		nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else if (components == 1) {  	// Grayscale  	throw new NotImplementedException ("Image format not supported (grayscales).");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	int nOffsetWrite = 3 * (height - 1 - y) * width;  	int nOffsetWriteAlpha = 0;  	if (hasAlpha) {  		mask.StartLine (y);  		nOffsetWriteAlpha = (height - 1 - y) * width;  	}  	for (int x = 0; x < width; ++x) {  		imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  		imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  		imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  		if (hasAlpha) {  			mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  			alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  			if (!hasMask || !hasAlphaMask) {  				if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  					hasMask = true;  					if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  						hasAlphaMask = true;  				}  			}  			++nOffsetWriteAlpha;  		}  		nOffsetRead += hasAlpha ? 4 : components;  		nOffsetWrite += 3;  	}  	nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  	imageData [nOffsetWrite + 1] = imageBits [nFileOffset + nOffsetRead + 1];  	imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  	if (hasAlpha) {  		mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  		alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  		if (!hasMask || !hasAlphaMask) {  			if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  				hasMask = true;  				if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  					hasAlphaMask = true;  			}  		}  		++nOffsetWriteAlpha;  	}  	nOffsetRead += hasAlpha ? 4 : components;  	nOffsetWrite += 3;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: imageData [nOffsetWrite] = imageBits [nFileOffset + nOffsetRead + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: imageData [nOffsetWrite + 2] = imageBits [nFileOffset + nOffsetRead];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasAlpha) {  	mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  	alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  	if (!hasMask || !hasAlphaMask) {  		if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  			hasMask = true;  			if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  				hasAlphaMask = true;  		}  	}  	++nOffsetWriteAlpha;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasAlpha) {  	mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  	alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  	if (!hasMask || !hasAlphaMask) {  		if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  			hasMask = true;  			if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  				hasAlphaMask = true;  		}  	}  	++nOffsetWriteAlpha;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasAlpha) {  	mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  	alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  	if (!hasMask || !hasAlphaMask) {  		if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  			hasMask = true;  			if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  				hasAlphaMask = true;  		}  	}  	++nOffsetWriteAlpha;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasAlpha) {  	mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  	alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  	if (!hasMask || !hasAlphaMask) {  		if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  			hasMask = true;  			if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  				hasAlphaMask = true;  		}  	}  	++nOffsetWriteAlpha;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasAlpha) {  	mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  	alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  	if (!hasMask || !hasAlphaMask) {  		if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  			hasMask = true;  			if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  				hasAlphaMask = true;  		}  	}  	++nOffsetWriteAlpha;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: mask.AddPel (imageBits [nFileOffset + nOffsetRead + 3]);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: alphaMask [nOffsetWriteAlpha] = imageBits [nFileOffset + nOffsetRead + 3];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (!hasMask || !hasAlphaMask) {  	if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  		hasMask = true;  		if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  			hasAlphaMask = true;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (!hasMask || !hasAlphaMask) {  	if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  		hasMask = true;  		if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  			hasAlphaMask = true;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (!hasMask || !hasAlphaMask) {  	if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  		hasMask = true;  		if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  			hasAlphaMask = true;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  	hasMask = true;  	if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  		hasAlphaMask = true;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  	hasMask = true;  	if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  		hasAlphaMask = true;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (imageBits [nFileOffset + nOffsetRead + 3] != 255) {  	hasMask = true;  	if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  		hasAlphaMask = true;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (imageBits [nFileOffset + nOffsetRead + 3] != 0)  	hasAlphaMask = true;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: nOffsetRead += hasAlpha ? 4 : components;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: nOffsetWrite += 3;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: nOffsetRead = 4 * ((nOffsetRead + 3) / 4);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasMask && hasAlphaMask && pdfVersion >= 14) {  	// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  	byte[] alphaMaskCompressed = fd.Encode (alphaMask);  	PdfDictionary smask = new PdfDictionary (document);  	smask.Elements.SetName (Keys.Type' "/XObject");  	smask.Elements.SetName (Keys.Subtype' "/Image");  	Owner.irefTable.Add (smask);  	smask.Stream = new PdfStream (alphaMaskCompressed' smask);  	smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  	smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	smask.Elements [Keys.Width] = new PdfInteger (width);  	smask.Elements [Keys.Height] = new PdfInteger (height);  	smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	Elements [Keys.SMask] = smask.Reference;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: if (hasMask && hasAlphaMask && pdfVersion >= 14) {  	// The image provides an alpha mask (requires Arcrobat 5.0 or higher)  	byte[] alphaMaskCompressed = fd.Encode (alphaMask);  	PdfDictionary smask = new PdfDictionary (document);  	smask.Elements.SetName (Keys.Type' "/XObject");  	smask.Elements.SetName (Keys.Subtype' "/Image");  	Owner.irefTable.Add (smask);  	smask.Stream = new PdfStream (alphaMaskCompressed' smask);  	smask.Elements [Keys.Length] = new PdfInteger (alphaMaskCompressed.Length);  	smask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	smask.Elements [Keys.Width] = new PdfInteger (width);  	smask.Elements [Keys.Height] = new PdfInteger (height);  	smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  	smask.Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	Elements [Keys.SMask] = smask.Reference;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: smask.Elements [Keys.BitsPerComponent] = new PdfInteger (8);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadTrueColorMemoryBitmap,The following statement contains a magic number: Elements [Keys.BitsPerComponent] = new PdfInteger (8);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (streamLength > 0) {  	byte[] imageBits = new byte[streamLength];  	memory.Seek (0' SeekOrigin.Begin);  	memory.Read (imageBits' 0' streamLength);  	memory.Close ();  	int height = image.PixelHeight;  	int width = image.PixelWidth;  	if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  	ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  	#if WPF  	// TODOWPF: bug with height and width??? With which files???  	ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  	#else  	          ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif  	 {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  	}  	#if WPF  	// TODOWPF: bug with height and width  	width = ReadDWord (imageBits' 18);  	height = ReadDWord (imageBits' 22);  	#endif  	int fileBits = ReadWord (imageBits' 28);  	if (fileBits != bits) {  		if (fileBits == 1 || fileBits == 4 || fileBits == 8)  			bits = fileBits;  	}  	if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  	}  	int bytesFileOffset = ReadDWord (imageBits' 10);  	int bytesColorPaletteOffset = 0x36;  	// GDI+ always returns Windows bitmaps: sizeof BITMAPFILEHEADER + sizeof BITMAPINFOHEADER  	int paletteColors = ReadDWord (imageBits' 46);  	if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  		throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  	}  	MonochromeMask mask = new MonochromeMask (width' height);  	bool isGray = bits == 8 && (paletteColors == 256 || paletteColors == 0);  	int isBitonal = 0;  	// 0: false; >0: true; <0: true (inverted)  	byte[] paletteData = new byte[3 * paletteColors];  	for (int color = 0; color < paletteColors; ++color) {  		paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  		paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  		paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  		if (isGray)  			isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  		if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  			// We treat this as transparency:  			if (firstMaskColor == -1)  				firstMaskColor = color;  			if (lastMaskColor == -1 || lastMaskColor == color - 1)  				lastMaskColor = color;  			if (lastMaskColor != color)  				segmentedColorMask = true;  		}  		//else  		//{  		//  // We treat this as opacity:  		//}  	}  	if (bits == 1) {  		if (paletteColors == 0)  			isBitonal = 1;  		if (paletteColors == 2) {  			if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  				isBitonal = 1;  			// Black on white  			if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  				isBitonal = -1;  			// White on black  		}  	}  	// NYI: (no sample found where this was required)   	// if (segmentedColorMask = true)  	// { ... }  	FlateDecode fd = new FlateDecode ();  	PdfDictionary colorPalette = null;  	if (isBitonal == 0 && !isGray) {  		colorPalette = new PdfDictionary (this.document);  		byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  		// don't compress small palettes  		if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  		 {  			// Create compressed color palette:  			colorPalette.CreateStream (packedPaletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  			colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		}  		else {  			// Create uncompressed color palette:  			colorPalette.CreateStream (paletteData);  			colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  		}  		Owner.irefTable.Add (colorPalette);  	}  	bool isFaxEncoding = false;  	byte[] imageData = new byte[((width * bits + 7) / 8) * height];  	byte[] imageDataFax = null;  	int k = 0;  	if (bits == 1) {  		// TODO: flag/option?  		// We try Group 3 1D and Group 4 (2D) encoding here and keep the smaller byte array.  		//byte[] temp = new byte[imageData.Length];  		//int ccittSize = DoFaxEncoding(ref temp' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		// It seems that Group 3 2D encoding never beats both other encodings' therefore we don't call it here.  		//byte[] temp2D = new byte[imageData.Length];  		//uint dpiY = (uint)image.VerticalResolution;  		//uint kTmp = 0;  		//int ccittSize2D = DoFaxEncoding2D((uint)bytesFileOffset' ref temp2D' imageBits' (uint)width' (uint)height' dpiY' out kTmp);  		//k = (int) kTmp;  		byte[] tempG4 = new byte[imageData.Length];  		int ccittSizeG4 = DoFaxEncodingGroup4 (ref tempG4' imageBits' (uint)bytesFileOffset' (uint)width' (uint)height);  		isFaxEncoding = /*ccittSize > 0 ||*/ccittSizeG4 > 0;  		if (isFaxEncoding) {  			//if (ccittSize == 0)  			//  ccittSize = 0x7fffffff;  			if (ccittSizeG4 == 0)  				ccittSizeG4 = 0x7fffffff;  			//if (ccittSize <= ccittSizeG4)  			//{  			//  Array.Resize(ref temp' ccittSize);  			//  imageDataFax = temp;  			//  k = 0;  			//}  			//else  			{  				Array.Resize (ref tempG4' ccittSizeG4);  				imageDataFax = tempG4;  				k = -1;  			}  		}  	}  	//if (!isFaxEncoding)  	{  		int bytesOffsetRead = 0;  		if (bits == 8 || bits == 4 || bits == 1) {  			int bytesPerLine = (width * bits + 7) / 8;  			for (int y = 0; y < height; ++y) {  				mask.StartLine (y);  				int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  				for (int x = 0; x < bytesPerLine; ++x) {  					if (isGray) {  						// Lookup the gray value from the palette:  						imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  					}  					else {  						// Store the palette index:  						imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  					}  					if (firstMaskColor != -1) {  						int n = imageBits [bytesFileOffset + bytesOffsetRead];  						if (bits == 8) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  						}  						else if (bits == 4) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							int n1 = (n & 0xf0) / 16;  							int n2 = (n & 0x0f);  							mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  							mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  						}  						else if (bits == 1) {  							// TODO???: segmentedColorMask == true => bad mask NYI  							for (int bit = 1; bit <= 8; ++bit) {  								int n1 = (n & 0x80) / 128;  								mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  								n *= 2;  							}  						}  					}  					bytesOffsetRead += 1;  					bytesOffsetWrite += 1;  				}  				bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  				// Align to 32 bit boundary  			}  		}  		else {  			throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  		}  	// TODO: CMYK  	// CCITT encoding: we need color palette for isBitonal == 0  	// FlateDecode: we need color palette for isBitonal <= 0 unless we have grayscales  	}  	if (firstMaskColor != -1 && lastMaskColor != -1) {  		// Color mask requires Reader 4.0 or higher:  		if (!segmentedColorMask && pdfVersion >= 13) {  			PdfArray array = new PdfArray (document);  			array.Elements.Add (new PdfInteger (firstMaskColor));  			array.Elements.Add (new PdfInteger (lastMaskColor));  			Elements [Keys.Mask] = array;  		}  		else {  			// Monochrome mask  			byte[] maskDataCompressed = fd.Encode (mask.MaskData);  			PdfDictionary pdfMask = new PdfDictionary (document);  			pdfMask.Elements.SetName (Keys.Type' "/XObject");  			pdfMask.Elements.SetName (Keys.Subtype' "/Image");  			this.Owner.irefTable.Add (pdfMask);  			pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  			pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  			pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  			pdfMask.Elements [Keys.Width] = new PdfInteger (width);  			pdfMask.Elements [Keys.Height] = new PdfInteger (height);  			pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  			pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  			Elements [Keys.Mask] = pdfMask.Reference;  		}  	}  	byte[] imageDataCompressed = fd.Encode (imageData);  	byte[] imageDataFaxCompressed = isFaxEncoding ? fd.Encode (imageDataFax) : null;  	bool usesCcittEncoding = false;  	if (isFaxEncoding && (imageDataFax.Length < imageDataCompressed.Length || imageDataFaxCompressed.Length < imageDataCompressed.Length)) {  		// /CCITTFaxDecode creates the smaller file (with or without /FlateDecode):  		usesCcittEncoding = true;  		if (imageDataFax.Length < imageDataCompressed.Length) {  			Stream = new PdfStream (imageDataFax' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFax.Length);  			Elements [Keys.Filter] = new PdfName ("/CCITTFaxDecode");  			//PdfArray array2 = new PdfArray(this.document);  			PdfDictionary dictionary = new PdfDictionary ();  			if (k != 0)  				dictionary.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictionary.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictionary.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictionary.Elements.Add ("/Columns"' new PdfInteger (width));  			dictionary.Elements.Add ("/Rows"' new PdfInteger (height));  			//array2.Elements.Add(dictionary);  			Elements [Keys.DecodeParms] = dictionary;  			// array2;  		}  		else {  			Stream = new PdfStream (imageDataFaxCompressed' this);  			Elements [Keys.Length] = new PdfInteger (imageDataFaxCompressed.Length);  			PdfArray arrayFilters = new PdfArray (document);  			arrayFilters.Elements.Add (new PdfName ("/FlateDecode"));  			arrayFilters.Elements.Add (new PdfName ("/CCITTFaxDecode"));  			Elements [Keys.Filter] = arrayFilters;  			PdfArray arrayDecodeParms = new PdfArray (document);  			PdfDictionary dictFlateDecodeParms = new PdfDictionary ();  			//dictFlateDecodeParms.Elements.Add("/Columns"' new PdfInteger(1));  			PdfDictionary dictCcittFaxDecodeParms = new PdfDictionary ();  			if (k != 0)  				dictCcittFaxDecodeParms.Elements.Add ("/K"' new PdfInteger (k));  			if (isBitonal < 0)  				dictCcittFaxDecodeParms.Elements.Add ("/BlackIs1"' new PdfBoolean (true));  			dictCcittFaxDecodeParms.Elements.Add ("/EndOfBlock"' new PdfBoolean (false));  			dictCcittFaxDecodeParms.Elements.Add ("/Columns"' new PdfInteger (width));  			dictCcittFaxDecodeParms.Elements.Add ("/Rows"' new PdfInteger (height));  			arrayDecodeParms.Elements.Add (dictFlateDecodeParms);  			// How to add the "null object"?  			arrayDecodeParms.Elements.Add (dictCcittFaxDecodeParms);  			Elements [Keys.DecodeParms] = arrayDecodeParms;  		}  	}  	else {  		// /FlateDecode creates the smaller file (or no monochrome bitmap):  		Stream = new PdfStream (imageDataCompressed' this);  		Elements [Keys.Length] = new PdfInteger (imageDataCompressed.Length);  		Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	Elements [Keys.Width] = new PdfInteger (width);  	Elements [Keys.Height] = new PdfInteger (height);  	Elements [Keys.BitsPerComponent] = new PdfInteger (bits);  	if ((usesCcittEncoding && isBitonal == 0) || (!usesCcittEncoding && isBitonal <= 0 && !isGray)) {  		PdfArray arrayColorSpace = new PdfArray (document);  		arrayColorSpace.Elements.Add (new PdfName ("/Indexed"));  		arrayColorSpace.Elements.Add (new PdfName ("/DeviceRGB"));  		arrayColorSpace.Elements.Add (new PdfInteger (paletteColors - 1));  		// ReSharper disable PossibleNullReferenceException  		arrayColorSpace.Elements.Add (colorPalette.Reference);  		// ReSharper restore PossibleNullReferenceException  		Elements [Keys.ColorSpace] = arrayColorSpace;  	}  	else {  		Elements [Keys.ColorSpace] = new PdfName ("/DeviceGray");  	}  	if (image.Interpolate)  		Elements [Keys.Interpolate] = PdfBoolean.True;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  #if WPF  // TODOWPF: bug with height and width??? With which files???  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  #else            ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif   {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  #if WPF  // TODOWPF: bug with height and width??? With which files???  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  #else            ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif   {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  #if WPF  // TODOWPF: bug with height and width??? With which files???  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  #else            ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif   {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  #if WPF  // TODOWPF: bug with height and width??? With which files???  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  #else            ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif   {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 0) != 0x4d42 || // "BM"  ReadDWord (imageBits' 2) != streamLength || ReadDWord (imageBits' 14) != 40 || // sizeof BITMAPINFOHEADER  #if WPF  // TODOWPF: bug with height and width??? With which files???  ReadDWord (imageBits' 18) != width || ReadDWord (imageBits' 22) != height)  #else            ReadDWord(imageBits' 18) != width ||           ReadDWord(imageBits' 22) != height) #endif   {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: width = ReadDWord (imageBits' 18);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: height = ReadDWord (imageBits' 22);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (fileBits != bits) {  	if (fileBits == 1 || fileBits == 4 || fileBits == 8)  		bits = fileBits;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (fileBits != bits) {  	if (fileBits == 1 || fileBits == 4 || fileBits == 8)  		bits = fileBits;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (fileBits == 1 || fileBits == 4 || fileBits == 8)  	bits = fileBits;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (fileBits == 1 || fileBits == 4 || fileBits == 8)  	bits = fileBits;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (ReadWord (imageBits' 26) != 1 || ReadWord (imageBits' 28) != bits || ReadDWord (imageBits' 30) != 0) {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #2");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if ((bytesFileOffset - bytesColorPaletteOffset) / 4 != paletteColors) {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int color = 0; color < paletteColors; ++color) {  	paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  	paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  	paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  	if (isGray)  		isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  	if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  		// We treat this as transparency:  		if (firstMaskColor == -1)  			firstMaskColor = color;  		if (lastMaskColor == -1 || lastMaskColor == color - 1)  			lastMaskColor = color;  		if (lastMaskColor != color)  			segmentedColorMask = true;  	}  	//else  	//{  	//  // We treat this as opacity:  	//}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color] = imageBits [bytesColorPaletteOffset + 4 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color + 1] = imageBits [bytesColorPaletteOffset + 4 * color + 1];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: paletteData [3 * color + 2] = imageBits [bytesColorPaletteOffset + 4 * color + 0];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isGray)  	isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isGray)  	isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isGray)  	isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isGray)  	isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isGray)  	isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: isGray = paletteData [3 * color] == paletteData [3 * color + 1] && paletteData [3 * color] == paletteData [3 * color + 2];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  	// We treat this as transparency:  	if (firstMaskColor == -1)  		firstMaskColor = color;  	if (lastMaskColor == -1 || lastMaskColor == color - 1)  		lastMaskColor = color;  	if (lastMaskColor != color)  		segmentedColorMask = true;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  	// We treat this as transparency:  	if (firstMaskColor == -1)  		firstMaskColor = color;  	if (lastMaskColor == -1 || lastMaskColor == color - 1)  		lastMaskColor = color;  	if (lastMaskColor != color)  		segmentedColorMask = true;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (imageBits [bytesColorPaletteOffset + 4 * color + 3] < 128) {  	// We treat this as transparency:  	if (firstMaskColor == -1)  		firstMaskColor = color;  	if (lastMaskColor == -1 || lastMaskColor == color - 1)  		lastMaskColor = color;  	if (lastMaskColor != color)  		segmentedColorMask = true;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	if (paletteColors == 0)  		isBitonal = 1;  	if (paletteColors == 2) {  		if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  			isBitonal = 1;  		// Black on white  		if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  			isBitonal = -1;  		// White on black  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteColors == 2) {  	if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  		isBitonal = 1;  	// Black on white  	if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  		isBitonal = -1;  	// White on black  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [0] == 0 && paletteData [1] == 0 && paletteData [2] == 0 && paletteData [3] == 255 && paletteData [4] == 255 && paletteData [5] == 255)  	isBitonal = 1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (paletteData [5] == 0 && paletteData [4] == 0 && paletteData [3] == 0 && paletteData [2] == 255 && paletteData [1] == 255 && paletteData [0] == 255)  	isBitonal = -1;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isBitonal == 0 && !isGray) {  	colorPalette = new PdfDictionary (this.document);  	byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  	// don't compress small palettes  	if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  	 {  		// Create compressed color palette:  		colorPalette.CreateStream (packedPaletteData);  		colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  		colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	else {  		// Create uncompressed color palette:  		colorPalette.CreateStream (paletteData);  		colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  	}  	Owner.irefTable.Add (colorPalette);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isBitonal == 0 && !isGray) {  	colorPalette = new PdfDictionary (this.document);  	byte[] packedPaletteData = paletteData.Length >= 48 ? fd.Encode (paletteData) : null;  	// don't compress small palettes  	if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)  	 {  		// Create compressed color palette:  		colorPalette.CreateStream (packedPaletteData);  		colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  		colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	}  	else {  		// Create uncompressed color palette:  		colorPalette.CreateStream (paletteData);  		colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  	}  	Owner.irefTable.Add (colorPalette);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (packedPaletteData != null && packedPaletteData.Length + 20 < paletteData.Length)// +20: compensate for the overhead (estimated value)   {  	// Create compressed color palette:  	colorPalette.CreateStream (packedPaletteData);  	colorPalette.Elements [Keys.Length] = new PdfInteger (packedPaletteData.Length);  	colorPalette.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  }  else {  	// Create uncompressed color palette:  	colorPalette.CreateStream (paletteData);  	colorPalette.Elements [Keys.Length] = new PdfInteger (paletteData.Length);  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8 || bits == 4 || bits == 1) {  	int bytesPerLine = (width * bits + 7) / 8;  	for (int y = 0; y < height; ++y) {  		mask.StartLine (y);  		int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  		for (int x = 0; x < bytesPerLine; ++x) {  			if (isGray) {  				// Lookup the gray value from the palette:  				imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  			}  			else {  				// Store the palette index:  				imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  			}  			if (firstMaskColor != -1) {  				int n = imageBits [bytesFileOffset + bytesOffsetRead];  				if (bits == 8) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  				}  				else if (bits == 4) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					int n1 = (n & 0xf0) / 16;  					int n2 = (n & 0x0f);  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  				}  				else if (bits == 1) {  					// TODO???: segmentedColorMask == true => bad mask NYI  					for (int bit = 1; bit <= 8; ++bit) {  						int n1 = (n & 0x80) / 128;  						mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  						n *= 2;  					}  				}  			}  			bytesOffsetRead += 1;  			bytesOffsetWrite += 1;  		}  		bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  		// Align to 32 bit boundary  	}  }  else {  	throw new NotImplementedException ("ReadIndexedMemoryBitmap: unsupported format #3");  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	mask.StartLine (y);  	int bytesOffsetWrite = (height - 1 - y) * ((width * bits + 7) / 8);  	for (int x = 0; x < bytesPerLine; ++x) {  		if (isGray) {  			// Lookup the gray value from the palette:  			imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  		}  		else {  			// Store the palette index:  			imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  		}  		if (firstMaskColor != -1) {  			int n = imageBits [bytesFileOffset + bytesOffsetRead];  			if (bits == 8) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  			}  			else if (bits == 4) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				int n1 = (n & 0xf0) / 16;  				int n2 = (n & 0x0f);  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  			}  			else if (bits == 1) {  				// TODO???: segmentedColorMask == true => bad mask NYI  				for (int bit = 1; bit <= 8; ++bit) {  					int n1 = (n & 0x80) / 128;  					mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  					n *= 2;  				}  			}  		}  		bytesOffsetRead += 1;  		bytesOffsetWrite += 1;  	}  	bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  	// Align to 32 bit boundary  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int x = 0; x < bytesPerLine; ++x) {  	if (isGray) {  		// Lookup the gray value from the palette:  		imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  	}  	else {  		// Store the palette index:  		imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  	}  	if (firstMaskColor != -1) {  		int n = imageBits [bytesFileOffset + bytesOffsetRead];  		if (bits == 8) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  		}  		else if (bits == 4) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			int n1 = (n & 0xf0) / 16;  			int n2 = (n & 0x0f);  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  		}  		else if (bits == 1) {  			// TODO???: segmentedColorMask == true => bad mask NYI  			for (int bit = 1; bit <= 8; ++bit) {  				int n1 = (n & 0x80) / 128;  				mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  				n *= 2;  			}  		}  	}  	bytesOffsetRead += 1;  	bytesOffsetWrite += 1;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (isGray) {  	// Lookup the gray value from the palette:  	imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  }  else {  	// Store the palette index:  	imageData [bytesOffsetWrite] = imageBits [bytesFileOffset + bytesOffsetRead];  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: imageData [bytesOffsetWrite] = paletteData [3 * imageBits [bytesFileOffset + bytesOffsetRead]];  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1) {  	int n = imageBits [bytesFileOffset + bytesOffsetRead];  	if (bits == 8) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  	}  	else if (bits == 4) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		int n1 = (n & 0xf0) / 16;  		int n2 = (n & 0x0f);  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  	}  	else if (bits == 1) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		for (int bit = 1; bit <= 8; ++bit) {  			int n1 = (n & 0x80) / 128;  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			n *= 2;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1) {  	int n = imageBits [bytesFileOffset + bytesOffsetRead];  	if (bits == 8) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  	}  	else if (bits == 4) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		int n1 = (n & 0xf0) / 16;  		int n2 = (n & 0x0f);  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  	}  	else if (bits == 1) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		for (int bit = 1; bit <= 8; ++bit) {  			int n1 = (n & 0x80) / 128;  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			n *= 2;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1) {  	int n = imageBits [bytesFileOffset + bytesOffsetRead];  	if (bits == 8) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  	}  	else if (bits == 4) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		int n1 = (n & 0xf0) / 16;  		int n2 = (n & 0x0f);  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  	}  	else if (bits == 1) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		for (int bit = 1; bit <= 8; ++bit) {  			int n1 = (n & 0x80) / 128;  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			n *= 2;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1) {  	int n = imageBits [bytesFileOffset + bytesOffsetRead];  	if (bits == 8) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  	}  	else if (bits == 4) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		int n1 = (n & 0xf0) / 16;  		int n2 = (n & 0x0f);  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  	}  	else if (bits == 1) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		for (int bit = 1; bit <= 8; ++bit) {  			int n1 = (n & 0x80) / 128;  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			n *= 2;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1) {  	int n = imageBits [bytesFileOffset + bytesOffsetRead];  	if (bits == 8) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  	}  	else if (bits == 4) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		int n1 = (n & 0xf0) / 16;  		int n2 = (n & 0x0f);  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  	}  	else if (bits == 1) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		for (int bit = 1; bit <= 8; ++bit) {  			int n1 = (n & 0x80) / 128;  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			n *= 2;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1) {  	int n = imageBits [bytesFileOffset + bytesOffsetRead];  	if (bits == 8) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  	}  	else if (bits == 4) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		int n1 = (n & 0xf0) / 16;  		int n2 = (n & 0x0f);  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  	}  	else if (bits == 1) {  		// TODO???: segmentedColorMask == true => bad mask NYI  		for (int bit = 1; bit <= 8; ++bit) {  			int n1 = (n & 0x80) / 128;  			mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  			n *= 2;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  }  else if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  }  else if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  }  else if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  }  else if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  }  else if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 8) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	mask.AddPel ((n >= firstMaskColor) && (n <= lastMaskColor));  }  else if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 4) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	int n1 = (n & 0xf0) / 16;  	int n2 = (n & 0x0f);  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	mask.AddPel ((n2 >= firstMaskColor) && (n2 <= lastMaskColor));  }  else if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (bits == 1) {  	// TODO???: segmentedColorMask == true => bad mask NYI  	for (int bit = 1; bit <= 8; ++bit) {  		int n1 = (n & 0x80) / 128;  		mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  		n *= 2;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int bit = 1; bit <= 8; ++bit) {  	int n1 = (n & 0x80) / 128;  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	n *= 2;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int bit = 1; bit <= 8; ++bit) {  	int n1 = (n & 0x80) / 128;  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	n *= 2;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: for (int bit = 1; bit <= 8; ++bit) {  	int n1 = (n & 0x80) / 128;  	mask.AddPel ((n1 >= firstMaskColor) && (n1 <= lastMaskColor));  	n *= 2;  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: n *= 2;  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: bytesOffsetRead = 4 * ((bytesOffsetRead + 3) / 4);  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (firstMaskColor != -1 && lastMaskColor != -1) {  	// Color mask requires Reader 4.0 or higher:  	if (!segmentedColorMask && pdfVersion >= 13) {  		PdfArray array = new PdfArray (document);  		array.Elements.Add (new PdfInteger (firstMaskColor));  		array.Elements.Add (new PdfInteger (lastMaskColor));  		Elements [Keys.Mask] = array;  	}  	else {  		// Monochrome mask  		byte[] maskDataCompressed = fd.Encode (mask.MaskData);  		PdfDictionary pdfMask = new PdfDictionary (document);  		pdfMask.Elements.SetName (Keys.Type' "/XObject");  		pdfMask.Elements.SetName (Keys.Subtype' "/Image");  		this.Owner.irefTable.Add (pdfMask);  		pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  		pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  		pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  		pdfMask.Elements [Keys.Width] = new PdfInteger (width);  		pdfMask.Elements [Keys.Height] = new PdfInteger (height);  		pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  		pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  		Elements [Keys.Mask] = pdfMask.Reference;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,PdfImage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,ReadIndexedMemoryBitmap,The following statement contains a magic number: if (!segmentedColorMask && pdfVersion >= 13) {  	PdfArray array = new PdfArray (document);  	array.Elements.Add (new PdfInteger (firstMaskColor));  	array.Elements.Add (new PdfInteger (lastMaskColor));  	Elements [Keys.Mask] = array;  }  else {  	// Monochrome mask  	byte[] maskDataCompressed = fd.Encode (mask.MaskData);  	PdfDictionary pdfMask = new PdfDictionary (document);  	pdfMask.Elements.SetName (Keys.Type' "/XObject");  	pdfMask.Elements.SetName (Keys.Subtype' "/Image");  	this.Owner.irefTable.Add (pdfMask);  	pdfMask.Stream = new PdfStream (maskDataCompressed' pdfMask);  	pdfMask.Elements [Keys.Length] = new PdfInteger (maskDataCompressed.Length);  	pdfMask.Elements [Keys.Filter] = new PdfName ("/FlateDecode");  	pdfMask.Elements [Keys.Width] = new PdfInteger (width);  	pdfMask.Elements [Keys.Height] = new PdfInteger (height);  	pdfMask.Elements [Keys.BitsPerComponent] = new PdfInteger (1);  	pdfMask.Elements [Keys.ImageMask] = new PdfBoolean (true);  	Elements [Keys.Mask] = pdfMask.Reference;  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,StartLine,The following statement contains a magic number: writeOffset = ((sizeX + 7) / 8) * (sizeY - 1 - newCurrentLine);  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,StartLine,The following statement contains a magic number: writeOffset = ((sizeX + 7) / 8) * (sizeY - 1 - newCurrentLine);  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if (bitsWritten < sizeX) {  	// Mask: 0: opaque' 1: transparent (default mapping)  	if (isTransparent)  		byteBuffer = (byteBuffer << 1) + 1;  	else  		byteBuffer = byteBuffer << 1;  	++bitsWritten;  	if ((bitsWritten & 7) == 0) {  		maskData [writeOffset] = (byte)byteBuffer;  		++writeOffset;  		byteBuffer = 0;  	}  	else if (bitsWritten == sizeX) {  		int n = 8 - (bitsWritten & 7);  		byteBuffer = byteBuffer << n;  		maskData [writeOffset] = (byte)byteBuffer;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if (bitsWritten < sizeX) {  	// Mask: 0: opaque' 1: transparent (default mapping)  	if (isTransparent)  		byteBuffer = (byteBuffer << 1) + 1;  	else  		byteBuffer = byteBuffer << 1;  	++bitsWritten;  	if ((bitsWritten & 7) == 0) {  		maskData [writeOffset] = (byte)byteBuffer;  		++writeOffset;  		byteBuffer = 0;  	}  	else if (bitsWritten == sizeX) {  		int n = 8 - (bitsWritten & 7);  		byteBuffer = byteBuffer << n;  		maskData [writeOffset] = (byte)byteBuffer;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if (bitsWritten < sizeX) {  	// Mask: 0: opaque' 1: transparent (default mapping)  	if (isTransparent)  		byteBuffer = (byteBuffer << 1) + 1;  	else  		byteBuffer = byteBuffer << 1;  	++bitsWritten;  	if ((bitsWritten & 7) == 0) {  		maskData [writeOffset] = (byte)byteBuffer;  		++writeOffset;  		byteBuffer = 0;  	}  	else if (bitsWritten == sizeX) {  		int n = 8 - (bitsWritten & 7);  		byteBuffer = byteBuffer << n;  		maskData [writeOffset] = (byte)byteBuffer;  	}  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if ((bitsWritten & 7) == 0) {  	maskData [writeOffset] = (byte)byteBuffer;  	++writeOffset;  	byteBuffer = 0;  }  else if (bitsWritten == sizeX) {  	int n = 8 - (bitsWritten & 7);  	byteBuffer = byteBuffer << n;  	maskData [writeOffset] = (byte)byteBuffer;  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if ((bitsWritten & 7) == 0) {  	maskData [writeOffset] = (byte)byteBuffer;  	++writeOffset;  	byteBuffer = 0;  }  else if (bitsWritten == sizeX) {  	int n = 8 - (bitsWritten & 7);  	byteBuffer = byteBuffer << n;  	maskData [writeOffset] = (byte)byteBuffer;  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if ((bitsWritten & 7) == 0) {  	maskData [writeOffset] = (byte)byteBuffer;  	++writeOffset;  	byteBuffer = 0;  }  else if (bitsWritten == sizeX) {  	int n = 8 - (bitsWritten & 7);  	byteBuffer = byteBuffer << n;  	maskData [writeOffset] = (byte)byteBuffer;  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if (bitsWritten == sizeX) {  	int n = 8 - (bitsWritten & 7);  	byteBuffer = byteBuffer << n;  	maskData [writeOffset] = (byte)byteBuffer;  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: if (bitsWritten == sizeX) {  	int n = 8 - (bitsWritten & 7);  	byteBuffer = byteBuffer << n;  	maskData [writeOffset] = (byte)byteBuffer;  }  
Magic Number,PdfSharp.Pdf.Advanced,MonochromeMask,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfImage.cs,AddPel,The following statement contains a magic number: AddPel (shade < 128);  
Magic Number,PdfSharp.Pdf.Advanced,PdfInternals,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfInternals.cs,GuidFromString,The following statement contains a magic number: if (id == null || id.Length != 16)  	return Guid.Empty;  
Magic Number,PdfSharp.Pdf.Advanced,PdfInternals,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfInternals.cs,GuidFromString,The following statement contains a magic number: for (int idx = 0; idx < 16; idx++)  	guid.AppendFormat ("{0:X2}"' (byte)id [idx]);  
Magic Number,PdfSharp.Pdf.Advanced,PdfShading,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfShading.cs,SetupFromBrush,The following statement contains a magic number: Elements [Keys.ShadingType] = new PdfInteger (2);  
Magic Number,PdfSharp.Pdf.Advanced,PdfShading,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfShading.cs,SetupFromBrush,The following statement contains a magic number: function.Elements ["/FunctionType"] = new PdfInteger (2);  
Magic Number,PdfSharp.Pdf.Advanced,PdfShadingPattern,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfShadingPattern.cs,PdfShadingPattern,The following statement contains a magic number: Elements [Keys.PatternType] = new PdfInteger (2);  
Magic Number,PdfSharp.Pdf.Advanced,PdfTrailer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrailer.cs,GetDocumentID,The following statement contains a magic number: if (array == null || array.Elements.Count < 2)  	return "";  
Magic Number,PdfSharp.Pdf.Advanced,PdfTrailer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrailer.cs,SetDocumentID,The following statement contains a magic number: if (array == null || array.Elements.Count < 2)  	array = CreateNewDocumentIDs ();  
Magic Number,PdfSharp.Pdf.Advanced,PdfTrueTypeFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrueTypeFont.cs,PrepareForSave,The following statement contains a magic number: LastChar = 255;  
Magic Number,PdfSharp.Pdf.Advanced,PdfTrueTypeFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrueTypeFont.cs,PrepareForSave,The following statement contains a magic number: for (int idx = 0; idx < 256; idx++)  	width.Elements.Add (new PdfInteger (this.fontDescriptor.descriptor.widths [idx]));  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanName,The following statement contains a magic number: while (true) {  	char ch = AppendAndScanNextChar ();  	if (IsWhiteSpace (ch) || IsDelimiter (ch))  		return this.symbol = CSymbol.Name;  	if (ch == '#') {  		ScanNextChar ();  		char[] hex = new char[2];  		hex [0] = this.currChar;  		hex [1] = this.nextChar;  		ScanNextChar ();  		// TODO Check syntax  		ch = (char)(ushort)int.Parse (new string (hex)' NumberStyles.AllowHexSpecifier);  		this.currChar = ch;  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanName,The following statement contains a magic number: if (ch == '#') {  	ScanNextChar ();  	char[] hex = new char[2];  	hex [0] = this.currChar;  	hex [1] = this.nextChar;  	ScanNextChar ();  	// TODO Check syntax  	ch = (char)(ushort)int.Parse (new string (hex)' NumberStyles.AllowHexSpecifier);  	this.currChar = ch;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: while (true) {  	if (char.IsDigit (ch)) {  		this.token.Append (ch);  		if (decimalDigits < 10) {  			value = 10 * value + ch - '0';  			if (period)  				decimalDigits++;  		}  	}  	else if (ch == '.') {  		if (period)  			throw new ContentReaderException ("More than one period in number.");  		period = true;  		this.token.Append (ch);  	}  	else  		break;  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: while (true) {  	if (char.IsDigit (ch)) {  		this.token.Append (ch);  		if (decimalDigits < 10) {  			value = 10 * value + ch - '0';  			if (period)  				decimalDigits++;  		}  	}  	else if (ch == '.') {  		if (period)  			throw new ContentReaderException ("More than one period in number.");  		period = true;  		this.token.Append (ch);  	}  	else  		break;  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: if (char.IsDigit (ch)) {  	this.token.Append (ch);  	if (decimalDigits < 10) {  		value = 10 * value + ch - '0';  		if (period)  			decimalDigits++;  	}  }  else if (ch == '.') {  	if (period)  		throw new ContentReaderException ("More than one period in number.");  	period = true;  	this.token.Append (ch);  }  else  	break;  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: if (char.IsDigit (ch)) {  	this.token.Append (ch);  	if (decimalDigits < 10) {  		value = 10 * value + ch - '0';  		if (period)  			decimalDigits++;  	}  }  else if (ch == '.') {  	if (period)  		throw new ContentReaderException ("More than one period in number.");  	period = true;  	this.token.Append (ch);  }  else  	break;  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: if (decimalDigits < 10) {  	value = 10 * value + ch - '0';  	if (period)  		decimalDigits++;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: if (decimalDigits < 10) {  	value = 10 * value + ch - '0';  	if (period)  		decimalDigits++;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNumber,The following statement contains a magic number: value = 10 * value + ch - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	ScanNextChar ();  	char chHi = ScanNextChar ();  	if (chHi == ')') {  		// The empty unicode string...  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	char chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			// TODO: not sure that this is correct...  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		chHi = ScanNextChar ();  		if (chHi == ')') {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		chLo = ScanNextChar ();  		ch = (char)(chHi * 256 + chLo);  	}  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	ScanNextChar ();  	char chHi = ScanNextChar ();  	if (chHi == ')') {  		// The empty unicode string...  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	char chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			// TODO: not sure that this is correct...  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		chHi = ScanNextChar ();  		if (chHi == ')') {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		chLo = ScanNextChar ();  		ch = (char)(chHi * 256 + chLo);  	}  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	ScanNextChar ();  	char chHi = ScanNextChar ();  	if (chHi == ')') {  		// The empty unicode string...  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	char chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			// TODO: not sure that this is correct...  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		chHi = ScanNextChar ();  		if (chHi == ')') {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		chLo = ScanNextChar ();  		ch = (char)(chHi * 256 + chLo);  	}  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	ScanNextChar ();  	char chHi = ScanNextChar ();  	if (chHi == ')') {  		// The empty unicode string...  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	char chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			// TODO: not sure that this is correct...  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		chHi = ScanNextChar ();  		if (chHi == ')') {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		chLo = ScanNextChar ();  		ch = (char)(chHi * 256 + chLo);  	}  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	ScanNextChar ();  	char chHi = ScanNextChar ();  	if (chHi == ')') {  		// The empty unicode string...  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	char chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			// TODO: not sure that this is correct...  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		chHi = ScanNextChar ();  		if (chHi == ')') {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		chLo = ScanNextChar ();  		ch = (char)(chHi * 256 + chLo);  	}  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	ScanNextChar ();  	char chHi = ScanNextChar ();  	if (chHi == ')') {  		// The empty unicode string...  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	char chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			// TODO: not sure that this is correct...  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		chHi = ScanNextChar ();  		if (chHi == ')') {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		chLo = ScanNextChar ();  		ch = (char)(chHi * 256 + chLo);  	}  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = CSymbol.String;  			}  			parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar))  							n = n * 8 + ScanNextChar () - '0';  					}  					ch = (char)n;  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: ch = (char)(chHi * 256 + chLo);  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		parenLevel--;  		break;  	case '\\': {  		// TODO: not sure that this is correct...  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar))  						n = n * 8 + ScanNextChar () - '0';  				}  				ch = (char)n;  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	chHi = ScanNextChar ();  	if (chHi == ')') {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		parenLevel--;  		break;  	case '\\': {  		// TODO: not sure that this is correct...  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar))  						n = n * 8 + ScanNextChar () - '0';  				}  				ch = (char)n;  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	chHi = ScanNextChar ();  	if (chHi == ')') {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		parenLevel--;  		break;  	case '\\': {  		// TODO: not sure that this is correct...  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar))  						n = n * 8 + ScanNextChar () - '0';  				}  				ch = (char)n;  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	chHi = ScanNextChar ();  	if (chHi == ')') {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	chLo = ScanNextChar ();  	ch = (char)(chHi * 256 + chLo);  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	parenLevel--;  	break;  case '\\': {  	// TODO: not sure that this is correct...  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (Char.IsDigit (ch)) {  			// Octal character code  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar))  					n = n * 8 + ScanNextChar () - '0';  			}  			ch = (char)n;  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	parenLevel--;  	break;  case '\\': {  	// TODO: not sure that this is correct...  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (Char.IsDigit (ch)) {  			// Octal character code  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar))  					n = n * 8 + ScanNextChar () - '0';  			}  			ch = (char)n;  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (Char.IsDigit (ch)) {  		// Octal character code  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar))  				n = n * 8 + ScanNextChar () - '0';  		}  		ch = (char)n;  	}  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (Char.IsDigit (ch)) {  		// Octal character code  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar))  				n = n * 8 + ScanNextChar () - '0';  		}  		ch = (char)n;  	}  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (ch)) {  	// Octal character code  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar))  			n = n * 8 + ScanNextChar () - '0';  	}  	ch = (char)n;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (ch)) {  	// Octal character code  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar))  			n = n * 8 + ScanNextChar () - '0';  	}  	ch = (char)n;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar))  		n = n * 8 + ScanNextChar () - '0';  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar))  		n = n * 8 + ScanNextChar () - '0';  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar))  	n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: ch = (char)(chHi * 256 + chLo);  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		parenLevel--;  		break;  	case '\\': {  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar))  						n = n * 8 + ScanNextChar () - '0';  				}  				ch = (char)n;  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = CSymbol.String;  		}  		parenLevel--;  		break;  	case '\\': {  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar))  						n = n * 8 + ScanNextChar () - '0';  				}  				ch = (char)n;  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	parenLevel--;  	break;  case '\\': {  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (Char.IsDigit (ch)) {  			// Octal character code  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar))  					n = n * 8 + ScanNextChar () - '0';  			}  			ch = (char)n;  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = CSymbol.String;  	}  	parenLevel--;  	break;  case '\\': {  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (Char.IsDigit (ch)) {  			// Octal character code  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar))  					n = n * 8 + ScanNextChar () - '0';  			}  			ch = (char)n;  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (Char.IsDigit (ch)) {  		// Octal character code  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar))  				n = n * 8 + ScanNextChar () - '0';  		}  		ch = (char)n;  	}  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (Char.IsDigit (ch)) {  		// Octal character code  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar))  				n = n * 8 + ScanNextChar () - '0';  		}  		ch = (char)n;  	}  	break;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (ch)) {  	// Octal character code  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar))  			n = n * 8 + ScanNextChar () - '0';  	}  	ch = (char)n;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (ch)) {  	// Octal character code  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar))  			n = n * 8 + ScanNextChar () - '0';  	}  	ch = (char)n;  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar))  		n = n * 8 + ScanNextChar () - '0';  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar))  		n = n * 8 + ScanNextChar () - '0';  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar))  	n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: Debug.Assert (count % 2 == 0);  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: for (int idx = 2; idx < count; idx += 2)  	this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: for (int idx = 2; idx < count; idx += 2)  	this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: for (int idx = 2; idx < count; idx += 2)  	this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: idx += 2
Magic Number,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanHexadecimalString,The following statement contains a magic number: this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.Content,ContentWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\ContentWriter.cs,WriteRaw,The following statement contains a magic number: Debug.Assert ((int)ch < 256' "Raw character greater than 255 dedected.");  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: while (wCount < words) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn++] << 8) + data [idxIn++];  	if (val == 0) {  		result [idxOut++] = (byte)'z';  	}  	else {  		byte c5 = (byte)(val % 85 + '!');  		val /= 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		result [idxOut++] = c1;  		result [idxOut++] = c2;  		result [idxOut++] = c3;  		result [idxOut++] = c4;  		result [idxOut++] = c5;  	}  	wCount++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (val == 0) {  	result [idxOut++] = (byte)'z';  }  else {  	byte c5 = (byte)(val % 85 + '!');  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  	result [idxOut++] = c5;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 1) {  	uint val = (uint)data [idxIn] << 24;  	val /= 85 * 85 * 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  }  else if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85 * 85 * 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85 * 85 * 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85 * 85 * 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 2) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn] << 16);  	val /= 85 * 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  }  else if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85 * 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85 * 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: if (rest == 3) {  	uint val = ((uint)data [idxIn++] << 24) + ((uint)data [idxIn++] << 16) + ((uint)data [idxIn] << 8);  	val /= 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	result [idxOut++] = c1;  	result [idxOut++] = c2;  	result [idxOut++] = c3;  	result [idxOut++] = c4;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Encode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: while (idx + 4 < length) {  	char ch = (char)data [idx];  	if (ch == 'z') {  		idx++;  		idxOut += 4;  	}  	else {  		uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  		output [idxOut++] = (byte)(val >> 24);  		output [idxOut++] = (byte)(val >> 16);  		output [idxOut++] = (byte)(val >> 8);  		output [idxOut++] = (byte)val;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (ch == 'z') {  	idx++;  	idxOut += 4;  }  else {  	uint val = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx++] - '!') * 85 + (uint)(data [idx++] - '!');  	output [idxOut++] = (byte)(val >> 24);  	output [idxOut++] = (byte)(val >> 16);  	output [idxOut++] = (byte)(val >> 8);  	output [idxOut++] = (byte)val;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: idxOut += 4;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut++] = (byte)(val >> 24);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut++] = (byte)(val >> 16);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut++] = (byte)(val >> 8);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 2)// one byte   {  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85 * 85);  	// Always increase if not zero (tried out)  	if (value != 0)  		value += 0x01000000;  	output [idxOut] = (byte)(value >> 24);  }  else if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut] = (byte)(value >> 24);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 3)// two bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx] - '!') * (85 * 85);  	if (value != 0) {  		value &= 0xFFFF0000;  		uint val = value / (85 * 85);  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  			value += 0x00010000;  			//Count2++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut] = (byte)(value >> 16);  }  else if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFF0000;  	uint val = value / (85 * 85);  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  		value += 0x00010000;  		//Count2++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2]) {  	value += 0x00010000;  	//Count2++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut++] = (byte)(value >> 24);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut] = (byte)(value >> 16);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (remainder == 4)// three bytes   {  	int idxIn = idx;  	uint value = (uint)(data [idx++] - '!') * (85 * 85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85 * 85) + (uint)(data [idx++] - '!') * (85 * 85) + (uint)(data [idx] - '!') * 85;  	if (value != 0) {  		value &= 0xFFFFFF00;  		uint val = value / 85;  		byte c4 = (byte)(val % 85 + '!');  		val /= 85;  		byte c3 = (byte)(val % 85 + '!');  		val /= 85;  		byte c2 = (byte)(val % 85 + '!');  		val /= 85;  		byte c1 = (byte)(val + '!');  		if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  			value += 0x00000100;  			//Count3++;  		}  	}  	output [idxOut++] = (byte)(value >> 24);  	output [idxOut++] = (byte)(value >> 16);  	output [idxOut] = (byte)(value >> 8);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (value != 0) {  	value &= 0xFFFFFF00;  	uint val = value / 85;  	byte c4 = (byte)(val % 85 + '!');  	val /= 85;  	byte c3 = (byte)(val % 85 + '!');  	val /= 85;  	byte c2 = (byte)(val % 85 + '!');  	val /= 85;  	byte c1 = (byte)(val + '!');  	if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  		value += 0x00000100;  		//Count3++;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: val /= 85;  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  	value += 0x00000100;  	//Count3++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: if (c1 != data [idxIn] || c2 != data [idxIn + 1] || c3 != data [idxIn + 2] || c4 != data [idxIn + 3]) {  	value += 0x00000100;  	//Count3++;  }  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut++] = (byte)(value >> 24);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut++] = (byte)(value >> 16);  
Magic Number,PdfSharp.Pdf.Filters,ASCII85Decode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCII85Decode.cs,Decode,The following statement contains a magic number: output [idxOut] = (byte)(value >> 8);  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte b = data [i];  	bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  	bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte b = data [i];  	bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  	bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte b = data [i];  	bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  	bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte b = data [i];  	bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  	bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte b = data [i];  	bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  	bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte b = data [i];  	bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  	bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: bytes [j++] = (byte)((b >> 4) + ((b >> 4) < 10 ? (byte)'0' : (byte)('A' - 10)));  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Encode,The following statement contains a magic number: bytes [j++] = (byte)((b & 0xF) + ((b & 0xF) < 10 ? (byte)'0' : (byte)('A' - 10)));  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Decode,The following statement contains a magic number: if (count % 2 == 1) {  	count++;  	byte[] temp = data;  	data = new byte[count];  	temp.CopyTo (data' 0);  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Decode,The following statement contains a magic number: count <<= 2;  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Decode,The following statement contains a magic number: for (int i = 0' j = 0; i < count; i++) {  	byte hi = data [j++];  	byte lo = data [j++];  	bytes [i] = (byte)((hi > '9' ? hi - 'A' : hi - '0') * 16 + (lo > '9' ? lo - 'A' : lo - '0'));  }  
Magic Number,PdfSharp.Pdf.Filters,ASCIIHexDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\ASCIIHexDecode.cs,Decode,The following statement contains a magic number: bytes [i] = (byte)((hi > '9' ? hi - 'A' : hi - '0') * 16 + (lo > '9' ? lo - 'A' : lo - '0'));  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,Decode,The following statement contains a magic number: while ((code = NextCode) != 257) {  	if (code == 256) {  		InitializeDictionary ();  		code = NextCode;  		if (code == 257) {  			break;  		}  		outputStream.Write (stringTable [code]' 0' stringTable [code].Length);  		oldCode = code;  	}  	else {  		if (code < tableIndex) {  			str = stringTable [code];  			outputStream.Write (str' 0' str.Length);  			AddEntry (stringTable [oldCode]' str [0]);  			oldCode = code;  		}  		else {  			str = stringTable [oldCode];  			outputStream.Write (str' 0' str.Length);  			AddEntry (str' str [0]);  			oldCode = code;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,Decode,The following statement contains a magic number: while ((code = NextCode) != 257) {  	if (code == 256) {  		InitializeDictionary ();  		code = NextCode;  		if (code == 257) {  			break;  		}  		outputStream.Write (stringTable [code]' 0' stringTable [code].Length);  		oldCode = code;  	}  	else {  		if (code < tableIndex) {  			str = stringTable [code];  			outputStream.Write (str' 0' str.Length);  			AddEntry (stringTable [oldCode]' str [0]);  			oldCode = code;  		}  		else {  			str = stringTable [oldCode];  			outputStream.Write (str' 0' str.Length);  			AddEntry (str' str [0]);  			oldCode = code;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,Decode,The following statement contains a magic number: while ((code = NextCode) != 257) {  	if (code == 256) {  		InitializeDictionary ();  		code = NextCode;  		if (code == 257) {  			break;  		}  		outputStream.Write (stringTable [code]' 0' stringTable [code].Length);  		oldCode = code;  	}  	else {  		if (code < tableIndex) {  			str = stringTable [code];  			outputStream.Write (str' 0' str.Length);  			AddEntry (stringTable [oldCode]' str [0]);  			oldCode = code;  		}  		else {  			str = stringTable [oldCode];  			outputStream.Write (str' 0' str.Length);  			AddEntry (str' str [0]);  			oldCode = code;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,Decode,The following statement contains a magic number: if (code == 256) {  	InitializeDictionary ();  	code = NextCode;  	if (code == 257) {  		break;  	}  	outputStream.Write (stringTable [code]' 0' stringTable [code].Length);  	oldCode = code;  }  else {  	if (code < tableIndex) {  		str = stringTable [code];  		outputStream.Write (str' 0' str.Length);  		AddEntry (stringTable [oldCode]' str [0]);  		oldCode = code;  	}  	else {  		str = stringTable [oldCode];  		outputStream.Write (str' 0' str.Length);  		AddEntry (str' str [0]);  		oldCode = code;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,Decode,The following statement contains a magic number: if (code == 256) {  	InitializeDictionary ();  	code = NextCode;  	if (code == 257) {  		break;  	}  	outputStream.Write (stringTable [code]' 0' stringTable [code].Length);  	oldCode = code;  }  else {  	if (code < tableIndex) {  		str = stringTable [code];  		outputStream.Write (str' 0' str.Length);  		AddEntry (stringTable [oldCode]' str [0]);  		oldCode = code;  	}  	else {  		str = stringTable [oldCode];  		outputStream.Write (str' 0' str.Length);  		AddEntry (str' str [0]);  		oldCode = code;  	}  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,Decode,The following statement contains a magic number: if (code == 257) {  	break;  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,InitializeDictionary,The following statement contains a magic number: stringTable = new byte[8192][];  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,InitializeDictionary,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	stringTable [i] = new byte[1];  	stringTable [i] [0] = (byte)i;  }  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,InitializeDictionary,The following statement contains a magic number: tableIndex = 258;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,InitializeDictionary,The following statement contains a magic number: bitsToGet = 9;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 511)  	bitsToGet = 10;  else if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 511)  	bitsToGet = 10;  else if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 511)  	bitsToGet = 10;  else if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 511)  	bitsToGet = 10;  else if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 511)  	bitsToGet = 10;  else if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 511)  	bitsToGet = 10;  else if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: bitsToGet = 10;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 1023)  	bitsToGet = 11;  else if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: bitsToGet = 11;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: if (tableIndex == 2047)  	bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Filters,LzwDecode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\LzwDecode.cs,AddEntry,The following statement contains a magic number: bitsToGet = 12;  
Magic Number,PdfSharp.Pdf.Internal,ColorSpaceHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\ColorSpaceHelper.cs,EnsureColorMode,The following statement contains a magic number: if (colorMode == PdfColorMode.Rgb && color.ColorSpace != XColorSpace.Rgb)  	return XColor.FromArgb ((int)(color.A * 255)' color.R' color.G' color.B);  
Magic Number,PdfSharp.Pdf.Internal,ColorSpaceHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\ColorSpaceHelper.cs,EnsureColorMode,The following statement contains a magic number: return XColor.FromArgb ((int)(color.A * 255)' color.R' color.G' color.B);  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: Debug.Assert (!unicode || bytes.Length % 2 == 0' "Odd number of bytes in Unicode string.");  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!unicode) {  	if (!hex) {  		pdf.Append ("(");  		for (int idx = 0; idx < count; idx++) {  			char ch = (char)bytes [idx];  			if (ch < 32) {  				switch (ch) {  				case '\n':  					pdf.Append ("\\n");  					break;  				case '\r':  					pdf.Append ("\\r");  					break;  				case '\t':  					pdf.Append ("\\t");  					break;  				case '\b':  					pdf.Append ("\\b");  					break;  				// currups encrypted text                      				//case '\f':  				//  pdf.Append("\\f");  				//  break;  				default:  					// Don't escape chararchters less than 32 if the string is encrypted' because it is  					// unreadable anyway.  					encrypted = true;  					if (!encrypted) {  						pdf.Append ("\\0");  						pdf.Append ((char)(ch % 8 + '0'));  						pdf.Append ((char)(ch / 8 + '0'));  					}  					else  						pdf.Append (ch);  					break;  				}  			}  			else {  				switch (ch) {  				case '(':  					pdf.Append ("\\(");  					break;  				case ')':  					pdf.Append ("\\)");  					break;  				case '\\':  					pdf.Append ("\\\\");  					break;  				default:  					pdf.Append (ch);  					break;  				}  			}  		}  		pdf.Append (')');  	}  	else {  		pdf.Append ('<');  		for (int idx = 0; idx < count; idx++)  			pdf.AppendFormat ("{0:X2}"' bytes [idx]);  		pdf.Append ('>');  	}  }  else {  	Hex:  	if (hex) {  		if (prefix)  			pdf.Append ("<FEFF");  		else  			pdf.Append ("<");  		for (int idx = 0; idx < count; idx += 2) {  			pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  			if (idx != 0 && (idx % 48) == 0)  				pdf.Append ("\n");  		}  		pdf.Append (">");  	}  	else {  		// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  		hex = true;  		goto Hex;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!unicode) {  	if (!hex) {  		pdf.Append ("(");  		for (int idx = 0; idx < count; idx++) {  			char ch = (char)bytes [idx];  			if (ch < 32) {  				switch (ch) {  				case '\n':  					pdf.Append ("\\n");  					break;  				case '\r':  					pdf.Append ("\\r");  					break;  				case '\t':  					pdf.Append ("\\t");  					break;  				case '\b':  					pdf.Append ("\\b");  					break;  				// currups encrypted text                      				//case '\f':  				//  pdf.Append("\\f");  				//  break;  				default:  					// Don't escape chararchters less than 32 if the string is encrypted' because it is  					// unreadable anyway.  					encrypted = true;  					if (!encrypted) {  						pdf.Append ("\\0");  						pdf.Append ((char)(ch % 8 + '0'));  						pdf.Append ((char)(ch / 8 + '0'));  					}  					else  						pdf.Append (ch);  					break;  				}  			}  			else {  				switch (ch) {  				case '(':  					pdf.Append ("\\(");  					break;  				case ')':  					pdf.Append ("\\)");  					break;  				case '\\':  					pdf.Append ("\\\\");  					break;  				default:  					pdf.Append (ch);  					break;  				}  			}  		}  		pdf.Append (')');  	}  	else {  		pdf.Append ('<');  		for (int idx = 0; idx < count; idx++)  			pdf.AppendFormat ("{0:X2}"' bytes [idx]);  		pdf.Append ('>');  	}  }  else {  	Hex:  	if (hex) {  		if (prefix)  			pdf.Append ("<FEFF");  		else  			pdf.Append ("<");  		for (int idx = 0; idx < count; idx += 2) {  			pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  			if (idx != 0 && (idx % 48) == 0)  				pdf.Append ("\n");  		}  		pdf.Append (">");  	}  	else {  		// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  		hex = true;  		goto Hex;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!unicode) {  	if (!hex) {  		pdf.Append ("(");  		for (int idx = 0; idx < count; idx++) {  			char ch = (char)bytes [idx];  			if (ch < 32) {  				switch (ch) {  				case '\n':  					pdf.Append ("\\n");  					break;  				case '\r':  					pdf.Append ("\\r");  					break;  				case '\t':  					pdf.Append ("\\t");  					break;  				case '\b':  					pdf.Append ("\\b");  					break;  				// currups encrypted text                      				//case '\f':  				//  pdf.Append("\\f");  				//  break;  				default:  					// Don't escape chararchters less than 32 if the string is encrypted' because it is  					// unreadable anyway.  					encrypted = true;  					if (!encrypted) {  						pdf.Append ("\\0");  						pdf.Append ((char)(ch % 8 + '0'));  						pdf.Append ((char)(ch / 8 + '0'));  					}  					else  						pdf.Append (ch);  					break;  				}  			}  			else {  				switch (ch) {  				case '(':  					pdf.Append ("\\(");  					break;  				case ')':  					pdf.Append ("\\)");  					break;  				case '\\':  					pdf.Append ("\\\\");  					break;  				default:  					pdf.Append (ch);  					break;  				}  			}  		}  		pdf.Append (')');  	}  	else {  		pdf.Append ('<');  		for (int idx = 0; idx < count; idx++)  			pdf.AppendFormat ("{0:X2}"' bytes [idx]);  		pdf.Append ('>');  	}  }  else {  	Hex:  	if (hex) {  		if (prefix)  			pdf.Append ("<FEFF");  		else  			pdf.Append ("<");  		for (int idx = 0; idx < count; idx += 2) {  			pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  			if (idx != 0 && (idx % 48) == 0)  				pdf.Append ("\n");  		}  		pdf.Append (">");  	}  	else {  		// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  		hex = true;  		goto Hex;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!unicode) {  	if (!hex) {  		pdf.Append ("(");  		for (int idx = 0; idx < count; idx++) {  			char ch = (char)bytes [idx];  			if (ch < 32) {  				switch (ch) {  				case '\n':  					pdf.Append ("\\n");  					break;  				case '\r':  					pdf.Append ("\\r");  					break;  				case '\t':  					pdf.Append ("\\t");  					break;  				case '\b':  					pdf.Append ("\\b");  					break;  				// currups encrypted text                      				//case '\f':  				//  pdf.Append("\\f");  				//  break;  				default:  					// Don't escape chararchters less than 32 if the string is encrypted' because it is  					// unreadable anyway.  					encrypted = true;  					if (!encrypted) {  						pdf.Append ("\\0");  						pdf.Append ((char)(ch % 8 + '0'));  						pdf.Append ((char)(ch / 8 + '0'));  					}  					else  						pdf.Append (ch);  					break;  				}  			}  			else {  				switch (ch) {  				case '(':  					pdf.Append ("\\(");  					break;  				case ')':  					pdf.Append ("\\)");  					break;  				case '\\':  					pdf.Append ("\\\\");  					break;  				default:  					pdf.Append (ch);  					break;  				}  			}  		}  		pdf.Append (')');  	}  	else {  		pdf.Append ('<');  		for (int idx = 0; idx < count; idx++)  			pdf.AppendFormat ("{0:X2}"' bytes [idx]);  		pdf.Append ('>');  	}  }  else {  	Hex:  	if (hex) {  		if (prefix)  			pdf.Append ("<FEFF");  		else  			pdf.Append ("<");  		for (int idx = 0; idx < count; idx += 2) {  			pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  			if (idx != 0 && (idx % 48) == 0)  				pdf.Append ("\n");  		}  		pdf.Append (">");  	}  	else {  		// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  		hex = true;  		goto Hex;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!unicode) {  	if (!hex) {  		pdf.Append ("(");  		for (int idx = 0; idx < count; idx++) {  			char ch = (char)bytes [idx];  			if (ch < 32) {  				switch (ch) {  				case '\n':  					pdf.Append ("\\n");  					break;  				case '\r':  					pdf.Append ("\\r");  					break;  				case '\t':  					pdf.Append ("\\t");  					break;  				case '\b':  					pdf.Append ("\\b");  					break;  				// currups encrypted text                      				//case '\f':  				//  pdf.Append("\\f");  				//  break;  				default:  					// Don't escape chararchters less than 32 if the string is encrypted' because it is  					// unreadable anyway.  					encrypted = true;  					if (!encrypted) {  						pdf.Append ("\\0");  						pdf.Append ((char)(ch % 8 + '0'));  						pdf.Append ((char)(ch / 8 + '0'));  					}  					else  						pdf.Append (ch);  					break;  				}  			}  			else {  				switch (ch) {  				case '(':  					pdf.Append ("\\(");  					break;  				case ')':  					pdf.Append ("\\)");  					break;  				case '\\':  					pdf.Append ("\\\\");  					break;  				default:  					pdf.Append (ch);  					break;  				}  			}  		}  		pdf.Append (')');  	}  	else {  		pdf.Append ('<');  		for (int idx = 0; idx < count; idx++)  			pdf.AppendFormat ("{0:X2}"' bytes [idx]);  		pdf.Append ('>');  	}  }  else {  	Hex:  	if (hex) {  		if (prefix)  			pdf.Append ("<FEFF");  		else  			pdf.Append ("<");  		for (int idx = 0; idx < count; idx += 2) {  			pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  			if (idx != 0 && (idx % 48) == 0)  				pdf.Append ("\n");  		}  		pdf.Append (">");  	}  	else {  		// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  		hex = true;  		goto Hex;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!hex) {  	pdf.Append ("(");  	for (int idx = 0; idx < count; idx++) {  		char ch = (char)bytes [idx];  		if (ch < 32) {  			switch (ch) {  			case '\n':  				pdf.Append ("\\n");  				break;  			case '\r':  				pdf.Append ("\\r");  				break;  			case '\t':  				pdf.Append ("\\t");  				break;  			case '\b':  				pdf.Append ("\\b");  				break;  			// currups encrypted text                      			//case '\f':  			//  pdf.Append("\\f");  			//  break;  			default:  				// Don't escape chararchters less than 32 if the string is encrypted' because it is  				// unreadable anyway.  				encrypted = true;  				if (!encrypted) {  					pdf.Append ("\\0");  					pdf.Append ((char)(ch % 8 + '0'));  					pdf.Append ((char)(ch / 8 + '0'));  				}  				else  					pdf.Append (ch);  				break;  			}  		}  		else {  			switch (ch) {  			case '(':  				pdf.Append ("\\(");  				break;  			case ')':  				pdf.Append ("\\)");  				break;  			case '\\':  				pdf.Append ("\\\\");  				break;  			default:  				pdf.Append (ch);  				break;  			}  		}  	}  	pdf.Append (')');  }  else {  	pdf.Append ('<');  	for (int idx = 0; idx < count; idx++)  		pdf.AppendFormat ("{0:X2}"' bytes [idx]);  	pdf.Append ('>');  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!hex) {  	pdf.Append ("(");  	for (int idx = 0; idx < count; idx++) {  		char ch = (char)bytes [idx];  		if (ch < 32) {  			switch (ch) {  			case '\n':  				pdf.Append ("\\n");  				break;  			case '\r':  				pdf.Append ("\\r");  				break;  			case '\t':  				pdf.Append ("\\t");  				break;  			case '\b':  				pdf.Append ("\\b");  				break;  			// currups encrypted text                      			//case '\f':  			//  pdf.Append("\\f");  			//  break;  			default:  				// Don't escape chararchters less than 32 if the string is encrypted' because it is  				// unreadable anyway.  				encrypted = true;  				if (!encrypted) {  					pdf.Append ("\\0");  					pdf.Append ((char)(ch % 8 + '0'));  					pdf.Append ((char)(ch / 8 + '0'));  				}  				else  					pdf.Append (ch);  				break;  			}  		}  		else {  			switch (ch) {  			case '(':  				pdf.Append ("\\(");  				break;  			case ')':  				pdf.Append ("\\)");  				break;  			case '\\':  				pdf.Append ("\\\\");  				break;  			default:  				pdf.Append (ch);  				break;  			}  		}  	}  	pdf.Append (')');  }  else {  	pdf.Append ('<');  	for (int idx = 0; idx < count; idx++)  		pdf.AppendFormat ("{0:X2}"' bytes [idx]);  	pdf.Append ('>');  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!hex) {  	pdf.Append ("(");  	for (int idx = 0; idx < count; idx++) {  		char ch = (char)bytes [idx];  		if (ch < 32) {  			switch (ch) {  			case '\n':  				pdf.Append ("\\n");  				break;  			case '\r':  				pdf.Append ("\\r");  				break;  			case '\t':  				pdf.Append ("\\t");  				break;  			case '\b':  				pdf.Append ("\\b");  				break;  			// currups encrypted text                      			//case '\f':  			//  pdf.Append("\\f");  			//  break;  			default:  				// Don't escape chararchters less than 32 if the string is encrypted' because it is  				// unreadable anyway.  				encrypted = true;  				if (!encrypted) {  					pdf.Append ("\\0");  					pdf.Append ((char)(ch % 8 + '0'));  					pdf.Append ((char)(ch / 8 + '0'));  				}  				else  					pdf.Append (ch);  				break;  			}  		}  		else {  			switch (ch) {  			case '(':  				pdf.Append ("\\(");  				break;  			case ')':  				pdf.Append ("\\)");  				break;  			case '\\':  				pdf.Append ("\\\\");  				break;  			default:  				pdf.Append (ch);  				break;  			}  		}  	}  	pdf.Append (')');  }  else {  	pdf.Append ('<');  	for (int idx = 0; idx < count; idx++)  		pdf.AppendFormat ("{0:X2}"' bytes [idx]);  	pdf.Append ('>');  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	char ch = (char)bytes [idx];  	if (ch < 32) {  		switch (ch) {  		case '\n':  			pdf.Append ("\\n");  			break;  		case '\r':  			pdf.Append ("\\r");  			break;  		case '\t':  			pdf.Append ("\\t");  			break;  		case '\b':  			pdf.Append ("\\b");  			break;  		// currups encrypted text                      		//case '\f':  		//  pdf.Append("\\f");  		//  break;  		default:  			// Don't escape chararchters less than 32 if the string is encrypted' because it is  			// unreadable anyway.  			encrypted = true;  			if (!encrypted) {  				pdf.Append ("\\0");  				pdf.Append ((char)(ch % 8 + '0'));  				pdf.Append ((char)(ch / 8 + '0'));  			}  			else  				pdf.Append (ch);  			break;  		}  	}  	else {  		switch (ch) {  		case '(':  			pdf.Append ("\\(");  			break;  		case ')':  			pdf.Append ("\\)");  			break;  		case '\\':  			pdf.Append ("\\\\");  			break;  		default:  			pdf.Append (ch);  			break;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	char ch = (char)bytes [idx];  	if (ch < 32) {  		switch (ch) {  		case '\n':  			pdf.Append ("\\n");  			break;  		case '\r':  			pdf.Append ("\\r");  			break;  		case '\t':  			pdf.Append ("\\t");  			break;  		case '\b':  			pdf.Append ("\\b");  			break;  		// currups encrypted text                      		//case '\f':  		//  pdf.Append("\\f");  		//  break;  		default:  			// Don't escape chararchters less than 32 if the string is encrypted' because it is  			// unreadable anyway.  			encrypted = true;  			if (!encrypted) {  				pdf.Append ("\\0");  				pdf.Append ((char)(ch % 8 + '0'));  				pdf.Append ((char)(ch / 8 + '0'));  			}  			else  				pdf.Append (ch);  			break;  		}  	}  	else {  		switch (ch) {  		case '(':  			pdf.Append ("\\(");  			break;  		case ')':  			pdf.Append ("\\)");  			break;  		case '\\':  			pdf.Append ("\\\\");  			break;  		default:  			pdf.Append (ch);  			break;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	char ch = (char)bytes [idx];  	if (ch < 32) {  		switch (ch) {  		case '\n':  			pdf.Append ("\\n");  			break;  		case '\r':  			pdf.Append ("\\r");  			break;  		case '\t':  			pdf.Append ("\\t");  			break;  		case '\b':  			pdf.Append ("\\b");  			break;  		// currups encrypted text                      		//case '\f':  		//  pdf.Append("\\f");  		//  break;  		default:  			// Don't escape chararchters less than 32 if the string is encrypted' because it is  			// unreadable anyway.  			encrypted = true;  			if (!encrypted) {  				pdf.Append ("\\0");  				pdf.Append ((char)(ch % 8 + '0'));  				pdf.Append ((char)(ch / 8 + '0'));  			}  			else  				pdf.Append (ch);  			break;  		}  	}  	else {  		switch (ch) {  		case '(':  			pdf.Append ("\\(");  			break;  		case ')':  			pdf.Append ("\\)");  			break;  		case '\\':  			pdf.Append ("\\\\");  			break;  		default:  			pdf.Append (ch);  			break;  		}  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (ch < 32) {  	switch (ch) {  	case '\n':  		pdf.Append ("\\n");  		break;  	case '\r':  		pdf.Append ("\\r");  		break;  	case '\t':  		pdf.Append ("\\t");  		break;  	case '\b':  		pdf.Append ("\\b");  		break;  	// currups encrypted text                      	//case '\f':  	//  pdf.Append("\\f");  	//  break;  	default:  		// Don't escape chararchters less than 32 if the string is encrypted' because it is  		// unreadable anyway.  		encrypted = true;  		if (!encrypted) {  			pdf.Append ("\\0");  			pdf.Append ((char)(ch % 8 + '0'));  			pdf.Append ((char)(ch / 8 + '0'));  		}  		else  			pdf.Append (ch);  		break;  	}  }  else {  	switch (ch) {  	case '(':  		pdf.Append ("\\(");  		break;  	case ')':  		pdf.Append ("\\)");  		break;  	case '\\':  		pdf.Append ("\\\\");  		break;  	default:  		pdf.Append (ch);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (ch < 32) {  	switch (ch) {  	case '\n':  		pdf.Append ("\\n");  		break;  	case '\r':  		pdf.Append ("\\r");  		break;  	case '\t':  		pdf.Append ("\\t");  		break;  	case '\b':  		pdf.Append ("\\b");  		break;  	// currups encrypted text                      	//case '\f':  	//  pdf.Append("\\f");  	//  break;  	default:  		// Don't escape chararchters less than 32 if the string is encrypted' because it is  		// unreadable anyway.  		encrypted = true;  		if (!encrypted) {  			pdf.Append ("\\0");  			pdf.Append ((char)(ch % 8 + '0'));  			pdf.Append ((char)(ch / 8 + '0'));  		}  		else  			pdf.Append (ch);  		break;  	}  }  else {  	switch (ch) {  	case '(':  		pdf.Append ("\\(");  		break;  	case ')':  		pdf.Append ("\\)");  		break;  	case '\\':  		pdf.Append ("\\\\");  		break;  	default:  		pdf.Append (ch);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (ch < 32) {  	switch (ch) {  	case '\n':  		pdf.Append ("\\n");  		break;  	case '\r':  		pdf.Append ("\\r");  		break;  	case '\t':  		pdf.Append ("\\t");  		break;  	case '\b':  		pdf.Append ("\\b");  		break;  	// currups encrypted text                      	//case '\f':  	//  pdf.Append("\\f");  	//  break;  	default:  		// Don't escape chararchters less than 32 if the string is encrypted' because it is  		// unreadable anyway.  		encrypted = true;  		if (!encrypted) {  			pdf.Append ("\\0");  			pdf.Append ((char)(ch % 8 + '0'));  			pdf.Append ((char)(ch / 8 + '0'));  		}  		else  			pdf.Append (ch);  		break;  	}  }  else {  	switch (ch) {  	case '(':  		pdf.Append ("\\(");  		break;  	case ')':  		pdf.Append ("\\)");  		break;  	case '\\':  		pdf.Append ("\\\\");  		break;  	default:  		pdf.Append (ch);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: switch (ch) {  case '\n':  	pdf.Append ("\\n");  	break;  case '\r':  	pdf.Append ("\\r");  	break;  case '\t':  	pdf.Append ("\\t");  	break;  case '\b':  	pdf.Append ("\\b");  	break;  // currups encrypted text                      //case '\f':  //  pdf.Append("\\f");  //  break;  default:  	// Don't escape chararchters less than 32 if the string is encrypted' because it is  	// unreadable anyway.  	encrypted = true;  	if (!encrypted) {  		pdf.Append ("\\0");  		pdf.Append ((char)(ch % 8 + '0'));  		pdf.Append ((char)(ch / 8 + '0'));  	}  	else  		pdf.Append (ch);  	break;  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: switch (ch) {  case '\n':  	pdf.Append ("\\n");  	break;  case '\r':  	pdf.Append ("\\r");  	break;  case '\t':  	pdf.Append ("\\t");  	break;  case '\b':  	pdf.Append ("\\b");  	break;  // currups encrypted text                      //case '\f':  //  pdf.Append("\\f");  //  break;  default:  	// Don't escape chararchters less than 32 if the string is encrypted' because it is  	// unreadable anyway.  	encrypted = true;  	if (!encrypted) {  		pdf.Append ("\\0");  		pdf.Append ((char)(ch % 8 + '0'));  		pdf.Append ((char)(ch / 8 + '0'));  	}  	else  		pdf.Append (ch);  	break;  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!encrypted) {  	pdf.Append ("\\0");  	pdf.Append ((char)(ch % 8 + '0'));  	pdf.Append ((char)(ch / 8 + '0'));  }  else  	pdf.Append (ch);  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (!encrypted) {  	pdf.Append ("\\0");  	pdf.Append ((char)(ch % 8 + '0'));  	pdf.Append ((char)(ch / 8 + '0'));  }  else  	pdf.Append (ch);  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: pdf.Append ((char)(ch % 8 + '0'));  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: pdf.Append ((char)(ch / 8 + '0'));  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (hex) {  	if (prefix)  		pdf.Append ("<FEFF");  	else  		pdf.Append ("<");  	for (int idx = 0; idx < count; idx += 2) {  		pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  		if (idx != 0 && (idx % 48) == 0)  			pdf.Append ("\n");  	}  	pdf.Append (">");  }  else {  	// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  	hex = true;  	goto Hex;  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (hex) {  	if (prefix)  		pdf.Append ("<FEFF");  	else  		pdf.Append ("<");  	for (int idx = 0; idx < count; idx += 2) {  		pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  		if (idx != 0 && (idx % 48) == 0)  			pdf.Append ("\n");  	}  	pdf.Append (">");  }  else {  	// TODO non hex literals... not sure how to treat linefeeds' '('' '\' etc.  	hex = true;  	goto Hex;  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: for (int idx = 0; idx < count; idx += 2) {  	pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  	if (idx != 0 && (idx % 48) == 0)  		pdf.Append ("\n");  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: for (int idx = 0; idx < count; idx += 2) {  	pdf.AppendFormat ("{0:X2}{1:X2}"' bytes [idx]' bytes [idx + 1]);  	if (idx != 0 && (idx % 48) == 0)  		pdf.Append ("\n");  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: idx += 2
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,FormatStringLiteral,The following statement contains a magic number: if (idx != 0 && (idx % 48) == 0)  	pdf.Append ("\n");  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The following statement contains a magic number: switch (colorMode) {  case PdfColorMode.Cmyk:  	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###} {3:0.###}"' color.C' color.M' color.Y' color.K);  default:  	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The following statement contains a magic number: switch (colorMode) {  case PdfColorMode.Cmyk:  	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###} {3:0.###}"' color.C' color.M' color.Y' color.K);  default:  	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The following statement contains a magic number: switch (colorMode) {  case PdfColorMode.Cmyk:  	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###} {3:0.###}"' color.C' color.M' color.Y' color.K);  default:  	return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  }  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,PdfSharp.Pdf.Internal,PdfEncoders,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\PdfEncoders.cs,ToString,The following statement contains a magic number: return String.Format (CultureInfo.InvariantCulture' "{0:0.###} {1:0.###} {2:0.###}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,PdfSharp.Pdf.Internal,RawEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawEncoding.cs,GetBytes,The following statement contains a magic number: for (int count = charCount; count > 0; charIndex++' byteIndex++' count--) {  	Debug.Assert ((uint)chars [charIndex] < 256' "Raw string contains invalid character with a value > 255.");  	bytes [byteIndex] = (byte)chars [charIndex];  }  
Magic Number,PdfSharp.Pdf.Internal,RawEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawEncoding.cs,GetBytes,The following statement contains a magic number: Debug.Assert ((uint)chars [charIndex] < 256' "Raw string contains invalid character with a value > 255.");  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetByteCount,The following statement contains a magic number: return 2 * count;  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetBytes,The following statement contains a magic number: for (int count = charCount; count > 0; charIndex++' count--) {  	char ch = chars [charIndex];  	bytes [byteIndex++] = (byte)(ch >> 8);  	bytes [byteIndex++] = (byte)ch;  }  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetBytes,The following statement contains a magic number: bytes [byteIndex++] = (byte)(ch >> 8);  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetBytes,The following statement contains a magic number: return charCount * 2;  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetCharCount,The following statement contains a magic number: return count / 2;  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetChars,The following statement contains a magic number: for (int count = byteCount; count > 0; byteIndex += 2' charIndex++' count--) {  	chars [charIndex] = (char)((int)bytes [byteIndex] << 8 + (int)bytes [byteIndex + 1]);  }  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetChars,The following statement contains a magic number: for (int count = byteCount; count > 0; byteIndex += 2' charIndex++' count--) {  	chars [charIndex] = (char)((int)bytes [byteIndex] << 8 + (int)bytes [byteIndex + 1]);  }  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetChars,The following statement contains a magic number: byteIndex += 2
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetChars,The following statement contains a magic number: chars [charIndex] = (char)((int)bytes [byteIndex] << 8 + (int)bytes [byteIndex + 1]);  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetMaxByteCount,The following statement contains a magic number: return charCount * 2;  
Magic Number,PdfSharp.Pdf.Internal,RawUnicodeEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\RawUnicodeEncoding.cs,GetMaxCharCount,The following statement contains a magic number: return byteCount / 2;  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ReadStream,The following statement contains a magic number: if (this.currChar == Chars.CR) {  	if (this.nextChar == Chars.LF)  		pos = this.idxChar + 2;  	else  		pos = this.idxChar + 1;  }  else  	pos = this.idxChar + 1;  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ReadStream,The following statement contains a magic number: if (this.nextChar == Chars.LF)  	pos = this.idxChar + 2;  else  	pos = this.idxChar + 1;  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ReadStream,The following statement contains a magic number: pos = this.idxChar + 2;  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanName,The following statement contains a magic number: while (true) {  	char ch = AppendAndScanNextChar ();  	if (IsWhiteSpace (ch) || IsDelimiter (ch))  		return this.symbol = Symbol.Name;  	if (ch == '#') {  		ScanNextChar ();  		char[] hex = new char[2];  		hex [0] = this.currChar;  		hex [1] = this.nextChar;  		ScanNextChar ();  		// TODO Check syntax  		ch = (char)(ushort)int.Parse (new string (hex)' NumberStyles.AllowHexSpecifier);  		this.currChar = ch;  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanName,The following statement contains a magic number: if (ch == '#') {  	ScanNextChar ();  	char[] hex = new char[2];  	hex [0] = this.currChar;  	hex [1] = this.nextChar;  	ScanNextChar ();  	// TODO Check syntax  	ch = (char)(ushort)int.Parse (new string (hex)' NumberStyles.AllowHexSpecifier);  	this.currChar = ch;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	// BUG: The code is not correct. I got a file containing the following sting:  	// (�����f��\r�F`:7.2.5 Acceptable daily intake \(ADI\) and other guideline levels)  	// It starts as unicode but ends as Ascii. No idea how to parse.  	#if true  	//List<byte> bytes = new List<byte>();  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			// is this possible in a Unicode string?  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		//chHi = ScanNextChar();  		//if (chHi == ')')  		//{  		//  ScanNextChar();  		//  return this.symbol = Symbol.String;  		//}  		//chLo = ScanNextChar();  		//ch = (char)((int)chHi * 256 + (int)chLo);  		ch = ScanNextChar ();  	}  	#else  	        char chHi' chLo;         ScanNextChar();         chHi = ScanNextChar();         if (chHi == ')')         {           // The empty unicode string...           ScanNextChar();           return this.symbol = Symbol.String;         }         chLo = ScanNextChar();         ch = (char)((int)chHi * 256 + (int)chLo);         while (true)         {         SkipChar:           switch (ch)           {             case '(':               parenLevel++;               break;              case ')':               if (parenLevel == 0)               {                 ScanNextChar();                 return this.symbol = Symbol.String;               }               else                 parenLevel--;               break;              case '\\':               {                 // TODO: not sure that this is correct...                 ch = ScanNextChar();                 switch (ch)                 {                   case 'n':                     ch = Chars.LF;                     break;                    case 'r':                     ch = Chars.CR;                     break;                    case 't':                     ch = Chars.HT;                     break;                    case 'b':                     ch = Chars.BS;                     break;                    case 'f':                     ch = Chars.FF;                     break;                    case '(':                     ch = Chars.ParenLeft;                     break;                    case ')':                     ch = Chars.ParenRight;                     break;                    case '\\':                     ch = Chars.BackSlash;                     break;                    case Chars.LF:                     ch = ScanNextChar();                     goto SkipChar;                    default:                     if (Char.IsDigit(ch))                     {                       // Octal character code                       Debug.Assert(ch < '8'' "Illegal octal digit.");                       int n = ch - '0';                       if (Char.IsDigit(this.nextChar))                       {                         Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                         n = n * 8 + ScanNextChar() - '0';                         if (Char.IsDigit(this.nextChar))                         {                           Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                           n = n * 8 + ScanNextChar() - '0';                         }                       }                       ch = (char)n;                     }                     else                     {                       //TODO                       Debug.Assert(false' "Not implemented; unknown escape character.");                     }                     break;                 }                 break;               }              // TODO ???             //case '':             //  Debug.Assert(false' "Not yet implemented");             //  break;              default:               break;           }           this.token.Append(ch);           chHi = ScanNextChar();           if (chHi == ')')           {             ScanNextChar();             return this.symbol = Symbol.String;           }           chLo = ScanNextChar();           ch = (char)((int)chHi * 256 + (int)chLo);         } #endif  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	// BUG: The code is not correct. I got a file containing the following sting:  	// (�����f��\r�F`:7.2.5 Acceptable daily intake \(ADI\) and other guideline levels)  	// It starts as unicode but ends as Ascii. No idea how to parse.  	#if true  	//List<byte> bytes = new List<byte>();  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			// is this possible in a Unicode string?  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		//chHi = ScanNextChar();  		//if (chHi == ')')  		//{  		//  ScanNextChar();  		//  return this.symbol = Symbol.String;  		//}  		//chLo = ScanNextChar();  		//ch = (char)((int)chHi * 256 + (int)chLo);  		ch = ScanNextChar ();  	}  	#else  	        char chHi' chLo;         ScanNextChar();         chHi = ScanNextChar();         if (chHi == ')')         {           // The empty unicode string...           ScanNextChar();           return this.symbol = Symbol.String;         }         chLo = ScanNextChar();         ch = (char)((int)chHi * 256 + (int)chLo);         while (true)         {         SkipChar:           switch (ch)           {             case '(':               parenLevel++;               break;              case ')':               if (parenLevel == 0)               {                 ScanNextChar();                 return this.symbol = Symbol.String;               }               else                 parenLevel--;               break;              case '\\':               {                 // TODO: not sure that this is correct...                 ch = ScanNextChar();                 switch (ch)                 {                   case 'n':                     ch = Chars.LF;                     break;                    case 'r':                     ch = Chars.CR;                     break;                    case 't':                     ch = Chars.HT;                     break;                    case 'b':                     ch = Chars.BS;                     break;                    case 'f':                     ch = Chars.FF;                     break;                    case '(':                     ch = Chars.ParenLeft;                     break;                    case ')':                     ch = Chars.ParenRight;                     break;                    case '\\':                     ch = Chars.BackSlash;                     break;                    case Chars.LF:                     ch = ScanNextChar();                     goto SkipChar;                    default:                     if (Char.IsDigit(ch))                     {                       // Octal character code                       Debug.Assert(ch < '8'' "Illegal octal digit.");                       int n = ch - '0';                       if (Char.IsDigit(this.nextChar))                       {                         Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                         n = n * 8 + ScanNextChar() - '0';                         if (Char.IsDigit(this.nextChar))                         {                           Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                           n = n * 8 + ScanNextChar() - '0';                         }                       }                       ch = (char)n;                     }                     else                     {                       //TODO                       Debug.Assert(false' "Not implemented; unknown escape character.");                     }                     break;                 }                 break;               }              // TODO ???             //case '':             //  Debug.Assert(false' "Not yet implemented");             //  break;              default:               break;           }           this.token.Append(ch);           chHi = ScanNextChar();           if (chHi == ')')           {             ScanNextChar();             return this.symbol = Symbol.String;           }           chLo = ScanNextChar();           ch = (char)((int)chHi * 256 + (int)chLo);         } #endif  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	// BUG: The code is not correct. I got a file containing the following sting:  	// (�����f��\r�F`:7.2.5 Acceptable daily intake \(ADI\) and other guideline levels)  	// It starts as unicode but ends as Ascii. No idea how to parse.  	#if true  	//List<byte> bytes = new List<byte>();  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			// is this possible in a Unicode string?  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		//chHi = ScanNextChar();  		//if (chHi == ')')  		//{  		//  ScanNextChar();  		//  return this.symbol = Symbol.String;  		//}  		//chLo = ScanNextChar();  		//ch = (char)((int)chHi * 256 + (int)chLo);  		ch = ScanNextChar ();  	}  	#else  	        char chHi' chLo;         ScanNextChar();         chHi = ScanNextChar();         if (chHi == ')')         {           // The empty unicode string...           ScanNextChar();           return this.symbol = Symbol.String;         }         chLo = ScanNextChar();         ch = (char)((int)chHi * 256 + (int)chLo);         while (true)         {         SkipChar:           switch (ch)           {             case '(':               parenLevel++;               break;              case ')':               if (parenLevel == 0)               {                 ScanNextChar();                 return this.symbol = Symbol.String;               }               else                 parenLevel--;               break;              case '\\':               {                 // TODO: not sure that this is correct...                 ch = ScanNextChar();                 switch (ch)                 {                   case 'n':                     ch = Chars.LF;                     break;                    case 'r':                     ch = Chars.CR;                     break;                    case 't':                     ch = Chars.HT;                     break;                    case 'b':                     ch = Chars.BS;                     break;                    case 'f':                     ch = Chars.FF;                     break;                    case '(':                     ch = Chars.ParenLeft;                     break;                    case ')':                     ch = Chars.ParenRight;                     break;                    case '\\':                     ch = Chars.BackSlash;                     break;                    case Chars.LF:                     ch = ScanNextChar();                     goto SkipChar;                    default:                     if (Char.IsDigit(ch))                     {                       // Octal character code                       Debug.Assert(ch < '8'' "Illegal octal digit.");                       int n = ch - '0';                       if (Char.IsDigit(this.nextChar))                       {                         Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                         n = n * 8 + ScanNextChar() - '0';                         if (Char.IsDigit(this.nextChar))                         {                           Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                           n = n * 8 + ScanNextChar() - '0';                         }                       }                       ch = (char)n;                     }                     else                     {                       //TODO                       Debug.Assert(false' "Not implemented; unknown escape character.");                     }                     break;                 }                 break;               }              // TODO ???             //case '':             //  Debug.Assert(false' "Not yet implemented");             //  break;              default:               break;           }           this.token.Append(ch);           chHi = ScanNextChar();           if (chHi == ')')           {             ScanNextChar();             return this.symbol = Symbol.String;           }           chLo = ScanNextChar();           ch = (char)((int)chHi * 256 + (int)chLo);         } #endif  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (ch == '\xFE' && this.nextChar == '\xFF') {  	// I'm not sure if the code is correct in any case.  	// ? Can a UNICODE character not start with ')' as hibyte  	// ? What about \# escape sequences  	// BUG: The code is not correct. I got a file containing the following sting:  	// (�����f��\r�F`:7.2.5 Acceptable daily intake \(ADI\) and other guideline levels)  	// It starts as unicode but ends as Ascii. No idea how to parse.  	#if true  	//List<byte> bytes = new List<byte>();  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			// is this possible in a Unicode string?  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (Char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		//chHi = ScanNextChar();  		//if (chHi == ')')  		//{  		//  ScanNextChar();  		//  return this.symbol = Symbol.String;  		//}  		//chLo = ScanNextChar();  		//ch = (char)((int)chHi * 256 + (int)chLo);  		ch = ScanNextChar ();  	}  	#else  	        char chHi' chLo;         ScanNextChar();         chHi = ScanNextChar();         if (chHi == ')')         {           // The empty unicode string...           ScanNextChar();           return this.symbol = Symbol.String;         }         chLo = ScanNextChar();         ch = (char)((int)chHi * 256 + (int)chLo);         while (true)         {         SkipChar:           switch (ch)           {             case '(':               parenLevel++;               break;              case ')':               if (parenLevel == 0)               {                 ScanNextChar();                 return this.symbol = Symbol.String;               }               else                 parenLevel--;               break;              case '\\':               {                 // TODO: not sure that this is correct...                 ch = ScanNextChar();                 switch (ch)                 {                   case 'n':                     ch = Chars.LF;                     break;                    case 'r':                     ch = Chars.CR;                     break;                    case 't':                     ch = Chars.HT;                     break;                    case 'b':                     ch = Chars.BS;                     break;                    case 'f':                     ch = Chars.FF;                     break;                    case '(':                     ch = Chars.ParenLeft;                     break;                    case ')':                     ch = Chars.ParenRight;                     break;                    case '\\':                     ch = Chars.BackSlash;                     break;                    case Chars.LF:                     ch = ScanNextChar();                     goto SkipChar;                    default:                     if (Char.IsDigit(ch))                     {                       // Octal character code                       Debug.Assert(ch < '8'' "Illegal octal digit.");                       int n = ch - '0';                       if (Char.IsDigit(this.nextChar))                       {                         Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                         n = n * 8 + ScanNextChar() - '0';                         if (Char.IsDigit(this.nextChar))                         {                           Debug.Assert(this.nextChar < '8'' "Illegal octal digit.");                           n = n * 8 + ScanNextChar() - '0';                         }                       }                       ch = (char)n;                     }                     else                     {                       //TODO                       Debug.Assert(false' "Not implemented; unknown escape character.");                     }                     break;                 }                 break;               }              // TODO ???             //case '':             //  Debug.Assert(false' "Not yet implemented");             //  break;              default:               break;           }           this.token.Append(ch);           chHi = ScanNextChar();           if (chHi == ')')           {             ScanNextChar();             return this.symbol = Symbol.String;           }           chLo = ScanNextChar();           ch = (char)((int)chHi * 256 + (int)chLo);         } #endif  }  else {  	// 8-bit characters  	while (true) {  		SkipChar:  		switch (ch) {  		case '(':  			parenLevel++;  			break;  		case ')':  			if (parenLevel == 0) {  				ScanNextChar ();  				return this.symbol = Symbol.String;  			}  			else  				parenLevel--;  			break;  		case '\\': {  			ch = ScanNextChar ();  			switch (ch) {  			case 'n':  				ch = Chars.LF;  				break;  			case 'r':  				ch = Chars.CR;  				break;  			case 't':  				ch = Chars.HT;  				break;  			case 'b':  				ch = Chars.BS;  				break;  			case 'f':  				ch = Chars.FF;  				break;  			case '(':  				ch = Chars.ParenLeft;  				break;  			case ')':  				ch = Chars.ParenRight;  				break;  			case '\\':  				ch = Chars.BackSlash;  				break;  			case Chars.LF:  				ch = ScanNextChar ();  				goto SkipChar;  			default:  				if (char.IsDigit (ch)) {  					// Octal character code  					Debug.Assert (ch < '8'' "Illegal octal digit.");  					int n = ch - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  						if (Char.IsDigit (this.nextChar)) {  							Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  							n = n * 8 + ScanNextChar () - '0';  						}  					}  					ch = (char)n;  				}  				else {  					//TODO  					Debug.Assert (false' "Not implemented; unknown escape character.");  				}  				break;  			}  			break;  		}  		// TODO ???  		//case '#':  		//  Debug.Assert(false' "Not yet implemented");  		//  break;  		default:  			break;  		}  		this.token.Append (ch);  		ch = ScanNextChar ();  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		// is this possible in a Unicode string?  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = Symbol.String;  		}  		else  			parenLevel--;  		break;  	case '\\': {  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				Debug.Assert (ch < '8'' "Illegal octal digit.");  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  					}  				}  				ch = (char)n;  			}  			else {  				//TODO  				Debug.Assert (false' "Not implemented; unknown escape character.");  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	//chHi = ScanNextChar();  	//if (chHi == ')')  	//{  	//  ScanNextChar();  	//  return this.symbol = Symbol.String;  	//}  	//chLo = ScanNextChar();  	//ch = (char)((int)chHi * 256 + (int)chLo);  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		// is this possible in a Unicode string?  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = Symbol.String;  		}  		else  			parenLevel--;  		break;  	case '\\': {  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (Char.IsDigit (ch)) {  				// Octal character code  				Debug.Assert (ch < '8'' "Illegal octal digit.");  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  					}  				}  				ch = (char)n;  			}  			else {  				//TODO  				Debug.Assert (false' "Not implemented; unknown escape character.");  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	//chHi = ScanNextChar();  	//if (chHi == ')')  	//{  	//  ScanNextChar();  	//  return this.symbol = Symbol.String;  	//}  	//chLo = ScanNextChar();  	//ch = (char)((int)chHi * 256 + (int)chLo);  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	// is this possible in a Unicode string?  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = Symbol.String;  	}  	else  		parenLevel--;  	break;  case '\\': {  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (Char.IsDigit (ch)) {  			// Octal character code  			Debug.Assert (ch < '8'' "Illegal octal digit.");  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  				}  			}  			ch = (char)n;  		}  		else {  			//TODO  			Debug.Assert (false' "Not implemented; unknown escape character.");  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	// is this possible in a Unicode string?  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = Symbol.String;  	}  	else  		parenLevel--;  	break;  case '\\': {  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (Char.IsDigit (ch)) {  			// Octal character code  			Debug.Assert (ch < '8'' "Illegal octal digit.");  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  				}  			}  			ch = (char)n;  		}  		else {  			//TODO  			Debug.Assert (false' "Not implemented; unknown escape character.");  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (Char.IsDigit (ch)) {  		// Octal character code  		Debug.Assert (ch < '8'' "Illegal octal digit.");  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  			}  		}  		ch = (char)n;  	}  	else {  		//TODO  		Debug.Assert (false' "Not implemented; unknown escape character.");  	}  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (Char.IsDigit (ch)) {  		// Octal character code  		Debug.Assert (ch < '8'' "Illegal octal digit.");  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  			}  		}  		ch = (char)n;  	}  	else {  		//TODO  		Debug.Assert (false' "Not implemented; unknown escape character.");  	}  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (ch)) {  	// Octal character code  	Debug.Assert (ch < '8'' "Illegal octal digit.");  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  		}  	}  	ch = (char)n;  }  else {  	//TODO  	Debug.Assert (false' "Not implemented; unknown escape character.");  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (ch)) {  	// Octal character code  	Debug.Assert (ch < '8'' "Illegal octal digit.");  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  		}  	}  	ch = (char)n;  }  else {  	//TODO  	Debug.Assert (false' "Not implemented; unknown escape character.");  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  	n = n * 8 + ScanNextChar () - '0';  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = Symbol.String;  		}  		else  			parenLevel--;  		break;  	case '\\': {  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (char.IsDigit (ch)) {  				// Octal character code  				Debug.Assert (ch < '8'' "Illegal octal digit.");  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  					}  				}  				ch = (char)n;  			}  			else {  				//TODO  				Debug.Assert (false' "Not implemented; unknown escape character.");  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: while (true) {  	SkipChar:  	switch (ch) {  	case '(':  		parenLevel++;  		break;  	case ')':  		if (parenLevel == 0) {  			ScanNextChar ();  			return this.symbol = Symbol.String;  		}  		else  			parenLevel--;  		break;  	case '\\': {  		ch = ScanNextChar ();  		switch (ch) {  		case 'n':  			ch = Chars.LF;  			break;  		case 'r':  			ch = Chars.CR;  			break;  		case 't':  			ch = Chars.HT;  			break;  		case 'b':  			ch = Chars.BS;  			break;  		case 'f':  			ch = Chars.FF;  			break;  		case '(':  			ch = Chars.ParenLeft;  			break;  		case ')':  			ch = Chars.ParenRight;  			break;  		case '\\':  			ch = Chars.BackSlash;  			break;  		case Chars.LF:  			ch = ScanNextChar ();  			goto SkipChar;  		default:  			if (char.IsDigit (ch)) {  				// Octal character code  				Debug.Assert (ch < '8'' "Illegal octal digit.");  				int n = ch - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  					if (Char.IsDigit (this.nextChar)) {  						Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  						n = n * 8 + ScanNextChar () - '0';  					}  				}  				ch = (char)n;  			}  			else {  				//TODO  				Debug.Assert (false' "Not implemented; unknown escape character.");  			}  			break;  		}  		break;  	}  	// TODO ???  	//case '#':  	//  Debug.Assert(false' "Not yet implemented");  	//  break;  	default:  		break;  	}  	this.token.Append (ch);  	ch = ScanNextChar ();  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = Symbol.String;  	}  	else  		parenLevel--;  	break;  case '\\': {  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (char.IsDigit (ch)) {  			// Octal character code  			Debug.Assert (ch < '8'' "Illegal octal digit.");  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  				}  			}  			ch = (char)n;  		}  		else {  			//TODO  			Debug.Assert (false' "Not implemented; unknown escape character.");  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case '(':  	parenLevel++;  	break;  case ')':  	if (parenLevel == 0) {  		ScanNextChar ();  		return this.symbol = Symbol.String;  	}  	else  		parenLevel--;  	break;  case '\\': {  	ch = ScanNextChar ();  	switch (ch) {  	case 'n':  		ch = Chars.LF;  		break;  	case 'r':  		ch = Chars.CR;  		break;  	case 't':  		ch = Chars.HT;  		break;  	case 'b':  		ch = Chars.BS;  		break;  	case 'f':  		ch = Chars.FF;  		break;  	case '(':  		ch = Chars.ParenLeft;  		break;  	case ')':  		ch = Chars.ParenRight;  		break;  	case '\\':  		ch = Chars.BackSlash;  		break;  	case Chars.LF:  		ch = ScanNextChar ();  		goto SkipChar;  	default:  		if (char.IsDigit (ch)) {  			// Octal character code  			Debug.Assert (ch < '8'' "Illegal octal digit.");  			int n = ch - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  				if (Char.IsDigit (this.nextChar)) {  					Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  					n = n * 8 + ScanNextChar () - '0';  				}  			}  			ch = (char)n;  		}  		else {  			//TODO  			Debug.Assert (false' "Not implemented; unknown escape character.");  		}  		break;  	}  	break;  }  // TODO ???  //case '#':  //  Debug.Assert(false' "Not yet implemented");  //  break;  default:  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (char.IsDigit (ch)) {  		// Octal character code  		Debug.Assert (ch < '8'' "Illegal octal digit.");  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  			}  		}  		ch = (char)n;  	}  	else {  		//TODO  		Debug.Assert (false' "Not implemented; unknown escape character.");  	}  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: switch (ch) {  case 'n':  	ch = Chars.LF;  	break;  case 'r':  	ch = Chars.CR;  	break;  case 't':  	ch = Chars.HT;  	break;  case 'b':  	ch = Chars.BS;  	break;  case 'f':  	ch = Chars.FF;  	break;  case '(':  	ch = Chars.ParenLeft;  	break;  case ')':  	ch = Chars.ParenRight;  	break;  case '\\':  	ch = Chars.BackSlash;  	break;  case Chars.LF:  	ch = ScanNextChar ();  	goto SkipChar;  default:  	if (char.IsDigit (ch)) {  		// Octal character code  		Debug.Assert (ch < '8'' "Illegal octal digit.");  		int n = ch - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  			if (Char.IsDigit (this.nextChar)) {  				Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  				n = n * 8 + ScanNextChar () - '0';  			}  		}  		ch = (char)n;  	}  	else {  		//TODO  		Debug.Assert (false' "Not implemented; unknown escape character.");  	}  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (char.IsDigit (ch)) {  	// Octal character code  	Debug.Assert (ch < '8'' "Illegal octal digit.");  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  		}  	}  	ch = (char)n;  }  else {  	//TODO  	Debug.Assert (false' "Not implemented; unknown escape character.");  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (char.IsDigit (ch)) {  	// Octal character code  	Debug.Assert (ch < '8'' "Illegal octal digit.");  	int n = ch - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  		if (Char.IsDigit (this.nextChar)) {  			Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  			n = n * 8 + ScanNextChar () - '0';  		}  	}  	ch = (char)n;  }  else {  	//TODO  	Debug.Assert (false' "Not implemented; unknown escape character.");  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  	n = n * 8 + ScanNextChar () - '0';  	if (Char.IsDigit (this.nextChar)) {  		Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  		n = n * 8 + ScanNextChar () - '0';  	}  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: if (Char.IsDigit (this.nextChar)) {  	Debug.Assert (this.nextChar < '8'' "Illegal octal digit.");  	n = n * 8 + ScanNextChar () - '0';  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The following statement contains a magic number: n = n * 8 + ScanNextChar () - '0';  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: if (count > 2 && chars [0] == (char)0xFE && chars [1] == (char)0xFF) {  	Debug.Assert (count % 2 == 0);  	this.token.Length = 0;  	for (int idx = 2; idx < count; idx += 2)  		this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  }  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: Debug.Assert (count % 2 == 0);  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: for (int idx = 2; idx < count; idx += 2)  	this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: for (int idx = 2; idx < count; idx += 2)  	this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: for (int idx = 2; idx < count; idx += 2)  	this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: idx += 2
Magic Number,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanHexadecimalString,The following statement contains a magic number: this.token.Append ((char)(chars [idx] * 256 + chars [idx + 1]));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadDictionary,The following statement contains a magic number: Debug.Assert (count % 2 == 0);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadDictionary,The following statement contains a magic number: for (int idx = 0; idx < count; idx += 2) {  	PdfItem val = items [idx];  	if (!(val is PdfName))  		throw new PdfReaderException ("name expected");  	string key = ((PdfName)val).ToString ();  	#if DEBUG_  	        if (key == "/ID")         {           GetType();           char x = ((PdfString)(((PdfArray)items[idx + 1]).Elements[0])).Value[0];           x.GetType();         } #endif  	val = items [idx + 1];  	if (includeReferences && val is PdfReference)  		val = ReadReference ((PdfReference)val' includeReferences);  	dict.Elements [key] = val;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadDictionary,The following statement contains a magic number: idx += 2
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: while ((symbol = ScanNextToken ()) != Symbol.Eof) {  	if (symbol == stop)  		return;  	switch (symbol) {  	case Symbol.Comment:  		// ignore comments  		break;  	case Symbol.Null:  		this.stack.Shift (PdfNull.Value);  		break;  	case Symbol.Boolean:  		this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  		break;  	case Symbol.Integer:  		this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  		break;  	case Symbol.UInteger:  		this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  		break;  	case Symbol.Real:  		this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  		break;  	case Symbol.String:  		//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  		break;  	case Symbol.UnicodeString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  		break;  	case Symbol.HexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  		break;  	case Symbol.UnicodeHexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  		break;  	case Symbol.Name:  		this.stack.Shift (new PdfName (this.lexer.Token));  		break;  	case Symbol.R: {  		Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  		PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  		PdfReference iref = this.document.irefTable [objectID];  		if (iref == null) {  			// If a document has more than one PdfXRefTable it is possible that the first trailer has  			// indirect references to objects whos iref entry is not yet read in.  			if (this.document.irefTable.IsUnderConstruction) {  				// XRefTable not complete when trailer is read. Create temporary irefs that are  				// removed later in PdfTrailer.FixXRefs.  				iref = new PdfReference (objectID' 0);  				this.stack.Reduce (iref' 2);  				break;  			}  			// PDF Reference section 3.2.9:  			// An indirect reference to an undefined object is not an error;  			// it is simply treated as a reference to the null object.  			this.stack.Reduce (PdfNull.Value' 2);  			// Let's see what null objects are good for...  			//Debug.Assert(false' "Null object detected!");  			//this.stack.Reduce(PdfNull.Value' 2);  		}  		else  			this.stack.Reduce (iref' 2);  		break;  	}  	case Symbol.BeginArray:  		PdfArray array = new PdfArray (this.document);  		ReadArray (array' false);  		this.stack.Shift (array);  		break;  	case Symbol.BeginDictionary:  		PdfDictionary dict = new PdfDictionary (this.document);  		ReadDictionary (dict' false);  		this.stack.Shift (dict);  		break;  	case Symbol.BeginStream:  		throw new NotImplementedException ();  	default:  		string error = this.lexer.Token;  		Debug.Assert (false' "Unexpected: " + error);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: while ((symbol = ScanNextToken ()) != Symbol.Eof) {  	if (symbol == stop)  		return;  	switch (symbol) {  	case Symbol.Comment:  		// ignore comments  		break;  	case Symbol.Null:  		this.stack.Shift (PdfNull.Value);  		break;  	case Symbol.Boolean:  		this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  		break;  	case Symbol.Integer:  		this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  		break;  	case Symbol.UInteger:  		this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  		break;  	case Symbol.Real:  		this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  		break;  	case Symbol.String:  		//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  		break;  	case Symbol.UnicodeString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  		break;  	case Symbol.HexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  		break;  	case Symbol.UnicodeHexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  		break;  	case Symbol.Name:  		this.stack.Shift (new PdfName (this.lexer.Token));  		break;  	case Symbol.R: {  		Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  		PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  		PdfReference iref = this.document.irefTable [objectID];  		if (iref == null) {  			// If a document has more than one PdfXRefTable it is possible that the first trailer has  			// indirect references to objects whos iref entry is not yet read in.  			if (this.document.irefTable.IsUnderConstruction) {  				// XRefTable not complete when trailer is read. Create temporary irefs that are  				// removed later in PdfTrailer.FixXRefs.  				iref = new PdfReference (objectID' 0);  				this.stack.Reduce (iref' 2);  				break;  			}  			// PDF Reference section 3.2.9:  			// An indirect reference to an undefined object is not an error;  			// it is simply treated as a reference to the null object.  			this.stack.Reduce (PdfNull.Value' 2);  			// Let's see what null objects are good for...  			//Debug.Assert(false' "Null object detected!");  			//this.stack.Reduce(PdfNull.Value' 2);  		}  		else  			this.stack.Reduce (iref' 2);  		break;  	}  	case Symbol.BeginArray:  		PdfArray array = new PdfArray (this.document);  		ReadArray (array' false);  		this.stack.Shift (array);  		break;  	case Symbol.BeginDictionary:  		PdfDictionary dict = new PdfDictionary (this.document);  		ReadDictionary (dict' false);  		this.stack.Shift (dict);  		break;  	case Symbol.BeginStream:  		throw new NotImplementedException ();  	default:  		string error = this.lexer.Token;  		Debug.Assert (false' "Unexpected: " + error);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: while ((symbol = ScanNextToken ()) != Symbol.Eof) {  	if (symbol == stop)  		return;  	switch (symbol) {  	case Symbol.Comment:  		// ignore comments  		break;  	case Symbol.Null:  		this.stack.Shift (PdfNull.Value);  		break;  	case Symbol.Boolean:  		this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  		break;  	case Symbol.Integer:  		this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  		break;  	case Symbol.UInteger:  		this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  		break;  	case Symbol.Real:  		this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  		break;  	case Symbol.String:  		//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  		break;  	case Symbol.UnicodeString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  		break;  	case Symbol.HexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  		break;  	case Symbol.UnicodeHexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  		break;  	case Symbol.Name:  		this.stack.Shift (new PdfName (this.lexer.Token));  		break;  	case Symbol.R: {  		Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  		PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  		PdfReference iref = this.document.irefTable [objectID];  		if (iref == null) {  			// If a document has more than one PdfXRefTable it is possible that the first trailer has  			// indirect references to objects whos iref entry is not yet read in.  			if (this.document.irefTable.IsUnderConstruction) {  				// XRefTable not complete when trailer is read. Create temporary irefs that are  				// removed later in PdfTrailer.FixXRefs.  				iref = new PdfReference (objectID' 0);  				this.stack.Reduce (iref' 2);  				break;  			}  			// PDF Reference section 3.2.9:  			// An indirect reference to an undefined object is not an error;  			// it is simply treated as a reference to the null object.  			this.stack.Reduce (PdfNull.Value' 2);  			// Let's see what null objects are good for...  			//Debug.Assert(false' "Null object detected!");  			//this.stack.Reduce(PdfNull.Value' 2);  		}  		else  			this.stack.Reduce (iref' 2);  		break;  	}  	case Symbol.BeginArray:  		PdfArray array = new PdfArray (this.document);  		ReadArray (array' false);  		this.stack.Shift (array);  		break;  	case Symbol.BeginDictionary:  		PdfDictionary dict = new PdfDictionary (this.document);  		ReadDictionary (dict' false);  		this.stack.Shift (dict);  		break;  	case Symbol.BeginStream:  		throw new NotImplementedException ();  	default:  		string error = this.lexer.Token;  		Debug.Assert (false' "Unexpected: " + error);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: while ((symbol = ScanNextToken ()) != Symbol.Eof) {  	if (symbol == stop)  		return;  	switch (symbol) {  	case Symbol.Comment:  		// ignore comments  		break;  	case Symbol.Null:  		this.stack.Shift (PdfNull.Value);  		break;  	case Symbol.Boolean:  		this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  		break;  	case Symbol.Integer:  		this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  		break;  	case Symbol.UInteger:  		this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  		break;  	case Symbol.Real:  		this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  		break;  	case Symbol.String:  		//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  		break;  	case Symbol.UnicodeString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  		break;  	case Symbol.HexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  		break;  	case Symbol.UnicodeHexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  		break;  	case Symbol.Name:  		this.stack.Shift (new PdfName (this.lexer.Token));  		break;  	case Symbol.R: {  		Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  		PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  		PdfReference iref = this.document.irefTable [objectID];  		if (iref == null) {  			// If a document has more than one PdfXRefTable it is possible that the first trailer has  			// indirect references to objects whos iref entry is not yet read in.  			if (this.document.irefTable.IsUnderConstruction) {  				// XRefTable not complete when trailer is read. Create temporary irefs that are  				// removed later in PdfTrailer.FixXRefs.  				iref = new PdfReference (objectID' 0);  				this.stack.Reduce (iref' 2);  				break;  			}  			// PDF Reference section 3.2.9:  			// An indirect reference to an undefined object is not an error;  			// it is simply treated as a reference to the null object.  			this.stack.Reduce (PdfNull.Value' 2);  			// Let's see what null objects are good for...  			//Debug.Assert(false' "Null object detected!");  			//this.stack.Reduce(PdfNull.Value' 2);  		}  		else  			this.stack.Reduce (iref' 2);  		break;  	}  	case Symbol.BeginArray:  		PdfArray array = new PdfArray (this.document);  		ReadArray (array' false);  		this.stack.Shift (array);  		break;  	case Symbol.BeginDictionary:  		PdfDictionary dict = new PdfDictionary (this.document);  		ReadDictionary (dict' false);  		this.stack.Shift (dict);  		break;  	case Symbol.BeginStream:  		throw new NotImplementedException ();  	default:  		string error = this.lexer.Token;  		Debug.Assert (false' "Unexpected: " + error);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: while ((symbol = ScanNextToken ()) != Symbol.Eof) {  	if (symbol == stop)  		return;  	switch (symbol) {  	case Symbol.Comment:  		// ignore comments  		break;  	case Symbol.Null:  		this.stack.Shift (PdfNull.Value);  		break;  	case Symbol.Boolean:  		this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  		break;  	case Symbol.Integer:  		this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  		break;  	case Symbol.UInteger:  		this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  		break;  	case Symbol.Real:  		this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  		break;  	case Symbol.String:  		//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  		break;  	case Symbol.UnicodeString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  		break;  	case Symbol.HexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  		break;  	case Symbol.UnicodeHexString:  		this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  		break;  	case Symbol.Name:  		this.stack.Shift (new PdfName (this.lexer.Token));  		break;  	case Symbol.R: {  		Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  		PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  		PdfReference iref = this.document.irefTable [objectID];  		if (iref == null) {  			// If a document has more than one PdfXRefTable it is possible that the first trailer has  			// indirect references to objects whos iref entry is not yet read in.  			if (this.document.irefTable.IsUnderConstruction) {  				// XRefTable not complete when trailer is read. Create temporary irefs that are  				// removed later in PdfTrailer.FixXRefs.  				iref = new PdfReference (objectID' 0);  				this.stack.Reduce (iref' 2);  				break;  			}  			// PDF Reference section 3.2.9:  			// An indirect reference to an undefined object is not an error;  			// it is simply treated as a reference to the null object.  			this.stack.Reduce (PdfNull.Value' 2);  			// Let's see what null objects are good for...  			//Debug.Assert(false' "Null object detected!");  			//this.stack.Reduce(PdfNull.Value' 2);  		}  		else  			this.stack.Reduce (iref' 2);  		break;  	}  	case Symbol.BeginArray:  		PdfArray array = new PdfArray (this.document);  		ReadArray (array' false);  		this.stack.Shift (array);  		break;  	case Symbol.BeginDictionary:  		PdfDictionary dict = new PdfDictionary (this.document);  		ReadDictionary (dict' false);  		this.stack.Shift (dict);  		break;  	case Symbol.BeginStream:  		throw new NotImplementedException ();  	default:  		string error = this.lexer.Token;  		Debug.Assert (false' "Unexpected: " + error);  		break;  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: switch (symbol) {  case Symbol.Comment:  	// ignore comments  	break;  case Symbol.Null:  	this.stack.Shift (PdfNull.Value);  	break;  case Symbol.Boolean:  	this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  	break;  case Symbol.Integer:  	this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  	break;  case Symbol.UInteger:  	this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  	break;  case Symbol.Real:  	this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  	break;  case Symbol.String:  	//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  	break;  case Symbol.UnicodeString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  	break;  case Symbol.HexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  	break;  case Symbol.UnicodeHexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  	break;  case Symbol.Name:  	this.stack.Shift (new PdfName (this.lexer.Token));  	break;  case Symbol.R: {  	Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  	PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  	PdfReference iref = this.document.irefTable [objectID];  	if (iref == null) {  		// If a document has more than one PdfXRefTable it is possible that the first trailer has  		// indirect references to objects whos iref entry is not yet read in.  		if (this.document.irefTable.IsUnderConstruction) {  			// XRefTable not complete when trailer is read. Create temporary irefs that are  			// removed later in PdfTrailer.FixXRefs.  			iref = new PdfReference (objectID' 0);  			this.stack.Reduce (iref' 2);  			break;  		}  		// PDF Reference section 3.2.9:  		// An indirect reference to an undefined object is not an error;  		// it is simply treated as a reference to the null object.  		this.stack.Reduce (PdfNull.Value' 2);  		// Let's see what null objects are good for...  		//Debug.Assert(false' "Null object detected!");  		//this.stack.Reduce(PdfNull.Value' 2);  	}  	else  		this.stack.Reduce (iref' 2);  	break;  }  case Symbol.BeginArray:  	PdfArray array = new PdfArray (this.document);  	ReadArray (array' false);  	this.stack.Shift (array);  	break;  case Symbol.BeginDictionary:  	PdfDictionary dict = new PdfDictionary (this.document);  	ReadDictionary (dict' false);  	this.stack.Shift (dict);  	break;  case Symbol.BeginStream:  	throw new NotImplementedException ();  default:  	string error = this.lexer.Token;  	Debug.Assert (false' "Unexpected: " + error);  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: switch (symbol) {  case Symbol.Comment:  	// ignore comments  	break;  case Symbol.Null:  	this.stack.Shift (PdfNull.Value);  	break;  case Symbol.Boolean:  	this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  	break;  case Symbol.Integer:  	this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  	break;  case Symbol.UInteger:  	this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  	break;  case Symbol.Real:  	this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  	break;  case Symbol.String:  	//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  	break;  case Symbol.UnicodeString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  	break;  case Symbol.HexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  	break;  case Symbol.UnicodeHexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  	break;  case Symbol.Name:  	this.stack.Shift (new PdfName (this.lexer.Token));  	break;  case Symbol.R: {  	Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  	PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  	PdfReference iref = this.document.irefTable [objectID];  	if (iref == null) {  		// If a document has more than one PdfXRefTable it is possible that the first trailer has  		// indirect references to objects whos iref entry is not yet read in.  		if (this.document.irefTable.IsUnderConstruction) {  			// XRefTable not complete when trailer is read. Create temporary irefs that are  			// removed later in PdfTrailer.FixXRefs.  			iref = new PdfReference (objectID' 0);  			this.stack.Reduce (iref' 2);  			break;  		}  		// PDF Reference section 3.2.9:  		// An indirect reference to an undefined object is not an error;  		// it is simply treated as a reference to the null object.  		this.stack.Reduce (PdfNull.Value' 2);  		// Let's see what null objects are good for...  		//Debug.Assert(false' "Null object detected!");  		//this.stack.Reduce(PdfNull.Value' 2);  	}  	else  		this.stack.Reduce (iref' 2);  	break;  }  case Symbol.BeginArray:  	PdfArray array = new PdfArray (this.document);  	ReadArray (array' false);  	this.stack.Shift (array);  	break;  case Symbol.BeginDictionary:  	PdfDictionary dict = new PdfDictionary (this.document);  	ReadDictionary (dict' false);  	this.stack.Shift (dict);  	break;  case Symbol.BeginStream:  	throw new NotImplementedException ();  default:  	string error = this.lexer.Token;  	Debug.Assert (false' "Unexpected: " + error);  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: switch (symbol) {  case Symbol.Comment:  	// ignore comments  	break;  case Symbol.Null:  	this.stack.Shift (PdfNull.Value);  	break;  case Symbol.Boolean:  	this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  	break;  case Symbol.Integer:  	this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  	break;  case Symbol.UInteger:  	this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  	break;  case Symbol.Real:  	this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  	break;  case Symbol.String:  	//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  	break;  case Symbol.UnicodeString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  	break;  case Symbol.HexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  	break;  case Symbol.UnicodeHexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  	break;  case Symbol.Name:  	this.stack.Shift (new PdfName (this.lexer.Token));  	break;  case Symbol.R: {  	Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  	PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  	PdfReference iref = this.document.irefTable [objectID];  	if (iref == null) {  		// If a document has more than one PdfXRefTable it is possible that the first trailer has  		// indirect references to objects whos iref entry is not yet read in.  		if (this.document.irefTable.IsUnderConstruction) {  			// XRefTable not complete when trailer is read. Create temporary irefs that are  			// removed later in PdfTrailer.FixXRefs.  			iref = new PdfReference (objectID' 0);  			this.stack.Reduce (iref' 2);  			break;  		}  		// PDF Reference section 3.2.9:  		// An indirect reference to an undefined object is not an error;  		// it is simply treated as a reference to the null object.  		this.stack.Reduce (PdfNull.Value' 2);  		// Let's see what null objects are good for...  		//Debug.Assert(false' "Null object detected!");  		//this.stack.Reduce(PdfNull.Value' 2);  	}  	else  		this.stack.Reduce (iref' 2);  	break;  }  case Symbol.BeginArray:  	PdfArray array = new PdfArray (this.document);  	ReadArray (array' false);  	this.stack.Shift (array);  	break;  case Symbol.BeginDictionary:  	PdfDictionary dict = new PdfDictionary (this.document);  	ReadDictionary (dict' false);  	this.stack.Shift (dict);  	break;  case Symbol.BeginStream:  	throw new NotImplementedException ();  default:  	string error = this.lexer.Token;  	Debug.Assert (false' "Unexpected: " + error);  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: switch (symbol) {  case Symbol.Comment:  	// ignore comments  	break;  case Symbol.Null:  	this.stack.Shift (PdfNull.Value);  	break;  case Symbol.Boolean:  	this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  	break;  case Symbol.Integer:  	this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  	break;  case Symbol.UInteger:  	this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  	break;  case Symbol.Real:  	this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  	break;  case Symbol.String:  	//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  	break;  case Symbol.UnicodeString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  	break;  case Symbol.HexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  	break;  case Symbol.UnicodeHexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  	break;  case Symbol.Name:  	this.stack.Shift (new PdfName (this.lexer.Token));  	break;  case Symbol.R: {  	Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  	PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  	PdfReference iref = this.document.irefTable [objectID];  	if (iref == null) {  		// If a document has more than one PdfXRefTable it is possible that the first trailer has  		// indirect references to objects whos iref entry is not yet read in.  		if (this.document.irefTable.IsUnderConstruction) {  			// XRefTable not complete when trailer is read. Create temporary irefs that are  			// removed later in PdfTrailer.FixXRefs.  			iref = new PdfReference (objectID' 0);  			this.stack.Reduce (iref' 2);  			break;  		}  		// PDF Reference section 3.2.9:  		// An indirect reference to an undefined object is not an error;  		// it is simply treated as a reference to the null object.  		this.stack.Reduce (PdfNull.Value' 2);  		// Let's see what null objects are good for...  		//Debug.Assert(false' "Null object detected!");  		//this.stack.Reduce(PdfNull.Value' 2);  	}  	else  		this.stack.Reduce (iref' 2);  	break;  }  case Symbol.BeginArray:  	PdfArray array = new PdfArray (this.document);  	ReadArray (array' false);  	this.stack.Shift (array);  	break;  case Symbol.BeginDictionary:  	PdfDictionary dict = new PdfDictionary (this.document);  	ReadDictionary (dict' false);  	this.stack.Shift (dict);  	break;  case Symbol.BeginStream:  	throw new NotImplementedException ();  default:  	string error = this.lexer.Token;  	Debug.Assert (false' "Unexpected: " + error);  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: switch (symbol) {  case Symbol.Comment:  	// ignore comments  	break;  case Symbol.Null:  	this.stack.Shift (PdfNull.Value);  	break;  case Symbol.Boolean:  	this.stack.Shift (new PdfBoolean (this.lexer.TokenToBoolean));  	break;  case Symbol.Integer:  	this.stack.Shift (new PdfInteger (this.lexer.TokenToInteger));  	break;  case Symbol.UInteger:  	this.stack.Shift (new PdfUInteger (this.lexer.TokenToUInteger));  	break;  case Symbol.Real:  	this.stack.Shift (new PdfReal (this.lexer.TokenToReal));  	break;  case Symbol.String:  	//this.stack.Shift(new PdfString(this.lexer.Token' PdfStringFlags.PDFDocEncoding));  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.RawEncoding));  	break;  case Symbol.UnicodeString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode));  	break;  case Symbol.HexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.HexLiteral));  	break;  case Symbol.UnicodeHexString:  	this.stack.Shift (new PdfString (this.lexer.Token' PdfStringFlags.Unicode | PdfStringFlags.HexLiteral));  	break;  case Symbol.Name:  	this.stack.Shift (new PdfName (this.lexer.Token));  	break;  case Symbol.R: {  	Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  	PdfObjectID objectID = new PdfObjectID (this.stack.GetInteger (-2)' this.stack.GetInteger (-1));  	PdfReference iref = this.document.irefTable [objectID];  	if (iref == null) {  		// If a document has more than one PdfXRefTable it is possible that the first trailer has  		// indirect references to objects whos iref entry is not yet read in.  		if (this.document.irefTable.IsUnderConstruction) {  			// XRefTable not complete when trailer is read. Create temporary irefs that are  			// removed later in PdfTrailer.FixXRefs.  			iref = new PdfReference (objectID' 0);  			this.stack.Reduce (iref' 2);  			break;  		}  		// PDF Reference section 3.2.9:  		// An indirect reference to an undefined object is not an error;  		// it is simply treated as a reference to the null object.  		this.stack.Reduce (PdfNull.Value' 2);  		// Let's see what null objects are good for...  		//Debug.Assert(false' "Null object detected!");  		//this.stack.Reduce(PdfNull.Value' 2);  	}  	else  		this.stack.Reduce (iref' 2);  	break;  }  case Symbol.BeginArray:  	PdfArray array = new PdfArray (this.document);  	ReadArray (array' false);  	this.stack.Shift (array);  	break;  case Symbol.BeginDictionary:  	PdfDictionary dict = new PdfDictionary (this.document);  	ReadDictionary (dict' false);  	this.stack.Shift (dict);  	break;  case Symbol.BeginStream:  	throw new NotImplementedException ();  default:  	string error = this.lexer.Token;  	Debug.Assert (false' "Unexpected: " + error);  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: Debug.Assert (this.stack.GetItem (-1) is PdfInteger && this.stack.GetItem (-2) is PdfInteger);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: if (iref == null) {  	// If a document has more than one PdfXRefTable it is possible that the first trailer has  	// indirect references to objects whos iref entry is not yet read in.  	if (this.document.irefTable.IsUnderConstruction) {  		// XRefTable not complete when trailer is read. Create temporary irefs that are  		// removed later in PdfTrailer.FixXRefs.  		iref = new PdfReference (objectID' 0);  		this.stack.Reduce (iref' 2);  		break;  	}  	// PDF Reference section 3.2.9:  	// An indirect reference to an undefined object is not an error;  	// it is simply treated as a reference to the null object.  	this.stack.Reduce (PdfNull.Value' 2);  	// Let's see what null objects are good for...  	//Debug.Assert(false' "Null object detected!");  	//this.stack.Reduce(PdfNull.Value' 2);  }  else  	this.stack.Reduce (iref' 2);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: if (iref == null) {  	// If a document has more than one PdfXRefTable it is possible that the first trailer has  	// indirect references to objects whos iref entry is not yet read in.  	if (this.document.irefTable.IsUnderConstruction) {  		// XRefTable not complete when trailer is read. Create temporary irefs that are  		// removed later in PdfTrailer.FixXRefs.  		iref = new PdfReference (objectID' 0);  		this.stack.Reduce (iref' 2);  		break;  	}  	// PDF Reference section 3.2.9:  	// An indirect reference to an undefined object is not an error;  	// it is simply treated as a reference to the null object.  	this.stack.Reduce (PdfNull.Value' 2);  	// Let's see what null objects are good for...  	//Debug.Assert(false' "Null object detected!");  	//this.stack.Reduce(PdfNull.Value' 2);  }  else  	this.stack.Reduce (iref' 2);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: if (iref == null) {  	// If a document has more than one PdfXRefTable it is possible that the first trailer has  	// indirect references to objects whos iref entry is not yet read in.  	if (this.document.irefTable.IsUnderConstruction) {  		// XRefTable not complete when trailer is read. Create temporary irefs that are  		// removed later in PdfTrailer.FixXRefs.  		iref = new PdfReference (objectID' 0);  		this.stack.Reduce (iref' 2);  		break;  	}  	// PDF Reference section 3.2.9:  	// An indirect reference to an undefined object is not an error;  	// it is simply treated as a reference to the null object.  	this.stack.Reduce (PdfNull.Value' 2);  	// Let's see what null objects are good for...  	//Debug.Assert(false' "Null object detected!");  	//this.stack.Reduce(PdfNull.Value' 2);  }  else  	this.stack.Reduce (iref' 2);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: if (this.document.irefTable.IsUnderConstruction) {  	// XRefTable not complete when trailer is read. Create temporary irefs that are  	// removed later in PdfTrailer.FixXRefs.  	iref = new PdfReference (objectID' 0);  	this.stack.Reduce (iref' 2);  	break;  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: this.stack.Reduce (iref' 2);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: this.stack.Reduce (PdfNull.Value' 2);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseObject,The following statement contains a magic number: this.stack.Reduce (iref' 2);  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ReadTrailer,The following statement contains a magic number: this.lexer.Position = length - 131 + idx;  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: try {  	if (date.StartsWith ("D:")) {  		// Format is  		// D:YYYYMMDDHHmmSSOHH'mm'  		//   ^2      ^10   ^16 ^20  		int length = date.Length;  		int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  		char o = 'Z';  		if (length >= 10) {  			year = Int32.Parse (date.Substring (2' 4));  			month = Int32.Parse (date.Substring (6' 2));  			day = Int32.Parse (date.Substring (8' 2));  			if (length >= 16) {  				hour = Int32.Parse (date.Substring (10' 2));  				minute = Int32.Parse (date.Substring (12' 2));  				second = Int32.Parse (date.Substring (14' 2));  				if (length >= 23) {  					if ((o = date [16]) != 'Z') {  						hh = Int32.Parse (date.Substring (17' 2));  						mm = Int32.Parse (date.Substring (20' 2));  					}  				}  			}  		}  		datetime = new DateTime (year' month' day' hour' minute' second);  		if (o != 'Z') {  			TimeSpan ts = new TimeSpan (hh' mm' 0);  			if (o == '+')  				datetime.Add (ts);  			else  				datetime.Subtract (ts);  		}  	}  	else {  		// Some libraries use plain English format.  		datetime = DateTime.Parse (date);  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (date.StartsWith ("D:")) {  	// Format is  	// D:YYYYMMDDHHmmSSOHH'mm'  	//   ^2      ^10   ^16 ^20  	int length = date.Length;  	int year = 0' month = 0' day = 0' hour = 0' minute = 0' second = 0' hh = 0' mm = 0;  	char o = 'Z';  	if (length >= 10) {  		year = Int32.Parse (date.Substring (2' 4));  		month = Int32.Parse (date.Substring (6' 2));  		day = Int32.Parse (date.Substring (8' 2));  		if (length >= 16) {  			hour = Int32.Parse (date.Substring (10' 2));  			minute = Int32.Parse (date.Substring (12' 2));  			second = Int32.Parse (date.Substring (14' 2));  			if (length >= 23) {  				if ((o = date [16]) != 'Z') {  					hh = Int32.Parse (date.Substring (17' 2));  					mm = Int32.Parse (date.Substring (20' 2));  				}  			}  		}  	}  	datetime = new DateTime (year' month' day' hour' minute' second);  	if (o != 'Z') {  		TimeSpan ts = new TimeSpan (hh' mm' 0);  		if (o == '+')  			datetime.Add (ts);  		else  			datetime.Subtract (ts);  	}  }  else {  	// Some libraries use plain English format.  	datetime = DateTime.Parse (date);  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 10) {  	year = Int32.Parse (date.Substring (2' 4));  	month = Int32.Parse (date.Substring (6' 2));  	day = Int32.Parse (date.Substring (8' 2));  	if (length >= 16) {  		hour = Int32.Parse (date.Substring (10' 2));  		minute = Int32.Parse (date.Substring (12' 2));  		second = Int32.Parse (date.Substring (14' 2));  		if (length >= 23) {  			if ((o = date [16]) != 'Z') {  				hh = Int32.Parse (date.Substring (17' 2));  				mm = Int32.Parse (date.Substring (20' 2));  			}  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: year = Int32.Parse (date.Substring (2' 4));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: year = Int32.Parse (date.Substring (2' 4));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: month = Int32.Parse (date.Substring (6' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: month = Int32.Parse (date.Substring (6' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: day = Int32.Parse (date.Substring (8' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: day = Int32.Parse (date.Substring (8' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 16) {  	hour = Int32.Parse (date.Substring (10' 2));  	minute = Int32.Parse (date.Substring (12' 2));  	second = Int32.Parse (date.Substring (14' 2));  	if (length >= 23) {  		if ((o = date [16]) != 'Z') {  			hh = Int32.Parse (date.Substring (17' 2));  			mm = Int32.Parse (date.Substring (20' 2));  		}  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: hour = Int32.Parse (date.Substring (10' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: hour = Int32.Parse (date.Substring (10' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: minute = Int32.Parse (date.Substring (12' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: minute = Int32.Parse (date.Substring (12' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: second = Int32.Parse (date.Substring (14' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: second = Int32.Parse (date.Substring (14' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 23) {  	if ((o = date [16]) != 'Z') {  		hh = Int32.Parse (date.Substring (17' 2));  		mm = Int32.Parse (date.Substring (20' 2));  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 23) {  	if ((o = date [16]) != 'Z') {  		hh = Int32.Parse (date.Substring (17' 2));  		mm = Int32.Parse (date.Substring (20' 2));  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 23) {  	if ((o = date [16]) != 'Z') {  		hh = Int32.Parse (date.Substring (17' 2));  		mm = Int32.Parse (date.Substring (20' 2));  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 23) {  	if ((o = date [16]) != 'Z') {  		hh = Int32.Parse (date.Substring (17' 2));  		mm = Int32.Parse (date.Substring (20' 2));  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 23) {  	if ((o = date [16]) != 'Z') {  		hh = Int32.Parse (date.Substring (17' 2));  		mm = Int32.Parse (date.Substring (20' 2));  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if (length >= 23) {  	if ((o = date [16]) != 'Z') {  		hh = Int32.Parse (date.Substring (17' 2));  		mm = Int32.Parse (date.Substring (20' 2));  	}  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if ((o = date [16]) != 'Z') {  	hh = Int32.Parse (date.Substring (17' 2));  	mm = Int32.Parse (date.Substring (20' 2));  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if ((o = date [16]) != 'Z') {  	hh = Int32.Parse (date.Substring (17' 2));  	mm = Int32.Parse (date.Substring (20' 2));  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if ((o = date [16]) != 'Z') {  	hh = Int32.Parse (date.Substring (17' 2));  	mm = Int32.Parse (date.Substring (20' 2));  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if ((o = date [16]) != 'Z') {  	hh = Int32.Parse (date.Substring (17' 2));  	mm = Int32.Parse (date.Substring (20' 2));  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: if ((o = date [16]) != 'Z') {  	hh = Int32.Parse (date.Substring (17' 2));  	mm = Int32.Parse (date.Substring (20' 2));  }  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: hh = Int32.Parse (date.Substring (17' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: hh = Int32.Parse (date.Substring (17' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: mm = Int32.Parse (date.Substring (20' 2));  
Magic Number,PdfSharp.Pdf.IO,Parser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Parser.cs,ParseDateTime,The following statement contains a magic number: mm = Int32.Parse (date.Substring (20' 2));  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: try {  	int pageNumber;  	string realPath = PdfSharp.Drawing.XPdfForm.ExtractPageNumber (path' out pageNumber);  	if (File.Exists (realPath))// prevent unwanted exceptions during debugging  	 {  		stream = new FileStream (realPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  		byte[] bytes = new byte[1024];  		stream.Read (bytes' 0' 1024);  		return GetPdfFileVersion (bytes);  	}  }  catch {  }  finally {  	try {  		if (stream != null)  			stream.Close ();  	}  	catch {  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: try {  	int pageNumber;  	string realPath = PdfSharp.Drawing.XPdfForm.ExtractPageNumber (path' out pageNumber);  	if (File.Exists (realPath))// prevent unwanted exceptions during debugging  	 {  		stream = new FileStream (realPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  		byte[] bytes = new byte[1024];  		stream.Read (bytes' 0' 1024);  		return GetPdfFileVersion (bytes);  	}  }  catch {  }  finally {  	try {  		if (stream != null)  			stream.Close ();  	}  	catch {  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: if (File.Exists (realPath))// prevent unwanted exceptions during debugging   {  	stream = new FileStream (realPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	byte[] bytes = new byte[1024];  	stream.Read (bytes' 0' 1024);  	return GetPdfFileVersion (bytes);  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: if (File.Exists (realPath))// prevent unwanted exceptions during debugging   {  	stream = new FileStream (realPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  	byte[] bytes = new byte[1024];  	stream.Read (bytes' 0' 1024);  	return GetPdfFileVersion (bytes);  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: stream.Read (bytes' 0' 1024);  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: try {  	pos = stream.Position;  	byte[] bytes = new byte[1024];  	stream.Read (bytes' 0' 1024);  	return GetPdfFileVersion (bytes);  }  catch {  }  finally {  	try {  		if (pos != -1)  			stream.Position = pos;  	}  	catch {  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: try {  	pos = stream.Position;  	byte[] bytes = new byte[1024];  	stream.Read (bytes' 0' 1024);  	return GetPdfFileVersion (bytes);  }  catch {  }  finally {  	try {  		if (pos != -1)  			stream.Position = pos;  	}  	catch {  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,TestPdfFile,The following statement contains a magic number: stream.Read (bytes' 0' 1024);  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: try {  	// Acrobat accepts headers like �%!PS-Adobe-N.n PDF-M.m�...  	string header = Encoding.ASCII.GetString (bytes);  	if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  		int ich = header.IndexOf ("PDF-");  		if (ich > 0 && header [ich + 5] == (byte)'.') {  			char major = header [ich + 4];  			char minor = header [ich + 6];  			if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  				return (major - '0') * 10 + (minor - '0');  		}  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: try {  	// Acrobat accepts headers like �%!PS-Adobe-N.n PDF-M.m�...  	string header = Encoding.ASCII.GetString (bytes);  	if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  		int ich = header.IndexOf ("PDF-");  		if (ich > 0 && header [ich + 5] == (byte)'.') {  			char major = header [ich + 4];  			char minor = header [ich + 6];  			if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  				return (major - '0') * 10 + (minor - '0');  		}  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: try {  	// Acrobat accepts headers like �%!PS-Adobe-N.n PDF-M.m�...  	string header = Encoding.ASCII.GetString (bytes);  	if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  		int ich = header.IndexOf ("PDF-");  		if (ich > 0 && header [ich + 5] == (byte)'.') {  			char major = header [ich + 4];  			char minor = header [ich + 6];  			if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  				return (major - '0') * 10 + (minor - '0');  		}  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: try {  	// Acrobat accepts headers like �%!PS-Adobe-N.n PDF-M.m�...  	string header = Encoding.ASCII.GetString (bytes);  	if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  		int ich = header.IndexOf ("PDF-");  		if (ich > 0 && header [ich + 5] == (byte)'.') {  			char major = header [ich + 4];  			char minor = header [ich + 6];  			if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  				return (major - '0') * 10 + (minor - '0');  		}  	}  }  catch {  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  	int ich = header.IndexOf ("PDF-");  	if (ich > 0 && header [ich + 5] == (byte)'.') {  		char major = header [ich + 4];  		char minor = header [ich + 6];  		if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  			return (major - '0') * 10 + (minor - '0');  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  	int ich = header.IndexOf ("PDF-");  	if (ich > 0 && header [ich + 5] == (byte)'.') {  		char major = header [ich + 4];  		char minor = header [ich + 6];  		if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  			return (major - '0') * 10 + (minor - '0');  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  	int ich = header.IndexOf ("PDF-");  	if (ich > 0 && header [ich + 5] == (byte)'.') {  		char major = header [ich + 4];  		char minor = header [ich + 6];  		if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  			return (major - '0') * 10 + (minor - '0');  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (header [0] == '%' || header.IndexOf ("%PDF") >= 0) {  	int ich = header.IndexOf ("PDF-");  	if (ich > 0 && header [ich + 5] == (byte)'.') {  		char major = header [ich + 4];  		char minor = header [ich + 6];  		if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  			return (major - '0') * 10 + (minor - '0');  	}  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (ich > 0 && header [ich + 5] == (byte)'.') {  	char major = header [ich + 4];  	char minor = header [ich + 6];  	if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  		return (major - '0') * 10 + (minor - '0');  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (ich > 0 && header [ich + 5] == (byte)'.') {  	char major = header [ich + 4];  	char minor = header [ich + 6];  	if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  		return (major - '0') * 10 + (minor - '0');  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (ich > 0 && header [ich + 5] == (byte)'.') {  	char major = header [ich + 4];  	char minor = header [ich + 6];  	if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  		return (major - '0') * 10 + (minor - '0');  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (ich > 0 && header [ich + 5] == (byte)'.') {  	char major = header [ich + 4];  	char minor = header [ich + 6];  	if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  		return (major - '0') * 10 + (minor - '0');  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: if (major >= '1' && major < '2' && minor >= '0' && minor <= '9')  	return (major - '0') * 10 + (minor - '0');  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,GetPdfFileVersion,The following statement contains a magic number: return (major - '0') * 10 + (minor - '0');  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,Open,The following statement contains a magic number: try {  	Lexer lexer = new Lexer (stream);  	document = new PdfDocument (lexer);  	document.state |= DocumentState.Imported;  	document.openMode = openmode;  	document.fileSize = stream.Length;  	// Get file version  	byte[] header = new byte[1024];  	stream.Position = 0;  	stream.Read (header' 0' 1024);  	document.version = GetPdfFileVersion (header);  	if (document.version == 0)  		throw new InvalidOperationException (PSSR.InvalidPdf);  	// Read all trailers  	document.irefTable.IsUnderConstruction = true;  	Parser parser = new Parser (document);  	document.trailer = parser.ReadTrailer ();  	document.irefTable.IsUnderConstruction = false;  	// Is document encrypted?  	PdfReference xrefEncrypt = document.trailer.Elements [PdfTrailer.Keys.Encrypt] as PdfReference;  	if (xrefEncrypt != null) {  		//xrefEncrypt.Value = parser.ReadObject(null' xrefEncrypt.ObjectID' false);  		PdfObject encrypt = parser.ReadObject (null' xrefEncrypt.ObjectID' false);  		encrypt.Reference = xrefEncrypt;  		xrefEncrypt.Value = encrypt;  		PdfStandardSecurityHandler securityHandler = document.SecurityHandler;  		TryAgain:  		PasswordValidity validity = securityHandler.ValidatePassword (password);  		if (validity == PasswordValidity.Invalid) {  			if (passwordProvider != null) {  				PdfPasswordProviderArgs args = new PdfPasswordProviderArgs ();  				passwordProvider (args);  				if (args.Abort)  					return null;  				password = args.Password;  				goto TryAgain;  			}  			else {  				if (password == null)  					throw new PdfReaderException (PSSR.PasswordRequired);  				else  					throw new PdfReaderException (PSSR.InvalidPassword);  			}  		}  		else if (validity == PasswordValidity.UserPassword && openmode == PdfDocumentOpenMode.Modify) {  			if (passwordProvider != null) {  				PdfPasswordProviderArgs args = new PdfPasswordProviderArgs ();  				passwordProvider (args);  				if (args.Abort)  					return null;  				password = args.Password;  				goto TryAgain;  			}  			else  				throw new PdfReaderException (PSSR.OwnerPasswordRequired);  		}  	}  	else {  		if (password != null) {  			// Password specified but document is not encrypted.  			// ignore  		}  	}  	PdfReference[] irefs = document.irefTable.AllReferences;  	int count = irefs.Length;  	// Read all indirect objects  	for (int idx = 0; idx < count; idx++) {  		PdfReference iref = irefs [idx];  		if (iref.Value == null) {  			try {  				Debug.Assert (document.irefTable.Contains (iref.ObjectID));  				PdfObject pdfObject = parser.ReadObject (null' iref.ObjectID' false);  				Debug.Assert (pdfObject.Reference == iref);  				pdfObject.Reference = iref;  				Debug.Assert (pdfObject.Reference.Value != null' "something got wrong");  			}  			catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		}  		else {  			Debug.Assert (document.irefTable.Contains (iref.ObjectID));  			iref.GetType ();  		}  		// Set maximum object number  		document.irefTable.maxObjectNumber = Math.Max (document.irefTable.maxObjectNumber' iref.ObjectNumber);  	}  	// Encrypt all objects  	if (xrefEncrypt != null) {  		document.SecurityHandler.EncryptDocument ();  	}  	// Fix references of trailer values and then objects and irefs are consistent.  	document.trailer.Finish ();  	#if DEBUG_  	        // Some tests...         PdfReference[] reachables = document.xrefTable.TransitiveClosure(document.trailer);         reachables.GetType();         reachables = document.xrefTable.AllXRefs;         document.xrefTable.CheckConsistence(); #endif  	if (openmode == PdfDocumentOpenMode.Modify) {  		// Create new or change existing document IDs  		if (document.Internals.SecondDocumentID == "")  			document.trailer.CreateNewDocumentIDs ();  		else {  			byte[] agTemp = Guid.NewGuid ().ToByteArray ();  			document.Internals.SecondDocumentID = PdfEncoders.RawEncoding.GetString (agTemp' 0' agTemp.Length);  		}  		// Change modification date  		document.Info.ModificationDate = DateTime.Now;  		// Remove all unreachable objects  		int removed = document.irefTable.Compact ();  		if (removed != 0)  			Debug.WriteLine ("Number of deleted unreachable objects: " + removed.ToString ());  		// Force flattening of page tree  		PdfPages pages = document.Pages;  		//bool b = document.irefTable.Contains(new PdfObjectID(1108));  		//b.GetType();  		document.irefTable.CheckConsistence ();  		document.irefTable.Renumber ();  		document.irefTable.CheckConsistence ();  	}  }  finally {  	//if (filestream != null)  	//  filestream.Close();  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,Open,The following statement contains a magic number: try {  	Lexer lexer = new Lexer (stream);  	document = new PdfDocument (lexer);  	document.state |= DocumentState.Imported;  	document.openMode = openmode;  	document.fileSize = stream.Length;  	// Get file version  	byte[] header = new byte[1024];  	stream.Position = 0;  	stream.Read (header' 0' 1024);  	document.version = GetPdfFileVersion (header);  	if (document.version == 0)  		throw new InvalidOperationException (PSSR.InvalidPdf);  	// Read all trailers  	document.irefTable.IsUnderConstruction = true;  	Parser parser = new Parser (document);  	document.trailer = parser.ReadTrailer ();  	document.irefTable.IsUnderConstruction = false;  	// Is document encrypted?  	PdfReference xrefEncrypt = document.trailer.Elements [PdfTrailer.Keys.Encrypt] as PdfReference;  	if (xrefEncrypt != null) {  		//xrefEncrypt.Value = parser.ReadObject(null' xrefEncrypt.ObjectID' false);  		PdfObject encrypt = parser.ReadObject (null' xrefEncrypt.ObjectID' false);  		encrypt.Reference = xrefEncrypt;  		xrefEncrypt.Value = encrypt;  		PdfStandardSecurityHandler securityHandler = document.SecurityHandler;  		TryAgain:  		PasswordValidity validity = securityHandler.ValidatePassword (password);  		if (validity == PasswordValidity.Invalid) {  			if (passwordProvider != null) {  				PdfPasswordProviderArgs args = new PdfPasswordProviderArgs ();  				passwordProvider (args);  				if (args.Abort)  					return null;  				password = args.Password;  				goto TryAgain;  			}  			else {  				if (password == null)  					throw new PdfReaderException (PSSR.PasswordRequired);  				else  					throw new PdfReaderException (PSSR.InvalidPassword);  			}  		}  		else if (validity == PasswordValidity.UserPassword && openmode == PdfDocumentOpenMode.Modify) {  			if (passwordProvider != null) {  				PdfPasswordProviderArgs args = new PdfPasswordProviderArgs ();  				passwordProvider (args);  				if (args.Abort)  					return null;  				password = args.Password;  				goto TryAgain;  			}  			else  				throw new PdfReaderException (PSSR.OwnerPasswordRequired);  		}  	}  	else {  		if (password != null) {  			// Password specified but document is not encrypted.  			// ignore  		}  	}  	PdfReference[] irefs = document.irefTable.AllReferences;  	int count = irefs.Length;  	// Read all indirect objects  	for (int idx = 0; idx < count; idx++) {  		PdfReference iref = irefs [idx];  		if (iref.Value == null) {  			try {  				Debug.Assert (document.irefTable.Contains (iref.ObjectID));  				PdfObject pdfObject = parser.ReadObject (null' iref.ObjectID' false);  				Debug.Assert (pdfObject.Reference == iref);  				pdfObject.Reference = iref;  				Debug.Assert (pdfObject.Reference.Value != null' "something got wrong");  			}  			catch (Exception ex) {  				Debug.WriteLine (ex.Message);  			}  		}  		else {  			Debug.Assert (document.irefTable.Contains (iref.ObjectID));  			iref.GetType ();  		}  		// Set maximum object number  		document.irefTable.maxObjectNumber = Math.Max (document.irefTable.maxObjectNumber' iref.ObjectNumber);  	}  	// Encrypt all objects  	if (xrefEncrypt != null) {  		document.SecurityHandler.EncryptDocument ();  	}  	// Fix references of trailer values and then objects and irefs are consistent.  	document.trailer.Finish ();  	#if DEBUG_  	        // Some tests...         PdfReference[] reachables = document.xrefTable.TransitiveClosure(document.trailer);         reachables.GetType();         reachables = document.xrefTable.AllXRefs;         document.xrefTable.CheckConsistence(); #endif  	if (openmode == PdfDocumentOpenMode.Modify) {  		// Create new or change existing document IDs  		if (document.Internals.SecondDocumentID == "")  			document.trailer.CreateNewDocumentIDs ();  		else {  			byte[] agTemp = Guid.NewGuid ().ToByteArray ();  			document.Internals.SecondDocumentID = PdfEncoders.RawEncoding.GetString (agTemp' 0' agTemp.Length);  		}  		// Change modification date  		document.Info.ModificationDate = DateTime.Now;  		// Remove all unreachable objects  		int removed = document.irefTable.Compact ();  		if (removed != 0)  			Debug.WriteLine ("Number of deleted unreachable objects: " + removed.ToString ());  		// Force flattening of page tree  		PdfPages pages = document.Pages;  		//bool b = document.irefTable.Contains(new PdfObjectID(1108));  		//b.GetType();  		document.irefTable.CheckConsistence ();  		document.irefTable.Renumber ();  		document.irefTable.CheckConsistence ();  	}  }  finally {  	//if (filestream != null)  	//  filestream.Close();  }  
Magic Number,PdfSharp.Pdf.IO,PdfReader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfReader.cs,Open,The following statement contains a magic number: stream.Read (header' 0' 1024);  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,Write,The following statement contains a magic number: for (int idx = 1; idx < name.Length; idx++) {  	char ch = name [idx];  	Debug.Assert (ch < 256);  	if (ch > ' ')  		switch (ch) {  		// TODO: is this all?  		case '%':  		case '/':  		case '<':  		case '>':  		case '(':  		case ')':  		case '#':  			break;  		default:  			pdf.Append (name [idx]);  			continue;  		}  	pdf.AppendFormat ("#{0:X2}"' (int)name [idx]);  }  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,Write,The following statement contains a magic number: Debug.Assert (ch < 256);  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteRaw,The following statement contains a magic number: Debug.Assert ((int)ch < 256' "Raw character greater than 255 dedected.");  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteFileHeader,The following statement contains a magic number: header.Append ((version / 10).ToString () + "." + (version % 10).ToString () + "\n%\xD3\xF4\xCC\xE1\n");  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteFileHeader,The following statement contains a magic number: header.Append ((version / 10).ToString () + "." + (version % 10).ToString () + "\n%\xD3\xF4\xCC\xE1\n");  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteFileHeader,The following statement contains a magic number: if (this.layout == PdfWriterLayout.Verbose) {  	this.WriteRaw (String.Format ("% PDFsharp Version {0} (verbose mode)\n"' VersionInfo.Version));  	// Keep some space for later fix-up.  	this.commentPosition = (int)this.stream.Position + 2;  	this.WriteRaw ("%                                                \n");  	this.WriteRaw ("%                                                \n");  	this.WriteRaw ("%                                                \n");  	this.WriteRaw ("%                                                \n");  	this.WriteRaw ("%                                                \n");  	this.WriteRaw ("%--------------------------------------------------------------------------------------------------\n");  }  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteFileHeader,The following statement contains a magic number: this.commentPosition = (int)this.stream.Position + 2;  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: if (this.layout == PdfWriterLayout.Verbose) {  	TimeSpan duration = DateTime.Now - document.creation;  	this.stream.Position = this.commentPosition;  	WriteRaw ("Creation date: " + document.creation.ToString ("G"));  	this.stream.Position = this.commentPosition + 50;  	WriteRaw ("Creation time: " + duration.TotalSeconds.ToString ("0.000"' CultureInfo.InvariantCulture) + " seconds");  	this.stream.Position = this.commentPosition + 100;  	WriteRaw ("File size: " + fileSize.ToString () + " bytes");  	this.stream.Position = this.commentPosition + 150;  	WriteRaw ("Pages: " + document.Pages.Count.ToString ());  	this.stream.Position = this.commentPosition + 200;  	WriteRaw ("Objects: " + document.irefTable.objectTable.Count.ToString ());  }  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: if (this.layout == PdfWriterLayout.Verbose) {  	TimeSpan duration = DateTime.Now - document.creation;  	this.stream.Position = this.commentPosition;  	WriteRaw ("Creation date: " + document.creation.ToString ("G"));  	this.stream.Position = this.commentPosition + 50;  	WriteRaw ("Creation time: " + duration.TotalSeconds.ToString ("0.000"' CultureInfo.InvariantCulture) + " seconds");  	this.stream.Position = this.commentPosition + 100;  	WriteRaw ("File size: " + fileSize.ToString () + " bytes");  	this.stream.Position = this.commentPosition + 150;  	WriteRaw ("Pages: " + document.Pages.Count.ToString ());  	this.stream.Position = this.commentPosition + 200;  	WriteRaw ("Objects: " + document.irefTable.objectTable.Count.ToString ());  }  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: if (this.layout == PdfWriterLayout.Verbose) {  	TimeSpan duration = DateTime.Now - document.creation;  	this.stream.Position = this.commentPosition;  	WriteRaw ("Creation date: " + document.creation.ToString ("G"));  	this.stream.Position = this.commentPosition + 50;  	WriteRaw ("Creation time: " + duration.TotalSeconds.ToString ("0.000"' CultureInfo.InvariantCulture) + " seconds");  	this.stream.Position = this.commentPosition + 100;  	WriteRaw ("File size: " + fileSize.ToString () + " bytes");  	this.stream.Position = this.commentPosition + 150;  	WriteRaw ("Pages: " + document.Pages.Count.ToString ());  	this.stream.Position = this.commentPosition + 200;  	WriteRaw ("Objects: " + document.irefTable.objectTable.Count.ToString ());  }  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: if (this.layout == PdfWriterLayout.Verbose) {  	TimeSpan duration = DateTime.Now - document.creation;  	this.stream.Position = this.commentPosition;  	WriteRaw ("Creation date: " + document.creation.ToString ("G"));  	this.stream.Position = this.commentPosition + 50;  	WriteRaw ("Creation time: " + duration.TotalSeconds.ToString ("0.000"' CultureInfo.InvariantCulture) + " seconds");  	this.stream.Position = this.commentPosition + 100;  	WriteRaw ("File size: " + fileSize.ToString () + " bytes");  	this.stream.Position = this.commentPosition + 150;  	WriteRaw ("Pages: " + document.Pages.Count.ToString ());  	this.stream.Position = this.commentPosition + 200;  	WriteRaw ("Objects: " + document.irefTable.objectTable.Count.ToString ());  }  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: this.stream.Position = this.commentPosition + 50;  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: this.stream.Position = this.commentPosition + 100;  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: this.stream.Position = this.commentPosition + 150;  
Magic Number,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteEof,The following statement contains a magic number: this.stream.Position = this.commentPosition + 200;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptObject,The following statement contains a magic number: if (value.ObjectID.ObjectNumber == 10)  	GetType ();  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ValidatePassword,The following statement contains a magic number: if (filter != "/Standard" || !(v >= 1 && v <= 3))  	throw new PdfReaderException (PSSR.UnknownEncryption);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: if (password == null)  	Array.Copy (passwordPadding' 0' padded' 0' 32);  else {  	int length = password.Length;  	Array.Copy (PdfEncoders.RawEncoding.GetBytes (password)' 0' padded' 0' Math.Min (length' 32));  	if (length < 32)  		Array.Copy (passwordPadding' 0' padded' length' 32 - length);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: if (password == null)  	Array.Copy (passwordPadding' 0' padded' 0' 32);  else {  	int length = password.Length;  	Array.Copy (PdfEncoders.RawEncoding.GetBytes (password)' 0' padded' 0' Math.Min (length' 32));  	if (length < 32)  		Array.Copy (passwordPadding' 0' padded' length' 32 - length);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: if (password == null)  	Array.Copy (passwordPadding' 0' padded' 0' 32);  else {  	int length = password.Length;  	Array.Copy (PdfEncoders.RawEncoding.GetBytes (password)' 0' padded' 0' Math.Min (length' 32));  	if (length < 32)  		Array.Copy (passwordPadding' 0' padded' length' 32 - length);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: if (password == null)  	Array.Copy (passwordPadding' 0' padded' 0' 32);  else {  	int length = password.Length;  	Array.Copy (PdfEncoders.RawEncoding.GetBytes (password)' 0' padded' 0' Math.Min (length' 32));  	if (length < 32)  		Array.Copy (passwordPadding' 0' padded' length' 32 - length);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: Array.Copy (passwordPadding' 0' padded' 0' 32);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: Array.Copy (PdfEncoders.RawEncoding.GetBytes (password)' 0' padded' 0' Math.Min (length' 32));  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: if (length < 32)  	Array.Copy (passwordPadding' 0' padded' length' 32 - length);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: if (length < 32)  	Array.Copy (passwordPadding' 0' padded' length' 32 - length);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PadPassword,The following statement contains a magic number: Array.Copy (passwordPadding' 0' padded' length' 32 - length);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: if (strongEncryption) {  	byte[] mkey = new byte[16];  	// Hash the pad 50 times  	for (int idx = 0; idx < 50; idx++)  		digest = this.md5.ComputeHash (digest);  	Array.Copy (userPad' 0' ownerKey' 0' 32);  	// Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < mkey.Length; ++j)  			mkey [j] = (byte)(digest [j] ^ i);  		PrepareRC4Key (mkey);  		EncryptRC4 (ownerKey);  	}  }  else {  	PrepareRC4Key (digest' 0' 5);  	EncryptRC4 (userPad' ownerKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: if (strongEncryption) {  	byte[] mkey = new byte[16];  	// Hash the pad 50 times  	for (int idx = 0; idx < 50; idx++)  		digest = this.md5.ComputeHash (digest);  	Array.Copy (userPad' 0' ownerKey' 0' 32);  	// Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < mkey.Length; ++j)  			mkey [j] = (byte)(digest [j] ^ i);  		PrepareRC4Key (mkey);  		EncryptRC4 (ownerKey);  	}  }  else {  	PrepareRC4Key (digest' 0' 5);  	EncryptRC4 (userPad' ownerKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: if (strongEncryption) {  	byte[] mkey = new byte[16];  	// Hash the pad 50 times  	for (int idx = 0; idx < 50; idx++)  		digest = this.md5.ComputeHash (digest);  	Array.Copy (userPad' 0' ownerKey' 0' 32);  	// Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < mkey.Length; ++j)  			mkey [j] = (byte)(digest [j] ^ i);  		PrepareRC4Key (mkey);  		EncryptRC4 (ownerKey);  	}  }  else {  	PrepareRC4Key (digest' 0' 5);  	EncryptRC4 (userPad' ownerKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: if (strongEncryption) {  	byte[] mkey = new byte[16];  	// Hash the pad 50 times  	for (int idx = 0; idx < 50; idx++)  		digest = this.md5.ComputeHash (digest);  	Array.Copy (userPad' 0' ownerKey' 0' 32);  	// Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < mkey.Length; ++j)  			mkey [j] = (byte)(digest [j] ^ i);  		PrepareRC4Key (mkey);  		EncryptRC4 (ownerKey);  	}  }  else {  	PrepareRC4Key (digest' 0' 5);  	EncryptRC4 (userPad' ownerKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: if (strongEncryption) {  	byte[] mkey = new byte[16];  	// Hash the pad 50 times  	for (int idx = 0; idx < 50; idx++)  		digest = this.md5.ComputeHash (digest);  	Array.Copy (userPad' 0' ownerKey' 0' 32);  	// Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < mkey.Length; ++j)  			mkey [j] = (byte)(digest [j] ^ i);  		PrepareRC4Key (mkey);  		EncryptRC4 (ownerKey);  	}  }  else {  	PrepareRC4Key (digest' 0' 5);  	EncryptRC4 (userPad' ownerKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: for (int idx = 0; idx < 50; idx++)  	digest = this.md5.ComputeHash (digest);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: Array.Copy (userPad' 0' ownerKey' 0' 32);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: for (int i = 0; i < 20; i++) {  	for (int j = 0; j < mkey.Length; ++j)  		mkey [j] = (byte)(digest [j] ^ i);  	PrepareRC4Key (mkey);  	EncryptRC4 (ownerKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,ComputeOwnerKey,The following statement contains a magic number: PrepareRC4Key (digest' 0' 5);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: this.encryptionKey = new byte[strongEncryption ? 16 : 5];  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: this.encryptionKey = new byte[strongEncryption ? 16 : 5];  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: permission [1] = (byte)(permissions >> 8);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: permission [2] = (byte)(permissions >> 16);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: permission [2] = (byte)(permissions >> 16);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: permission [3] = (byte)(permissions >> 24);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: permission [3] = (byte)(permissions >> 24);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: this.md5.TransformBlock (permission' 0' 4' permission' 0);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	for (int idx = 0; idx < 50; idx++) {  		digest = this.md5.ComputeHash (digest);  		this.md5.Initialize ();  	}  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	for (int idx = 0; idx < 50; idx++) {  		digest = this.md5.ComputeHash (digest);  		this.md5.Initialize ();  	}  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,InitEncryptionKey,The following statement contains a magic number: for (int idx = 0; idx < 50; idx++) {  	digest = this.md5.ComputeHash (digest);  	this.md5.Initialize ();  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	this.md5.TransformBlock (passwordPadding' 0' passwordPadding.Length' passwordPadding' 0);  	this.md5.TransformFinalBlock (documentID' 0' documentID.Length);  	byte[] digest = this.md5.Hash;  	this.md5.Initialize ();  	Array.Copy (digest' 0' this.userKey' 0' 16);  	for (int idx = 16; idx < 32; idx++)  		this.userKey [idx] = 0;  	//Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < this.encryptionKey.Length; j++)  			digest [j] = (byte)(this.encryptionKey [j] ^ i);  		PrepareRC4Key (digest' 0' this.encryptionKey.Length);  		EncryptRC4 (this.userKey' 0' 16);  	}  }  else {  	PrepareRC4Key (this.encryptionKey);  	EncryptRC4 (passwordPadding' this.userKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	this.md5.TransformBlock (passwordPadding' 0' passwordPadding.Length' passwordPadding' 0);  	this.md5.TransformFinalBlock (documentID' 0' documentID.Length);  	byte[] digest = this.md5.Hash;  	this.md5.Initialize ();  	Array.Copy (digest' 0' this.userKey' 0' 16);  	for (int idx = 16; idx < 32; idx++)  		this.userKey [idx] = 0;  	//Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < this.encryptionKey.Length; j++)  			digest [j] = (byte)(this.encryptionKey [j] ^ i);  		PrepareRC4Key (digest' 0' this.encryptionKey.Length);  		EncryptRC4 (this.userKey' 0' 16);  	}  }  else {  	PrepareRC4Key (this.encryptionKey);  	EncryptRC4 (passwordPadding' this.userKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	this.md5.TransformBlock (passwordPadding' 0' passwordPadding.Length' passwordPadding' 0);  	this.md5.TransformFinalBlock (documentID' 0' documentID.Length);  	byte[] digest = this.md5.Hash;  	this.md5.Initialize ();  	Array.Copy (digest' 0' this.userKey' 0' 16);  	for (int idx = 16; idx < 32; idx++)  		this.userKey [idx] = 0;  	//Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < this.encryptionKey.Length; j++)  			digest [j] = (byte)(this.encryptionKey [j] ^ i);  		PrepareRC4Key (digest' 0' this.encryptionKey.Length);  		EncryptRC4 (this.userKey' 0' 16);  	}  }  else {  	PrepareRC4Key (this.encryptionKey);  	EncryptRC4 (passwordPadding' this.userKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	this.md5.TransformBlock (passwordPadding' 0' passwordPadding.Length' passwordPadding' 0);  	this.md5.TransformFinalBlock (documentID' 0' documentID.Length);  	byte[] digest = this.md5.Hash;  	this.md5.Initialize ();  	Array.Copy (digest' 0' this.userKey' 0' 16);  	for (int idx = 16; idx < 32; idx++)  		this.userKey [idx] = 0;  	//Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < this.encryptionKey.Length; j++)  			digest [j] = (byte)(this.encryptionKey [j] ^ i);  		PrepareRC4Key (digest' 0' this.encryptionKey.Length);  		EncryptRC4 (this.userKey' 0' 16);  	}  }  else {  	PrepareRC4Key (this.encryptionKey);  	EncryptRC4 (passwordPadding' this.userKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	this.md5.TransformBlock (passwordPadding' 0' passwordPadding.Length' passwordPadding' 0);  	this.md5.TransformFinalBlock (documentID' 0' documentID.Length);  	byte[] digest = this.md5.Hash;  	this.md5.Initialize ();  	Array.Copy (digest' 0' this.userKey' 0' 16);  	for (int idx = 16; idx < 32; idx++)  		this.userKey [idx] = 0;  	//Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < this.encryptionKey.Length; j++)  			digest [j] = (byte)(this.encryptionKey [j] ^ i);  		PrepareRC4Key (digest' 0' this.encryptionKey.Length);  		EncryptRC4 (this.userKey' 0' 16);  	}  }  else {  	PrepareRC4Key (this.encryptionKey);  	EncryptRC4 (passwordPadding' this.userKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: if (this.encryptionKey.Length == 16) {  	this.md5.TransformBlock (passwordPadding' 0' passwordPadding.Length' passwordPadding' 0);  	this.md5.TransformFinalBlock (documentID' 0' documentID.Length);  	byte[] digest = this.md5.Hash;  	this.md5.Initialize ();  	Array.Copy (digest' 0' this.userKey' 0' 16);  	for (int idx = 16; idx < 32; idx++)  		this.userKey [idx] = 0;  	//Encrypt the key  	for (int i = 0; i < 20; i++) {  		for (int j = 0; j < this.encryptionKey.Length; j++)  			digest [j] = (byte)(this.encryptionKey [j] ^ i);  		PrepareRC4Key (digest' 0' this.encryptionKey.Length);  		EncryptRC4 (this.userKey' 0' 16);  	}  }  else {  	PrepareRC4Key (this.encryptionKey);  	EncryptRC4 (passwordPadding' this.userKey);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: Array.Copy (digest' 0' this.userKey' 0' 16);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: for (int idx = 16; idx < 32; idx++)  	this.userKey [idx] = 0;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: for (int idx = 16; idx < 32; idx++)  	this.userKey [idx] = 0;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: for (int i = 0; i < 20; i++) {  	for (int j = 0; j < this.encryptionKey.Length; j++)  		digest [j] = (byte)(this.encryptionKey [j] ^ i);  	PrepareRC4Key (digest' 0' this.encryptionKey.Length);  	EncryptRC4 (this.userKey' 0' 16);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: for (int i = 0; i < 20; i++) {  	for (int j = 0; j < this.encryptionKey.Length; j++)  		digest [j] = (byte)(this.encryptionKey [j] ^ i);  	PrepareRC4Key (digest' 0' this.encryptionKey.Length);  	EncryptRC4 (this.userKey' 0' 16);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetupUserKey,The following statement contains a magic number: EncryptRC4 (this.userKey' 0' 16);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareRC4Key,The following statement contains a magic number: for (int idx = 0; idx < 256; idx++)  	this.state [idx] = (byte)idx;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareRC4Key,The following statement contains a magic number: for (int idx = 0; idx < 256; idx++) {  	idx2 = (key [idx1 + offset] + this.state [idx] + idx2) & 255;  	tmp = this.state [idx];  	this.state [idx] = this.state [idx2];  	this.state [idx2] = tmp;  	idx1 = (idx1 + 1) % length;  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareRC4Key,The following statement contains a magic number: for (int idx = 0; idx < 256; idx++) {  	idx2 = (key [idx1 + offset] + this.state [idx] + idx2) & 255;  	tmp = this.state [idx];  	this.state [idx] = this.state [idx2];  	this.state [idx2] = tmp;  	idx1 = (idx1 + 1) % length;  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareRC4Key,The following statement contains a magic number: idx2 = (key [idx1 + offset] + this.state [idx] + idx2) & 255;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptRC4,The following statement contains a magic number: for (int idx = offset; idx < length; idx++) {  	x = (x + 1) & 255;  	y = (this.state [x] + y) & 255;  	b = this.state [x];  	this.state [x] = this.state [y];  	this.state [y] = b;  	outputData [idx] = (byte)(inputData [idx] ^ state [(this.state [x] + this.state [y]) & 255]);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptRC4,The following statement contains a magic number: for (int idx = offset; idx < length; idx++) {  	x = (x + 1) & 255;  	y = (this.state [x] + y) & 255;  	b = this.state [x];  	this.state [x] = this.state [y];  	this.state [y] = b;  	outputData [idx] = (byte)(inputData [idx] ^ state [(this.state [x] + this.state [y]) & 255]);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptRC4,The following statement contains a magic number: for (int idx = offset; idx < length; idx++) {  	x = (x + 1) & 255;  	y = (this.state [x] + y) & 255;  	b = this.state [x];  	this.state [x] = this.state [y];  	this.state [y] = b;  	outputData [idx] = (byte)(inputData [idx] ^ state [(this.state [x] + this.state [y]) & 255]);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptRC4,The following statement contains a magic number: x = (x + 1) & 255;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptRC4,The following statement contains a magic number: y = (this.state [x] + y) & 255;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,EncryptRC4,The following statement contains a magic number: outputData [idx] = (byte)(inputData [idx] ^ state [(this.state [x] + this.state [y]) & 255]);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: objectId [1] = (byte)(id.ObjectNumber >> 8);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: objectId [2] = (byte)(id.ObjectNumber >> 16);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: objectId [2] = (byte)(id.ObjectNumber >> 16);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: objectId [3] = (byte)id.GenerationNumber;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: objectId [4] = (byte)(id.GenerationNumber >> 8);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: objectId [4] = (byte)(id.GenerationNumber >> 8);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: this.keySize = this.encryptionKey.Length + 5;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: if (this.keySize > 16)  	this.keySize = 16;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: if (this.keySize > 16)  	this.keySize = 16;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,SetHashKey,The following statement contains a magic number: this.keySize = 16;  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: if (strongEncryption) {  	vValue = new PdfInteger (2);  	length = new PdfInteger (128);  	rValue = new PdfInteger (3);  }  else {  	vValue = new PdfInteger (1);  	length = new PdfInteger (40);  	rValue = new PdfInteger (2);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: if (strongEncryption) {  	vValue = new PdfInteger (2);  	length = new PdfInteger (128);  	rValue = new PdfInteger (3);  }  else {  	vValue = new PdfInteger (1);  	length = new PdfInteger (40);  	rValue = new PdfInteger (2);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: if (strongEncryption) {  	vValue = new PdfInteger (2);  	length = new PdfInteger (128);  	rValue = new PdfInteger (3);  }  else {  	vValue = new PdfInteger (1);  	length = new PdfInteger (40);  	rValue = new PdfInteger (2);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: if (strongEncryption) {  	vValue = new PdfInteger (2);  	length = new PdfInteger (128);  	rValue = new PdfInteger (3);  }  else {  	vValue = new PdfInteger (1);  	length = new PdfInteger (40);  	rValue = new PdfInteger (2);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: if (strongEncryption) {  	vValue = new PdfInteger (2);  	length = new PdfInteger (128);  	rValue = new PdfInteger (3);  }  else {  	vValue = new PdfInteger (1);  	length = new PdfInteger (40);  	rValue = new PdfInteger (2);  }  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: vValue = new PdfInteger (2);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: length = new PdfInteger (128);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: rValue = new PdfInteger (3);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: length = new PdfInteger (40);  
Magic Number,PdfSharp.Pdf.Security,PdfStandardSecurityHandler,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Security\PdfStandardSecurityHandler.cs,PrepareEncryption,The following statement contains a magic number: rValue = new PdfInteger (2);  
Magic Number,PdfSharp.Pdf,PdfDocument,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfDocument.cs,PdfDocument,The following statement contains a magic number: this.version = 14;  
Magic Number,PdfSharp.Pdf,PdfDocument,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfDocument.cs,PdfDocument,The following statement contains a magic number: this.version = 14;  
Magic Number,PdfSharp.Pdf,PdfObjectID,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfObjectID.cs,PdfObjectID,The following statement contains a magic number: if (generationNumber > 65535)  	Debug.WriteLine (String.Format ("Generation number: {0}"' generationNumber));  
Magic Number,PdfSharp.Pdf,PdfPage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPage.cs,PdfPage,The following statement contains a magic number: if (Math.Abs ((rotate / 90)) % 2 == 1)  	this.orientation = PageOrientation.Landscape;  
Magic Number,PdfSharp.Pdf,PdfPage,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfPage.cs,PdfPage,The following statement contains a magic number: if (Math.Abs ((rotate / 90)) % 2 == 1)  	this.orientation = PageOrientation.Landscape;  
Magic Number,PdfSharp.Pdf,PdfRectangle,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfRectangle.cs,PdfRectangle,The following statement contains a magic number: this.x2 = array.Elements.GetReal (2);  
Magic Number,PdfSharp.Pdf,PdfRectangle,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfRectangle.cs,PdfRectangle,The following statement contains a magic number: this.y2 = array.Elements.GetReal (3);  
Magic Number,PdfSharp.Pdf,PdfRectangle,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfRectangle.cs,GetHashCode,The following statement contains a magic number: return (int)(((((uint)this.x1) ^ ((((uint)this.y1) << 13) | (((uint)this.y1) >> 0x13))) ^ ((((uint)this.x2) << 0x1a) | (((uint)this.x2) >> 6))) ^ ((((uint)this.y2) << 7) | (((uint)this.y2) >> 0x19)));  
Magic Number,PdfSharp.Pdf,PdfRectangle,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfRectangle.cs,GetHashCode,The following statement contains a magic number: return (int)(((((uint)this.x1) ^ ((((uint)this.y1) << 13) | (((uint)this.y1) >> 0x13))) ^ ((((uint)this.x2) << 0x1a) | (((uint)this.x2) >> 6))) ^ ((((uint)this.y2) << 7) | (((uint)this.y2) >> 0x19)));  
Magic Number,PdfSharp.Pdf,PdfRectangle,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfRectangle.cs,GetHashCode,The following statement contains a magic number: return (int)(((((uint)this.x1) ^ ((((uint)this.y1) << 13) | (((uint)this.y1) >> 0x13))) ^ ((((uint)this.x2) << 0x1a) | (((uint)this.x2) >> 6))) ^ ((((uint)this.y2) << 7) | (((uint)this.y2) >> 0x19)));  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,WriteObject,The following statement contains a magic number: writer.WriteRaw (String.Format ("{0:0000000000} {1:00000} {2} \n"' 0' 65535' "f"));  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: try {  	nestingLevel++;  	if (nestingLevel >= 1000) {  		//Debug.WriteLine(String.Format("Nestinglevel={0}"' nestingLevel));  		//GetType();  		if (!this.overflow.ContainsKey (pdfObject))  			this.overflow.Add (pdfObject' null);  		return;  	}  	#if DEBUG_  	        //enterCount++;         if (enterCount == 5400)           GetType();         //if (!Object.ReferenceEquals(pdfObject.Owner' this.document))         //  GetType();         //////Debug.Assert(Object.ReferenceEquals(pdfObject27.Document' this.document));         //      if (item is PdfObject && ((PdfObject)item).ObjectID.ObjectNumber == 5)         //        Debug.WriteLine("items: " + ((PdfObject)item).ObjectID.ToString());         //if (pdfObject.ObjectNumber == 5)         //  GetType(); #endif  	IEnumerable enumerable = null;  	//(IEnumerator)pdfObject;  	if (pdfObject is PdfDictionary)  		enumerable = ((PdfDictionary)pdfObject).Elements.Values;  	else if (pdfObject is PdfArray)  		enumerable = ((PdfArray)pdfObject).Elements;  	if (enumerable != null) {  		foreach (PdfItem item in enumerable) {  			PdfReference iref = item as PdfReference;  			if (iref != null) {  				// Is this an indirect reference to an object that not exists?  				//if (iref.Document == null)  				//{  				//  Debug.WriteLine("Dead object dedected: " + iref.ObjectID.ToString());  				//  PdfReference dead = DeadObject;  				//  iref.ObjectID = dead.ObjectID;  				//  iref.Document = this.document;  				//  iref.SetObject(dead.Value);  				//  PdfDictionary dict = (PdfDictionary)dead.Value;  				//  				//  dict.Elements["/DeadObjectCount"] =   				//    new PdfInteger(dict.Elements.GetInteger("/DeadObjectCount") + 1);  				//  				//  iref = dead;  				//}  				if (!Object.ReferenceEquals (iref.Document' this.document)) {  					GetType ();  					Debug.WriteLine (String.Format ("Bad iref: {0}"' iref.ObjectID.ToString ()));  				}  				Debug.Assert (Object.ReferenceEquals (iref.Document' this.document) || iref.Document == null' "External object detected!");  				#if DEBUG  				if (iref.ObjectID.ObjectNumber == 23)  					GetType ();  				#endif  				if (!objects.ContainsKey (iref)) {  					PdfObject value = iref.Value;  					// Ignore unreachable objets  					if (iref.Document != null) {  						// ... from trailer hack  						if (value == null) {  							iref = this.objectTable [iref.ObjectID];  							Debug.Assert (iref.Value != null);  							value = iref.Value;  						}  						Debug.Assert (Object.ReferenceEquals (iref.Document' this.document));  						objects.Add (iref' null);  						//Debug.WriteLine(String.Format("objects.Add('{0}'' null);"' iref.ObjectID.ToString()));  						if (value is PdfArray || value is PdfDictionary)  							TransitiveClosureImplementation (objects' value' ref depth);  					}  					//else  					//{  					//  objects2.Add(this[iref.ObjectID]' null);  					//}  				}  			}  			else {  				PdfObject pdfObject28 = item as PdfObject;  				//if (pdfObject28 != null)  				//  Debug.Assert(Object.ReferenceEquals(pdfObject28.Document' this.document));  				if (pdfObject28 != null && (pdfObject28 is PdfDictionary || pdfObject28 is PdfArray))  					TransitiveClosureImplementation (objects' pdfObject28' ref depth);  			}  		}  	}  }  finally {  	nestingLevel--;  }  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: try {  	nestingLevel++;  	if (nestingLevel >= 1000) {  		//Debug.WriteLine(String.Format("Nestinglevel={0}"' nestingLevel));  		//GetType();  		if (!this.overflow.ContainsKey (pdfObject))  			this.overflow.Add (pdfObject' null);  		return;  	}  	#if DEBUG_  	        //enterCount++;         if (enterCount == 5400)           GetType();         //if (!Object.ReferenceEquals(pdfObject.Owner' this.document))         //  GetType();         //////Debug.Assert(Object.ReferenceEquals(pdfObject27.Document' this.document));         //      if (item is PdfObject && ((PdfObject)item).ObjectID.ObjectNumber == 5)         //        Debug.WriteLine("items: " + ((PdfObject)item).ObjectID.ToString());         //if (pdfObject.ObjectNumber == 5)         //  GetType(); #endif  	IEnumerable enumerable = null;  	//(IEnumerator)pdfObject;  	if (pdfObject is PdfDictionary)  		enumerable = ((PdfDictionary)pdfObject).Elements.Values;  	else if (pdfObject is PdfArray)  		enumerable = ((PdfArray)pdfObject).Elements;  	if (enumerable != null) {  		foreach (PdfItem item in enumerable) {  			PdfReference iref = item as PdfReference;  			if (iref != null) {  				// Is this an indirect reference to an object that not exists?  				//if (iref.Document == null)  				//{  				//  Debug.WriteLine("Dead object dedected: " + iref.ObjectID.ToString());  				//  PdfReference dead = DeadObject;  				//  iref.ObjectID = dead.ObjectID;  				//  iref.Document = this.document;  				//  iref.SetObject(dead.Value);  				//  PdfDictionary dict = (PdfDictionary)dead.Value;  				//  				//  dict.Elements["/DeadObjectCount"] =   				//    new PdfInteger(dict.Elements.GetInteger("/DeadObjectCount") + 1);  				//  				//  iref = dead;  				//}  				if (!Object.ReferenceEquals (iref.Document' this.document)) {  					GetType ();  					Debug.WriteLine (String.Format ("Bad iref: {0}"' iref.ObjectID.ToString ()));  				}  				Debug.Assert (Object.ReferenceEquals (iref.Document' this.document) || iref.Document == null' "External object detected!");  				#if DEBUG  				if (iref.ObjectID.ObjectNumber == 23)  					GetType ();  				#endif  				if (!objects.ContainsKey (iref)) {  					PdfObject value = iref.Value;  					// Ignore unreachable objets  					if (iref.Document != null) {  						// ... from trailer hack  						if (value == null) {  							iref = this.objectTable [iref.ObjectID];  							Debug.Assert (iref.Value != null);  							value = iref.Value;  						}  						Debug.Assert (Object.ReferenceEquals (iref.Document' this.document));  						objects.Add (iref' null);  						//Debug.WriteLine(String.Format("objects.Add('{0}'' null);"' iref.ObjectID.ToString()));  						if (value is PdfArray || value is PdfDictionary)  							TransitiveClosureImplementation (objects' value' ref depth);  					}  					//else  					//{  					//  objects2.Add(this[iref.ObjectID]' null);  					//}  				}  			}  			else {  				PdfObject pdfObject28 = item as PdfObject;  				//if (pdfObject28 != null)  				//  Debug.Assert(Object.ReferenceEquals(pdfObject28.Document' this.document));  				if (pdfObject28 != null && (pdfObject28 is PdfDictionary || pdfObject28 is PdfArray))  					TransitiveClosureImplementation (objects' pdfObject28' ref depth);  			}  		}  	}  }  finally {  	nestingLevel--;  }  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: if (nestingLevel >= 1000) {  	//Debug.WriteLine(String.Format("Nestinglevel={0}"' nestingLevel));  	//GetType();  	if (!this.overflow.ContainsKey (pdfObject))  		this.overflow.Add (pdfObject' null);  	return;  }  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: if (enumerable != null) {  	foreach (PdfItem item in enumerable) {  		PdfReference iref = item as PdfReference;  		if (iref != null) {  			// Is this an indirect reference to an object that not exists?  			//if (iref.Document == null)  			//{  			//  Debug.WriteLine("Dead object dedected: " + iref.ObjectID.ToString());  			//  PdfReference dead = DeadObject;  			//  iref.ObjectID = dead.ObjectID;  			//  iref.Document = this.document;  			//  iref.SetObject(dead.Value);  			//  PdfDictionary dict = (PdfDictionary)dead.Value;  			//  			//  dict.Elements["/DeadObjectCount"] =   			//    new PdfInteger(dict.Elements.GetInteger("/DeadObjectCount") + 1);  			//  			//  iref = dead;  			//}  			if (!Object.ReferenceEquals (iref.Document' this.document)) {  				GetType ();  				Debug.WriteLine (String.Format ("Bad iref: {0}"' iref.ObjectID.ToString ()));  			}  			Debug.Assert (Object.ReferenceEquals (iref.Document' this.document) || iref.Document == null' "External object detected!");  			#if DEBUG  			if (iref.ObjectID.ObjectNumber == 23)  				GetType ();  			#endif  			if (!objects.ContainsKey (iref)) {  				PdfObject value = iref.Value;  				// Ignore unreachable objets  				if (iref.Document != null) {  					// ... from trailer hack  					if (value == null) {  						iref = this.objectTable [iref.ObjectID];  						Debug.Assert (iref.Value != null);  						value = iref.Value;  					}  					Debug.Assert (Object.ReferenceEquals (iref.Document' this.document));  					objects.Add (iref' null);  					//Debug.WriteLine(String.Format("objects.Add('{0}'' null);"' iref.ObjectID.ToString()));  					if (value is PdfArray || value is PdfDictionary)  						TransitiveClosureImplementation (objects' value' ref depth);  				}  				//else  				//{  				//  objects2.Add(this[iref.ObjectID]' null);  				//}  			}  		}  		else {  			PdfObject pdfObject28 = item as PdfObject;  			//if (pdfObject28 != null)  			//  Debug.Assert(Object.ReferenceEquals(pdfObject28.Document' this.document));  			if (pdfObject28 != null && (pdfObject28 is PdfDictionary || pdfObject28 is PdfArray))  				TransitiveClosureImplementation (objects' pdfObject28' ref depth);  		}  	}  }  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: foreach (PdfItem item in enumerable) {  	PdfReference iref = item as PdfReference;  	if (iref != null) {  		// Is this an indirect reference to an object that not exists?  		//if (iref.Document == null)  		//{  		//  Debug.WriteLine("Dead object dedected: " + iref.ObjectID.ToString());  		//  PdfReference dead = DeadObject;  		//  iref.ObjectID = dead.ObjectID;  		//  iref.Document = this.document;  		//  iref.SetObject(dead.Value);  		//  PdfDictionary dict = (PdfDictionary)dead.Value;  		//  		//  dict.Elements["/DeadObjectCount"] =   		//    new PdfInteger(dict.Elements.GetInteger("/DeadObjectCount") + 1);  		//  		//  iref = dead;  		//}  		if (!Object.ReferenceEquals (iref.Document' this.document)) {  			GetType ();  			Debug.WriteLine (String.Format ("Bad iref: {0}"' iref.ObjectID.ToString ()));  		}  		Debug.Assert (Object.ReferenceEquals (iref.Document' this.document) || iref.Document == null' "External object detected!");  		#if DEBUG  		if (iref.ObjectID.ObjectNumber == 23)  			GetType ();  		#endif  		if (!objects.ContainsKey (iref)) {  			PdfObject value = iref.Value;  			// Ignore unreachable objets  			if (iref.Document != null) {  				// ... from trailer hack  				if (value == null) {  					iref = this.objectTable [iref.ObjectID];  					Debug.Assert (iref.Value != null);  					value = iref.Value;  				}  				Debug.Assert (Object.ReferenceEquals (iref.Document' this.document));  				objects.Add (iref' null);  				//Debug.WriteLine(String.Format("objects.Add('{0}'' null);"' iref.ObjectID.ToString()));  				if (value is PdfArray || value is PdfDictionary)  					TransitiveClosureImplementation (objects' value' ref depth);  			}  			//else  			//{  			//  objects2.Add(this[iref.ObjectID]' null);  			//}  		}  	}  	else {  		PdfObject pdfObject28 = item as PdfObject;  		//if (pdfObject28 != null)  		//  Debug.Assert(Object.ReferenceEquals(pdfObject28.Document' this.document));  		if (pdfObject28 != null && (pdfObject28 is PdfDictionary || pdfObject28 is PdfArray))  			TransitiveClosureImplementation (objects' pdfObject28' ref depth);  	}  }  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: if (iref != null) {  	// Is this an indirect reference to an object that not exists?  	//if (iref.Document == null)  	//{  	//  Debug.WriteLine("Dead object dedected: " + iref.ObjectID.ToString());  	//  PdfReference dead = DeadObject;  	//  iref.ObjectID = dead.ObjectID;  	//  iref.Document = this.document;  	//  iref.SetObject(dead.Value);  	//  PdfDictionary dict = (PdfDictionary)dead.Value;  	//  	//  dict.Elements["/DeadObjectCount"] =   	//    new PdfInteger(dict.Elements.GetInteger("/DeadObjectCount") + 1);  	//  	//  iref = dead;  	//}  	if (!Object.ReferenceEquals (iref.Document' this.document)) {  		GetType ();  		Debug.WriteLine (String.Format ("Bad iref: {0}"' iref.ObjectID.ToString ()));  	}  	Debug.Assert (Object.ReferenceEquals (iref.Document' this.document) || iref.Document == null' "External object detected!");  	#if DEBUG  	if (iref.ObjectID.ObjectNumber == 23)  		GetType ();  	#endif  	if (!objects.ContainsKey (iref)) {  		PdfObject value = iref.Value;  		// Ignore unreachable objets  		if (iref.Document != null) {  			// ... from trailer hack  			if (value == null) {  				iref = this.objectTable [iref.ObjectID];  				Debug.Assert (iref.Value != null);  				value = iref.Value;  			}  			Debug.Assert (Object.ReferenceEquals (iref.Document' this.document));  			objects.Add (iref' null);  			//Debug.WriteLine(String.Format("objects.Add('{0}'' null);"' iref.ObjectID.ToString()));  			if (value is PdfArray || value is PdfDictionary)  				TransitiveClosureImplementation (objects' value' ref depth);  		}  		//else  		//{  		//  objects2.Add(this[iref.ObjectID]' null);  		//}  	}  }  else {  	PdfObject pdfObject28 = item as PdfObject;  	//if (pdfObject28 != null)  	//  Debug.Assert(Object.ReferenceEquals(pdfObject28.Document' this.document));  	if (pdfObject28 != null && (pdfObject28 is PdfDictionary || pdfObject28 is PdfArray))  		TransitiveClosureImplementation (objects' pdfObject28' ref depth);  }  
Magic Number,PdfSharp.Pdf,PdfReferenceTable,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfReferenceTable.cs,TransitiveClosureImplementation,The following statement contains a magic number: if (iref.ObjectID.ObjectNumber == 23)  	GetType ();  
Magic Number,PdfSharp.Pdf,PdfString,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfString.cs,ToStringFromPdfDocEncoded,The following statement contains a magic number: for (int idx = 0; idx < length; idx++) {  	char ch = this.value [idx];  	if (ch <= 255) {  		bytes [idx] = Encode [ch];  	}  	else {  		Debugger.Break ();  	}  }  
Magic Number,PdfSharp.Pdf,PdfString,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf\PdfString.cs,ToStringFromPdfDocEncoded,The following statement contains a magic number: if (ch <= 255) {  	bytes [idx] = Encode [ch];  }  else {  	Debugger.Break ();  }  
Magic Number,PdfSharp.SharpZipLib.Checksums,Adler32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,PdfSharp.SharpZipLib.Checksums,Adler32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (len > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > len) {  		n = len;  	}  	len -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buf [off++] & 0xFF);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,PdfSharp.SharpZipLib.Checksums,Adler32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,PdfSharp.SharpZipLib.Checksums,Crc32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable [(oldCrc ^ bval) & 0xFF] ^ (oldCrc >> 8));  
Magic Number,PdfSharp.SharpZipLib.Checksums,Crc32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ bval) & 0xFF] ^ (crc >> 8);  
Magic Number,PdfSharp.SharpZipLib.Checksums,Crc32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: while (--len >= 0) {  	crc = CrcTable [(crc ^ buf [off++]) & 0xFF] ^ (crc >> 8);  }  
Magic Number,PdfSharp.SharpZipLib.Checksums,Crc32,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ buf [off++]) & 0xFF] ^ (crc >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: level = 6;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (lvl == DEFAULT_COMPRESSION) {  	lvl = 6;  }  else if (lvl < NO_COMPRESSION || lvl > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("lvl");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: lvl = 6;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if ((state & IS_SETDICT) != 0) {  	int chksum = engine.Adler;  	engine.ResetAdler ();  	pending.WriteShortMSB (chksum >> 16);  	pending.WriteShortMSB (chksum & 0xffff);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (chksum >> 16);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead                * is needed by the zlib inflater' and we must fill                * the next byte' so that all bits are flushed.                */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of                  * an EOF:                  */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: neededbits -= 10;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!noZlibHeaderOrFooter) {  	int adler = engine.Adler;  	pending.WriteShortMSB (adler >> 16);  	pending.WriteShortMSB (adler & 0xffff);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Deflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (adler >> 16);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  	int more = 2 * WSIZE - lookahead - strstart;  	if (more > inputEnd - inputOff) {  		more = inputEnd - inputOff;  	}  	System.Array.Copy (inputBuf' inputOff' window' strstart + lookahead' more);  	adler.Update (inputBuf' inputOff' more);  	inputOff += more;  	totalIn += more;  	lookahead += more;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  	chainLength >>= 2;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (DeflaterConstants.DEBUGGING && strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	throw new InvalidOperationException ("need lookahead");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	if (DeflaterConstants.DEBUGGING && curMatch >= strstart) {  		throw new InvalidOperationException ("future match");  	}  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend)  		;  	if (scan > best_end) {  		//  	if (DeflaterConstants.DEBUGGING && ins_h == 0)  		//  	  System.err.println("Found match: "+curMatch+"-"+(scan-strstart));  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	if (DeflaterConstants.DEBUGGING && curMatch >= strstart) {  		throw new InvalidOperationException ("future match");  	}  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend)  		;  	if (scan > best_end) {  		//  	if (DeflaterConstants.DEBUGGING && ins_h == 0)  		//  	  System.err.println("Found match: "+curMatch+"-"+(scan-strstart));  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		/* We are flushing everything */huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int hashHead;  	if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		/* longestMatch sets matchStart and matchLen *///					if (DeflaterConstants.DEBUGGING) {  		//						for (int i = 0 ; i < matchLen; i++) {  		//							if (window[strstart+i] != window[matchStart + i]) {  		//								throw new SharpZipBaseException();  		//							}  		//						}  		//					}  		// -jr- Hak hak hak this stops problems with fast/low compression and index out of range  		if (huffman.TallyDist (strstart - matchStart' matchLen)) {  			bool lastBlock = finish && lookahead == 0;  			huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  			blockStart = strstart;  		}  		lookahead -= matchLen;  		if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  			while (--matchLen > 0) {  				++strstart;  				InsertString ();  			}  			++strstart;  		}  		else {  			strstart += matchLen;  			if (lookahead >= MIN_MATCH - 1) {  				UpdateHash ();  			}  		}  		matchLen = MIN_MATCH - 1;  		continue;  	}  	else {  		/* No match found */huffman.TallyLit (window [strstart] & 0xff);  		++strstart;  		--lookahead;  	}  	if (huffman.IsFull ()) {  		bool lastBlock = finish && lookahead == 0;  		huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  		blockStart = strstart;  		return !lastBlock;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as findLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		/* We are flushing everything */if (DeflaterConstants.DEBUGGING && !flush) {  			throw new SharpZipBaseException ("Not flushing' but no lookahead");  		}  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	/* previous match was better */if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						for (int i = 0 ; i < matchLen; i++) {  		//							if (window[strstart-1+i] != window[prevMatch + i])  		//								throw new SharpZipBaseException();  		//						}  		//					}  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && lookahead == 0 && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		/* We are flushing everything */if (DeflaterConstants.DEBUGGING && !flush) {  			throw new SharpZipBaseException ("Not flushing' but no lookahead");  		}  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	/* previous match was better */if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						for (int i = 0 ; i < matchLen; i++) {  		//							if (window[strstart-1+i] != window[prevMatch + i])  		//								throw new SharpZipBaseException();  		//						}  		//					}  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && lookahead == 0 && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		/* We are flushing everything */if (DeflaterConstants.DEBUGGING && !flush) {  			throw new SharpZipBaseException ("Not flushing' but no lookahead");  		}  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	/* previous match was better */if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						for (int i = 0 ; i < matchLen; i++) {  		//							if (window[strstart-1+i] != window[prevMatch + i])  		//								throw new SharpZipBaseException();  		//						}  		//					}  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && lookahead == 0 && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (lookahead >= MIN_MATCH) {  	int hashHead = InsertString ();  	if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  			matchLen = MIN_MATCH - 1;  		}  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  	/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  		matchLen = MIN_MATCH - 1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  	matchLen = MIN_MATCH - 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						for (int i = 0 ; i < matchLen; i++) {  	//							if (window[strstart-1+i] != window[prevMatch + i])  	//								throw new SharpZipBaseException();  	//						}  	//					}  	huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  	prevLen -= 2;  	do {  		strstart++;  		lookahead--;  		if (lookahead >= MIN_MATCH) {  			InsertString ();  		}  	}  	while (--prevLen > 0);  	strstart++;  	lookahead--;  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  }  else {  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	prevAvailable = true;  	strstart++;  	lookahead--;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x030 + i) << 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 9;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 7;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes [i] = BitReverse (i << 11);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength [i] = 5;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree (this' DIST_NUM' 1' 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (len == 255) {  	return 285;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (len == 255) {  	return 285;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: return 285;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (len >= 8) {  	code += 4;  	len >>= 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (len >= 8) {  	code += 4;  	len >>= 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: code += 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: code += 2;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (distTree.numCodes - 1' 5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  	pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (bits > 0 && bits <= 5) {  	pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  	if (blTree.length [BL_ORDER [i]] > 0) {  		blTreeCodes = i + 1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf [last_lit++] = (byte)(len - 3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  }  else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	}  	else {  		/* symbol == 256: end of block */distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	}  	else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  }  else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,Inflater,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  }  else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buf [end++] = (byte)(s >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buf [end++] = (byte)(s >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buf [end++] = (byte)(s >> 16);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buf [end++] = (byte)(s >> 24);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buf [end++] = (byte)bits;  	if (bitCount > 8) {  		buf [end++] = (byte)(bits >> 8);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buf [end++] = (byte)bits;  	if (bitCount > 8) {  		buf [end++] = (byte)(bits >> 8);  	}  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buf [end++] = (byte)(bits >> 8);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buf [end++] = (byte)(bits >> 8);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: buf [end++] = (byte)(bits >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: buf [end++] = (byte)(bits >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bits >>= 16;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buf [end++] = (byte)(s >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buf [end++] = (byte)bits;  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buf [end++] = (byte)bits;  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buf [end++] = (byte)bits;  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bits >>= 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bitCount -= 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,EncryptByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,UpdateKeys,The following statement contains a magic number: keys [1] = keys [1] * 134775813 + 1;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek) {  	baseInputStream.Seek (n' SeekOrigin.Current);  	return n;  }  else {  	int len = 2048;  	if (n < len) {  		len = (int)n;  	}  	byte[] tmp = new byte[len];  	return (long)baseInputStream.Read (tmp' 0' tmp.Length);  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,DecryptByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,UpdateKeys,The following statement contains a magic number: keys [1] = keys [1] * 134775813 + 1;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bits_in_buffer < n) {  	if (window_start == window_end) {  		return -1;  		// ok  	}  	buffer |= (uint)((window [window_start++] & 0xff | (window [window_start++] & 0xff) << 8) << bits_in_buffer);  	bits_in_buffer += 16;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bits_in_buffer < n) {  	if (window_start == window_end) {  		return -1;  		// ok  	}  	buffer |= (uint)((window [window_start++] & 0xff | (window [window_start++] & 0xff) << 8) << bits_in_buffer);  	bits_in_buffer += 16;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer |= (uint)((window [window_start++] & 0xff | (window [window_start++] & 0xff) << 8) << bits_in_buffer);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bits_in_buffer += 16;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer >>= (bits_in_buffer & 7);  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bits_in_buffer &= ~7;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bits_in_buffer & 7) != 0) {  	/* bits_in_buffer may only be 0 or a multiple of 8 */throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while (bits_in_buffer > 0 && length > 0) {  	output [offset++] = (byte)buffer;  	buffer >>= 8;  	bits_in_buffer -= 8;  	length--;  	count++;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while (bits_in_buffer > 0 && length > 0) {  	output [offset++] = (byte)buffer;  	buffer >>= 8;  	bits_in_buffer -= 8;  	length--;  	count++;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer >>= 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bits_in_buffer -= 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((window_start - window_end) & 1) != 0) {  	/* We always want an even number of bytes in input' see peekBits */buffer = (uint)(window [window_start++] & 0xff);  	bits_in_buffer = 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bits_in_buffer = 8;  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((len & 1) != 0) {  	/* We always want an even number of bytes in input' see peekBits */buffer |= (uint)((buf [off++] & 0xff) << bits_in_buffer);  	bits_in_buffer += 8;  }  
Magic Number,PdfSharp.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bits_in_buffer += 8;  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2380' 3368);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2380' 3368);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1684' 2380);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1684' 2380);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1190' 1684);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1190' 1684);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (842' 1190);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (842' 1190);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (595' 842);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (595' 842);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (420' 595);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (420' 595);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2438' 3458);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2438' 3458);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1729' 2438);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1729' 2438);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1219' 1729);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1219' 1729);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (865' 1219);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (865' 1219);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (609' 865);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (609' 865);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (343' 609);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (343' 609);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2835' 4008);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2835' 4008);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2004' 2835);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2004' 2835);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (4252' 1417);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (4252' 1417);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1001' 1417);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1001' 1417);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (729' 1032);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (729' 1032);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (516' 729);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (516' 729);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (576' 720);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (576' 720);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (576' 936);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (576' 936);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (540' 720);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (540' 720);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (756' 576);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (756' 576);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (612' 792);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (612' 792);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (612' 1008);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (612' 1008);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1224' 792);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1224' 792);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (792' 1224);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (792' 1224);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1126' 1386);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1126' 1386);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1440' 1080);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1440' 1080);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1188' 1512);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1188' 1512);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1260' 1584);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1260' 1584);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1296' 1656);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1296' 1656);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1440' 1800);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1440' 1800);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1565' 2016);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1565' 2016);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1692' 2520);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (1692' 2520);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2520' 3240);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (2520' 3240);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (396' 612);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (396' 612);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (612' 936);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (612' 936);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (396' 612);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (396' 612);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (720' 1008);  
Magic Number,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following statement contains a magic number: return new XSize (720' 1008);  
Duplicate Code,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanLiteralString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((35' 86)' (112' 163))
Duplicate Code,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((25' 65)' (233' 273))
Duplicate Code,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanLiteralString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((67' 95)' (275' 303))
Missing Default,PdfSharp.Internal,Calc,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Internal\Calc.cs,PageSizeToSize,The following switch statement is missing a default case: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Letter:  	return new XSize (612' 792);  case PageSize.Legal:  	return new XSize (612' 1008);  case PageSize.Tabloid:  	return new XSize (792' 1224);  case PageSize.Ledger:  	return new XSize (1224' 792);  case PageSize.Statement:  	return new XSize (396' 612);  case PageSize.Executive:  	return new XSize (540' 720);  case PageSize.Folio:  	return new XSize (612' 936);  case PageSize.Quarto:  	return new XSize (610' 780);  case PageSize.Size10x14:  	return new XSize (720' 1008);  }  
Missing Default,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,CreateEncoding,The following switch statement is missing a default case: switch (dmEncoding) {  case DataMatrixEncoding.Ascii:  	tempencoding = new String ('a'' length);  	break;  case DataMatrixEncoding.C40:  	tempencoding = new String ('c'' length);  	break;  case DataMatrixEncoding.Text:  	tempencoding = new String ('t'' length);  	break;  case DataMatrixEncoding.X12:  	tempencoding = new String ('x'' length);  	break;  case DataMatrixEncoding.EDIFACT:  	tempencoding = new String ('e'' length);  	break;  case DataMatrixEncoding.Base256:  	tempencoding = new String ('b'' length);  	break;  }  
Missing Default,PdfSharp.Drawing.BarCodes,CodeDataMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeDataMatrix.cs,Render,The following switch statement is missing a default case: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Missing Default,PdfSharp.Drawing.BarCodes,CodeOmr,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\CodeOmr.cs,Render,The following switch statement is missing a default case: switch (this.direction) {  case CodeDirection.RightToLeft:  	gfx.RotateAtTransform (180' position);  	break;  case CodeDirection.TopToBottom:  	gfx.RotateAtTransform (90' position);  	break;  case CodeDirection.BottomToTop:  	gfx.RotateAtTransform (-90' position);  	break;  }  
Missing Default,PdfSharp.Drawing.BarCodes,ThickThinBarCode,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.BarCodes\ThickThinBarcodeRenderer.cs,InitRendering,The following switch statement is missing a default case: switch (this.direction) {  case CodeDirection.RightToLeft:  	info.Gfx.RotateAtTransform (180' info.Position);  	break;  case CodeDirection.TopToBottom:  	info.Gfx.RotateAtTransform (90' info.Position);  	break;  case CodeDirection.BottomToTop:  	info.Gfx.RotateAtTransform (-90' info.Position);  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,PdfGraphicsState,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\PdfGraphicsState.cs,RealizePen,The following switch statement is missing a default case: switch (dashStyle) {  case XDashStyle.Solid:  	this.renderer.Append ("[]0 d\n");  	break;  case XDashStyle.Dash:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Dot:  	this.renderer.AppendFormat ("[{0:0.##}]0 d\n"' dot);  	break;  case XDashStyle.DashDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.DashDotDot:  	this.renderer.AppendFormat ("[{0:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##} {1:0.##}]0 d\n"' dash' dot);  	break;  case XDashStyle.Custom:  	{  		StringBuilder pdf = new StringBuilder ("["' 256);  		int len = pen.dashPattern == null ? 0 : pen.dashPattern.Length;  		for (int idx = 0; idx < len; idx++) {  			if (idx > 0)  				pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (pen.dashPattern [idx] * pen.width));  		}  		// Make an even number of values look like in GDI+  		if (len > 0 && len % 2 == 1) {  			pdf.Append (' ');  			pdf.Append (PdfEncoders.ToString (0.2 * pen.width));  		}  		pdf.AppendFormat (CultureInfo.InvariantCulture' "]{0:0.###} d\n"' pen.dashOffset * pen.width);  		string pattern = pdf.ToString ();  		// BUG: drice2@ageone.de reported a realizing problem  		// HACK: I romove the if clause  		//if (this.realizedDashPattern != pattern)  		{  			this.realizedDashPattern = pattern;  			this.renderer.Append (pattern);  		}  	}  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following switch statement is missing a default case: switch (format.Alignment) {  case XStringAlignment.Near:  	// nothing to do  	break;  case XStringAlignment.Center:  	x += (rect.Width - width) / 2;  	break;  case XStringAlignment.Far:  	x += rect.Width - width;  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following switch statement is missing a default case: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += (cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyDescent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,DrawString,The following switch statement is missing a default case: switch (format.LineAlignment) {  case XLineAlignment.Near:  	y += cyDescent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	y += -cyAscent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following switch statement is missing a default case: switch (pathStart) {  case PathStart.MoveTo1st:  	pt1 = matrix.Transform (new XPoint (x0 + δx * cosα' y0 + δy * sinα));  	AppendFormat ("{0:0.###} {1:0.###} m\n"' pt1.x' pt1.y);  	break;  case PathStart.LineTo1st:  	pt1 = matrix.Transform (new XPoint (x0 + δx * cosα' y0 + δy * sinα));  	AppendFormat ("{0:0.###} {1:0.###} l\n"' pt1.x' pt1.y);  	break;  case PathStart.Ignore1st:  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPartialArcQuadrant,The following switch statement is missing a default case: switch (pathStart) {  case PathStart.MoveTo1st:  	pt1 = matrix.Transform (new XPoint (x0 - δx * cosα' y0 - δy * sinα));  	AppendFormat ("{0:0.###} {1:0.###} m\n"' pt1.x' pt1.y);  	break;  case PathStart.LineTo1st:  	pt1 = matrix.Transform (new XPoint (x0 - δx * cosα' y0 - δy * sinα));  	AppendFormat ("{0:0.###} {1:0.###} l\n"' pt1.x' pt1.y);  	break;  case PathStart.Ignore1st:  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,AppendPath,The following switch statement is missing a default case: switch (type & PathPointTypePathTypeMask) {  case PathPointTypeStart:  	//PDF_moveto(pdf' points[idx].X' points[idx].Y);  	AppendFormat ("{0:0.####} {1:0.####} m\n"' points [idx].X' points [idx].Y);  	break;  case PathPointTypeLine:  	//PDF_lineto(pdf' points[idx].X' points[idx].Y);  	AppendFormat ("{0:0.####} {1:0.####} l\n"' points [idx].X' points [idx].Y);  	if ((type & PathPointTypeCloseSubpath) != 0)  		Append ("h\n");  	break;  case PathPointTypeBezier:  	Debug.Assert (idx + 2 < count);  	//PDF_curveto(pdf' points[idx].X' points[idx].Y'   	//                 points[idx + 1].X' points[idx + 1].Y'   	//                 points[idx + 2].X' points[idx + 2].Y);  	AppendFormat ("{0:0.####} {1:0.####} {2:0.####} {3:0.####} {4:0.####} {5:0.####} c\n"' points [idx].X' points [idx].Y' points [++idx].X' points [idx].Y' points [++idx].X' points [idx].Y);  	if ((types [idx] & PathPointTypeCloseSubpath) != 0)  		Append ("h\n");  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following switch statement is missing a default case: switch (this.gfx.PageUnit) {  case XGraphicsUnit.Inch:  	defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  	break;  case XGraphicsUnit.Millimeter:  	defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  	break;  case XGraphicsUnit.Centimeter:  	defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  	break;  }  
Missing Default,PdfSharp.Drawing.Pdf,XGraphicsPdfRenderer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing.Pdf\XGraphicsPdfRenderer.cs,BeginPage,The following switch statement is missing a default case: switch (this.gfx.PageUnit) {  case XGraphicsUnit.Inch:  	defaultViewMatrix.ScalePrepend (XUnit.InchFactor);  	break;  case XGraphicsUnit.Millimeter:  	defaultViewMatrix.ScalePrepend (XUnit.MillimeterFactor);  	break;  case XGraphicsUnit.Centimeter:  	defaultViewMatrix.ScalePrepend (XUnit.CentimeterFactor);  	break;  }  
Missing Default,PdfSharp.Drawing,FontHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\FontHelper.cs,FontStyleFromStyle,The following switch statement is missing a default case: switch (style & XFontStyle.BoldItalic) // mask out Underline and Strikeout  {  case XFontStyle.Regular:  	return FontStyles.Normal;  case XFontStyle.Bold:  	return FontStyles.Normal;  case XFontStyle.Italic:  	return FontStyles.Italic;  case XFontStyle.BoldItalic:  	return FontStyles.Italic;  }  
Missing Default,PdfSharp.Drawing,FontHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\FontHelper.cs,FontWeightFromStyle,The following switch statement is missing a default case: switch (style) {  case XFontStyle.Regular:  	return FontWeights.Normal;  case XFontStyle.Bold:  	return FontWeights.Bold;  case XFontStyle.Italic:  	return FontWeights.Normal;  case XFontStyle.BoldItalic:  	return FontWeights.Bold;  }  
Missing Default,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following switch statement is missing a default case: switch (pathStart) {  case PathStart.MoveTo1st:  	points.Add (matrix.Transform (new XPoint (x0 + δx * cosα' y0 + δy * sinα)));  	break;  case PathStart.LineTo1st:  	points.Add (matrix.Transform (new XPoint (x0 + δx * cosα' y0 + δy * sinα)));  	break;  case PathStart.Ignore1st:  	break;  }  
Missing Default,PdfSharp.Drawing,GeometryHelper,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\GeometryHelper.cs,AppendPartialArcQuadrant,The following switch statement is missing a default case: switch (pathStart) {  case PathStart.MoveTo1st:  	points.Add (matrix.Transform (new XPoint (x0 - δx * cosα' y0 - δy * sinα)));  	break;  case PathStart.LineTo1st:  	points.Add (matrix.Transform (new XPoint (x0 - δx * cosα' y0 - δy * sinα)));  	break;  case PathStart.Ignore1st:  	break;  }  
Missing Default,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightStringToKnownWeight,The following switch statement is missing a default case: switch (s.ToLower ()) {  case "thin":  	fontWeight = Thin;  	return true;  case "extralight":  	fontWeight = ExtraLight;  	return true;  case "ultralight":  	fontWeight = UltraLight;  	return true;  case "light":  	fontWeight = Light;  	return true;  case "normal":  	fontWeight = Normal;  	return true;  case "regular":  	fontWeight = Regular;  	return true;  case "medium":  	fontWeight = Medium;  	return true;  case "semibold":  	fontWeight = SemiBold;  	return true;  case "demibold":  	fontWeight = DemiBold;  	return true;  case "bold":  	fontWeight = Bold;  	return true;  case "extrabold":  	fontWeight = ExtraBold;  	return true;  case "ultrabold":  	fontWeight = UltraBold;  	return true;  case "heavy":  	fontWeight = Heavy;  	return true;  case "black":  	fontWeight = Black;  	return true;  case "extrablack":  	fontWeight = ExtraBlack;  	return true;  case "ultrablack":  	fontWeight = UltraBlack;  	return true;  }  
Missing Default,PdfSharp.Drawing,XFontWeights,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XFontWeights.cs,FontWeightToString,The following switch statement is missing a default case: switch (weight) {  case 100:  	convertedValue = "Thin";  	return true;  case 200:  	convertedValue = "ExtraLight";  	return true;  case 300:  	convertedValue = "Light";  	return true;  case 400:  	convertedValue = "Normal";  	return true;  case 500:  	convertedValue = "Medium";  	return true;  case 600:  	convertedValue = "SemiBold";  	return true;  case 700:  	convertedValue = "Bold";  	return true;  case 800:  	convertedValue = "ExtraBold";  	return true;  case 900:  	convertedValue = "Black";  	return true;  case 950:  	convertedValue = "ExtraBlack";  	return true;  }  
Missing Default,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,XGraphics,The following switch statement is missing a default case: switch (options) {  case XGraphicsPdfPageOptions.Replace:  	page.Contents.Elements.Clear ();  	goto case XGraphicsPdfPageOptions.Append;  case XGraphicsPdfPageOptions.Prepend:  	content = page.Contents.PrependContent ();  	break;  case XGraphicsPdfPageOptions.Append:  	content = page.Contents.AppendContent ();  	break;  }  
Missing Default,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,Initialize,The following switch statement is missing a default case: switch (this.pageUnit) {  case XGraphicsUnit.Inch:  	matrix.ScalePrepend (XUnit.InchFactor);  	break;  case XGraphicsUnit.Millimeter:  	matrix.ScalePrepend (XUnit.MillimeterFactor);  	break;  case XGraphicsUnit.Centimeter:  	matrix.ScalePrepend (XUnit.CentimeterFactor);  	break;  case XGraphicsUnit.Presentation:  	matrix.ScalePrepend (XUnit.PresentationFactor);  	break;  }  
Missing Default,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,Initialize,The following switch statement is missing a default case: switch (this.pageUnit) {  case XGraphicsUnit.Point:  	matrix.ScalePrepend (XUnit.PointFactorWpf);  	break;  case XGraphicsUnit.Inch:  	matrix.ScalePrepend (XUnit.InchFactorWpf);  	break;  case XGraphicsUnit.Millimeter:  	matrix.ScalePrepend (XUnit.MillimeterFactorWpf);  	break;  case XGraphicsUnit.Centimeter:  	matrix.ScalePrepend (XUnit.CentimeterFactorWpf);  	break;  }  
Missing Default,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following switch statement is missing a default case: switch (format.Alignment) {  case XStringAlignment.Near:  	// nothing to do' this is the default  	//formattedText.TextAlignment = TextAlignment.Left;  	break;  case XStringAlignment.Center:  	x += layoutRectangle.Width / 2;  	formattedText.TextAlignment = TextAlignment.Center;  	break;  case XStringAlignment.Far:  	x += layoutRectangle.Width;  	formattedText.TextAlignment = TextAlignment.Right;  	break;  }  
Missing Default,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following switch statement is missing a default case: switch (format.LineAlignment) {  case XLineAlignment.Near:  	//y += cyAscent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	y += -formattedText.Baseline + (cyAscent * 1 / 3) + layoutRectangle.Height / 2;  	//y += -formattedText.Baseline + (font.Size * font.Metrics.CapHeight / font.unitsPerEm / 2) + layoutRectangle.Height / 2;  	break;  case XLineAlignment.Far:  	y += -formattedText.Baseline - cyDescent + layoutRectangle.Height;  	break;  case XLineAlignment.BaseLine:  	y -= formattedText.Baseline;  	break;  }  
Missing Default,PdfSharp.Drawing,XGraphics,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XGraphics.cs,DrawString,The following switch statement is missing a default case: switch (format.LineAlignment) {  case XLineAlignment.Near:  	//y += cyDescent;  	break;  case XLineAlignment.Center:  	// TODO use CapHeight. PDFlib also uses 3/4 of ascent  	//y += -(cyAscent * 3 / 4) / 2 + rect.Height / 2;  	break;  case XLineAlignment.Far:  	//y += -cyAscent + rect.Height;  	break;  case XLineAlignment.BaseLine:  	// nothing to do  	break;  }  
Missing Default,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,MultiplyVector,The following switch statement is missing a default case: switch (this.type) {  case XMatrixTypes.Identity:  case XMatrixTypes.Translation:  	return;  case XMatrixTypes.Scaling:  case XMatrixTypes.Scaling | XMatrixTypes.Translation:  	x *= this.m11;  	y *= this.m22;  	return;  }  
Missing Default,PdfSharp.Drawing,XMatrix,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XMatrix.cs,MultiplyPoint,The following switch statement is missing a default case: switch (this.type) {  case XMatrixTypes.Identity:  	return;  case XMatrixTypes.Translation:  	x += this.offsetX;  	y += this.offsetY;  	return;  case XMatrixTypes.Scaling:  	x *= this.m11;  	y *= this.m22;  	return;  case (XMatrixTypes.Scaling | XMatrixTypes.Translation):  	x *= this.m11;  	x += this.offsetX;  	y *= this.m22;  	y += this.offsetY;  	return;  }  
Missing Default,PdfSharp.Drawing,XPen,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Drawing\XPen.cs,RealizeWpfPen,The following switch statement is missing a default case: switch (this.dashStyle) {  case XDashStyle.Solid:  	this.wpfPen.DashStyle = DashStyles.Solid;  	break;  case XDashStyle.Dash:  	//this.wpfPen.DashStyle = DashStyles.Dash;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2  	}' 0);  	break;  case XDashStyle.Dot:  	//this.wpfPen.DashStyle = DashStyles.Dot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		0'  		2  	}' 1.5);  	break;  case XDashStyle.DashDot:  	//this.wpfPen.DashStyle = DashStyles.DashDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2  	}' 0);  	break;  case XDashStyle.DashDotDot:  	//this.wpfPen.DashStyle = DashStyles.DashDotDot;  	this.wpfPen.DashStyle = new System.Windows.Media.DashStyle (new double[] {  		2'  		2'  		0'  		2'  		0'  		2  	}' 0);  	break;  }  
Missing Default,PdfSharp.Fonts.OpenType,FontData,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Fonts.OpenType\FontData.cs,AddTable,The following switch statement is missing a default case: switch (fontTable.DirectoryEntry.Tag) {  case TableTagNames.CMap:  	this.cmap = fontTable as CMapTable;  	break;  case TableTagNames.Cvt:  	this.cvt = fontTable as ControlValueTable;  	break;  case TableTagNames.Fpgm:  	this.fpgm = fontTable as FontProgram;  	break;  case TableTagNames.MaxP:  	this.maxp = fontTable as MaximumProfileTable;  	break;  case TableTagNames.Name:  	this.name = fontTable as NameTable;  	break;  case TableTagNames.Head:  	this.head = fontTable as FontHeaderTable;  	break;  case TableTagNames.HHea:  	this.hhea = fontTable as HorizontalHeaderTable;  	break;  case TableTagNames.HMtx:  	this.hmtx = fontTable as HorizontalMetricsTable;  	break;  case TableTagNames.OS2:  	this.os2 = fontTable as OS2Table;  	break;  case TableTagNames.Post:  	this.post = fontTable as PostScriptTable;  	break;  case TableTagNames.Glyf:  	this.glyf = fontTable as GlyphDataTable;  	break;  case TableTagNames.Loca:  	this.loca = fontTable as IndexToLocationTable;  	break;  case TableTagNames.GSUB:  	this.gsub = fontTable as GlyphSubstitutionTable;  	break;  case TableTagNames.Prep:  	this.prep = fontTable as ControlValueProgram;  	break;  }  
Missing Default,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,OnPaintBackground,The following switch statement is missing a default case: switch (this.borderStyle) {  case BorderStyle.FixedSingle:  	gfx.DrawRectangle (SystemPens.WindowFrame' clientRect.X' clientRect.Y' clientRect.Width - 1' clientRect.Height - 1);  	d = 1;  	break;  case BorderStyle.Fixed3D:  	ControlPaint.DrawBorder3D (gfx' clientRect' Border3DStyle.Sunken);  	d = 2;  	break;  }  
Missing Default,PdfSharp.Forms,PagePreview,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Forms\PagePreview.cs,LayoutChildren,The following switch statement is missing a default case: switch (this.borderStyle) {  case BorderStyle.FixedSingle:  	clientRect.Inflate (-1' -1);  	break;  case BorderStyle.Fixed3D:  	clientRect.Inflate (-2' -2);  	break;  }  
Missing Default,PdfSharp.Pdf.Advanced,PdfShading,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfShading.cs,SetupFromBrush,The following switch statement is missing a default case: switch (brush.linearGradientMode) {  case XLinearGradientMode.Horizontal:  	x1 = brush.rect.x;  	y1 = brush.rect.y;  	x2 = brush.rect.x + brush.rect.width;  	y2 = brush.rect.y;  	break;  case XLinearGradientMode.Vertical:  	x1 = brush.rect.x;  	y1 = brush.rect.y;  	x2 = brush.rect.x;  	y2 = brush.rect.y + brush.rect.height;  	break;  case XLinearGradientMode.ForwardDiagonal:  	x1 = brush.rect.x;  	y1 = brush.rect.y;  	x2 = brush.rect.x + brush.rect.width;  	y2 = brush.rect.y + brush.rect.height;  	break;  case XLinearGradientMode.BackwardDiagonal:  	x1 = brush.rect.x + brush.rect.width;  	y1 = brush.rect.y;  	x2 = brush.rect.x;  	y2 = brush.rect.y + brush.rect.height;  	break;  }  
Missing Default,PdfSharp.Pdf.Advanced,PdfTrueTypeFont,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfTrueTypeFont.cs,PdfTrueTypeFont,The following switch statement is missing a default case: switch (font.Style & (XFontStyle.Bold | XFontStyle.Italic)) {  case XFontStyle.Bold:  	BaseFont += "'Bold";  	break;  case XFontStyle.Italic:  	BaseFont += "'Italic";  	break;  case XFontStyle.Bold | XFontStyle.Italic:  	BaseFont += "'BoldItalic";  	break;  }  
Missing Default,PdfSharp.Pdf.Advanced,PdfType0Font,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Advanced\PdfType0Font.cs,PdfType0Font,The following switch statement is missing a default case: switch (font.Style & (XFontStyle.Bold | XFontStyle.Italic)) {  case XFontStyle.Bold:  	this.BaseFont += "'Bold";  	break;  case XFontStyle.Italic:  	this.BaseFont += "'Italic";  	break;  case XFontStyle.Bold | XFontStyle.Italic:  	this.BaseFont += "'BoldItalic";  	break;  }  
Missing Default,PdfSharp.Pdf.Annotations,PdfLinkAnnotation,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Annotations\PdfLinkAnnotation.cs,WriteObject,The following switch statement is missing a default case: switch (this.linkType) {  case LinkType.Document:  	// destIndex > Owner.PageCount can happen rendering pages using PDFsharp directly  	int destIndex = this.destPage;  	if (destIndex > Owner.PageCount)  		destIndex = Owner.PageCount;  	destIndex--;  	dest = this.Owner.Pages [destIndex];  	//pdf.AppendFormat("/Dest[{0} 0 R/XYZ null null 0]\n"' dest.ObjectID);  	Elements [Keys.Dest] = new PdfLiteral ("[{0} 0 R/XYZ null null 0]"' dest.ObjectNumber);  	break;  case LinkType.Web:  	//pdf.AppendFormat("/A<</S/URI/URI{0}>>\n"' PdfEncoders.EncodeAsLiteral(this.url));  	Elements [Keys.A] = new PdfLiteral ("<</S/URI/URI{0}>>"' //PdfEncoders.EncodeAsLiteral(this.url));  	PdfEncoders.ToStringLiteral (this.url' PdfStringEncoding.WinAnsiEncoding' writer.SecurityHandler));  	break;  case LinkType.File:  	//pdf.AppendFormat("/A<</Type/Action/S/Launch/F<</Type/Filespec/F{0}>> >>\n"'   	//  PdfEncoders.EncodeAsLiteral(this.url));  	Elements [Keys.A] = new PdfLiteral ("<</Type/Action/S/Launch/F<</Type/Filespec/F{0}>> >>"' //PdfEncoders.EncodeAsLiteral(this.url));  	PdfEncoders.ToStringLiteral (this.url' PdfStringEncoding.WinAnsiEncoding' writer.SecurityHandler));  	break;  }  
Missing Default,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,ScanNextToken,The following switch statement is missing a default case: switch (ch) {  case '%':  	// Eat comments' the parser doesn't handle them  	//return this.symbol = ScanComment();  	ScanComment ();  	goto Again;  case '/':  	return this.symbol = ScanName ();  //case 'R':  //  if (Lexer.IsWhiteSpace(this.nextChar))  //  {  //    ScanNextChar();  //    return Symbol.R;  //  }  //  break;  case '+':  case '-':  	return this.symbol = ScanNumber ();  case '[':  	ScanNextChar ();  	return this.symbol = CSymbol.BeginArray;  case ']':  	ScanNextChar ();  	return this.symbol = CSymbol.EndArray;  case '(':  	return this.symbol = ScanLiteralString ();  case '<':  	return this.symbol = ScanHexadecimalString ();  case '.':  	return this.symbol = ScanNumber ();  case '"':  case '\'':  	return this.symbol = ScanOperator ();  }  
Missing Default,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,IsWhiteSpace,The following switch statement is missing a default case: switch (ch) {  case Chars.NUL:  // 0 Null  case Chars.HT:  // 9 Tab  case Chars.LF:  // 10 Line feed  case Chars.FF:  // 12 Form feed  case Chars.CR:  // 13 Carriage return  case Chars.SP:  	// 32 Space  	return true;  }  
Missing Default,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,IsOperatorChar,The following switch statement is missing a default case: switch (ch) {  case Chars.Asterisk:  // *  case Chars.QuoteSingle:  // '  case Chars.QuoteDbl:  	// "  	return true;  }  
Missing Default,PdfSharp.Pdf.Content,CLexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CLexer.cs,IsDelimiter,The following switch statement is missing a default case: switch (ch) {  case '(':  case ')':  case '<':  case '>':  case '[':  case ']':  //case '{':  //case '}':  case '/':  case '%':  	return true;  }  
Missing Default,PdfSharp.Pdf.Content,ContentWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\ContentWriter.cs,WriteSeparator,The following switch statement is missing a default case: switch (this.lastCat) {  //case CharCat.NewLine:  //  if (this.layout == PdfWriterLayout.Verbose)  //    WriteIndent();  //  break;  case CharCat.Delimiter:  	break;  //case CharCat.Character:  //  if (this.layout == PdfWriterLayout.Verbose)  //  {  //    //if (cat == CharCat.Character || ch == '/')  //    this.stream.WriteByte((byte)' ');  //  }  //  else  //  {  //    if (cat == CharCat.Character)  //      this.stream.WriteByte((byte)' ');  //  }  //  break;  }  
Missing Default,PdfSharp.Pdf.Content,CParser,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Content\CParser.cs,ParseObject,The following switch statement is missing a default case: switch (symbol) {  case CSymbol.Comment:  	// ignore comments  	break;  case CSymbol.Integer:  	CInteger n = new CInteger ();  	n.Value = this.lexer.TokenToInteger;  	this.operands.Add (n);  	break;  case CSymbol.Real:  	CReal r = new CReal ();  	r.Value = this.lexer.TokenToReal;  	this.operands.Add (r);  	break;  case CSymbol.String:  case CSymbol.HexString:  case CSymbol.UnicodeString:  case CSymbol.UnicodeHexString:  	CString s = new CString ();  	s.Value = this.lexer.Token;  	this.operands.Add (s);  	break;  case CSymbol.Name:  	CName name = new CName ();  	name.Name = this.lexer.Token;  	this.operands.Add (name);  	break;  case CSymbol.Operator:  	COperator op = CreateOperator ();  	this.operands.Clear ();  	sequence.Add (op);  	break;  case CSymbol.BeginArray:  	CArray array = new CArray ();  	Debug.Assert (this.operands.Count == 0' "Array within array...");  	ParseObject (array' CSymbol.EndArray);  	array.Add (this.operands);  	this.operands.Clear ();  	this.operands.Add ((CObject)array);  	break;  case CSymbol.EndArray:  	throw new ContentReaderException ("Unexpected: ']'");  }  
Missing Default,PdfSharp.Pdf.Filters,Filtering,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Filters\Filtering.cs,GetFilter,The following switch statement is missing a default case: switch (filterName) {  case "ASCIIHexDecode":  case "AHx":  	if (Filtering.asciiHexDecode == null)  		Filtering.asciiHexDecode = new ASCIIHexDecode ();  	return Filtering.asciiHexDecode;  case "ASCII85Decode":  case "A85":  	if (Filtering.ascii85Decode == null)  		Filtering.ascii85Decode = new ASCII85Decode ();  	return Filtering.ascii85Decode;  case "LZWDecode":  case "LZW":  	if (Filtering.lzwDecode == null)  		Filtering.lzwDecode = new LzwDecode ();  	return Filtering.lzwDecode;  case "FlateDecode":  case "Fl":  	if (Filtering.flateDecode == null)  		Filtering.flateDecode = new FlateDecode ();  	return Filtering.flateDecode;  //case "RunLengthDecode":  //  if (Filtering.RunLengthDecode == null)  //    Filtering.RunLengthDecode = new RunLengthDecode();  //  return Filtering.RunLengthDecode;  //  //case "CCITTFaxDecode":  //  if (Filtering.CCITTFaxDecode == null)  //    Filtering.CCITTFaxDecode = new CCITTFaxDecode();  //  return Filtering.CCITTFaxDecode;  //  //case "JBIG2Decode":  //  if (Filtering.JBIG2Decode == null)  //    Filtering.JBIG2Decode = new JBIG2Decode();  //  return Filtering.JBIG2Decode;  //  //case "DCTDecode":  //  if (Filtering.DCTDecode == null)  //    Filtering.DCTDecode = new DCTDecode();  //  return Filtering.DCTDecode;  //  //case "JPXDecode":  //  if (Filtering.JPXDecode == null)  //    Filtering.JPXDecode = new JPXDecode();  //  return Filtering.JPXDecode;  //  //case "Crypt":  //  if (Filtering.Crypt == null)  //    Filtering.Crypt = new Crypt();  //  return Filtering.Crypt;  case "RunLengthDecode":  case "CCITTFaxDecode":  case "JBIG2Decode":  case "DCTDecode":  case "JPXDecode":  case "Crypt":  	Debug.WriteLine ("Filter not implemented: " + filterName.ToString ());  	return null;  }  
Missing Default,PdfSharp.Pdf.Internal,AnsiEncoding,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.Internal\AnsiEncoding.cs,IsAnsi1252Char,The following switch statement is missing a default case: switch (ch) {  case '\u20AC':  case '\u0081':  case '\u201A':  case '\u0192':  case '\u201E':  case '\u2026':  case '\u2020':  case '\u2021':  case '\u02C6':  case '\u2030':  case '\u0160':  case '\u2039':  case '\u0152':  case '\u008D':  case '\u017D':  case '\u008F':  case '\u0090':  case '\u2018':  case '\u2019':  case '\u201C':  case '\u201D':  case '\u2022':  case '\u2013':  case '\u2014':  case '\u02DC':  case '\u2122':  case '\u0161':  case '\u203A':  case '\u0153':  case '\u009D':  case '\u017E':  case '\u0178':  	return true;  }  
Missing Default,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanNextToken,The following switch statement is missing a default case: switch (ch) {  case '%':  	// Eat comments' the parser doesn't handle them  	//return this.symbol = ScanComment();  	ScanComment ();  	goto Again;  case '/':  	return this.symbol = ScanName ();  //case 'R':  //  if (Lexer.IsWhiteSpace(this.nextChar))  //  {  //    ScanNextChar();  //    return Symbol.R;  //  }  //  break;  case '+':  //TODO is it so easy?  case '-':  	return this.symbol = ScanNumber ();  case '(':  	return this.symbol = ScanLiteralString ();  case '[':  	ScanNextChar ();  	return this.symbol = Symbol.BeginArray;  case ']':  	ScanNextChar ();  	return this.symbol = Symbol.EndArray;  case '<':  	if (this.nextChar == '<') {  		ScanNextChar ();  		ScanNextChar ();  		return this.symbol = Symbol.BeginDictionary;  	}  	return this.symbol = ScanHexadecimalString ();  case '>':  	if (this.nextChar == '>') {  		ScanNextChar ();  		ScanNextChar ();  		return this.symbol = Symbol.EndDictionary;  	}  	Debug.Assert (false' ">???");  	break;  case '.':  	return this.symbol = ScanNumber ();  }  
Missing Default,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,ScanKeyword,The following switch statement is missing a default case: switch (this.token.ToString ()) {  case "obj":  	return this.symbol = Symbol.Obj;  case "endobj":  	return this.symbol = Symbol.EndObj;  case "null":  	return this.symbol = Symbol.Null;  case "true":  case "false":  	return this.symbol = Symbol.Boolean;  case "R":  	return this.symbol = Symbol.R;  case "stream":  	return this.symbol = Symbol.BeginStream;  case "endstream":  	return this.symbol = Symbol.EndStream;  case "xref":  	return this.symbol = Symbol.XRef;  case "trailer":  	return this.symbol = Symbol.Trailer;  case "startxref":  	return this.symbol = Symbol.StartXRef;  }  
Missing Default,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,IsWhiteSpace,The following switch statement is missing a default case: switch (ch) {  case Chars.NUL:  // 0 Null  case Chars.HT:  // 9 Tab  case Chars.LF:  // 10 Line feed  case Chars.FF:  // 12 Form feed  case Chars.CR:  // 13 Carriage return  case Chars.SP:  	// 32 Space  	return true;  }  
Missing Default,PdfSharp.Pdf.IO,Lexer,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\Lexer.cs,IsDelimiter,The following switch statement is missing a default case: switch (ch) {  case '(':  case ')':  case '<':  case '>':  case '[':  case ']':  case '{':  case '}':  case '/':  case '%':  	return true;  }  
Missing Default,PdfSharp.Pdf.IO,PdfWriter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.Pdf.IO\PdfWriter.cs,WriteSeparator,The following switch statement is missing a default case: switch (this.lastCat) {  case CharCat.NewLine:  	if (this.layout == PdfWriterLayout.Verbose)  		WriteIndent ();  	break;  case CharCat.Delimiter:  	break;  case CharCat.Character:  	if (this.layout == PdfWriterLayout.Verbose) {  		//if (cat == CharCat.Character || ch == '/')  		this.stream.WriteByte ((byte)' ');  	}  	else {  		if (cat == CharCat.Character)  			this.stream.WriteByte ((byte)' ');  	}  	break;  }  
Missing Default,PdfSharp.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (comprFunc) {  case DEFLATE_STORED:  	if (strstart > blockStart) {  		huffman.FlushStoredBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	UpdateHash ();  	break;  case DEFLATE_FAST:  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	break;  case DEFLATE_SLOW:  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  	break;  }  
Missing Default,PdfSharp.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp.SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Missing Default,PdfSharp,PageSizeConverter,C:\repos\GNOME_pdfmod\lib\PdfSharp\PdfSharp\PageSizeConverter.cs,ToSize,The following switch statement is missing a default case: switch (value) {  case PageSize.A0:  	return new XSize (2380' 3368);  case PageSize.A1:  	return new XSize (1684' 2380);  case PageSize.A2:  	return new XSize (1190' 1684);  case PageSize.A3:  	return new XSize (842' 1190);  case PageSize.A4:  	return new XSize (595' 842);  case PageSize.A5:  	return new XSize (420' 595);  case PageSize.RA0:  	return new XSize (2438' 3458);  case PageSize.RA1:  	return new XSize (1729' 2438);  case PageSize.RA2:  	return new XSize (1219' 1729);  case PageSize.RA3:  	return new XSize (865' 1219);  case PageSize.RA4:  	return new XSize (609' 865);  case PageSize.RA5:  	return new XSize (343' 609);  case PageSize.B0:  	return new XSize (2835' 4008);  case PageSize.B1:  	return new XSize (2004' 2835);  case PageSize.B2:  	return new XSize (4252' 1417);  case PageSize.B3:  	return new XSize (1001' 1417);  case PageSize.B4:  	return new XSize (729' 1032);  case PageSize.B5:  	return new XSize (516' 729);  // The strange sizes from overseas...  case PageSize.Quarto:  	// 8 x 10 inch�  	return new XSize (576' 720);  case PageSize.Foolscap:  	// 8 x 13 inch�  	return new XSize (576' 936);  case PageSize.Executive:  	// 7.5 x 10 inch�  	return new XSize (540' 720);  case PageSize.GovernmentLetter:  	// 10.5 x 8 inch�  	return new XSize (756' 576);  case PageSize.Letter:  	// 8.5 x 11 inch�  	return new XSize (612' 792);  case PageSize.Legal:  	// 8.5 x 14 inch  	return new XSize (612' 1008);  case PageSize.Ledger:  	// 17 x 11 inch�  	return new XSize (1224' 792);  case PageSize.Tabloid:  	// 11 x 17 inch�  	return new XSize (792' 1224);  case PageSize.Post:  	// 15.5 x 19.25 inch�  	return new XSize (1126' 1386);  case PageSize.Crown:  	// 20 x 15 inch�  	return new XSize (1440' 1080);  case PageSize.LargePost:  	// 16.5 x 21 inch�  	return new XSize (1188' 1512);  case PageSize.Demy:  	// 17.5 x 22 inch�  	return new XSize (1260' 1584);  case PageSize.Medium:  	// 18 x 23 inch�  	return new XSize (1296' 1656);  case PageSize.Royal:  	// 20 x 25 inch�  	return new XSize (1440' 1800);  case PageSize.Elephant:  	// 23 x 28 inch�  	return new XSize (1565' 2016);  case PageSize.DoubleDemy:  	// 23.5 x 35 inch�  	return new XSize (1692' 2520);  case PageSize.QuadDemy:  	// 35 x 45 inch�  	return new XSize (2520' 3240);  case PageSize.STMT:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Folio:  	// 8.5 x 13 inch�  	return new XSize (612' 936);  case PageSize.Statement:  	// 5.5 x 8.5 inch�  	return new XSize (396' 612);  case PageSize.Size10x14:  	// 8.5 x 13 inch�  	return new XSize (720' 1008);  }  
