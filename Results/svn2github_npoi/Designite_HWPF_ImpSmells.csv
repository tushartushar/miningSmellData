Implementation smell,Namespace,Class,File,Method,Description
Long Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The method has 261 lines of code.
Long Method,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has 152 lines of code.
Long Method,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The method has 184 lines of code.
Long Method,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,The method has 170 lines of code.
Long Method,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The method has 139 lines of code.
Long Method,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The method has 135 lines of code.
Long Method,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,ToString,The method has 204 lines of code.
Long Method,NPOI.HWPF.Model.Types,PAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\PAPAbstractType.cs,ToString,The method has 163 lines of code.
Long Method,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The method has 249 lines of code.
Long Method,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The method has 472 lines of code.
Long Method,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The method has 340 lines of code.
Long Method,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The method has 295 lines of code.
Long Method,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The method has 197 lines of code.
Long Method,NPOI.HWPF.SPRM,SectionSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,The method has 159 lines of code.
Long Method,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The method has 184 lines of code.
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,Cyclomatic complexity of the method is 41
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraphes,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessTable,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,DefaultFontReplacer,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\DefaultFontReplacer.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF.Converter,NumberFormatter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\NumberFormatter.cs,ToLetters,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,Cyclomatic complexity of the method is 23
Complex Method,NPOI.HWPF.Model,Ffn,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Ffn.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.Model,ListTables,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,Cyclomatic complexity of the method is 19
Complex Method,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,Cyclomatic complexity of the method is 57
Complex Method,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,Cyclomatic complexity of the method is 64
Complex Method,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,Cyclomatic complexity of the method is 47
Complex Method,NPOI.HWPF.SPRM,TableSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.UserModel,OfficeDrawingsImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetBitmapRecord,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.UserModel,Range,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Range.cs,GetTable,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.UserModel,Range,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Range.cs,FindRange,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.UserModel,TableRow,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\TableRow.cs,initCells,Cyclomatic complexity of the method is 8
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,getTableCellEdgesIndexSkipCount,The method has 6 parameters. Parameters: table' r' tableCellEdges' currentEdgeIndex' c' tableCell
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The method has 7 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' beginMark' separatorMark' endMark
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The method has 5 parameters. Parameters: wordDocument' charactersRange' currentTableLevel' startOffset' currentBlock
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The method has 5 parameters. Parameters: wordDocument' parentRange' currentTableLevel' field' currentBlock
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: wordDocument' parentElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,The method has 5 parameters. Parameters: wordDocument' range' currentTableLevel' beginMark' currentBlock
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: hwpfDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: hwpfDocument' parentFopElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The method has 7 parameters. Parameters: tableRow' tableCell' XmlElement' toppest' bottomest' leftest' rightest
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: wordDocument' parentElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessNoteAutonumbered,The method has 5 parameters. Parameters: wordDocument' type' noteIndex' block' noteTextRange
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: wordDocument' parentElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The method has 7 parameters. Parameters: tableRow' tableCell' toppest' bottomest' leftest' rightest' style
Long Parameter List,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The method has 6 parameters. Parameters: documentStream' tableStream' offset' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The method has 5 parameters. Parameters: documentStream' tableStream' offset' size' translator
Long Parameter List,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The method has 5 parameters. Parameters: mainStream' offset' tableStream' offsetList' areKnown
Long Parameter List,NPOI.HWPF.Model,ListLevel,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,ListLevel,The method has 6 parameters. Parameters: startAt' numberFormatCode' alignment' numberProperties' entryProperties' numberText
Long Parameter List,NPOI.HWPF.Model,OldCHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldCHPBinTable.cs,OldCHPBinTable,The method has 5 parameters. Parameters: documentStream' OffSet' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,OldPAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldPAPBinTable.cs,OldPAPBinTable,The method has 5 parameters. Parameters: documentStream' OffSet' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,OldSectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The method has 5 parameters. Parameters: documentStream' offset' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The method has 7 parameters. Parameters: documentStream' tableStream' dataStream' offset' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The method has 6 parameters. Parameters: documentStream' tableStream' dataStream' offset' size' charIndexTranslator
Long Parameter List,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,PAPFormattedDiskPage,The method has 5 parameters. Parameters: documentStream' dataStream' offset' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 6 parameters. Parameters: fcStart' fcEnd' translator' papx' phe' dataStream
Long Parameter List,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 5 parameters. Parameters: charStart' charEnd' papx' phe' dataStream
Long Parameter List,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 5 parameters. Parameters: fcStart' fcEnd' translator' buf' dataStream
Long Parameter List,NPOI.HWPF.Model,PicturesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,PicturesTable,The method has 5 parameters. Parameters: _document' _dataStream' _mainStream' fspa' dgg
Long Parameter List,NPOI.HWPF.Model,SectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,SectionTable,The method has 7 parameters. Parameters: documentStream' tableStream' OffSet' size' fcMin' tpt' cps
Long Parameter List,NPOI.HWPF.Model,TextPiece,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPiece.cs,TextPiece,The method has 5 parameters. Parameters: start' end' text' pd' cpStart
Long Parameter List,NPOI.HWPF.Model,TextPieceTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The method has 5 parameters. Parameters: documentStream' tableStream' offset' size' fcMin
Long Parameter List,NPOI.HWPF.UserModel,TableCell,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\TableCell.cs,TableCell,The method has 7 parameters. Parameters: startIdx' endIdx' parent' levelNum' tcd' leftEdge' width
Long Identifier,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,,The length of the parameter SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE is 40.
Long Identifier,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,,The length of the parameter UNICODECHAR_NONBREAKING_HYPHEN is 30.
Long Identifier,NPOI.HWPF.Model,PicturesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,,The length of the parameter TYPE_IMAGE_PASTED_FROM_CLIPBOARD is 32.
Long Identifier,NPOI.HWPF.Model,PicturesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,,The length of the parameter TYPE_IMAGE_PASTED_FROM_CLIPBOARD_WORD2000 is 41.
Long Identifier,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,,The length of the parameter oldfSuppressSpbfAfterPageBreak is 30.
Long Identifier,NPOI.HWPF.Model.Types,HRESIAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\HRESIAbstractType.cs,,The length of the parameter HRES_DELETE_BEFORE_CHANGE_BEFORE is 32.
Long Identifier,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,,The length of the parameter fHtmlHangingIndentBeneathNumber is 31.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "                    IEnumerator<List<Bookmark>> iterator = ((HWPFDocument)wordDocument).GetBookmarks().GetBookmarksStartedBetween(structure.Start' structure.Start + 1).Values.GetEnumerator(); " is 171.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessOle2,The length of the statement  "                logger.Log(POILogger.WARN' "Referenced OLE2 object '"' (characterRun.GetPicOffset()).ToString()' "' not found in ObjectPool"); " is 126.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "                htmlDocumentFacade.AddStyleClass(root' "d"' "vertical-align:text-bottom;width:" + visibleWidth + "in;height:" + visibleHeight + "in;"); " is 135.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "                htmlDocumentFacade.AddStyleClass(inner' "d"' "position:relative;width:" + visibleWidth + "in;height:" + visibleHeight + "in;overflow:hidden;"); " is 143.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "                htmlDocumentFacade.AddStyleClass(image' "i"' "position:absolute;left:-" + cropLeft + ";top:-" + cropTop + ";width:" + imageWidth + "in;height:" + imageHeight + "in;"); " is 167.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "                    WordToHtmlUtils.AddTableCellProperties(tableRow' tableCell' r == 0' r == tableRows - 1' c == 0' c == rowCells - 1' tableCellStyle); " is 131.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "                            htmlDocumentFacade.GetOrCreateCssClass(tableElement.LocalName' "t"' "table-layout:fixed;border-collapse:collapse;border-spacing:0;")); " is 134.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "                logger.Log(POILogger.WARN' "Table without body starting at ["' table.StartOffset.ToString()' "; "' table.EndOffset.ToString()' ")"); " is 132.
Long Statement,NPOI.HWPF.Model,ListTables,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,GetLevel,The length of the statement  "            //log.log(POILogger.WARN' "Requested level " + level + " which was greater than the maximum defined (" + lst.numLevels() + ")"); " is 128.
Long Statement,NPOI.HWPF.Model,PicturesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,IsPictureRecognized,The length of the statement  "            return (blockType == TYPE_IMAGE || blockType == TYPE_IMAGE_PASTED_FROM_CLIPBOARD || (blockType == TYPE_IMAGE_WORD2000 && mappingModeOfMETAFILEPICT == 0x64) || (blockType == TYPE_IMAGE_PASTED_FROM_CLIPBOARD_WORD2000 && mappingModeOfMETAFILEPICT == 0x64)); " is 254.
Long Statement,NPOI.HWPF.Model,SectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,WriteTo,The length of the statement  "                GenericPropertyNode property = new GenericPropertyNode(tpt.GetCharIndex(sepx.StartBytes)' tpt.GetCharIndex(sepx.EndBytes)' sed.ToArray()); " is 138.
Long Statement,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The length of the statement  "                            throw new InvalidOperationException("Pap style " + istd + " claimed to have itself as its parent' which isn't allowed"); " is 120.
Long Statement,NPOI.HWPF.Model,TextPiece,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPiece.cs,Substring,The length of the statement  "                throw new IndexOutOfRangeException("Asked for text from " + start + " to " + end + "' which has an end before the start!"); " is 123.
Long Statement,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The length of the statement  "            return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4; " is 183.
Long Statement,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,ToString,The length of the statement  "            buffer.Append("         .oldfSuppressSpbfAfterPageBreak     = ").Append(IsOldfSuppressSpbfAfterPageBreak()).Append('\n'); " is 121.
Long Statement,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The length of the statement  "            return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2; " is 227.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The length of the statement  "            int PICTFBlockSize = LittleEndian.GetShort(_dataStream' dataBlockStartOffset + PICT_HEADER_OFFSET); // Should be 68 bytes " is 121.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The length of the statement  "            int unknownHeaderOffset = (PICTF1BlockSize + PICTF1BlockOffset) < dataBlockEndOffset ? (PICTF1BlockSize + PICTF1BlockOffset) : PICTF1BlockOffset; " is 145.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The length of the statement  "                    else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) " is 121.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The length of the statement  "            return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF)); " is 138.
Complex Conditional,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,AddToStructures,The conditional expression  "(structure.Start < another.Start && another.Start < structure.End)                          || (structure.Start < another.Start && another.End <= structure.End)                          || (structure.Start <= another.Start && another.End < structure.End)"  is complex.
Complex Conditional,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The conditional expression  "charChar >= 0x20 || charChar == 0x09                                  || charChar == 0x0A || charChar == 0x0D"  is complex.
Complex Conditional,NPOI.HWPF.Converter,FoDocumentFacade,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\FoDocumentFacade.cs,SetProperty,The conditional expression  "!string.IsNullOrEmpty(childElement.NamespaceURI)                              && !string.IsNullOrEmpty(childElement.LocalName)                              && ns.Equals(childElement.NamespaceURI)                              && name.Equals(childElement.LocalName)"  is complex.
Complex Conditional,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The conditional expression  "picture.DyaCropTop != 0 || picture.DxaCropRight != 0                      || picture.DyaCropBottom != 0                      || picture.DxaCropLeft != 0"  is complex.
Complex Conditional,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The conditional expression  "cropTop != 0 || cropRight != 0 || cropBottom != 0 || cropLeft != 0"  is complex.
Complex Conditional,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The conditional expression  "first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f'"  is complex.
Complex Conditional,NPOI.HWPF.Model,FileInformationBlock,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FileInformationBlock.cs,ToString,The conditional expression  "!method.Name.StartsWith("get")                              || !method.IsPublic                              || method.IsStatic                              || method.GetParameters().Length > 0"  is complex.
Complex Conditional,NPOI.HWPF.Model,PicturesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,HasPicture,The conditional expression  "run.IsSpecialCharacter() && !run.IsObj() && !run.IsOle2() && !run.IsData()"  is complex.
Complex Conditional,NPOI.HWPF.Model,PicturesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,HasEscherPicture,The conditional expression  "run.IsSpecialCharacter() && !run.IsObj() && !run.IsOle2() && !run.IsData() && run.Text.StartsWith("\u0008")"  is complex.
Complex Conditional,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,Equals,The conditional expression  "sd._infoshort == _infoshort && sd._infoshort2 == _infoshort2 &&                  sd._infoshort3 == _infoshort3 && sd._bchUpe == _bchUpe &&                  sd._infoshort4 == _infoshort4 &&                  _name.Equals(sd._name)"  is complex.
Complex Conditional,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The conditional expression  "ss._baseLength == _baseLength && ss._flags == _flags &&                  ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex &&                  ss._rgftc[0] == _rgftc[0] && ss._rgftc[1] == _rgftc[1] &&                  ss._rgftc[2] == _rgftc[2] && ss._stshiLength == _stshiLength &&                  ss._stylenameVersion == _stylenameVersion"  is complex.
Complex Conditional,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The conditional expression  "fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The conditional expression  "(secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,Range,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Range.cs,FindRange,The conditional expression  "startIndex < 0 || startIndex >= rpl.Count                      || startIndex > endIndex || endIndex < 0                      || endIndex >= rpl.Count"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,TableRow,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The conditional expression  "( ( s.Length > 0 && s[s.Length - 1]== TABLE_CELL_MARK ) || paragraph                      .IsEmbeddedCellMark() )                      && paragraph.GetTableLevel() == _levelNum"  is complex.
Virtual Method Call from Constructor,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The constructor "HWPFDocument" calls a virtual method "Read".
Virtual Method Call from Constructor,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The constructor "HWPFDocument" calls a virtual method "Read".
Virtual Method Call from Constructor,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,HWPFDocumentCore,The constructor "HWPFDocumentCore" calls a virtual method "Read".
Empty Catch Block,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAP,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The method has an empty catch block.
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: for (int c = 0; c < range.NumCharacterRuns; c++)              {                  CharacterRun characterRun = range.GetCharacterRun(c);                    if (characterRun == null)                      throw new NullReferenceException();                    if (wordDocument is HWPFDocument && ((HWPFDocument)wordDocument).GetPicturesTable().HasPicture(characterRun))                  {                      HWPFDocument newFormat = (HWPFDocument)wordDocument;                      Picture picture = newFormat.GetPicturesTable().ExtractPicture(characterRun' true);                        ProcessImage(block' characterRun.Text[0] == 0x01' picture);                      continue;                  }                    string text = characterRun.Text;                  byte[] textByte = System.Text.Encoding.GetEncoding("iso-8859-1").GetBytes(text);                  //if ( text.getBytes().length == 0 )                  if (textByte.Length == 0)                      continue;                    if (characterRun.IsSpecialCharacter())                  {                      if (text[0] == SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessNoteAnchor(doc' characterRun' block);                          continue;                      }                      if (text[0] == SPECCHAR_DRAWN_OBJECT                              && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessDrawnObject(doc' characterRun' block);                          continue;                      }                      if (characterRun.IsOle2() && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessOle2(doc' characterRun' block);                          continue;                      }                  }                  if (textByte[0] == FIELD_BEGIN_MARK)                  //if ( text.getBytes()[0] == FIELD_BEGIN_MARK )                  {                      if (wordDocument is HWPFDocument)                      {                          Field aliveField = ((HWPFDocument)wordDocument).GetFields().GetFieldByStartOffset(                                          FieldsDocumentPart.MAIN' characterRun.StartOffset);                          if (aliveField != null)                          {                              ProcessField(((HWPFDocument)wordDocument)' range'                                      currentTableLevel' aliveField' block);                                int continueAfter = aliveField.GetFieldEndOffset();                              while (c < range.NumCharacterRuns                                      && range.GetCharacterRun(c).EndOffset <= continueAfter)                                  c++;                                if (c < range.NumCharacterRuns)                                  c--;                                continue;                          }                      }                        int skipTo = TryDeadField(wordDocument' range'                              currentTableLevel' c' block);                        if (skipTo != c)                      {                          c = skipTo;                          continue;                      }                        continue;                  }                  if (textByte[0] == FIELD_SEPARATOR_MARK)                  {                      // shall not appear without FIELD_BEGIN_MARK                      continue;                  }                  if (textByte[0] == FIELD_END_MARK)                  {                      // shall not appear without FIELD_BEGIN_MARK                      continue;                  }                    if (characterRun.IsSpecialCharacter() || characterRun.IsObj()                          || characterRun.IsOle2())                  {                      continue;                  }                    if (text.EndsWith("\r")                          || (text[text.Length - 1] == BEL_MARK && currentTableLevel != int.MinValue))                      text = text.Substring(0' text.Length - 1);                    {                      // line breaks                      StringBuilder stringBuilder = new StringBuilder();                      foreach (char charChar in text.ToCharArray())                      {                          if (charChar == 11)                          {                              if (stringBuilder.Length > 0)                              {                                  OutputCharacters(block' characterRun'                                          stringBuilder.ToString());                                  stringBuilder.Length = 0;                              }                              ProcessLineBreak(block' characterRun);                          }                          else if (charChar == 30)                          {                              // Non-breaking hyphens are stored as ASCII 30                              stringBuilder.Append(UNICODECHAR_NONBREAKING_HYPHEN);                          }                          else if (charChar == 31)                          {                              // Non-required hyphens to zero-width space                              stringBuilder.Append(UNICODECHAR_ZERO_WIDTH_SPACE);                          }                          else if (charChar >= 0x20 || charChar == 0x09                                  || charChar == 0x0A || charChar == 0x0D)                          {                              stringBuilder.Append(charChar);                          }                      }                      if (stringBuilder.Length > 0)                      {                          OutputCharacters(block' characterRun'                                  stringBuilder.ToString());                          stringBuilder.Length = 0;                      }                  }                    haveAnyText |= text.Trim().Length != 0;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: for (int c = 0; c < range.NumCharacterRuns; c++)              {                  CharacterRun characterRun = range.GetCharacterRun(c);                    if (characterRun == null)                      throw new NullReferenceException();                    if (wordDocument is HWPFDocument && ((HWPFDocument)wordDocument).GetPicturesTable().HasPicture(characterRun))                  {                      HWPFDocument newFormat = (HWPFDocument)wordDocument;                      Picture picture = newFormat.GetPicturesTable().ExtractPicture(characterRun' true);                        ProcessImage(block' characterRun.Text[0] == 0x01' picture);                      continue;                  }                    string text = characterRun.Text;                  byte[] textByte = System.Text.Encoding.GetEncoding("iso-8859-1").GetBytes(text);                  //if ( text.getBytes().length == 0 )                  if (textByte.Length == 0)                      continue;                    if (characterRun.IsSpecialCharacter())                  {                      if (text[0] == SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessNoteAnchor(doc' characterRun' block);                          continue;                      }                      if (text[0] == SPECCHAR_DRAWN_OBJECT                              && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessDrawnObject(doc' characterRun' block);                          continue;                      }                      if (characterRun.IsOle2() && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessOle2(doc' characterRun' block);                          continue;                      }                  }                  if (textByte[0] == FIELD_BEGIN_MARK)                  //if ( text.getBytes()[0] == FIELD_BEGIN_MARK )                  {                      if (wordDocument is HWPFDocument)                      {                          Field aliveField = ((HWPFDocument)wordDocument).GetFields().GetFieldByStartOffset(                                          FieldsDocumentPart.MAIN' characterRun.StartOffset);                          if (aliveField != null)                          {                              ProcessField(((HWPFDocument)wordDocument)' range'                                      currentTableLevel' aliveField' block);                                int continueAfter = aliveField.GetFieldEndOffset();                              while (c < range.NumCharacterRuns                                      && range.GetCharacterRun(c).EndOffset <= continueAfter)                                  c++;                                if (c < range.NumCharacterRuns)                                  c--;                                continue;                          }                      }                        int skipTo = TryDeadField(wordDocument' range'                              currentTableLevel' c' block);                        if (skipTo != c)                      {                          c = skipTo;                          continue;                      }                        continue;                  }                  if (textByte[0] == FIELD_SEPARATOR_MARK)                  {                      // shall not appear without FIELD_BEGIN_MARK                      continue;                  }                  if (textByte[0] == FIELD_END_MARK)                  {                      // shall not appear without FIELD_BEGIN_MARK                      continue;                  }                    if (characterRun.IsSpecialCharacter() || characterRun.IsObj()                          || characterRun.IsOle2())                  {                      continue;                  }                    if (text.EndsWith("\r")                          || (text[text.Length - 1] == BEL_MARK && currentTableLevel != int.MinValue))                      text = text.Substring(0' text.Length - 1);                    {                      // line breaks                      StringBuilder stringBuilder = new StringBuilder();                      foreach (char charChar in text.ToCharArray())                      {                          if (charChar == 11)                          {                              if (stringBuilder.Length > 0)                              {                                  OutputCharacters(block' characterRun'                                          stringBuilder.ToString());                                  stringBuilder.Length = 0;                              }                              ProcessLineBreak(block' characterRun);                          }                          else if (charChar == 30)                          {                              // Non-breaking hyphens are stored as ASCII 30                              stringBuilder.Append(UNICODECHAR_NONBREAKING_HYPHEN);                          }                          else if (charChar == 31)                          {                              // Non-required hyphens to zero-width space                              stringBuilder.Append(UNICODECHAR_ZERO_WIDTH_SPACE);                          }                          else if (charChar >= 0x20 || charChar == 0x09                                  || charChar == 0x0A || charChar == 0x0D)                          {                              stringBuilder.Append(charChar);                          }                      }                      if (stringBuilder.Length > 0)                      {                          OutputCharacters(block' characterRun'                                  stringBuilder.ToString());                          stringBuilder.Length = 0;                      }                  }                    haveAnyText |= text.Trim().Length != 0;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: for (int c = 0; c < range.NumCharacterRuns; c++)              {                  CharacterRun characterRun = range.GetCharacterRun(c);                    if (characterRun == null)                      throw new NullReferenceException();                    if (wordDocument is HWPFDocument && ((HWPFDocument)wordDocument).GetPicturesTable().HasPicture(characterRun))                  {                      HWPFDocument newFormat = (HWPFDocument)wordDocument;                      Picture picture = newFormat.GetPicturesTable().ExtractPicture(characterRun' true);                        ProcessImage(block' characterRun.Text[0] == 0x01' picture);                      continue;                  }                    string text = characterRun.Text;                  byte[] textByte = System.Text.Encoding.GetEncoding("iso-8859-1").GetBytes(text);                  //if ( text.getBytes().length == 0 )                  if (textByte.Length == 0)                      continue;                    if (characterRun.IsSpecialCharacter())                  {                      if (text[0] == SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessNoteAnchor(doc' characterRun' block);                          continue;                      }                      if (text[0] == SPECCHAR_DRAWN_OBJECT                              && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessDrawnObject(doc' characterRun' block);                          continue;                      }                      if (characterRun.IsOle2() && (wordDocument is HWPFDocument))                      {                          HWPFDocument doc = (HWPFDocument)wordDocument;                          ProcessOle2(doc' characterRun' block);                          continue;                      }                  }                  if (textByte[0] == FIELD_BEGIN_MARK)                  //if ( text.getBytes()[0] == FIELD_BEGIN_MARK )                  {                      if (wordDocument is HWPFDocument)                      {                          Field aliveField = ((HWPFDocument)wordDocument).GetFields().GetFieldByStartOffset(                                          FieldsDocumentPart.MAIN' characterRun.StartOffset);                          if (aliveField != null)                          {                              ProcessField(((HWPFDocument)wordDocument)' range'                                      currentTableLevel' aliveField' block);                                int continueAfter = aliveField.GetFieldEndOffset();                              while (c < range.NumCharacterRuns                                      && range.GetCharacterRun(c).EndOffset <= continueAfter)                                  c++;                                if (c < range.NumCharacterRuns)                                  c--;                                continue;                          }                      }                        int skipTo = TryDeadField(wordDocument' range'                              currentTableLevel' c' block);                        if (skipTo != c)                      {                          c = skipTo;                          continue;                      }                        continue;                  }                  if (textByte[0] == FIELD_SEPARATOR_MARK)                  {                      // shall not appear without FIELD_BEGIN_MARK                      continue;                  }                  if (textByte[0] == FIELD_END_MARK)                  {                      // shall not appear without FIELD_BEGIN_MARK                      continue;                  }                    if (characterRun.IsSpecialCharacter() || characterRun.IsObj()                          || characterRun.IsOle2())                  {                      continue;                  }                    if (text.EndsWith("\r")                          || (text[text.Length - 1] == BEL_MARK && currentTableLevel != int.MinValue))                      text = text.Substring(0' text.Length - 1);                    {                      // line breaks                      StringBuilder stringBuilder = new StringBuilder();                      foreach (char charChar in text.ToCharArray())                      {                          if (charChar == 11)                          {                              if (stringBuilder.Length > 0)                              {                                  OutputCharacters(block' characterRun'                                          stringBuilder.ToString());                                  stringBuilder.Length = 0;                              }                              ProcessLineBreak(block' characterRun);                          }                          else if (charChar == 30)                          {                              // Non-breaking hyphens are stored as ASCII 30                              stringBuilder.Append(UNICODECHAR_NONBREAKING_HYPHEN);                          }                          else if (charChar == 31)                          {                              // Non-required hyphens to zero-width space                              stringBuilder.Append(UNICODECHAR_ZERO_WIDTH_SPACE);                          }                          else if (charChar >= 0x20 || charChar == 0x09                                  || charChar == 0x0A || charChar == 0x0D)                          {                              stringBuilder.Append(charChar);                          }                      }                      if (stringBuilder.Length > 0)                      {                          OutputCharacters(block' characterRun'                                  stringBuilder.ToString());                          stringBuilder.Length = 0;                      }                  }                    haveAnyText |= text.Trim().Length != 0;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: int pt = lineWidth / 8;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: int pte = lineWidth - pt * 8;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: stringBuilder.Append(1000 / 8 * pte);
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: stringBuilder.Append(1000 / 8 * pte);
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBulletText,The following statement contains a magic number: foreach (char element in xst)              {                  if (element < 9)//todo:review_antony                  {                      ListLevel numLevel = listTables.GetLevel(listId' element);                        int num = numLevel.GetStartAt();                      bulletBuffer.Append(NumberFormatter.GetNumber(num'                              listLevel.GetNumberFormat()));                        if (numLevel == listLevel)                      {                          numLevel.SetStartAt(numLevel.GetStartAt() + 1);                      }                    }                  else                  {                      bulletBuffer.Append(element);                  }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetOpacity,The following statement contains a magic number: int opacity = (int)((argbValue & 0xFF000000L) >> 24);
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: int rgbValue = (bgrValue & 0x0000FF) << 16 | (bgrValue & 0x00FF00)                      | (bgrValue & 0xFF0000) >> 16;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: int rgbValue = (bgrValue & 0x0000FF) << 16 | (bgrValue & 0x00FF00)                      | (bgrValue & 0xFF0000) >> 16;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: for (int i = hex.Length; i < 6; i++)              {                  result.Append('0');              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,OutputCharacters,The following statement contains a magic number: WordToFoUtils.SetFontSize(inline' characterRun.GetFontSize() / 2);
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: int opacity = (int)(characterRun.GetIco24() & 0xFF000000L) >> 24;
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: if (characterRun.IsShadowed())              {                  inline.SetAttribute("text-shadow"' characterRun.GetFontSize() / 24 + "pt");              }
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: if (characterRun.GetSubSuperScriptIndex() == 2)              {                  inline.SetAttribute("baseline-shift"' "sub");                  inline.SetAttribute("font-size"' "smaller");              }
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: if (horizontalScale > 0)              {                  graphicXmlElement                          .SetAttribute("content-width"' ((picture.DxaGoal                                  * horizontalScale / 1000) / TWIPS_PER_PT)                                  + "pt");              }              else                  graphicXmlElement.SetAttribute("content-width"'                          (picture.DxaGoal / TWIPS_PER_PT) + "pt");
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: if (verticalScale > 0)                  graphicXmlElement                          .SetAttribute("content-height"' ((picture.DyaGoal                                  * verticalScale / 1000) / TWIPS_PER_PT)                                  + "pt");              else                  graphicXmlElement.SetAttribute("content-height"'                          (picture.DyaGoal / TWIPS_PER_PT) + "pt");
Magic Number,NPOI.HWPF.Converter,NumberFormatter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\NumberFormatter.cs,ToLetters,The following statement contains a magic number: int letterBase = 26;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: if (characterRun.GetFontSize() / 2 != blockProperies.pFontSize)              {                  style.Append("font-size:" + characterRun.GetFontSize() / 2 + "pt;");              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: if (characterRun.GetFontSize() / 2 != blockProperies.pFontSize)              {                  style.Append("font-size:" + characterRun.GetFontSize() / 2 + "pt;");              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioX > 0)              {                  imageWidth = picture.DxaGoal * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropRight = picture.DxaCropRight * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropLeft = picture.DxaCropLeft * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;              }              else              {                  imageWidth = picture.DxaGoal / AbstractWordUtils.TWIPS_PER_INCH;                  cropRight = picture.DxaCropRight / AbstractWordUtils.TWIPS_PER_INCH;                  cropLeft = picture.DxaCropLeft / AbstractWordUtils.TWIPS_PER_INCH;              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioX > 0)              {                  imageWidth = picture.DxaGoal * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropRight = picture.DxaCropRight * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropLeft = picture.DxaCropLeft * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;              }              else              {                  imageWidth = picture.DxaGoal / AbstractWordUtils.TWIPS_PER_INCH;                  cropRight = picture.DxaCropRight / AbstractWordUtils.TWIPS_PER_INCH;                  cropLeft = picture.DxaCropLeft / AbstractWordUtils.TWIPS_PER_INCH;              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioX > 0)              {                  imageWidth = picture.DxaGoal * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropRight = picture.DxaCropRight * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropLeft = picture.DxaCropLeft * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;              }              else              {                  imageWidth = picture.DxaGoal / AbstractWordUtils.TWIPS_PER_INCH;                  cropRight = picture.DxaCropRight / AbstractWordUtils.TWIPS_PER_INCH;                  cropLeft = picture.DxaCropLeft / AbstractWordUtils.TWIPS_PER_INCH;              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioY > 0)              {                  imageHeight = picture.DyaGoal * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropTop = picture.DyaCropTop * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropBottom = picture.DyaCropBottom * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;              }              else              {                  imageHeight = picture.DyaGoal / AbstractWordUtils.TWIPS_PER_INCH;                  cropTop = picture.DyaCropTop / AbstractWordUtils.TWIPS_PER_INCH;                  cropBottom = picture.DyaCropBottom / AbstractWordUtils.TWIPS_PER_INCH;              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioY > 0)              {                  imageHeight = picture.DyaGoal * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropTop = picture.DyaCropTop * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropBottom = picture.DyaCropBottom * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;              }              else              {                  imageHeight = picture.DyaGoal / AbstractWordUtils.TWIPS_PER_INCH;                  cropTop = picture.DyaCropTop / AbstractWordUtils.TWIPS_PER_INCH;                  cropBottom = picture.DyaCropBottom / AbstractWordUtils.TWIPS_PER_INCH;              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioY > 0)              {                  imageHeight = picture.DyaGoal * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropTop = picture.DyaCropTop * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;                  cropBottom = picture.DyaCropBottom * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;              }              else              {                  imageHeight = picture.DyaGoal / AbstractWordUtils.TWIPS_PER_INCH;                  cropTop = picture.DyaCropTop / AbstractWordUtils.TWIPS_PER_INCH;                  cropBottom = picture.DyaCropBottom / AbstractWordUtils.TWIPS_PER_INCH;              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The following statement contains a magic number: {                  String pFontName;                  int pFontSize;                  CharacterRun characterRun = paragraph.GetCharacterRun(0);                  if (characterRun != null)                  {                      Triplet triplet = GetCharacterRunTriplet(characterRun);                      pFontSize = characterRun.GetFontSize() / 2;                      pFontName = triplet.fontName;                      WordToHtmlUtils.AddFontFamily(pFontName' style);                      WordToHtmlUtils.AddFontSize(pFontSize' style);                  }                  else                  {                      pFontSize = -1;                      pFontName = string.Empty;                  }                  blocksProperies.Push(new BlockProperies(pFontName' pFontSize));              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddBorder,The following statement contains a magic number: if (borderCode.LineWidth < 8)                  style.Append("thin");              else                  style.Append(GetBorderWidth(borderCode));
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: if (characterRun.IsShadowed())              {                  style.Append("text-shadow:" + characterRun.GetFontSize() / 24 + "pt;");              }
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: if (characterRun.GetSubSuperScriptIndex() == 2)              {                  style.Append("vertical-align:sub;");                  style.Append("font-size:smaller;");              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The following statement contains a magic number: if (_fib.GetNFib() < 106)              {                  throw new OldWordFileFormatException("The document is too old - Word 95 or older. Try HWPFOldDocument instead?");              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (mainBuf.Length < 4096)              {                  byte[] tempBuf = new byte[4096];                  Array.Copy(mainBuf' 0' tempBuf' 0' mainBuf.Length);                  mainBuf = tempBuf;              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (mainBuf.Length < 4096)              {                  byte[] tempBuf = new byte[4096];                  Array.Copy(mainBuf' 0' tempBuf' 0' mainBuf.Length);                  mainBuf = tempBuf;              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (tableBuf.Length < 4096)              {                  byte[] tempBuf = new byte[4096];                  Array.Copy(tableBuf' 0' tempBuf' 0' tableBuf.Length);                  tableBuf = tempBuf;              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (tableBuf.Length < 4096)              {                  byte[] tempBuf = new byte[4096];                  Array.Copy(tableBuf' 0' tempBuf' 0' tableBuf.Length);                  tableBuf = tempBuf;              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (dataBuf == null)              {                  dataBuf = new byte[4096];              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (dataBuf.Length < 4096)              {                  byte[] tempBuf = new byte[4096];                  Array.Copy(dataBuf' 0' tempBuf' 0' dataBuf.Length);                  dataBuf = tempBuf;              }
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (dataBuf.Length < 4096)              {                  byte[] tempBuf = new byte[4096];                  Array.Copy(dataBuf' 0' tempBuf' 0' dataBuf.Length);                  dataBuf = tempBuf;              }
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: byte[] first6 = new byte[6];
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: pis.Read(first6' 0' 6);
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: if (first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f')              {                  throw new ArgumentException("The document is really a RTF file");              }
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: if (first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f')              {                  throw new ArgumentException("The document is really a RTF file");              }
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: if (first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f')              {                  throw new ArgumentException("The document is really a RTF file");              }
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: pis.Unread(6);
Magic Number,NPOI.HWPF,HWPFOldDocument,C:\repos\svn2github_npoi\scratchpad\HWPF\HWPFOldDocument.cs,HWPFOldDocument,The following statement contains a magic number: if (_fib.IsFComplex())              {                  ComplexFileTable cft = new ComplexFileTable(                          _mainStream' _mainStream'                          complexTableOffset' _fib.GetFcMin()                  );                  tpt = cft.GetTextPieceTable();                    foreach (TextPiece tp in tpt.TextPieces)                  {                      text.Append(tp.GetStringBuilder());                  }              }              else              {                  // TODO Discover if these older documents can ever hold Unicode Strings?                  //  (We think not' because they seem to lack a Piece table)                  // TODO Build the Piece Descriptor properly                  //  (We have to fake it' as they don't seem to have a proper Piece table)                  PieceDescriptor pd = new PieceDescriptor(new byte[] { 0' 0' 0' 0' 0' 127' 0' 0 }' 0);                  pd.FilePosition = _fib.GetFcMin();                    // Generate a single Text Piece Table' with a single Text Piece                  //  which covers all the (8 bit only) text in the file                  tpt = new TextPieceTable();                  byte[] textData = new byte[_fib.GetFcMac() - _fib.GetFcMin()];                  Array.Copy(_mainStream' _fib.GetFcMin()' textData' 0' textData.Length);                  TextPiece tp = new TextPiece(                          0' textData.Length' textData' pd                  );                  tpt.Add(tp);                    text.Append(tp.GetStringBuilder());              }
Magic Number,NPOI.HWPF.Model,BookmarkFirstDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\BookmarkFirstDescriptor.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(tableStream' offset' size' 4);
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,Insert,The following statement contains a magic number: if (listIndex == _textRuns.Count)              {                  _textRuns.Add(insertChpx);              }              else              {                  CHPX chpx = _textRuns[listIndex];                  if (chpx.Start < cpStart)                  {                      // Copy the properties of the one before to afterwards                      // Will go:                      //  Original' until insert at point                      //  New one                      //  Clone of original' on to the old end                      CHPX clone = new CHPX(0' 0' chpx.GetSprmBuf());                      // Again ensure Contains character based OffSets no matter what                      clone.Start = (cpStart);                      clone.End = (chpx.End);                        chpx.End = (cpStart);                        _textRuns.Insert(listIndex + 1' insertChpx);                      _textRuns.Insert(listIndex + 2' clone);                  }                  else                  {                      _textRuns.Insert(listIndex' insertChpx);                  }              }
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,WriteTo,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(4);
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,WriteTo,The following statement contains a magic number: do              {                  PropertyNode startingProp = (PropertyNode)overflow[0];                  int start = startingProp.Start + fcMin;                    CHPFormattedDiskPage cfkp = new CHPFormattedDiskPage();                  cfkp.Fill(overflow);                    byte[] bufFkp = cfkp.ToArray(fcMin);                  docStream.Write(bufFkp);                  overflow = cfkp.GetOverflow();                    int end = endingFc;                  if (overflow != null)                  {                      end = ((PropertyNode)overflow[0]).Start + fcMin;                  }                    byte[] intHolder = new byte[4];                  LittleEndian.PutInt(intHolder' pageNum++);                  binTable.AddProperty(new GenericPropertyNode(start' end' intHolder));                }              while (overflow != null);
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int chpxOffset = 2 * LittleEndian.GetUByte(_fkp' _offset + (((_crun + 1) * 4) + index));
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int chpxOffset = 2 * LittleEndian.GetUByte(_fkp' _offset + (((_crun + 1) * 4) + index));
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[512];
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: int grpprlOffset = 511;
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: int totalSize = FC_SIZE + 2;
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++)              {                  int grpprlLength = (_chpxList[index]).GetGrpprl().Length;                    // check to see if we have enough room for an FC' the grpprl offset'                  // the grpprl size byte and the grpprl.                  totalSize += (FC_SIZE + 2 + grpprlLength);                  // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= (FC_SIZE + 2 + grpprlLength);                      break;                  }                    // grpprls must fall on word boundaries                  if ((1 + grpprlLength) % 2 > 0)                  {                      totalSize += 1;                  }              }
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++)              {                  int grpprlLength = (_chpxList[index]).GetGrpprl().Length;                    // check to see if we have enough room for an FC' the grpprl offset'                  // the grpprl size byte and the grpprl.                  totalSize += (FC_SIZE + 2 + grpprlLength);                  // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= (FC_SIZE + 2 + grpprlLength);                      break;                  }                    // grpprls must fall on word boundaries                  if ((1 + grpprlLength) % 2 > 0)                  {                      totalSize += 1;                  }              }
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++)              {                  int grpprlLength = (_chpxList[index]).GetGrpprl().Length;                    // check to see if we have enough room for an FC' the grpprl offset'                  // the grpprl size byte and the grpprl.                  totalSize += (FC_SIZE + 2 + grpprlLength);                  // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= (FC_SIZE + 2 + grpprlLength);                      break;                  }                    // grpprls must fall on word boundaries                  if ((1 + grpprlLength) % 2 > 0)                  {                      totalSize += 1;                  }              }
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++)              {                  int grpprlLength = (_chpxList[index]).GetGrpprl().Length;                    // check to see if we have enough room for an FC' the grpprl offset'                  // the grpprl size byte and the grpprl.                  totalSize += (FC_SIZE + 2 + grpprlLength);                  // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= (FC_SIZE + 2 + grpprlLength);                      break;                  }                    // grpprls must fall on word boundaries                  if ((1 + grpprlLength) % 2 > 0)                  {                      totalSize += 1;                  }              }
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++)              {                  int grpprlLength = (_chpxList[index]).GetGrpprl().Length;                    // check to see if we have enough room for an FC' the grpprl offset'                  // the grpprl size byte and the grpprl.                  totalSize += (FC_SIZE + 2 + grpprlLength);                  // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= (FC_SIZE + 2 + grpprlLength);                      break;                  }                    // grpprls must fall on word boundaries                  if ((1 + grpprlLength) % 2 > 0)                  {                      totalSize += 1;                  }              }
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: buf[511] = (byte)index;
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  chpx = (CHPX)_chpxList[x];                  byte[] grpprl = chpx.GetGrpprl();                    LittleEndian.PutInt(buf' fcOffset' chpx.StartBytes + fcMin);                  grpprlOffset -= (1 + grpprl.Length);                  grpprlOffset -= (grpprlOffset % 2);                  buf[offsetOffset] = (byte)(grpprlOffset / 2);                  buf[grpprlOffset] = (byte)grpprl.Length;                  Array.Copy(grpprl' 0' buf' grpprlOffset + 1' grpprl.Length);                    offsetOffset += 1;                  fcOffset += FC_SIZE;              }
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  chpx = (CHPX)_chpxList[x];                  byte[] grpprl = chpx.GetGrpprl();                    LittleEndian.PutInt(buf' fcOffset' chpx.StartBytes + fcMin);                  grpprlOffset -= (1 + grpprl.Length);                  grpprlOffset -= (grpprlOffset % 2);                  buf[offsetOffset] = (byte)(grpprlOffset / 2);                  buf[grpprlOffset] = (byte)grpprl.Length;                  Array.Copy(grpprl' 0' buf' grpprlOffset + 1' grpprl.Length);                    offsetOffset += 1;                  fcOffset += FC_SIZE;              }
Magic Number,NPOI.HWPF.Model,PictureDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PictureDescriptor.cs,PictureDescriptor,The following statement contains a magic number: this.offset14 = LittleEndian.GetByteArray(_dataStream'                      startOffset + 0x0E' 14);
Magic Number,NPOI.HWPF.Model,Ffn,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Ffn.cs,Ffn,The following statement contains a magic number: _xszFfnLength = (this.GetSize() - offsetTmp) / 2;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields = new int[numFields * 2];
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: for (int x = 0; x < numFields; x++)              {                  int fieldOffset = (x * FIELD_SIZE) + offset;                  int dsOffset = LittleEndian.GetInt(mainStream' fieldOffset);                  fieldOffset += LittleEndianConsts.INT_SIZE;                  int dsSize = LittleEndian.GetInt(mainStream' fieldOffset);                    if (offsetList.Contains(x) ^ areKnown)                  {                      if (dsSize > 0)                      {                          if (dsOffset + dsSize > tableStream.Length)                          {                              //log.log(POILogger.WARN' "Unhandled data structure points to outside the buffer. " +                              //                        "offset = " + dsOffset + "' length = " + dsSize +                              //                        "' buffer length = " + tableStream.Length);                          }                          else                          {                              UnhandledDataStructure unhandled = new UnhandledDataStructure(                                tableStream' dsOffset' dsSize);                              _unknownMap.Add(x' unhandled);                          }                      }                  }                  _fields[x * 2] = dsOffset;                  _fields[(x * 2) + 1] = dsSize;              }
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: for (int x = 0; x < numFields; x++)              {                  int fieldOffset = (x * FIELD_SIZE) + offset;                  int dsOffset = LittleEndian.GetInt(mainStream' fieldOffset);                  fieldOffset += LittleEndianConsts.INT_SIZE;                  int dsSize = LittleEndian.GetInt(mainStream' fieldOffset);                    if (offsetList.Contains(x) ^ areKnown)                  {                      if (dsSize > 0)                      {                          if (dsOffset + dsSize > tableStream.Length)                          {                              //log.log(POILogger.WARN' "Unhandled data structure points to outside the buffer. " +                              //                        "offset = " + dsOffset + "' length = " + dsSize +                              //                        "' buffer length = " + tableStream.Length);                          }                          else                          {                              UnhandledDataStructure unhandled = new UnhandledDataStructure(                                tableStream' dsOffset' dsSize);                              _unknownMap.Add(x' unhandled);                          }                      }                  }                  _fields[x * 2] = dsOffset;                  _fields[(x * 2) + 1] = dsSize;              }
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,GetFieldOffset,The following statement contains a magic number: return _fields[field * 2];
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,GetFieldSize,The following statement contains a magic number: return _fields[(field * 2) + 1];
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,SetFieldOffset,The following statement contains a magic number: _fields[field * 2] = offset;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,SetFieldSize,The following statement contains a magic number: _fields[(field * 2) + 1] = size;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: int length = _fields.Length / 2;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < length; x++)              {                  UnhandledDataStructure ds = (UnhandledDataStructure)_unknownMap[x];                  if (ds != null)                  {                      LittleEndian.PutInt(mainStream' offset' tableStream.Offset);                      offset += LittleEndianConsts.INT_SIZE;                      byte[] buf = ds.GetBuf();                      tableStream.Write(buf);                      LittleEndian.PutInt(mainStream' offset' buf.Length);                      offset += LittleEndianConsts.INT_SIZE;                  }                  else                  {                      LittleEndian.PutInt(mainStream' offset' _fields[x * 2]);                      offset += LittleEndianConsts.INT_SIZE;                      LittleEndian.PutInt(mainStream' offset' _fields[(x * 2) + 1]);                      offset += LittleEndianConsts.INT_SIZE;                  }              }
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < length; x++)              {                  UnhandledDataStructure ds = (UnhandledDataStructure)_unknownMap[x];                  if (ds != null)                  {                      LittleEndian.PutInt(mainStream' offset' tableStream.Offset);                      offset += LittleEndianConsts.INT_SIZE;                      byte[] buf = ds.GetBuf();                      tableStream.Write(buf);                      LittleEndian.PutInt(mainStream' offset' buf.Length);                      offset += LittleEndianConsts.INT_SIZE;                  }                  else                  {                      LittleEndian.PutInt(mainStream' offset' _fields[x * 2]);                      offset += LittleEndianConsts.INT_SIZE;                      LittleEndian.PutInt(mainStream' offset' _fields[(x * 2) + 1]);                      offset += LittleEndianConsts.INT_SIZE;                  }              }
Magic Number,NPOI.HWPF.Model,FootnoteReferenceDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FootnoteReferenceDescriptor.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FormattedDiskPage.cs,FormattedDiskPage,The following statement contains a magic number: _crun = LittleEndian.GetUByte(documentStream' offset + 511);
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FormattedDiskPage.cs,GetStart,The following statement contains a magic number: return LittleEndian.GetInt(_fkp' _offset + (index * 4));
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\FormattedDiskPage.cs,GetEnd,The following statement contains a magic number: return LittleEndian.GetInt(_fkp' _offset + ((index + 1) * 4));
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _rgistd = new short[9];
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: for (int x = 0; x < 9; x++)              {                  _rgistd[x] = (short)StyleSheet.NIL_STYLE;              }
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _levels = new ListLevel[9];
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _rgistd = new short[9];
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: for (int x = 0; x < 9; x++)              {                  _rgistd[x] = LittleEndian.GetShort(buf' offset);                  offset += LittleEndianConsts.SHORT_SIZE;              }
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: if (_fSimpleList.GetValue(_info) > 0)              {                  _levels = new ListLevel[1];              }              else              {                  _levels = new ListLevel[9];              }
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ResetListID,The following statement contains a magic number: _lsid = (int)((new Random((int)DateTime.Now.Ticks)).Next(0'100)/100 * DateTime.Now.Millisecond);
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ResetListID,The following statement contains a magic number: _lsid = (int)((new Random((int)DateTime.Now.Ticks)).Next(0'100)/100 * DateTime.Now.Millisecond);
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[28];
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < 9; x++)              {                  LittleEndian.PutShort(buf' offset' _rgistd[x]);                  offset += LittleEndianConsts.SHORT_SIZE;              }
Magic Number,NPOI.HWPF.Model,ListFormatOverride,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverride.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[16];
Magic Number,NPOI.HWPF.Model,ListFormatOverride,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverride.cs,ToArray,The following statement contains a magic number: Array.Copy(_reserved3' 0' buf' offset' 3);
Magic Number,NPOI.HWPF.Model,ListFormatOverrideLevel,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,ToArray,The following statement contains a magic number: Array.Copy(_reserved' 0' buf' offset' 3);
Magic Number,NPOI.HWPF.Model,ListFormatOverrideLevel,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,ToArray,The following statement contains a magic number: offset += 3;
Magic Number,NPOI.HWPF.Model,ListLevel,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,GetSizeInBytes,The following statement contains a magic number: int result =                  6 // int byte byte                  + RGBXCH_NUMS_SIZE                  + 13 // byte int int byte byte short                  + _cbGrpprlChpx                  + _cbGrpprlPapx                  + 2;
Magic Number,NPOI.HWPF.Model,ListLevel,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,GetSizeInBytes,The following statement contains a magic number: int result =                  6 // int byte byte                  + RGBXCH_NUMS_SIZE                  + 13 // byte int int byte byte short                  + _cbGrpprlChpx                  + _cbGrpprlPapx                  + 2;
Magic Number,NPOI.HWPF.Model,ListLevel,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,GetSizeInBytes,The following statement contains a magic number: int result =                  6 // int byte byte                  + RGBXCH_NUMS_SIZE                  + 13 // byte int int byte byte short                  + _cbGrpprlChpx                  + _cbGrpprlPapx                  + 2;
Magic Number,NPOI.HWPF.Model,ListTables,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,ListTables,The following statement contains a magic number: for (int x = 0; x < length; x++)              {                  ListFormatOverride lfo = new ListFormatOverride(tableStream' lfoOffset);                  lfoOffset += LIST_FORMAT_OVERRIDE_SIZE;                  int num = lfo.numOverrides();                  for (int y = 0; y < num; y++)                  {                      while (tableStream[lfolvlOffset] == 255)                      {                          lfolvlOffset++;                      }                      ListFormatOverrideLevel lfolvl = new ListFormatOverrideLevel(tableStream' lfolvlOffset);                      lfo.SetOverride(y' lfolvl);                      lfolvlOffset += lfolvl.GetSizeInBytes();                  }                  _overrideList.Add(lfo);              }
Magic Number,NPOI.HWPF.Model,ListTables,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,WriteListDataTo,The following statement contains a magic number: byte[] shortHolder = new byte[2];
Magic Number,NPOI.HWPF.Model,ListTables,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,WriteListOverridesTo,The following statement contains a magic number: byte[] intHolder = new byte[4];
Magic Number,NPOI.HWPF.Model,OldCHPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldCHPBinTable.cs,OldCHPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(documentStream' OffSet' size' 2);
Magic Number,NPOI.HWPF.Model,OldPAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldPAPBinTable.cs,OldPAPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(documentStream' OffSet' size' 2);
Magic Number,NPOI.HWPF.Model,OldSectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The following statement contains a magic number: PlexOfCps sedPlex = new PlexOfCps(documentStream' offset' size' 12);
Magic Number,NPOI.HWPF.Model,OldSectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The following statement contains a magic number: for (int x = 0; x < length; x++)              {                  GenericPropertyNode node = sedPlex.GetProperty(x);                  SectionDescriptor sed = new SectionDescriptor(node.Bytes' 0);                    int fileOffset = sed.GetFc();                  int startAt = node.Start;                  int endAt = node.End;                    SEPX sepx;                  // check for the optimization                  if (fileOffset == unchecked((int)0xffffffff))                  {                      sepx = new SEPX(sed' startAt' endAt' new byte[0]);                  }                  else                  {                      // The first short at the offset is the size of the grpprl.                      int sepxSize = LittleEndian.GetShort(documentStream' fileOffset);                      // Because we don't properly know about all the details of the old                      //  section properties' and we're trying to decode them as if they                      //  were the new ones' we sometimes "need" more data than we have.                      // As a workaround' have a few extra 0 bytes on the end!                      byte[] buf = new byte[sepxSize+2];                      fileOffset += LittleEndianConsts.SHORT_SIZE;                      Array.Copy(documentStream' fileOffset' buf' 0' buf.Length);                      sepx = new SEPX(sed' startAt' endAt'buf);                  }                  _sections.Add(sepx);              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(tableStream' offset' size' 4);
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Insert,The following statement contains a magic number: if (listIndex == _paragraphs.Count)              {                  _paragraphs.Add(forInsert);              }              else              {                  PAPX currentPap = _paragraphs[listIndex];                  if (currentPap != null && currentPap.Start < cpStart)                  {                      SprmBuffer ClonedBuf = null;                      ClonedBuf = (SprmBuffer)currentPap.GetSprmBuf().Clone();                          // Copy the properties of the one before to afterwards                      // Will go:                      //  Original' until insert at point                      //  New one                      //  Clone of original' on to the old end                      PAPX clone = new PAPX(0' 0' ClonedBuf);                      // Again ensure Contains character based OffSets no matter what                      clone.Start = (cpStart);                      clone.End = (currentPap.End);                        currentPap.End = cpStart;                        _paragraphs.Insert(listIndex + 1' forInsert);                      _paragraphs.Insert(listIndex + 2' clone);                  }                  else                  {                      _paragraphs.Insert(listIndex' forInsert);                  }              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (complexFileTable != null)              {                  SprmBuffer[] sprmBuffers = complexFileTable.GetGrpprls();                    // adding PAPX from fast-saved SPRMs                  foreach (TextPiece textPiece in complexFileTable.GetTextPieceTable()                          .TextPieces)                  {                      PropertyModifier prm = textPiece.PieceDescriptor.Prm;                      if (!prm.IsComplex())                          continue;                      int igrpprl = prm.GetIgrpprl();                        if (igrpprl < 0 || igrpprl >= sprmBuffers.Length)                      {                          logger.Log(POILogger.WARN' textPiece                                  + "'s PRM references to unknown grpprl");                          continue;                      }                        bool hasPap = false;                      SprmBuffer sprmBuffer = sprmBuffers[igrpprl];                      for (SprmIterator iterator = sprmBuffer.Iterator(); iterator                              .HasNext(); )                      {                          SprmOperation sprmOperation = iterator.Next();                          if (sprmOperation.Type == SprmOperation.TYPE_PAP)                          {                              hasPap = true;                              break;                          }                      }                        if (hasPap)                      {                          SprmBuffer newSprmBuffer = new SprmBuffer(2);                          newSprmBuffer.Append(sprmBuffer.ToByteArray());                            PAPX papx = new PAPX(textPiece.Start'                                  textPiece.End' newSprmBuffer);                          _paragraphs.Add(papx);                      }                  }                    logger.Log(POILogger.DEBUG'                          "Merged (?) with PAPX from complex file table in "'                          DateTime.Now.Ticks - start'                          " ms ("' _paragraphs.Count'                          " elements in total)");                  start = DateTime.Now.Ticks;              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++)              {                  char c = docText[charIndex];                  if (c != 13 && c != 7 && c != 12)                      continue;                    int startInclusive = lastParStart;                  int endExclusive = charIndex + 1;                    bool broken = false;                  List<PAPX> papxs = new List<PAPX>();                  for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos                          .Count; papxIndex++)                  {                      broken = false;                      PAPX papx = oldPapxSortedByEndPos[papxIndex];                          if (papx.End - 1 > charIndex)                      {                          lastPapxIndex = papxIndex;                          broken = true;                          break;                      }                        papxs.Add(papx);                  }                  if (!broken)                  {                      lastPapxIndex = oldPapxSortedByEndPos.Count - 1;                  }                    if (papxs.Count == 0)                  {                      logger.Log(POILogger.WARN' "Paragraph ["'                               startInclusive' "; "'                               endExclusive'                              ") has no PAPX. Creating new one.");                      // create it manually                      PAPX papx = new PAPX(startInclusive' endExclusive'                              new SprmBuffer(2));                      newPapxs.Add(papx);                        lastParStart = endExclusive;                      continue;                  }                    if (papxs.Count == 1)                  {                      // can we reuse existing?                      PAPX existing = papxs[0];                      if (existing.Start == startInclusive                              && existing.End == endExclusive)                      {                          newPapxs.Add(existing);                          lastParStart = endExclusive;                          continue;                      }                  }                  PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer(papxToFileOrder);                  // restore file order of PAPX                  papxs.Sort(papxFileOrderComparator);                    SprmBuffer sprmBuffer = null;                  foreach (PAPX papx in papxs)                  {                      if (sprmBuffer == null)                          sprmBuffer = (SprmBuffer)papx.GetSprmBuf().Clone();                        else                          sprmBuffer.Append(papx.GetGrpprl()' 2);                  }                  PAPX newPapx = new PAPX(startInclusive' endExclusive' sprmBuffer);                  newPapxs.Add(newPapx);                    lastParStart = endExclusive;                  continue;              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++)              {                  char c = docText[charIndex];                  if (c != 13 && c != 7 && c != 12)                      continue;                    int startInclusive = lastParStart;                  int endExclusive = charIndex + 1;                    bool broken = false;                  List<PAPX> papxs = new List<PAPX>();                  for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos                          .Count; papxIndex++)                  {                      broken = false;                      PAPX papx = oldPapxSortedByEndPos[papxIndex];                          if (papx.End - 1 > charIndex)                      {                          lastPapxIndex = papxIndex;                          broken = true;                          break;                      }                        papxs.Add(papx);                  }                  if (!broken)                  {                      lastPapxIndex = oldPapxSortedByEndPos.Count - 1;                  }                    if (papxs.Count == 0)                  {                      logger.Log(POILogger.WARN' "Paragraph ["'                               startInclusive' "; "'                               endExclusive'                              ") has no PAPX. Creating new one.");                      // create it manually                      PAPX papx = new PAPX(startInclusive' endExclusive'                              new SprmBuffer(2));                      newPapxs.Add(papx);                        lastParStart = endExclusive;                      continue;                  }                    if (papxs.Count == 1)                  {                      // can we reuse existing?                      PAPX existing = papxs[0];                      if (existing.Start == startInclusive                              && existing.End == endExclusive)                      {                          newPapxs.Add(existing);                          lastParStart = endExclusive;                          continue;                      }                  }                  PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer(papxToFileOrder);                  // restore file order of PAPX                  papxs.Sort(papxFileOrderComparator);                    SprmBuffer sprmBuffer = null;                  foreach (PAPX papx in papxs)                  {                      if (sprmBuffer == null)                          sprmBuffer = (SprmBuffer)papx.GetSprmBuf().Clone();                        else                          sprmBuffer.Append(papx.GetGrpprl()' 2);                  }                  PAPX newPapx = new PAPX(startInclusive' endExclusive' sprmBuffer);                  newPapxs.Add(newPapx);                    lastParStart = endExclusive;                  continue;              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++)              {                  char c = docText[charIndex];                  if (c != 13 && c != 7 && c != 12)                      continue;                    int startInclusive = lastParStart;                  int endExclusive = charIndex + 1;                    bool broken = false;                  List<PAPX> papxs = new List<PAPX>();                  for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos                          .Count; papxIndex++)                  {                      broken = false;                      PAPX papx = oldPapxSortedByEndPos[papxIndex];                          if (papx.End - 1 > charIndex)                      {                          lastPapxIndex = papxIndex;                          broken = true;                          break;                      }                        papxs.Add(papx);                  }                  if (!broken)                  {                      lastPapxIndex = oldPapxSortedByEndPos.Count - 1;                  }                    if (papxs.Count == 0)                  {                      logger.Log(POILogger.WARN' "Paragraph ["'                               startInclusive' "; "'                               endExclusive'                              ") has no PAPX. Creating new one.");                      // create it manually                      PAPX papx = new PAPX(startInclusive' endExclusive'                              new SprmBuffer(2));                      newPapxs.Add(papx);                        lastParStart = endExclusive;                      continue;                  }                    if (papxs.Count == 1)                  {                      // can we reuse existing?                      PAPX existing = papxs[0];                      if (existing.Start == startInclusive                              && existing.End == endExclusive)                      {                          newPapxs.Add(existing);                          lastParStart = endExclusive;                          continue;                      }                  }                  PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer(papxToFileOrder);                  // restore file order of PAPX                  papxs.Sort(papxFileOrderComparator);                    SprmBuffer sprmBuffer = null;                  foreach (PAPX papx in papxs)                  {                      if (sprmBuffer == null)                          sprmBuffer = (SprmBuffer)papx.GetSprmBuf().Clone();                        else                          sprmBuffer.Append(papx.GetGrpprl()' 2);                  }                  PAPX newPapx = new PAPX(startInclusive' endExclusive' sprmBuffer);                  newPapxs.Add(newPapx);                    lastParStart = endExclusive;                  continue;              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++)              {                  char c = docText[charIndex];                  if (c != 13 && c != 7 && c != 12)                      continue;                    int startInclusive = lastParStart;                  int endExclusive = charIndex + 1;                    bool broken = false;                  List<PAPX> papxs = new List<PAPX>();                  for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos                          .Count; papxIndex++)                  {                      broken = false;                      PAPX papx = oldPapxSortedByEndPos[papxIndex];                          if (papx.End - 1 > charIndex)                      {                          lastPapxIndex = papxIndex;                          broken = true;                          break;                      }                        papxs.Add(papx);                  }                  if (!broken)                  {                      lastPapxIndex = oldPapxSortedByEndPos.Count - 1;                  }                    if (papxs.Count == 0)                  {                      logger.Log(POILogger.WARN' "Paragraph ["'                               startInclusive' "; "'                               endExclusive'                              ") has no PAPX. Creating new one.");                      // create it manually                      PAPX papx = new PAPX(startInclusive' endExclusive'                              new SprmBuffer(2));                      newPapxs.Add(papx);                        lastParStart = endExclusive;                      continue;                  }                    if (papxs.Count == 1)                  {                      // can we reuse existing?                      PAPX existing = papxs[0];                      if (existing.Start == startInclusive                              && existing.End == endExclusive)                      {                          newPapxs.Add(existing);                          lastParStart = endExclusive;                          continue;                      }                  }                  PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer(papxToFileOrder);                  // restore file order of PAPX                  papxs.Sort(papxFileOrderComparator);                    SprmBuffer sprmBuffer = null;                  foreach (PAPX papx in papxs)                  {                      if (sprmBuffer == null)                          sprmBuffer = (SprmBuffer)papx.GetSprmBuf().Clone();                        else                          sprmBuffer.Append(papx.GetGrpprl()' 2);                  }                  PAPX newPapx = new PAPX(startInclusive' endExclusive' sprmBuffer);                  newPapxs.Add(newPapx);                    lastParStart = endExclusive;                  continue;              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++)              {                  char c = docText[charIndex];                  if (c != 13 && c != 7 && c != 12)                      continue;                    int startInclusive = lastParStart;                  int endExclusive = charIndex + 1;                    bool broken = false;                  List<PAPX> papxs = new List<PAPX>();                  for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos                          .Count; papxIndex++)                  {                      broken = false;                      PAPX papx = oldPapxSortedByEndPos[papxIndex];                          if (papx.End - 1 > charIndex)                      {                          lastPapxIndex = papxIndex;                          broken = true;                          break;                      }                        papxs.Add(papx);                  }                  if (!broken)                  {                      lastPapxIndex = oldPapxSortedByEndPos.Count - 1;                  }                    if (papxs.Count == 0)                  {                      logger.Log(POILogger.WARN' "Paragraph ["'                               startInclusive' "; "'                               endExclusive'                              ") has no PAPX. Creating new one.");                      // create it manually                      PAPX papx = new PAPX(startInclusive' endExclusive'                              new SprmBuffer(2));                      newPapxs.Add(papx);                        lastParStart = endExclusive;                      continue;                  }                    if (papxs.Count == 1)                  {                      // can we reuse existing?                      PAPX existing = papxs[0];                      if (existing.Start == startInclusive                              && existing.End == endExclusive)                      {                          newPapxs.Add(existing);                          lastParStart = endExclusive;                          continue;                      }                  }                  PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer(papxToFileOrder);                  // restore file order of PAPX                  papxs.Sort(papxFileOrderComparator);                    SprmBuffer sprmBuffer = null;                  foreach (PAPX papx in papxs)                  {                      if (sprmBuffer == null)                          sprmBuffer = (SprmBuffer)papx.GetSprmBuf().Clone();                        else                          sprmBuffer.Append(papx.GetGrpprl()' 2);                  }                  PAPX newPapx = new PAPX(startInclusive' endExclusive' sprmBuffer);                  newPapxs.Add(newPapx);                    lastParStart = endExclusive;                  continue;              }
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,WriteTo,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(4);
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,WriteTo,The following statement contains a magic number: do              {                  PropertyNode startingProp = (PropertyNode)overflow[0];                  int start = translator.GetByteIndex(startingProp.Start);                    PAPFormattedDiskPage pfkp = new PAPFormattedDiskPage(_dataStream);                  pfkp.Fill(overflow);                    byte[] bufFkp = pfkp.ToByteArray(tableStream'translator);                  docStream.Write(bufFkp);                  overflow = pfkp.GetOverflow();                    int end = endingFc;                  if (overflow != null)                  {                      end = translator.GetByteIndex(overflow[0].Start);                  }                    byte[] intHolder = new byte[4];                  LittleEndian.PutInt(intHolder' pageNum++);                  binTable.AddProperty(new GenericPropertyNode(start' end' intHolder));                }              while (overflow != null);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int papxOffset = 2 * LittleEndian.GetUByte(_fkp' _offset + (((_crun + 1) * FC_SIZE) + (index * BX_SIZE)));
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int size = 2 * LittleEndian.GetUByte(_fkp' _offset + papxOffset);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: if (size == 0)              {                  size = 2 * LittleEndian.GetUByte(_fkp' _offset + ++papxOffset);              }              else              {                  size--;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: byte[] buf = new byte[512];
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++)              {                  byte[] grpprl = ((PAPX)_papxList[index]).GetGrpprl();                  int grpprlLength = grpprl.Length;                    // is grpprl huge?                  if (grpprlLength > 488)                  {                      grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl                  }                    // check to see if we have enough room for an FC' a BX' and the grpprl                  // and the 1 byte size of the grpprl.                  int addition = 0;                  if (!Arrays.Equals(grpprl' lastGrpprl))                  {                      addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);                  }                  else                  {                      addition = (FC_SIZE + BX_SIZE);                  }                    totalSize += addition;                    // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= addition;                      break;                  }                    // grpprls must fall on word boundaries                  if (grpprlLength % 2 > 0)                  {                      totalSize += 1;                  }                  else                  {                      totalSize += 2;                  }                  lastGrpprl = grpprl;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++)              {                  byte[] grpprl = ((PAPX)_papxList[index]).GetGrpprl();                  int grpprlLength = grpprl.Length;                    // is grpprl huge?                  if (grpprlLength > 488)                  {                      grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl                  }                    // check to see if we have enough room for an FC' a BX' and the grpprl                  // and the 1 byte size of the grpprl.                  int addition = 0;                  if (!Arrays.Equals(grpprl' lastGrpprl))                  {                      addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);                  }                  else                  {                      addition = (FC_SIZE + BX_SIZE);                  }                    totalSize += addition;                    // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= addition;                      break;                  }                    // grpprls must fall on word boundaries                  if (grpprlLength % 2 > 0)                  {                      totalSize += 1;                  }                  else                  {                      totalSize += 2;                  }                  lastGrpprl = grpprl;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++)              {                  byte[] grpprl = ((PAPX)_papxList[index]).GetGrpprl();                  int grpprlLength = grpprl.Length;                    // is grpprl huge?                  if (grpprlLength > 488)                  {                      grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl                  }                    // check to see if we have enough room for an FC' a BX' and the grpprl                  // and the 1 byte size of the grpprl.                  int addition = 0;                  if (!Arrays.Equals(grpprl' lastGrpprl))                  {                      addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);                  }                  else                  {                      addition = (FC_SIZE + BX_SIZE);                  }                    totalSize += addition;                    // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= addition;                      break;                  }                    // grpprls must fall on word boundaries                  if (grpprlLength % 2 > 0)                  {                      totalSize += 1;                  }                  else                  {                      totalSize += 2;                  }                  lastGrpprl = grpprl;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++)              {                  byte[] grpprl = ((PAPX)_papxList[index]).GetGrpprl();                  int grpprlLength = grpprl.Length;                    // is grpprl huge?                  if (grpprlLength > 488)                  {                      grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl                  }                    // check to see if we have enough room for an FC' a BX' and the grpprl                  // and the 1 byte size of the grpprl.                  int addition = 0;                  if (!Arrays.Equals(grpprl' lastGrpprl))                  {                      addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);                  }                  else                  {                      addition = (FC_SIZE + BX_SIZE);                  }                    totalSize += addition;                    // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= addition;                      break;                  }                    // grpprls must fall on word boundaries                  if (grpprlLength % 2 > 0)                  {                      totalSize += 1;                  }                  else                  {                      totalSize += 2;                  }                  lastGrpprl = grpprl;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++)              {                  byte[] grpprl = ((PAPX)_papxList[index]).GetGrpprl();                  int grpprlLength = grpprl.Length;                    // is grpprl huge?                  if (grpprlLength > 488)                  {                      grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl                  }                    // check to see if we have enough room for an FC' a BX' and the grpprl                  // and the 1 byte size of the grpprl.                  int addition = 0;                  if (!Arrays.Equals(grpprl' lastGrpprl))                  {                      addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);                  }                  else                  {                      addition = (FC_SIZE + BX_SIZE);                  }                    totalSize += addition;                    // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= addition;                      break;                  }                    // grpprls must fall on word boundaries                  if (grpprlLength % 2 > 0)                  {                      totalSize += 1;                  }                  else                  {                      totalSize += 2;                  }                  lastGrpprl = grpprl;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++)              {                  byte[] grpprl = ((PAPX)_papxList[index]).GetGrpprl();                  int grpprlLength = grpprl.Length;                    // is grpprl huge?                  if (grpprlLength > 488)                  {                      grpprlLength = 8; // set equal to size of sprmPHugePapx grpprl                  }                    // check to see if we have enough room for an FC' a BX' and the grpprl                  // and the 1 byte size of the grpprl.                  int addition = 0;                  if (!Arrays.Equals(grpprl' lastGrpprl))                  {                      addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);                  }                  else                  {                      addition = (FC_SIZE + BX_SIZE);                  }                    totalSize += addition;                    // if size is uneven we will have to add one so the first grpprl falls                  // on a word boundary                  if (totalSize > 511 + (index % 2))                  {                      totalSize -= addition;                      break;                  }                    // grpprls must fall on word boundaries                  if (grpprlLength % 2 > 0)                  {                      totalSize += 1;                  }                  else                  {                      totalSize += 2;                  }                  lastGrpprl = grpprl;              }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf[511] = (byte)index;
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset = 511;
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++)              {                  papx = _papxList[x];                  byte[] phe = papx.GetParagraphHeight().ToArray();                  byte[] grpprl = papx.GetGrpprl();                    // is grpprl huge?                  if (grpprl.Length > 488)                  {                      /*                      // if so do we have storage at GetHugeGrpprloffset()                      int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                      if (hugeGrpprlOffset == -1) // then we have no storage...                      {                          throw new InvalidOperationException(                                "This Paragraph has no dataStream storage.");                      }                      // we have some storage...                        // get the size of the existing storage                      int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                        if (maxHugeGrpprlSize < grpprl.Length - 2)                      { // grpprl.Length-2 because we don't store the istd                          throw new InvalidOperationException(                              "This Paragraph's dataStream storage is too small.");                      }                                             // store grpprl at hugeGrpprlOffset                      Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                       grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                      LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                        */                        byte[] hugePapx = new byte[grpprl.Length - 2];                      System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);                      int dataStreamOffset = dataStream.Offset;                      dataStream.Write(hugePapx);                        // grpprl = grpprl Containing only a sprmPHugePapx2                      int istd = LittleEndian.GetUShort(grpprl' 0);                      grpprl = new byte[8];                      LittleEndian.PutUShort(grpprl' 0' istd);                      LittleEndian.PutUShort(grpprl' 2' 0x6646); // sprmPHugePapx2                      LittleEndian.PutInt(grpprl' 4' dataStreamOffset);                  }                    bool same = Arrays.Equals(lastGrpprl' grpprl);                  if (!same)                  {                      grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));                      grpprlOffset -= (grpprlOffset % 2);                  }                  LittleEndian.PutInt(buf' fcOffset' translator.GetByteIndex(papx.Start));                  buf[bxOffset] = (byte)(grpprlOffset / 2);                  Array.Copy(phe' 0' buf' bxOffset + 1' phe.Length);                    // refer to the section on PAPX in the spec. Places a size on the front                  // of the PAPX. Has to do with how the grpprl stays on word                  // boundaries.                  if (!same)                  {                      int copyOffset = grpprlOffset;                      if ((grpprl.Length % 2) > 0)                      {                          buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);                      }                      else                      {                          buf[++copyOffset] = (byte)((grpprl.Length) / 2);                          copyOffset++;                      }                      Array.Copy(grpprl' 0' buf' copyOffset' grpprl.Length);                      lastGrpprl = grpprl;                  }                    bxOffset += BX_SIZE;                  fcOffset += FC_SIZE;                }
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetParagraphHeight,The following statement contains a magic number: int pheOffset = _offset + 1 + (((_crun + 1) * 4) + (index * 13));
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetParagraphHeight,The following statement contains a magic number: int pheOffset = _offset + 1 + (((_crun + 1) * 4) + (index * 13));
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The following statement contains a magic number: SprmBuffer buf = FindHuge(new SprmBuffer(papx'2)' dataStream);
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The following statement contains a magic number: SprmBuffer buf = FindHuge(new SprmBuffer(papx' 2)' dataStream);
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null) // then check for sprmPHugePapx              {                  SprmOperation sprm = new SprmOperation(grpprl' 2);                  if ((sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3)                  {                      int hugeGrpprlOffset = sprm.Operand;                      if (hugeGrpprlOffset + 1 < datastream.Length)                      {                          int grpprlSize = LittleEndian.GetShort(datastream' hugeGrpprlOffset);                          if (hugeGrpprlOffset + grpprlSize < datastream.Length)                          {                              byte[] hugeGrpprl = new byte[grpprlSize + 2];                              // copy original istd into huge Grpprl                              hugeGrpprl[0] = grpprl[0];                               hugeGrpprl[1] = grpprl[1];                              // copy Grpprl from dataStream                              Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);                                return new SprmBuffer(hugeGrpprl'2);                          }                      }                  }              }
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,GetParagraphProperties,The following statement contains a magic number: ParagraphProperties props = ParagraphSprmUncompressor.UncompressPAP(baseStyle' GetGrpprl()' 2);
Magic Number,NPOI.HWPF.Model,ParagraphHeight,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ParagraphHeight.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[12];
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PieceDescriptor.cs,PieceDescriptor,The following statement contains a magic number: if ((fc & 0x40000000) == 0)              {                  unicode = true;              }              else              {                  unicode = false;                  fc &= ~(0x40000000);//gives me FC in doc stream                  fc /= 2;              }
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PieceDescriptor.cs,ToByteArray,The following statement contains a magic number: if (!unicode)              {                  tempFc *= 2;                  tempFc |= (0x40000000);              }
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PieceDescriptor.cs,ToByteArray,The following statement contains a magic number: byte[] buf = new byte[8];
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,PlexOfCps,The following statement contains a magic number: _iMac = (size - 4) / (4 + sizeOfStruct);
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,PlexOfCps,The following statement contains a magic number: _iMac = (size - 4) / (4 + sizeOfStruct);
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,GetIntOffset,The following statement contains a magic number: return index * 4;
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,GetStructOffset,The following statement contains a magic number: return (4 * (_iMac + 1)) + (_sizeOfStruct * index);
Magic Number,NPOI.HWPF.Model,PropertyModifier,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PropertyModifier.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Magic Number,NPOI.HWPF.Model,PropertyNode,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\PropertyNode.cs,GetHashCode,The following statement contains a magic number: return this._cpStart * 31 + this._buf.GetHashCode();
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: for (int i = 0; i < cData; i++)              {                  int len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                    String name = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                    entries[i] = name;              }
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: for (int i = 0; i < cData; i++)              {                  int len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                    String name = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                    entries[i] = name;              }
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: byte[] header = new byte[6];
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(header' 2' cData);
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(header' 4' cbExtra);
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: foreach (String name in entries)              {                  byte[] buf = new byte[name.Length * 2 + 2];                  LittleEndian.PutShort(buf' 0' (short)name.Length);                  StringUtil.PutUnicodeLE(name' buf' 2);                  tableStream.Write(buf);              }
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: foreach (String name in entries)              {                  byte[] buf = new byte[name.Length * 2 + 2];                  LittleEndian.PutShort(buf' 0' (short)name.Length);                  StringUtil.PutUnicodeLE(name' buf' 2);                  tableStream.Write(buf);              }
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: foreach (String name in entries)              {                  byte[] buf = new byte[name.Length * 2 + 2];                  LittleEndian.PutShort(buf' 0' (short)name.Length);                  StringUtil.PutUnicodeLE(name' buf' 2);                  tableStream.Write(buf);              }
Magic Number,NPOI.HWPF.Model,SavedByEntry,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: int hash = 29;
Magic Number,NPOI.HWPF.Model,SavedByEntry,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: hash = hash * 13 + userName.GetHashCode();
Magic Number,NPOI.HWPF.Model,SavedByEntry,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: hash = hash * 13 + saveLocation.GetHashCode();
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: int numEntries = LittleEndian.GetInt(tableStream' offset) / 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 4;
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++)              {                  int len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String userName = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                  len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String saveLocation = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                    entries[i] = new SavedByEntry(userName' saveLocation);              }
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++)              {                  int len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String userName = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                  len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String saveLocation = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                    entries[i] = new SavedByEntry(userName' saveLocation);              }
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++)              {                  int len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String userName = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                  len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String saveLocation = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                    entries[i] = new SavedByEntry(userName' saveLocation);              }
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++)              {                  int len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String userName = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                  len = LittleEndian.GetShort(tableStream' offset);                  offset += 2;                  String saveLocation = StringUtil.GetFromUnicodeLE(tableStream' offset' len);                  offset += len * 2;                    entries[i] = new SavedByEntry(userName' saveLocation);              }
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: byte[] header = new byte[6];
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt(header' 2' entries.Length * 2);
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt(header' 2' entries.Length * 2);
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: byte[] buf = new byte[value.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: byte[] buf = new byte[value.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: StringUtil.PutUnicodeLE(value' buf' 2);
Magic Number,NPOI.HWPF.Model,SectionDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SectionDescriptor.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[12];
Magic Number,NPOI.HWPF.Model,SectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,CPtoFC,The following statement contains a magic number: if (TP.IsUnicode)              {                  offset = offset * 2;              }
Magic Number,NPOI.HWPF.Model,SectionTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < len; x++)              {                  SEPX sepx = _sections[x];                  byte[] grpprl = sepx.GetGrpprl();                    // write the sepx to the document stream. starts with a 2 byte size                  // followed by the grpprl                  byte[] shortBuf = new byte[2];                  LittleEndian.PutShort(shortBuf' (short)grpprl.Length);                    docStream.Write(shortBuf);                  docStream.Write(grpprl);                    // set the fc in the section descriptor                  SectionDescriptor sed = sepx.GetSectionDescriptor();                  sed.SetFc(offset);                    // add the section descriptor bytes to the PlexOfCps.                      // original line -                  //GenericPropertyNode property = new GenericPropertyNode(sepx.Start' sepx.End' sed.ToArray());                    // Line using Ryan's FCtoCP() conversion method -                  // unable to observe any effect on our testcases when using this code - piers                  GenericPropertyNode property = new GenericPropertyNode(tpt.GetCharIndex(sepx.StartBytes)' tpt.GetCharIndex(sepx.EndBytes)' sed.ToArray());                      plex.AddProperty(property);                    offset = docStream.Offset;              }
Magic Number,NPOI.HWPF.Model,ShapesTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\ShapesTable.cs,ShapesTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(tblStream'                   fib.GetFcPlcspaMom()' fib.GetLcbPlcspaMom()' 26);
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: int offset = startOffset + 2;
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += 4;
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: for (int i = 0; i < numEntries; i++)              {                  int len = LittleEndian.GetShort(data' offset);                  offset += 2;                  String value = StringUtil.GetFromUnicodeLE(data' offset' len);                  offset += len * 2;                  entries[i] = value;              }
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: for (int i = 0; i < numEntries; i++)              {                  int len = LittleEndian.GetShort(data' offset);                  offset += 2;                  String value = StringUtil.GetFromUnicodeLE(data' offset' len);                  offset += len * 2;                  entries[i] = value;              }
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: byte[] header = new byte[6];
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: if (entries == null || entries.Length == 0)              {                  LittleEndian.PutInt(header' 2' 0);                  tableStream.Write(header);                  return 6;              }
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: if (entries == null || entries.Length == 0)              {                  LittleEndian.PutInt(header' 2' 0);                  tableStream.Write(header);                  return 6;              }
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: LittleEndian.PutInt(header' 2' entries.Length);
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: int size = 6;
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: foreach (String entry in entries)              {                  byte[] buf = new byte[entry.Length * 2 + 2];                  LittleEndian.PutShort(buf' 0' (short)entry.Length);                  StringUtil.PutUnicodeLE(entry' buf' 2);                  tableStream.Write(buf);                  size += buf.Length;              }
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: foreach (String entry in entries)              {                  byte[] buf = new byte[entry.Length * 2 + 2];                  LittleEndian.PutShort(buf' 0' (short)entry.Length);                  StringUtil.PutUnicodeLE(entry' buf' 2);                  tableStream.Write(buf);                  size += buf.Length;              }
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: foreach (String entry in entries)              {                  byte[] buf = new byte[entry.Length * 2 + 2];                  LittleEndian.PutShort(buf' 0' (short)entry.Length);                  StringUtil.PutUnicodeLE(entry' buf' 2);                  tableStream.Write(buf);                  size += buf.Length;              }
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: if (word9)              {                  nameLength = LittleEndian.GetShort(std' nameStart);                  multiplier = 2;                  nameStart += LittleEndianConsts.SHORT_SIZE;              }              else              {                  nameLength = std[nameStart];              }
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: for (int x = 0; x < numUPX; x++)              {                  int upxSize = LittleEndian.GetShort(std' varoffset);                  varoffset += LittleEndianConsts.SHORT_SIZE;                    byte[] upx = new byte[upxSize];                  Array.Copy(std' varoffset' upx' 0' upxSize);                  _upxs[x] = new UPX(upx);                  varoffset += upxSize;                      // the upx will always start on a word boundary.                  if (upxSize % 2 == 1)                  {                      ++varoffset;                  }                }
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: int size = _baseLength + 2 + ((_name.Length + 1) * 2);
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: int size = _baseLength + 2 + ((_name.Length + 1) * 2);
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs[0].Size + 2;
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: for (int x = 1; x < _upxs.Length; x++)              {                  size += _upxs[x - 1].Size % 2;                  size += _upxs[x].Size + 2;              }
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: for (int x = 1; x < _upxs.Length; x++)              {                  size += _upxs[x - 1].Size % 2;                  size += _upxs[x].Size + 2;              }
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < _upxs.Length; x++)              {                  short upxSize = (short)_upxs[x].Size;                  LittleEndian.PutShort(buf' offset' upxSize);                  offset += LittleEndianConsts.SHORT_SIZE;                  Array.Copy(_upxs[x].GetUPX()' 0' buf' offset' upxSize);                  offset += upxSize + (upxSize % 2);              }
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: _rgftc = new int[3];
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: _rgftc[2] = LittleEndian.GetShort(tableStream' offset);
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: for (int x = 0; x < stdCount; x++)              {                  int stdSize = LittleEndian.GetShort(tableStream' offset);                  //get past the size                  offset += 2;                  if (stdSize > 0)                  {                      //byte[] std = new byte[stdSize];                        StyleDescription aStyle = new StyleDescription(tableStream'                        _baseLength' offset' true);                        _styleDescriptions[x] = aStyle;                  }                    offset += stdSize;                }
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: byte[] buf = new byte[_stshiLength + 2];
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(buf' offset' (short)_rgftc[2]);
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: byte[] sizeHolder = new byte[2];
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < _styleDescriptions.Length; x++)              {                  if (_styleDescriptions[x] != null)                  {                      byte[] std = _styleDescriptions[x].ToArray();                        // adjust the size so it is always on a word boundary                      LittleEndian.PutShort(sizeHolder' (short)((std.Length) + (std.Length % 2)));                      out1.Write(sizeHolder);                      out1.Write(std);                        // Must always start on a word boundary.                      if (std.Length % 2 == 1)                      {                          out1.Write('\0');                      }                  }                  else                  {                      sizeHolder[0] = 0;                      sizeHolder[1] = 0;                      out1.Write(sizeHolder);                  }              }
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < _styleDescriptions.Length; x++)              {                  if (_styleDescriptions[x] != null)                  {                      byte[] std = _styleDescriptions[x].ToArray();                        // adjust the size so it is always on a word boundary                      LittleEndian.PutShort(sizeHolder' (short)((std.Length) + (std.Length % 2)));                      out1.Write(sizeHolder);                      out1.Write(std);                        // Must always start on a word boundary.                      if (std.Length % 2 == 1)                      {                          out1.Write('\0');                      }                  }                  else                  {                      sizeHolder[0] = 0;                      sizeHolder[1] = 0;                      out1.Write(sizeHolder);                  }              }
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The following statement contains a magic number: if (ss._baseLength == _baseLength && ss._flags == _flags &&                  ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex &&                  ss._rgftc[0] == _rgftc[0] && ss._rgftc[1] == _rgftc[1] &&                  ss._rgftc[2] == _rgftc[2] && ss._stshiLength == _stshiLength &&                  ss._stylenameVersion == _stylenameVersion)              {                  if (ss._styleDescriptions.Length == _styleDescriptions.Length)                  {                      for (int x = 0; x < _styleDescriptions.Length; x++)                      {                          // check for null                          if (ss._styleDescriptions[x] != _styleDescriptions[x])                          {                              // check for Equality                              if (!ss._styleDescriptions[x].Equals(_styleDescriptions[x]))                              {                                  return false;                              }                          }                      }                      return true;                  }              }
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The following statement contains a magic number: if (ss._baseLength == _baseLength && ss._flags == _flags &&                  ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex &&                  ss._rgftc[0] == _rgftc[0] && ss._rgftc[1] == _rgftc[1] &&                  ss._rgftc[2] == _rgftc[2] && ss._stshiLength == _stshiLength &&                  ss._stylenameVersion == _stylenameVersion)              {                  if (ss._styleDescriptions.Length == _styleDescriptions.Length)                  {                      for (int x = 0; x < _styleDescriptions.Length; x++)                      {                          // check for null                          if (ss._styleDescriptions[x] != _styleDescriptions[x])                          {                              // check for Equality                              if (!ss._styleDescriptions[x].Equals(_styleDescriptions[x]))                              {                                  return false;                              }                          }                      }                      return true;                  }              }
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The following statement contains a magic number: if (pap == null && papx != null)              {                  ParagraphProperties parentPAP = new ParagraphProperties();                  if (baseIndex != NIL_STYLE)                  {                        parentPAP = _styleDescriptions[baseIndex].GetPAP();                      if (parentPAP == null)                      {                          if (baseIndex == istd)                          {                              // Oh dear' style claims that it is its own parent                              throw new InvalidOperationException("Pap style " + istd + " claimed to have itself as its parent' which isn't allowed");                          }                          // Create the parent style                          CreatePap(baseIndex);                          parentPAP = _styleDescriptions[baseIndex].GetPAP();                      }                    }                    pap = ParagraphSprmUncompressor.UncompressPAP(parentPAP' papx' 2);                  sd.SetPAP(pap);              }
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The following statement contains a magic number: for (int x = 0; x < pieces.Length; x++)              {                  int start = pieces[x].FilePosition;                  PropertyNode node = pieceTable.GetProperty(x);                    // Grab the start and end' which are in characters                  int nodeStartChars = node.Start;                  int nodeEndChars = node.End;                    // What's the relationship between bytes and characters?                  bool unicode = pieces[x].IsUnicode;                  int multiple = 1;                  if (unicode)                  {                      multiple = 2;                  }                    // Figure out the Length' in bytes and chars                  int textSizeChars = (nodeEndChars - nodeStartChars);                  int textSizeBytes = textSizeChars * multiple;                    // Grab the data that Makes up the piece                  byte[] buf = new byte[textSizeBytes];                  Array.Copy(documentStream' start' buf' 0' textSizeBytes);                    // And now build the piece                  _textPieces.Add(new TextPiece(nodeStartChars' nodeEndChars' buf' pieces[x]' node                          .Start));              }
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: foreach (TextPiece tp in _textPieces)              {                  if (charPos >= tp.End)                  {                      byteCount = tp.PieceDescriptor.FilePosition                              + (tp.End - tp.Start)                              * (tp.IsUnicode ? 2 : 1);                        if (charPos == tp.End)                          break;                        continue;                  }                  if (charPos < tp.End)                  {                      int left = charPos - tp.Start;                      byteCount = tp.PieceDescriptor.FilePosition + left                              * (tp.IsUnicode ? 2 : 1);                      break;                  }              }
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: foreach (TextPiece tp in _textPieces)              {                  if (charPos >= tp.End)                  {                      byteCount = tp.PieceDescriptor.FilePosition                              + (tp.End - tp.Start)                              * (tp.IsUnicode ? 2 : 1);                        if (charPos == tp.End)                          break;                        continue;                  }                  if (charPos < tp.End)                  {                      int left = charPos - tp.Start;                      byteCount = tp.PieceDescriptor.FilePosition + left                              * (tp.IsUnicode ? 2 : 1);                      break;                  }              }
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,GetCharIndex,The following statement contains a magic number: foreach (TextPiece tp in _textPieces)              {                  int pieceStart = tp.PieceDescriptor.FilePosition;                    int bytesLength = tp.BytesLength;                  int pieceEnd = pieceStart + bytesLength;                    int toAdd;                    if (bytePos < pieceStart || bytePos > pieceEnd)                  {                      toAdd = bytesLength;                  }                  else if (bytePos > pieceStart && bytePos < pieceEnd)                  {                      toAdd = (bytePos - pieceStart);                  }                  else                  {                      toAdd = bytesLength - (pieceEnd - bytePos);                  }                    if (tp.IsUnicode)                  {                      charCount += toAdd / 2;                  }                  else                  {                      charCount += toAdd;                  }                    if (bytePos >= pieceStart && bytePos <= pieceEnd && charCount >= startCP)                  {                      break;                  }              }
Magic Number,NPOI.HWPF.Model.Types,BKFAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\BKFAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,BKFAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\BKFAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_35_doptypography = LittleEndian.GetByteArray(data' 0x5a + offset' 310);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_36_dogrid = LittleEndian.GetByteArray(data' 0x190 + offset' 10);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_39_asumyi = LittleEndian.GetByteArray(data' 0x19e + offset' 12);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_44_Spare = LittleEndian.GetByteArray(data' 0x1ba + offset' 30);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FLDAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FLDAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1;
Magic Number,NPOI.HWPF.Model.Types,FRDAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FRDAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,HRESIAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\HRESIAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1;
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
Magic Number,NPOI.HWPF.Model.Types,PAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\PAPAbstractType.cs,PAPAbstractType,The following statement contains a magic number: this.field_41_lvl = 9;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_1_bkc = 2;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_13_dxaPgn = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_14_dyaPgn = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_39_xaPage = 12240;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_40_yaPage = 15840;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_41_xaPageNUp = 12240;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_42_yaPageNUp = 15840;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_43_dxaLeft = 1800;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_44_dxaRight = 1800;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_45_dyaTop = 1440;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_46_dyaBottom = 1440;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_48_dyaHdrTop = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_49_dyaHdrBottom = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_53_dxaColumns = 720;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TLPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TLPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 1;
Magic Number,NPOI.HWPF.Model.Types,TLPAbstractType,C:\repos\svn2github_npoi\scratchpad\HWPF\Model\Types\TLPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 1;
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: if (!newCHP.GetDttmRMark().Equals(oldCHP.GetDttmRMark()))              {                  byte[] buf = new byte[4];                  newCHP.GetDttmRMark().Serialize(buf' 0);                    size += SprmUtils.AddSprm((short)0x6805' LittleEndian.GetInt(buf)' null' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: if (newCHP.IsFSpec() && newCHP.GetFtcSym() != 0)              {                  byte[] varParam = new byte[4];                  LittleEndian.PutShort(varParam' 0' (short)newCHP.GetFtcSym());                  LittleEndian.PutShort(varParam' 2' (short)newCHP.GetXchSym());                    size += SprmUtils.AddSprm((short)0x6a09' 0' varParam' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: if (newCHP.IsFSpec() && newCHP.GetFtcSym() != 0)              {                  byte[] varParam = new byte[4];                  LittleEndian.PutShort(varParam' 0' (short)newCHP.GetFtcSym());                  LittleEndian.PutShort(varParam' 2' (short)newCHP.GetXchSym());                    size += SprmUtils.AddSprm((short)0x6a09' 0' varParam' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: if (!newPAP.GetLspd().Equals(oldPAP.GetLspd()))              {                  // sprmPDyaLine                  byte[] buf = new byte[4];                  newPAP.GetLspd().Serialize(buf' 0);                    size += SprmUtils.AddSprm((short)0x6412' LittleEndian.GetInt(buf)' null' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: if (newPAP.GetFPropRMark() != oldPAP.GetFPropRMark() ||                  newPAP.GetIbstPropRMark() != oldPAP.GetIbstPropRMark() ||                  !newPAP.GetDttmPropRMark().Equals(oldPAP.GetDttmPropRMark()))              {                  // sprmPPropRMark                  byte[] buf = new byte[7];                  buf[0] = (byte)(newPAP.GetFPropRMark() ? 1 : 0);                  LittleEndian.PutShort(buf' 1' (short)newPAP.GetIbstPropRMark());                  newPAP.GetDttmPropRMark().Serialize(buf' 3);                  size += SprmUtils.AddSprm(unchecked((short)0xC63F)' 0' buf' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: if (newPAP.GetFPropRMark() != oldPAP.GetFPropRMark() ||                  newPAP.GetIbstPropRMark() != oldPAP.GetIbstPropRMark() ||                  !newPAP.GetDttmPropRMark().Equals(oldPAP.GetDttmPropRMark()))              {                  // sprmPPropRMark                  byte[] buf = new byte[7];                  buf[0] = (byte)(newPAP.GetFPropRMark() ? 1 : 0);                  LittleEndian.PutShort(buf' 1' (short)newPAP.GetIbstPropRMark());                  newPAP.GetDttmPropRMark().Serialize(buf' 3);                  size += SprmUtils.AddSprm(unchecked((short)0xC63F)' 0' buf' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The following statement contains a magic number: if (newSEP.GetFPropMark() != DEFAULT_SEP.GetFPropMark() ||                  newSEP.GetIbstPropRMark() != DEFAULT_SEP.GetIbstPropRMark() ||                  !newSEP.GetDttmPropRMark().Equals(DEFAULT_SEP.GetDttmPropRMark()))              {                  byte[] buf = new byte[7];                  buf[0] = (byte)(newSEP.GetFPropMark() ? 1 : 0);                  int offset = LittleEndianConsts.BYTE_SIZE;                  LittleEndian.PutShort(buf' (short)newSEP.GetIbstPropRMark());                  offset += LittleEndianConsts.SHORT_SIZE;                  newSEP.GetDttmPropRMark().Serialize(buf' offset);                  size += SprmUtils.AddSprm(unchecked((short)0xD227)' -1' buf' sprmList);              }
Magic Number,NPOI.HWPF.SPRM,SectionSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newSEP.SetCnsPgn((byte)sprm.Operand);                      break;                  case 0x1:                      newSEP.SetIHeadingPgn((byte)sprm.Operand);                      break;                  case 0x2:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(sprm.Grpprl' sprm.GrpprlOffset' buf' 0' buf.Length);                      newSEP.SetOlstAnm(buf);                      break;                  case 0x3:                      //not quite sure                      break;                  case 0x4:                      //not quite sure                      break;                  case 0x5:                      newSEP.SetFEvenlySpaced(GetFlag(sprm.Operand));                      break;                  case 0x6:                      newSEP.SetFUnlocked(GetFlag(sprm.Operand));                      break;                  case 0x7:                      newSEP.SetDmBinFirst((short)sprm.Operand);                      break;                  case 0x8:                      newSEP.SetDmBinOther((short)sprm.Operand);                      break;                  case 0x9:                      newSEP.SetBkc((byte)sprm.Operand);                      break;                  case 0xa:                      newSEP.SetFTitlePage(GetFlag(sprm.Operand));                      break;                  case 0xb:                      newSEP.SetCcolM1((short)sprm.Operand);                      break;                  case 0xc:                      newSEP.SetDxaColumns(sprm.Operand);                      break;                  case 0xd:                      newSEP.SetFAutoPgn(GetFlag(sprm.Operand));                      break;                  case 0xe:                      newSEP.SetNfcPgn((byte)sprm.Operand);                      break;                  case 0xf:                      newSEP.SetDyaPgn((short)sprm.Operand);                      break;                  case 0x10:                      newSEP.SetDxaPgn((short)sprm.Operand);                      break;                  case 0x11:                      newSEP.SetFPgnRestart(GetFlag(sprm.Operand));                      break;                  case 0x12:                      newSEP.SetFEndNote(GetFlag(sprm.Operand));                      break;                  case 0x13:                      newSEP.SetLnc((byte)sprm.Operand);                      break;                  case 0x14:                      newSEP.SetGrpfIhdt((byte)sprm.Operand);                      break;                  case 0x15:                      newSEP.SetNLnnMod((short)sprm.Operand);                      break;                  case 0x16:                      newSEP.SetDxaLnn(sprm.Operand);                      break;                  case 0x17:                      newSEP.SetDyaHdrTop(sprm.Operand);                      break;                  case 0x18:                      newSEP.SetDyaHdrBottom(sprm.Operand);                      break;                  case 0x19:                      newSEP.SetFLBetween(GetFlag(sprm.Operand));                      break;                  case 0x1a:                      newSEP.SetVjc((byte)sprm.Operand);                      break;                  case 0x1b:                      newSEP.SetLnnMin((short)sprm.Operand);                      break;                  case 0x1c:                      newSEP.SetPgnStart((short)sprm.Operand);                      break;                  case 0x1d:                      newSEP.SetDmOrientPage(sprm.Operand!=0);                      break;                  case 0x1e:                        //nothing                      break;                  case 0x1f:                      newSEP.SetXaPage(sprm.Operand);                      break;                  case 0x20:                      newSEP.SetYaPage(sprm.Operand);                      break;                  case 0x21:                      newSEP.SetDxaLeft(sprm.Operand);                      break;                  case 0x22:                      newSEP.SetDxaRight(sprm.Operand);                      break;                  case 0x23:                      newSEP.SetDyaTop(sprm.Operand);                      break;                  case 0x24:                      newSEP.SetDyaBottom(sprm.Operand);                      break;                  case 0x25:                      newSEP.SetDzaGutter(sprm.Operand);                      break;                  case 0x26:                      newSEP.SetDmPaperReq((short)sprm.Operand);                      break;                  case 0x27:                      newSEP.SetFPropMark(GetFlag(sprm.Operand));                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      newSEP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2c:                      newSEP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2d:                      newSEP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2e:                      newSEP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2f:                      newSEP.SetPgbProp(sprm.Operand);                      break;                  case 0x30:                      newSEP.SetDxtCharSpace(sprm.Operand);                      break;                  case 0x31:                      newSEP.SetDyaLinePitch(sprm.Operand);                      break;                  case 0x33:                      newSEP.SetWTextFlow((short)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,SprmBuffer,The following statement contains a magic number: _buf = new byte[sprmsStartOffset + 4];
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,SprmBuffer,The following statement contains a magic number: _buf = new byte[4];
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,FindSprm,The following statement contains a magic number: SprmIterator si = new SprmIterator(_buf' 2);
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,EnsureCapacity,The following statement contains a magic number: if (_offset + Addition >= _buf.Length)              {                  // Add 6 more than they need for use the next iteration                  byte[] newBuf = new byte[_offset + Addition + 6];                  Array.Copy(_buf' 0' newBuf' 0' _buf.Length);                  _buf = newBuf;              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,SprmOperation,The following statement contains a magic number: _gOffset = offset + 2;
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,FindSprm,The following statement contains a magic number: SprmIterator si = new SprmIterator(_buf' 2);
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: byte[] sprm = new byte[varParam.Length + 4];
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: System.Array.Copy(varParam' 0' sprm' 4' varParam.Length);
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: LittleEndian.PutShort(sprm' 2' (short)(varParam.Length + 1));
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: int type = (instruction & 0xe000) >> 13;
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,ConvertBrcToInt,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,NPOI.HWPF.SPRM,TableSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,The following statement contains a magic number: byte[] brcBuf = new byte[6 * BorderCode.SIZE];
Magic Number,NPOI.HWPF.SPRM,TableSprmCompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,The following statement contains a magic number: byte[] compare = new byte[6 * BorderCode.SIZE];
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.UserModel,BookmarkImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\BookmarksImpl.cs,GetHashCode,The following statement contains a magic number: return 31 + (first == null ? 0 : first.GetHashCode());
Magic Number,NPOI.HWPF.UserModel,BorderCode,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\BorderCode.cs,ToInt,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_41_xstDispFldRMark = new byte[36];
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_7_hps = 20;
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_24_istd = 10;
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_16_wCharScale = 100;
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1)              {                  switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }              }
Magic Number,NPOI.HWPF.UserModel,FieldsImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\FieldsImpl.cs,BinarySearch,The following statement contains a magic number: return -mid - (result >= 0 ? 1 : 2);
Magic Number,NPOI.HWPF.UserModel,FieldsImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\FieldsImpl.cs,ParseFieldStructure,The following statement contains a magic number: List<FieldImpl> fields = new List<FieldImpl>(                      plexOfFields.Count / 3 + 1);
Magic Number,NPOI.HWPF.UserModel,HeaderStories,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\HeaderStories.cs,GetHeader,The following statement contains a magic number: if (pageNumber % 2 == 0)              {                  if (EvenHeader.Length > 0)                  {                      return EvenHeader;                  }              }
Magic Number,NPOI.HWPF.UserModel,HeaderStories,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\HeaderStories.cs,GetFooter,The following statement contains a magic number: if (pageNumber % 2 == 0)              {                  if (EvenFooter.Length > 0)                  {                      return EvenFooter;                  }              }
Magic Number,NPOI.HWPF.UserModel,HWPFList,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\HWPFList.cs,HWPFList,The following statement contains a magic number: _listData = new ListData((int)(new Random((int)DateTime.Now.Ticks).Next(0'100)/100 * DateTime.Now.Millisecond)' numbered);
Magic Number,NPOI.HWPF.UserModel,HWPFList,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\HWPFList.cs,HWPFList,The following statement contains a magic number: _listData = new ListData((int)(new Random((int)DateTime.Now.Ticks).Next(0'100)/100 * DateTime.Now.Millisecond)' numbered);
Magic Number,NPOI.HWPF.UserModel,LineSpacingDescriptor,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\LineSpacingDescriptor.cs,ToInt,The following statement contains a magic number: byte[] intHolder = new byte[4];
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following statement contains a magic number: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following statement contains a magic number: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following statement contains a magic number: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following statement contains a magic number: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following statement contains a magic number: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following statement contains a magic number: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
Magic Number,NPOI.HWPF.UserModel,Paragraph,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: if (_props.IsFBackward())              {                  retVal |= 2;              }
Magic Number,NPOI.HWPF.UserModel,Paragraph,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: if (_props.IsFRotateFont())              {                  retVal |= 4;              }
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,ParagraphProperties,The following statement contains a magic number: SetAnld(new byte[84]);
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,ParagraphProperties,The following statement contains a magic number: SetPhe(new byte[12]);
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: if (jcLogical)              {                  if (!GetFBiDi())                      return GetJc();                    switch (GetJc())                  {                      case 0:                          return 2;                      case 2:                          return 0;                      default:                          return GetJc();                  }              }
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: if (jcLogical)              {                  if (!GetFBiDi())                      return GetJc();                    switch (GetJc())                  {                      case 0:                          return 2;                      case 2:                          return 0;                      default:                          return GetJc();                  }              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32))              {                try                {                      ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);                  MemoryStream out1 = new MemoryStream();                  byte[] buf = new byte[4096];                  int readBytes;                  while ((readBytes = gzip.Read(buf'0'4096)) > 0)                  {                      out1.Write(buf' 0' readBytes);                  }                  content = out1.ToArray();                }                catch (IOException)                {                  // Problems Reading from the actual MemoryStream should never happen                  // so this will only ever be a ZipException.                  //log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);                }              } else {                // Raw data is not compressed.                content = rawContent;              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32))              {                try                {                      ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);                  MemoryStream out1 = new MemoryStream();                  byte[] buf = new byte[4096];                  int readBytes;                  while ((readBytes = gzip.Read(buf'0'4096)) > 0)                  {                      out1.Write(buf' 0' readBytes);                  }                  content = out1.ToArray();                }                catch (IOException)                {                  // Problems Reading from the actual MemoryStream should never happen                  // so this will only ever be a ZipException.                  //log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);                }              } else {                // Raw data is not compressed.                content = rawContent;              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32))              {                try                {                      ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);                  MemoryStream out1 = new MemoryStream();                  byte[] buf = new byte[4096];                  int readBytes;                  while ((readBytes = gzip.Read(buf'0'4096)) > 0)                  {                      out1.Write(buf' 0' readBytes);                  }                  content = out1.ToArray();                }                catch (IOException)                {                  // Problems Reading from the actual MemoryStream should never happen                  // so this will only ever be a ZipException.                  //log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);                }              } else {                // Raw data is not compressed.                content = rawContent;              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32))              {                try                {                      ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);                  MemoryStream out1 = new MemoryStream();                  byte[] buf = new byte[4096];                  int readBytes;                  while ((readBytes = gzip.Read(buf'0'4096)) > 0)                  {                      out1.Write(buf' 0' readBytes);                  }                  content = out1.ToArray();                }                catch (IOException)                {                  // Problems Reading from the actual MemoryStream should never happen                  // so this will only ever be a ZipException.                  //log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);                }              } else {                // Raw data is not compressed.                content = rawContent;              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32))              {                try                {                      ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);                  MemoryStream out1 = new MemoryStream();                  byte[] buf = new byte[4096];                  int readBytes;                  while ((readBytes = gzip.Read(buf'0'4096)) > 0)                  {                      out1.Write(buf' 0' readBytes);                  }                  content = out1.ToArray();                }                catch (IOException)                {                  // Problems Reading from the actual MemoryStream should never happen                  // so this will only ever be a ZipException.                  //log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);                }              } else {                // Raw data is not compressed.                content = rawContent;              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32))              {                try                {                      ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);                  MemoryStream out1 = new MemoryStream();                  byte[] buf = new byte[4096];                  int readBytes;                  while ((readBytes = gzip.Read(buf'0'4096)) > 0)                  {                      out1.Write(buf' 0' readBytes);                  }                  content = out1.ToArray();                }                catch (IOException)                {                  // Problems Reading from the actual MemoryStream should never happen                  // so this will only ever be a ZipException.                  //log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);                }              } else {                // Raw data is not compressed.                content = rawContent;              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The following statement contains a magic number: short MM_TYPE = LittleEndian.GetShort(_dataStream' dataBlockStartOffset + PICT_HEADER_OFFSET + 2);
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: int pointer = pictureBytesStartOffset + 2;
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: while (pointer < endOfPicture - 1)              {                  do                  {                      firstByte = _dataStream[pointer];                      secondByte = _dataStream[pointer + 1];                      pointer += 2;                  } while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);                    if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1)                  {                      if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA)                      {                          break;                      }                      else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC)                      {                          pointer += 5;                          this.height = GetBigEndianShort(_dataStream' pointer);                          this.width = GetBigEndianShort(_dataStream' pointer + 2);                          break;                      }                      else                      {                          pointer++;                          pointer++;                          int length = GetBigEndianShort(_dataStream' pointer);                          pointer += length;                      }                  }                  else                  {                      pointer++;                  }              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: while (pointer < endOfPicture - 1)              {                  do                  {                      firstByte = _dataStream[pointer];                      secondByte = _dataStream[pointer + 1];                      pointer += 2;                  } while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);                    if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1)                  {                      if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA)                      {                          break;                      }                      else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC)                      {                          pointer += 5;                          this.height = GetBigEndianShort(_dataStream' pointer);                          this.width = GetBigEndianShort(_dataStream' pointer + 2);                          break;                      }                      else                      {                          pointer++;                          pointer++;                          int length = GetBigEndianShort(_dataStream' pointer);                          pointer += length;                      }                  }                  else                  {                      pointer++;                  }              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: while (pointer < endOfPicture - 1)              {                  do                  {                      firstByte = _dataStream[pointer];                      secondByte = _dataStream[pointer + 1];                      pointer += 2;                  } while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);                    if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1)                  {                      if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA)                      {                          break;                      }                      else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC)                      {                          pointer += 5;                          this.height = GetBigEndianShort(_dataStream' pointer);                          this.width = GetBigEndianShort(_dataStream' pointer + 2);                          break;                      }                      else                      {                          pointer++;                          pointer++;                          int length = GetBigEndianShort(_dataStream' pointer);                          pointer += length;                      }                  }                  else                  {                      pointer++;                  }              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: int HEADER_START = pictureBytesStartOffset + PictureType.PNG.Signatures[0].Length + 4;
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: if (MatchSignature(_dataStream' IHDR' HEADER_START))              {                  int IHDR_CHUNK_WIDTH = HEADER_START + 4;                  this.width = GetBigEndianInt(_dataStream' IHDR_CHUNK_WIDTH);                  this.height = GetBigEndianInt(_dataStream' IHDR_CHUNK_WIDTH + 4);              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: if (MatchSignature(_dataStream' IHDR' HEADER_START))              {                  int IHDR_CHUNK_WIDTH = HEADER_START + 4;                  this.width = GetBigEndianInt(_dataStream' IHDR_CHUNK_WIDTH);                  this.height = GetBigEndianInt(_dataStream' IHDR_CHUNK_WIDTH + 4);              }
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianShort,The following statement contains a magic number: return (((data[offset] & 0xFF) << 8) + (data[offset + 1] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _left = LittleEndian.GetInt(contenuto' 4);
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _top = LittleEndian.GetInt(contenuto' 8);
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _right = LittleEndian.GetInt(contenuto' 12);
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _bottom = LittleEndian.GetInt(contenuto' 16);
Magic Number,NPOI.HWPF.UserModel,TableAutoformatLookSpecifier,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\TableAutoformatLookSpecifier.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Missing Default,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following switch statement is missing a default case: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Missing Default,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following switch statement is missing a default case: switch (rgbValue)              {                  case 0xFFFFFF:                      return "white";                  case 0xC0C0C0:                      return "silver";                  case 0x808080:                      return "gray";                  case 0x000000:                      return "black";                  case 0xFF0000:                      return "red";                  case 0x800000:                      return "maroon";                  case 0xFFFF00:                      return "yellow";                  case 0x808000:                      return "olive";                  case 0x00FF00:                      return "lime";                  case 0x008000:                      return "green";                  case 0x00FFFF:                      return "aqua";                  case 0x008080:                      return "teal";                  case 0x0000FF:                      return "blue";                  case 0x000080:                      return "navy";                  case 0xFF00FF:                      return "fuchsia";                  case 0x800080:                      return "purple";              }
Missing Default,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following switch statement is missing a default case: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Missing Default,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following switch statement is missing a default case: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Missing Default,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following switch statement is missing a default case: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following switch statement is missing a default case: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following switch statement is missing a default case: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following switch statement is missing a default case: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,C:\repos\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following switch statement is missing a default case: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
