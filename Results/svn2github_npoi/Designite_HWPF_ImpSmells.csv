Implementation smell,Namespace,Class,File,Method,Description
Long Method,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The method has 261 lines of code.
Long Method,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has 152 lines of code.
Long Method,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The method has 184 lines of code.
Long Method,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,The method has 170 lines of code.
Long Method,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The method has 139 lines of code.
Long Method,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The method has 135 lines of code.
Long Method,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,ToString,The method has 204 lines of code.
Long Method,NPOI.HWPF.Model.Types,PAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\PAPAbstractType.cs,ToString,The method has 163 lines of code.
Long Method,NPOI.HWPF.SPRM,CharacterSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The method has 249 lines of code.
Long Method,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The method has 472 lines of code.
Long Method,NPOI.HWPF.SPRM,ParagraphSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The method has 340 lines of code.
Long Method,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The method has 295 lines of code.
Long Method,NPOI.HWPF.SPRM,SectionSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The method has 197 lines of code.
Long Method,NPOI.HWPF.SPRM,SectionSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,The method has 159 lines of code.
Long Method,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The method has 184 lines of code.
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,Cyclomatic complexity of the method is 45
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraphes,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,Cyclomatic complexity of the method is 17
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,Cyclomatic complexity of the method is 18
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessTable,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,DefaultFontReplacer,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\DefaultFontReplacer.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF.Converter,NumberFormatter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\NumberFormatter.cs,ToLetters,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,WordToHtmlUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Model,BaseObject,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\BaseObject.cs,Clone,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,Cyclomatic complexity of the method is 23
Complex Method,NPOI.HWPF.Model,Ffn,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Ffn.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.Model,ListTables,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,Cyclomatic complexity of the method is 19
Complex Method,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HWPF.Model,SectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,SectionTable,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.SPRM,CharacterSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,Cyclomatic complexity of the method is 57
Complex Method,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,Cyclomatic complexity of the method is 125
Complex Method,NPOI.HWPF.SPRM,ParagraphSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,Cyclomatic complexity of the method is 64
Complex Method,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,Cyclomatic complexity of the method is 80
Complex Method,NPOI.HWPF.SPRM,SectionSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,Cyclomatic complexity of the method is 47
Complex Method,NPOI.HWPF.SPRM,SectionSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,Cyclomatic complexity of the method is 52
Complex Method,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.SPRM,TableSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,Cyclomatic complexity of the method is 22
Complex Method,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,Cyclomatic complexity of the method is 18
Complex Method,NPOI.HWPF.UserModel,FieldsImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\FieldsImpl.cs,ParseFieldStructureImpl,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF.UserModel,OfficeDrawingsImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetBitmapRecord,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.UserModel,Range,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Range.cs,GetTable,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.UserModel,Range,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Range.cs,FindRange,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.UserModel,TableRow,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\TableRow.cs,initCells,Cyclomatic complexity of the method is 8
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,getTableCellEdgesIndexSkipCount,The method has 6 parameters. Parameters: table' r' tableCellEdges' currentEdgeIndex' c' tableCell
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The method has 7 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' beginMark' separatorMark' endMark
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The method has 5 parameters. Parameters: wordDocument' charactersRange' currentTableLevel' startOffset' currentBlock
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The method has 5 parameters. Parameters: wordDocument' parentRange' currentTableLevel' field' currentBlock
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: wordDocument' parentElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,The method has 5 parameters. Parameters: wordDocument' range' currentTableLevel' beginMark' currentBlock
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: hwpfDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: hwpfDocument' parentFopElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The method has 7 parameters. Parameters: tableRow' tableCell' XmlElement' toppest' bottomest' leftest' rightest
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: wordDocument' parentElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessBookmarks,The method has 5 parameters. Parameters: wordDocument' currentBlock' range' currentTableLevel' rangeBookmarks
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessDrawnObject,The method has 5 parameters. Parameters: doc' characterRun' officeDrawing' path' block
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessNoteAutonumbered,The method has 5 parameters. Parameters: wordDocument' type' noteIndex' block' noteTextRange
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessHyperlink,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' hyperlink
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessPageref,The method has 5 parameters. Parameters: wordDocument' currentBlock' textRange' currentTableLevel' pageref
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The method has 5 parameters. Parameters: wordDocument' parentElement' currentTableLevel' paragraph' bulletText
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The method has 7 parameters. Parameters: tableRow' tableCell' toppest' bottomest' leftest' rightest' style
Long Parameter List,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The method has 6 parameters. Parameters: documentStream' tableStream' offset' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The method has 5 parameters. Parameters: documentStream' tableStream' offset' size' translator
Long Parameter List,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The method has 5 parameters. Parameters: mainStream' offset' tableStream' offsetList' areKnown
Long Parameter List,NPOI.HWPF.Model,ListLevel,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,ListLevel,The method has 6 parameters. Parameters: startAt' numberFormatCode' alignment' numberProperties' entryProperties' numberText
Long Parameter List,NPOI.HWPF.Model,OldCHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\OldCHPBinTable.cs,OldCHPBinTable,The method has 5 parameters. Parameters: documentStream' OffSet' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,OldPAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\OldPAPBinTable.cs,OldPAPBinTable,The method has 5 parameters. Parameters: documentStream' OffSet' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,OldSectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The method has 5 parameters. Parameters: documentStream' offset' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The method has 7 parameters. Parameters: documentStream' tableStream' dataStream' offset' size' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The method has 6 parameters. Parameters: documentStream' tableStream' dataStream' offset' size' charIndexTranslator
Long Parameter List,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,PAPFormattedDiskPage,The method has 5 parameters. Parameters: documentStream' dataStream' offset' fcMin' tpt
Long Parameter List,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 6 parameters. Parameters: fcStart' fcEnd' translator' papx' phe' dataStream
Long Parameter List,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 5 parameters. Parameters: charStart' charEnd' papx' phe' dataStream
Long Parameter List,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 5 parameters. Parameters: fcStart' fcEnd' translator' buf' dataStream
Long Parameter List,NPOI.HWPF.Model,PicturesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,PicturesTable,The method has 5 parameters. Parameters: _document' _dataStream' _mainStream' fspa' dgg
Long Parameter List,NPOI.HWPF.Model,SectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,SectionTable,The method has 7 parameters. Parameters: documentStream' tableStream' OffSet' size' fcMin' tpt' cps
Long Parameter List,NPOI.HWPF.Model,TextPiece,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPiece.cs,TextPiece,The method has 5 parameters. Parameters: start' end' text' pd' cpStart
Long Parameter List,NPOI.HWPF.Model,TextPieceTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The method has 5 parameters. Parameters: documentStream' tableStream' offset' size' fcMin
Long Parameter List,NPOI.HWPF.UserModel,TableCell,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\TableCell.cs,TableCell,The method has 7 parameters. Parameters: startIdx' endIdx' parent' levelNum' tcd' leftEdge' width
Long Identifier,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,,The length of the parameter SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE is 40.
Long Identifier,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,,The length of the parameter UNICODECHAR_NONBREAKING_HYPHEN is 30.
Long Identifier,NPOI.HWPF.Model,PicturesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,,The length of the parameter TYPE_IMAGE_PASTED_FROM_CLIPBOARD is 32.
Long Identifier,NPOI.HWPF.Model,PicturesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,,The length of the parameter TYPE_IMAGE_PASTED_FROM_CLIPBOARD_WORD2000 is 41.
Long Identifier,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,,The length of the parameter oldfSuppressSpbfAfterPageBreak is 30.
Long Identifier,NPOI.HWPF.Model.Types,HRESIAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\HRESIAbstractType.cs,,The length of the parameter HRES_DELETE_BEFORE_CHANGE_BEFORE is 32.
Long Identifier,NPOI.HWPF.Model.Types,LFOAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,,The length of the parameter fHtmlHangingIndentBeneathNumber is 31.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "                    IEnumerator<List<Bookmark>> iterator = ((HWPFDocument)wordDocument).GetBookmarks().GetBookmarksStartedBetween(structure.Start' structure.Start + 1).Values.GetEnumerator(); " is 171.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessOle2,The length of the statement  "                logger.Log(POILogger.WARN' "Referenced OLE2 object '"' (characterRun.GetPicOffset()).ToString()' "' not found in ObjectPool"); " is 126.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "                htmlDocumentFacade.AddStyleClass(root' "d"' "vertical-align:text-bottom;width:" + visibleWidth + "in;height:" + visibleHeight + "in;"); " is 135.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "                htmlDocumentFacade.AddStyleClass(inner' "d"' "position:relative;width:" + visibleWidth + "in;height:" + visibleHeight + "in;overflow:hidden;"); " is 143.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "                htmlDocumentFacade.AddStyleClass(image' "i"' "position:absolute;left:-" + cropLeft + ";top:-" + cropTop + ";width:" + imageWidth + "in;height:" + imageHeight + "in;"); " is 167.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "                    WordToHtmlUtils.AddTableCellProperties(tableRow' tableCell' r == 0' r == tableRows - 1' c == 0' c == rowCells - 1' tableCellStyle); " is 131.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "                            htmlDocumentFacade.GetOrCreateCssClass(tableElement.LocalName' "t"' "table-layout:fixed;border-collapse:collapse;border-spacing:0;")); " is 134.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "                logger.Log(POILogger.WARN' "Table without body starting at ["' table.StartOffset.ToString()' "; "' table.EndOffset.ToString()' ")"); " is 132.
Long Statement,NPOI.HWPF.Model,ListTables,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,GetLevel,The length of the statement  "            //log.log(POILogger.WARN' "Requested level " + level + " which was greater than the maximum defined (" + lst.numLevels() + ")"); " is 128.
Long Statement,NPOI.HWPF.Model,PicturesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,IsPictureRecognized,The length of the statement  "            return (blockType == TYPE_IMAGE || blockType == TYPE_IMAGE_PASTED_FROM_CLIPBOARD || (blockType == TYPE_IMAGE_WORD2000 && mappingModeOfMETAFILEPICT == 0x64) || (blockType == TYPE_IMAGE_PASTED_FROM_CLIPBOARD_WORD2000 && mappingModeOfMETAFILEPICT == 0x64)); " is 254.
Long Statement,NPOI.HWPF.Model,SectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,WriteTo,The length of the statement  "                GenericPropertyNode property = new GenericPropertyNode(tpt.GetCharIndex(sepx.StartBytes)' tpt.GetCharIndex(sepx.EndBytes)' sed.ToArray()); " is 138.
Long Statement,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The length of the statement  "                            throw new InvalidOperationException("Pap style " + istd + " claimed to have itself as its parent' which isn't allowed"); " is 120.
Long Statement,NPOI.HWPF.Model,TextPiece,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPiece.cs,Substring,The length of the statement  "                throw new IndexOutOfRangeException("Asked for text from " + start + " to " + end + "' which has an end before the start!"); " is 123.
Long Statement,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The length of the statement  "            return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4; " is 183.
Long Statement,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,ToString,The length of the statement  "            buffer.Append("         .oldfSuppressSpbfAfterPageBreak     = ").Append(IsOldfSuppressSpbfAfterPageBreak()).Append('\n'); " is 121.
Long Statement,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The length of the statement  "            return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2; " is 227.
Long Statement,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The length of the statement  "            int PICTFBlockSize = LittleEndian.GetShort(_dataStream' dataBlockStartOffset + PICT_HEADER_OFFSET); // Should be 68 bytes " is 121.
Long Statement,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The length of the statement  "            int unknownHeaderOffset = (PICTF1BlockSize + PICTF1BlockOffset) < dataBlockEndOffset ? (PICTF1BlockSize + PICTF1BlockOffset) : PICTF1BlockOffset; " is 145.
Long Statement,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The length of the statement  "                    else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) " is 121.
Long Statement,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The length of the statement  "            return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF)); " is 138.
Complex Conditional,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,AddToStructures,The conditional expression  "(structure.Start < another.Start && another.Start < structure.End)                          || (structure.Start < another.Start && another.End <= structure.End)                          || (structure.Start <= another.Start && another.End < structure.End)"  is complex.
Complex Conditional,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The conditional expression  "charChar >= 0x20 || charChar == 0x09                                  || charChar == 0x0A || charChar == 0x0D"  is complex.
Complex Conditional,NPOI.HWPF.Converter,FoDocumentFacade,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\FoDocumentFacade.cs,SetProperty,The conditional expression  "!string.IsNullOrEmpty(childElement.NamespaceURI)                              && !string.IsNullOrEmpty(childElement.LocalName)                              && ns.Equals(childElement.NamespaceURI)                              && name.Equals(childElement.LocalName)"  is complex.
Complex Conditional,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The conditional expression  "picture.DyaCropTop != 0 || picture.DxaCropRight != 0                      || picture.DyaCropBottom != 0                      || picture.DxaCropLeft != 0"  is complex.
Complex Conditional,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The conditional expression  "cropTop != 0 || cropRight != 0 || cropBottom != 0 || cropLeft != 0"  is complex.
Complex Conditional,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The conditional expression  "first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f'"  is complex.
Complex Conditional,NPOI.HWPF.Model,FileInformationBlock,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FileInformationBlock.cs,ToString,The conditional expression  "!method.Name.StartsWith("get")                              || !method.IsPublic                              || method.IsStatic                              || method.GetParameters().Length > 0"  is complex.
Complex Conditional,NPOI.HWPF.Model,PicturesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,HasPicture,The conditional expression  "run.IsSpecialCharacter() && !run.IsObj() && !run.IsOle2() && !run.IsData()"  is complex.
Complex Conditional,NPOI.HWPF.Model,PicturesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PicturesTable.cs,HasEscherPicture,The conditional expression  "run.IsSpecialCharacter() && !run.IsObj() && !run.IsOle2() && !run.IsData() && run.Text.StartsWith("\u0008")"  is complex.
Complex Conditional,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,Equals,The conditional expression  "sd._infoshort == _infoshort && sd._infoshort2 == _infoshort2 &&                  sd._infoshort3 == _infoshort3 && sd._bchUpe == _bchUpe &&                  sd._infoshort4 == _infoshort4 &&                  _name.Equals(sd._name)"  is complex.
Complex Conditional,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The conditional expression  "ss._baseLength == _baseLength && ss._flags == _flags &&                  ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex &&                  ss._rgftc[0] == _rgftc[0] && ss._rgftc[1] == _rgftc[1] &&                  ss._rgftc[2] == _rgftc[2] && ss._stshiLength == _stshiLength &&                  ss._stylenameVersion == _stylenameVersion"  is complex.
Complex Conditional,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The conditional expression  "fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The conditional expression  "(secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,Range,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Range.cs,FindRange,The conditional expression  "startIndex < 0 || startIndex >= rpl.Count                      || startIndex > endIndex || endIndex < 0                      || endIndex >= rpl.Count"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,TableRow,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The conditional expression  "( ( s.Length > 0 && s[s.Length - 1]== TABLE_CELL_MARK ) || paragraph                      .IsEmbeddedCellMark() )                      && paragraph.GetTableLevel() == _levelNum"  is complex.
Virtual Method Call from Constructor,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The constructor "HWPFDocument" calls a virtual method "Read".
Virtual Method Call from Constructor,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The constructor "HWPFDocument" calls a virtual method "Read".
Virtual Method Call from Constructor,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,HWPFDocumentCore,The constructor "HWPFDocumentCore" calls a virtual method "Read".
Empty Catch Block,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAP,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The method has an empty catch block.
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType)              {                  case 1:                  case 2:                      return "solid";                  case 3:                      return "double";                  case 5:                      return "solid";                  case 6:                      return "dotted";                  case 7:                  case 8:                      return "dashed";                  case 9:                      return "dotted";                  case 10:                  case 11:                  case 12:                  case 13:                  case 14:                  case 15:                  case 16:                  case 17:                  case 18:                  case 19:                      return "double";                  case 20:                      return "solid";                  case 21:                      return "double";                  case 22:                      return "dashed";                  case 23:                      return "dashed";                  case 24:                      return "ridge";                  case 25:                      return "grooved";                  default:                      return "solid";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: int pt = lineWidth / 8;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: int pte = lineWidth - pt * 8;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: stringBuilder.Append(1000 / 8 * pte);
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: stringBuilder.Append(1000 / 8 * pte);
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBulletText,The following statement contains a magic number: element < 9
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico)              {                  case 1:                      return "black";                  case 2:                      return "blue";                  case 3:                      return "cyan";                  case 4:                      return "green";                  case 5:                      return "magenta";                  case 6:                      return "red";                  case 7:                      return "yellow";                  case 8:                      return "white";                  case 9:                      return "darkblue";                  case 10:                      return "darkcyan";                  case 11:                      return "darkgreen";                  case 12:                      return "darkmagenta";                  case 13:                      return "darkred";                  case 14:                      return "darkyellow";                  case 15:                      return "darkgray";                  case 16:                      return "lightgray";                  default:                      return "black";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetOpacity,The following statement contains a magic number: int opacity = (int)((argbValue & 0xFF000000L) >> 24);
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: int rgbValue = (bgrValue & 0x0000FF) << 16 | (bgrValue & 0x00FF00)                      | (bgrValue & 0xFF0000) >> 16;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: int rgbValue = (bgrValue & 0x0000FF) << 16 | (bgrValue & 0x00FF00)                      | (bgrValue & 0xFF0000) >> 16;
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: i < 6
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode)              {                  case 1024:                      return string.Empty;                  case 1033:                      return "en-us";                  case 1049:                      return "ru-ru";                  case 2057:                      return "en-uk";                  default:                      logger.Log(POILogger.WARN' "Uknown or unmapped language code: "' languageCode);                      return string.Empty;              }
Magic Number,NPOI.HWPF.Converter,WordToFoConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoConverter.cs,OutputCharacters,The following statement contains a magic number: WordToFoUtils.SetFontSize(inline' characterRun.GetFontSize() / 2);
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: int opacity = (int)(characterRun.GetIco24() & 0xFF000000L) >> 24;
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: inline.SetAttribute("text-shadow"' characterRun.GetFontSize() / 24 + "pt");
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: characterRun.GetSubSuperScriptIndex() == 2
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: graphicXmlElement                          .SetAttribute("content-width"' ((picture.DxaGoal                                  * horizontalScale / 1000) / TWIPS_PER_PT)                                  + "pt");
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: graphicXmlElement                          .SetAttribute("content-height"' ((picture.DyaGoal                                  * verticalScale / 1000) / TWIPS_PER_PT)                                  + "pt");
Magic Number,NPOI.HWPF.Converter,NumberFormatter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\NumberFormatter.cs,ToLetters,The following statement contains a magic number: int letterBase = 26;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: style.Append("font-size:" + characterRun.GetFontSize() / 2 + "pt;");
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: characterRun.GetFontSize() / 2 != blockProperies.pFontSize
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: imageWidth = picture.DxaGoal * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropRight = picture.DxaCropRight * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropLeft = picture.DxaCropLeft * aspectRatioX / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: imageHeight = picture.DyaGoal * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropTop = picture.DyaCropTop * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropBottom = picture.DyaCropBottom * aspectRatioY / 1000                          / AbstractWordUtils.TWIPS_PER_INCH;
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The following statement contains a magic number: pFontSize = characterRun.GetFontSize() / 2;
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddBorder,The following statement contains a magic number: borderCode.LineWidth < 8
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: style.Append("text-shadow:" + characterRun.GetFontSize() / 24 + "pt;");
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: characterRun.GetSubSuperScriptIndex() == 2
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The following statement contains a magic number: _fib.GetNFib() < 106
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: byte[] tempBuf = new byte[4096];
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: mainBuf.Length < 4096
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: byte[] tempBuf = new byte[4096];
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: tableBuf.Length < 4096
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: dataBuf = new byte[4096];
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: byte[] tempBuf = new byte[4096];
Magic Number,NPOI.HWPF,HWPFDocument,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: dataBuf.Length < 4096
Magic Number,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: byte[] first6 = new byte[6];
Magic Number,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: pis.Read(first6' 0' 6);
Magic Number,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f'
Magic Number,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f'
Magic Number,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: first6[0] == '{' && first6[1] == '\\' && first6[2] == 'r'                  && first6[3] == 't' && first6[4] == 'f'
Magic Number,NPOI.HWPF,HWPFDocumentCore,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: pis.Unread(6);
Magic Number,NPOI.HWPF.Model,BookmarkFirstDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\BookmarkFirstDescriptor.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Magic Number,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(tableStream' offset' size' 4);
Magic Number,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,WriteTo,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(4);
Magic Number,NPOI.HWPF.Model,CHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPBinTable.cs,WriteTo,The following statement contains a magic number: byte[] intHolder = new byte[4];
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int chpxOffset = 2 * LittleEndian.GetUByte(_fkp' _offset + (((_crun + 1) * 4) + index));
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int chpxOffset = 2 * LittleEndian.GetUByte(_fkp' _offset + (((_crun + 1) * 4) + index));
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[512];
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: int grpprlOffset = 511;
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: int totalSize = FC_SIZE + 2;
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: totalSize += (FC_SIZE + 2 + grpprlLength);
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: totalSize -= (FC_SIZE + 2 + grpprlLength);
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: totalSize > 511 + (index % 2)
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: totalSize > 511 + (index % 2)
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: (1 + grpprlLength) % 2 > 0
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: buf[511] = (byte)index;
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: grpprlOffset -= (grpprlOffset % 2);
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: buf[offsetOffset] = (byte)(grpprlOffset / 2);
Magic Number,NPOI.HWPF.Model,PictureDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PictureDescriptor.cs,PictureDescriptor,The following statement contains a magic number: this.offset14 = LittleEndian.GetByteArray(_dataStream'                      startOffset + 0x0E' 14);
Magic Number,NPOI.HWPF.Model,Ffn,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Ffn.cs,Ffn,The following statement contains a magic number: _xszFfnLength = (this.GetSize() - offsetTmp) / 2;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields = new int[numFields * 2];
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields[x * 2] = dsOffset;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields[(x * 2) + 1] = dsSize;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,GetFieldOffset,The following statement contains a magic number: return _fields[field * 2];
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,GetFieldSize,The following statement contains a magic number: return _fields[(field * 2) + 1];
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,SetFieldOffset,The following statement contains a magic number: _fields[field * 2] = offset;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,SetFieldSize,The following statement contains a magic number: _fields[(field * 2) + 1] = size;
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: int length = _fields.Length / 2;
Magic Number,NPOI.HWPF.Model,FootnoteReferenceDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FootnoteReferenceDescriptor.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FormattedDiskPage.cs,FormattedDiskPage,The following statement contains a magic number: _crun = LittleEndian.GetUByte(documentStream' offset + 511);
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FormattedDiskPage.cs,GetStart,The following statement contains a magic number: return LittleEndian.GetInt(_fkp' _offset + (index * 4));
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\FormattedDiskPage.cs,GetEnd,The following statement contains a magic number: return LittleEndian.GetInt(_fkp' _offset + ((index + 1) * 4));
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _rgistd = new short[9];
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: x < 9
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _levels = new ListLevel[9];
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _rgistd = new short[9];
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: x < 9
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ResetListID,The following statement contains a magic number: _lsid = (int)((new Random((int)DateTime.Now.Ticks)).Next(0'100)/100 * DateTime.Now.Millisecond);
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ResetListID,The following statement contains a magic number: _lsid = (int)((new Random((int)DateTime.Now.Ticks)).Next(0'100)/100 * DateTime.Now.Millisecond);
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[28];
Magic Number,NPOI.HWPF.Model,ListData,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListData.cs,ToArray,The following statement contains a magic number: x < 9
Magic Number,NPOI.HWPF.Model,ListFormatOverride,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverride.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[16];
Magic Number,NPOI.HWPF.Model,ListFormatOverride,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverride.cs,ToArray,The following statement contains a magic number: Array.Copy(_reserved3' 0' buf' offset' 3);
Magic Number,NPOI.HWPF.Model,ListFormatOverrideLevel,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,ToArray,The following statement contains a magic number: Array.Copy(_reserved' 0' buf' offset' 3);
Magic Number,NPOI.HWPF.Model,ListFormatOverrideLevel,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,ToArray,The following statement contains a magic number: offset += 3;
Magic Number,NPOI.HWPF.Model,ListLevel,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,GetSizeInBytes,The following statement contains a magic number: int result =                  6 // int byte byte                  + RGBXCH_NUMS_SIZE                  + 13 // byte int int byte byte short                  + _cbGrpprlChpx                  + _cbGrpprlPapx                  + 2;
Magic Number,NPOI.HWPF.Model,ListLevel,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,GetSizeInBytes,The following statement contains a magic number: int result =                  6 // int byte byte                  + RGBXCH_NUMS_SIZE                  + 13 // byte int int byte byte short                  + _cbGrpprlChpx                  + _cbGrpprlPapx                  + 2;
Magic Number,NPOI.HWPF.Model,ListLevel,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListLevel.cs,GetSizeInBytes,The following statement contains a magic number: int result =                  6 // int byte byte                  + RGBXCH_NUMS_SIZE                  + 13 // byte int int byte byte short                  + _cbGrpprlChpx                  + _cbGrpprlPapx                  + 2;
Magic Number,NPOI.HWPF.Model,ListTables,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,ListTables,The following statement contains a magic number: tableStream[lfolvlOffset] == 255
Magic Number,NPOI.HWPF.Model,ListTables,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,WriteListDataTo,The following statement contains a magic number: byte[] shortHolder = new byte[2];
Magic Number,NPOI.HWPF.Model,ListTables,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ListTables.cs,WriteListOverridesTo,The following statement contains a magic number: byte[] intHolder = new byte[4];
Magic Number,NPOI.HWPF.Model,OldCHPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\OldCHPBinTable.cs,OldCHPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(documentStream' OffSet' size' 2);
Magic Number,NPOI.HWPF.Model,OldPAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\OldPAPBinTable.cs,OldPAPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(documentStream' OffSet' size' 2);
Magic Number,NPOI.HWPF.Model,OldSectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The following statement contains a magic number: PlexOfCps sedPlex = new PlexOfCps(documentStream' offset' size' 12);
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(tableStream' offset' size' 4);
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: SprmBuffer newSprmBuffer = new SprmBuffer(2);
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: c != 13 && c != 7 && c != 12
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: c != 13 && c != 7 && c != 12
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: c != 13 && c != 7 && c != 12
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: PAPX papx = new PAPX(startInclusive' endExclusive'                              new SprmBuffer(2));
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,WriteTo,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(4);
Magic Number,NPOI.HWPF.Model,PAPBinTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPBinTable.cs,WriteTo,The following statement contains a magic number: byte[] intHolder = new byte[4];
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int papxOffset = 2 * LittleEndian.GetUByte(_fkp' _offset + (((_crun + 1) * FC_SIZE) + (index * BX_SIZE)));
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: int size = 2 * LittleEndian.GetUByte(_fkp' _offset + papxOffset);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: size = 2 * LittleEndian.GetUByte(_fkp' _offset + ++papxOffset);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: byte[] buf = new byte[512];
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlLength = 8;
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlLength > 488
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: totalSize > 511 + (index % 2)
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: totalSize > 511 + (index % 2)
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlLength % 2 > 0
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf[511] = (byte)index;
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset = 511;
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: byte[] hugePapx = new byte[grpprl.Length - 2];
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: System.Array.Copy(grpprl' 2' hugePapx' 0' grpprl.Length - 2);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprl = new byte[8];
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: LittleEndian.PutUShort(grpprl' 2' 0x6646);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: LittleEndian.PutInt(grpprl' 4' dataStreamOffset);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprl.Length > 488
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset -= (grpprlOffset % 2);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf[bxOffset] = (byte)(grpprlOffset / 2);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf[copyOffset++] = (byte)((grpprl.Length + 1) / 2);
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: (grpprl.Length % 2) > 0
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetParagraphHeight,The following statement contains a magic number: int pheOffset = _offset + 1 + (((_crun + 1) * 4) + (index * 13));
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetParagraphHeight,The following statement contains a magic number: int pheOffset = _offset + 1 + (((_crun + 1) * 4) + (index * 13));
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The following statement contains a magic number: SprmBuffer buf = FindHuge(new SprmBuffer(papx'2)' dataStream);
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,PAPX,The following statement contains a magic number: SprmBuffer buf = FindHuge(new SprmBuffer(papx' 2)' dataStream);
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: SprmOperation sprm = new SprmOperation(grpprl' 2);
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: byte[] hugeGrpprl = new byte[grpprlSize + 2];
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: Array.Copy(datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2'                                               grpprlSize);
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: return new SprmBuffer(hugeGrpprl'2);
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: (sprm.Operation == 0x45 || sprm.Operation == 0x46)                      && sprm.SizeCode == 3
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: grpprl.Length == 8 && datastream != null
Magic Number,NPOI.HWPF.Model,PAPX,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PAPX.cs,GetParagraphProperties,The following statement contains a magic number: ParagraphProperties props = ParagraphSprmUncompressor.UncompressPAP(baseStyle' GetGrpprl()' 2);
Magic Number,NPOI.HWPF.Model,ParagraphHeight,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ParagraphHeight.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[12];
Magic Number,NPOI.HWPF.Model,PieceDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PieceDescriptor.cs,ToByteArray,The following statement contains a magic number: tempFc *= 2;
Magic Number,NPOI.HWPF.Model,PieceDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PieceDescriptor.cs,ToByteArray,The following statement contains a magic number: byte[] buf = new byte[8];
Magic Number,NPOI.HWPF.Model,PlexOfCps,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,PlexOfCps,The following statement contains a magic number: _iMac = (size - 4) / (4 + sizeOfStruct);
Magic Number,NPOI.HWPF.Model,PlexOfCps,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,PlexOfCps,The following statement contains a magic number: _iMac = (size - 4) / (4 + sizeOfStruct);
Magic Number,NPOI.HWPF.Model,PlexOfCps,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,GetIntOffset,The following statement contains a magic number: return index * 4;
Magic Number,NPOI.HWPF.Model,PlexOfCps,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PlexOfCps.cs,GetStructOffset,The following statement contains a magic number: return (4 * (_iMac + 1)) + (_sizeOfStruct * index);
Magic Number,NPOI.HWPF.Model,PropertyModifier,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PropertyModifier.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Magic Number,NPOI.HWPF.Model,PropertyNode,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\PropertyNode.cs,GetHashCode,The following statement contains a magic number: return this._cpStart * 31 + this._buf.GetHashCode();
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += len * 2;
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: byte[] header = new byte[6];
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(header' 2' cData);
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(header' 4' cbExtra);
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: byte[] buf = new byte[name.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: byte[] buf = new byte[name.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: StringUtil.PutUnicodeLE(name' buf' 2);
Magic Number,NPOI.HWPF.Model,SavedByEntry,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: int hash = 29;
Magic Number,NPOI.HWPF.Model,SavedByEntry,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: hash = hash * 13 + userName.GetHashCode();
Magic Number,NPOI.HWPF.Model,SavedByEntry,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: hash = hash * 13 + saveLocation.GetHashCode();
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: int numEntries = LittleEndian.GetInt(tableStream' offset) / 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 4;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += len * 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += len * 2;
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: byte[] header = new byte[6];
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt(header' 2' entries.Length * 2);
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt(header' 2' entries.Length * 2);
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: byte[] buf = new byte[value.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: byte[] buf = new byte[value.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,SavedByTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: StringUtil.PutUnicodeLE(value' buf' 2);
Magic Number,NPOI.HWPF.Model,SectionDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SectionDescriptor.cs,ToArray,The following statement contains a magic number: byte[] buf = new byte[12];
Magic Number,NPOI.HWPF.Model,SectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,CPtoFC,The following statement contains a magic number: offset = offset * 2;
Magic Number,NPOI.HWPF.Model,SectionTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SectionTable.cs,WriteTo,The following statement contains a magic number: byte[] shortBuf = new byte[2];
Magic Number,NPOI.HWPF.Model,ShapesTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\ShapesTable.cs,ShapesTable,The following statement contains a magic number: PlexOfCps binTable = new PlexOfCps(tblStream'                   fib.GetFcPlcspaMom()' fib.GetLcbPlcspaMom()' 26);
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: int offset = startOffset + 2;
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += 4;
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += len * 2;
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: byte[] header = new byte[6];
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: LittleEndian.PutInt(header' 2' 0);
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: return 6;
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: LittleEndian.PutInt(header' 2' entries.Length);
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: int size = 6;
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: byte[] buf = new byte[entry.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: byte[] buf = new byte[entry.Length * 2 + 2];
Magic Number,NPOI.HWPF.Model,SttbfUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: StringUtil.PutUnicodeLE(entry' buf' 2);
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: multiplier = 2;
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: upxSize % 2 == 1
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: int size = _baseLength + 2 + ((_name.Length + 1) * 2);
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: int size = _baseLength + 2 + ((_name.Length + 1) * 2);
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs[0].Size + 2;
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs[x - 1].Size % 2;
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs[x].Size + 2;
Magic Number,NPOI.HWPF.Model,StyleDescription,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: offset += upxSize + (upxSize % 2);
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: _rgftc = new int[3];
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: _rgftc[2] = LittleEndian.GetShort(tableStream' offset);
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: offset += 2;
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: byte[] buf = new byte[_stshiLength + 2];
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(buf' offset' (short)_rgftc[2]);
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: byte[] sizeHolder = new byte[2];
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort(sizeHolder' (short)((std.Length) + (std.Length % 2)));
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: std.Length % 2 == 1
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The following statement contains a magic number: ss._baseLength == _baseLength && ss._flags == _flags &&                  ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex &&                  ss._rgftc[0] == _rgftc[0] && ss._rgftc[1] == _rgftc[1] &&                  ss._rgftc[2] == _rgftc[2] && ss._stshiLength == _stshiLength &&                  ss._stylenameVersion == _stylenameVersion
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The following statement contains a magic number: ss._baseLength == _baseLength && ss._flags == _flags &&                  ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex &&                  ss._rgftc[0] == _rgftc[0] && ss._rgftc[1] == _rgftc[1] &&                  ss._rgftc[2] == _rgftc[2] && ss._stshiLength == _stshiLength &&                  ss._stylenameVersion == _stylenameVersion
Magic Number,NPOI.HWPF.Model,StyleSheet,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The following statement contains a magic number: pap = ParagraphSprmUncompressor.UncompressPAP(parentPAP' papx' 2);
Magic Number,NPOI.HWPF.Model,TextPieceTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The following statement contains a magic number: multiple = 2;
Magic Number,NPOI.HWPF.Model,TextPieceTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: byteCount = tp.PieceDescriptor.FilePosition                              + (tp.End - tp.Start)                              * (tp.IsUnicode ? 2 : 1);
Magic Number,NPOI.HWPF.Model,TextPieceTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: byteCount = tp.PieceDescriptor.FilePosition + left                              * (tp.IsUnicode ? 2 : 1);
Magic Number,NPOI.HWPF.Model,TextPieceTable,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\TextPieceTable.cs,GetCharIndex,The following statement contains a magic number: charCount += toAdd / 2;
Magic Number,NPOI.HWPF.Model.Types,BKFAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\BKFAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,BKFAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\BKFAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_35_doptypography = LittleEndian.GetByteArray(data' 0x5a + offset' 310);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_36_dogrid = LittleEndian.GetByteArray(data' 0x190 + offset' 10);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_39_asumyi = LittleEndian.GetByteArray(data' 0x19e + offset' 12);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_44_Spare = LittleEndian.GetByteArray(data' 0x1ba + offset' 30);
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,FLDAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FLDAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1;
Magic Number,NPOI.HWPF.Model.Types,FRDAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FRDAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;
Magic Number,NPOI.HWPF.Model.Types,HRESIAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\HRESIAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1;
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
Magic Number,NPOI.HWPF.Model.Types,PAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\PAPAbstractType.cs,PAPAbstractType,The following statement contains a magic number: this.field_41_lvl = 9;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_1_bkc = 2;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_13_dxaPgn = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_14_dyaPgn = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_39_xaPage = 12240;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_40_yaPage = 15840;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_41_xaPageNUp = 12240;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_42_yaPageNUp = 15840;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_43_dxaLeft = 1800;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_44_dxaRight = 1800;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_45_dyaTop = 1440;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_46_dyaBottom = 1440;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_48_dyaHdrTop = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_49_dyaHdrBottom = 720;
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_53_dxaColumns = 720;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;
Magic Number,NPOI.HWPF.Model.Types,TLPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TLPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 1;
Magic Number,NPOI.HWPF.Model.Types,TLPAbstractType,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Model\Types\TLPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 1;
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: byte[] varParam = new byte[4];
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: LittleEndian.PutShort(varParam' 2' (short)newCHP.GetXchSym());
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: byte[] buf = new byte[7];
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: newPAP.GetDttmPropRMark().Serialize(buf' 3);
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newPAP.SetIstd(sprm.Operand);                      break;                  case 0x1:                        // Used only for piece table grpprl's not for PAPX                      //        int istdFirst = LittleEndian.Getshort (varParam' 2);                      //        int istdLast = LittleEndian.Getshort (varParam' 4);                      //        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))                      //        {                      //          permuteIstd (newPAP' varParam' opSize);                      //        }                      break;                  case 0x2:                      if (newPAP.GetIstd() <= 9 || newPAP.GetIstd() >= 1)                      {                          byte paramTmp = (byte)sprm.Operand;                          newPAP.SetIstd(newPAP.GetIstd() + paramTmp);                          newPAP.SetLvl((byte)(newPAP.GetLvl() + paramTmp));                            if (((paramTmp >> 7) & 0x01) == 1)                          {                              newPAP.SetIstd(Math.Max(newPAP.GetIstd()' 1));                          }                          else                          {                              newPAP.SetIstd(Math.Min(newPAP.GetIstd()' 9));                          }                        }                      break;                  case 0x3:                      // Physical justification of the paragraph                      newPAP.SetJc((byte)sprm.Operand);                      break;                  case 0x4:                      newPAP.SetFSideBySide(sprm.Operand!=0);                      break;                  case 0x5:                      newPAP.SetFKeep(sprm.Operand!=0);                      break;                  case 0x6:                      newPAP.SetFKeepFollow(sprm.Operand!=0);                      break;                  case 0x7:                      newPAP.SetFPageBreakBefore(sprm.Operand!=0);                      break;                  case 0x8:                      newPAP.SetBrcl((byte)sprm.Operand);                      break;                  case 0x9:                      newPAP.SetBrcp((byte)sprm.Operand);                      break;                  case 0xa:                      newPAP.SetIlvl((byte)sprm.Operand);                      break;                  case 0xb:                      newPAP.SetIlfo(sprm.Operand);                      break;                  case 0xc:                      newPAP.SetFNoLnn(sprm.Operand!=0);                      break;                  case 0xd:                      /**handle tabs . variable parameter. seperate Processing needed*/                      handleTabs(newPAP' sprm);                      break;                  case 0xe:                      newPAP.SetDxaRight(sprm.Operand);                      break;                  case 0xf:                      newPAP.SetDxaLeft(sprm.Operand);                      break;                  case 0x10:                        // sprmPNest is only stored in grpprls linked to a piece table.                      newPAP.SetDxaLeft(newPAP.GetDxaLeft() + sprm.Operand);                      newPAP.SetDxaLeft(Math.Max(0' newPAP.GetDxaLeft()));                      break;                  case 0x11:                      newPAP.SetDxaLeft1(sprm.Operand);                      break;                  case 0x12:                      newPAP.SetLspd(new LineSpacingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x13:                      newPAP.SetDyaBefore(sprm.Operand);                      break;                  case 0x14:                      newPAP.SetDyaAfter(sprm.Operand);                      break;                  case 0x15:                      // fast saved only                      //ApplySprmPChgTabs (newPAP' varParam' opSize);                      break;                  case 0x16:                      newPAP.SetFInTable(sprm.Operand!=0);                      break;                  case 0x17:                      newPAP.SetFTtp(sprm.Operand!=0);                      break;                  case 0x18:                      newPAP.SetDxaAbs(sprm.Operand);                      break;                  case 0x19:                      newPAP.SetDyaAbs(sprm.Operand);                      break;                  case 0x1a:                      newPAP.SetDxaWidth(sprm.Operand);                      break;                  case 0x1b:                      byte param = (byte)sprm.Operand;                      /** @todo handle paragraph postioning*/                      byte pcVert = (byte)((param & 0x0c) >> 2);                      byte pcHorz = (byte)(param & 0x03);                      if (pcVert != 3)                      {                          newPAP.SetPcVert(pcVert);                      }                      if (pcHorz != 3)                      {                          newPAP.SetPcHorz(pcHorz);                      }                      break;                    // BrcXXX1 is older Version. Brc is used                  case 0x1c:                        //newPAP.SetBrcTop1((short)param);                      break;                  case 0x1d:                        //newPAP.SetBrcLeft1((short)param);                      break;                  case 0x1e:                        //newPAP.SetBrcBottom1((short)param);                      break;                  case 0x1f:                        //newPAP.SetBrcRight1((short)param);                      break;                  case 0x20:                        //newPAP.SetBrcBetween1((short)param);                      break;                  case 0x21:                        //newPAP.SetBrcBar1((byte)param);                      break;                  case 0x22:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x23:                      newPAP.SetWr((byte)sprm.Operand);                      break;                  case 0x24:                      newPAP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x25:                      newPAP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x26:                      newPAP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x27:                      newPAP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x28:                      newPAP.SetBrcBetween(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x29:                      newPAP.SetBrcBar(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2a:                      newPAP.SetFNoAutoHyph(sprm.Operand!=0);                      break;                  case 0x2b:                      newPAP.SetDyaHeight(sprm.Operand);                      break;                  case 0x2c:                      newPAP.SetDcs(new DropCapSpecifier((short)sprm.Operand));                      break;                  case 0x2d:                      newPAP.SetShd(new ShadingDescriptor((short)sprm.Operand));                      break;                  case 0x2e:                      newPAP.SetDyaFromText(sprm.Operand);                      break;                  case 0x2f:                      newPAP.SetDxaFromText(sprm.Operand);                      break;                  case 0x30:                      newPAP.SetFLocked(sprm.Operand!=0);                      break;                  case 0x31:                      newPAP.SetFWidowControl(sprm.Operand!=0);                      break;                  case 0x32:                        //undocumented                      break;                  case 0x33:                      newPAP.SetFKinsoku(sprm.Operand!=0);                      break;                  case 0x34:                      newPAP.SetFWordWrap(sprm.Operand!=0);                      break;                  case 0x35:                      newPAP.SetFOverflowPunct(sprm.Operand!=0);                      break;                  case 0x36:                      newPAP.SetFTopLinePunct(sprm.Operand!=0);                      break;                  case 0x37:                      newPAP.SetFAutoSpaceDE(sprm.Operand!=0);                      break;                  case 0x38:                      newPAP.SetFAutoSpaceDN(sprm.Operand!=0);                      break;                  case 0x39:                      newPAP.SetWAlignFont(sprm.Operand);                      break;                  case 0x3a:                      newPAP.SetFontAlign((short)sprm.Operand);                      break;                  case 0x3b:                        //obsolete                      break;                  case 0x3e:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(buf' 0' sprm.Grpprl' sprm.GrpprlOffset'                                       buf.Length);                      newPAP.SetAnld(buf);                      break;                  case 0x3f:                      //don't really need this. spec is confusing regarding this                      //sprm                          byte[] varParam = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newPAP.SetFPropRMark(varParam[offset]!=0);                          newPAP.SetIbstPropRMark(LittleEndian.GetShort(varParam' offset + 1));                          newPAP.SetDttmPropRMark(new DateAndTime(varParam' offset + 3));                        break;                  case 0x40:                      // This condition commented out' as Word seems to set outline levels even for                       //  paragraph with other styles than Heading 1..9' even though specification                       //  does not say so. See bug 49820 for discussion.                      //if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)                      //{                          newPAP.SetLvl((byte)sprm.Operand);                      //}                      break;                  case 0x41:                        // undocumented                      break;                  case 0x43:                        //pap.fNumRMIns                      newPAP.SetFNumRMIns(sprm.Operand!=0);                      break;                  case 0x44:                        //undocumented                      break;                  case 0x45:                      if (sprm.SizeCode == 6)                      {                          byte[] buf1 = new byte[sprm.Size - 3];                          Array.Copy(buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);                          newPAP.SetNumrm(buf1);                      }                      else                      {                          /**@todo handle large PAPX from data stream*/                      }                      break;                    case 0x47:                      newPAP.SetFUsePgsuSettings(sprm.Operand!=0);                      break;                  case 0x48:                      newPAP.SetFAdjustRight(sprm.Operand!=0);                      break;                  case 0x49:                      // sprmPItap -- 0x6649                      newPAP.SetItap(sprm.Operand);                      break;                  case 0x4a:                      // sprmPDtap -- 0x664a                      newPAP.SetItap((byte)(newPAP.GetItap() + sprm.Operand));                      break;                  case 0x4b:                      // sprmPFInnerTableCell -- 0x244b                      newPAP.SetFInnerTableCell(sprm.Operand!=0);                      break;                  case 0x4c:                      // sprmPFInnerTtp -- 0x244c                      newPAP.SetFTtpEmbedded(sprm.Operand!=0);                      break;                  case 0x61:                      // sprmPJc                       newPAP.SetJustificationLogical((byte)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,SectionSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The following statement contains a magic number: byte[] buf = new byte[7];
Magic Number,NPOI.HWPF.SPRM,SectionSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newSEP.SetCnsPgn((byte)sprm.Operand);                      break;                  case 0x1:                      newSEP.SetIHeadingPgn((byte)sprm.Operand);                      break;                  case 0x2:                      byte[] buf = new byte[sprm.Size - 3];                      Array.Copy(sprm.Grpprl' sprm.GrpprlOffset' buf' 0' buf.Length);                      newSEP.SetOlstAnm(buf);                      break;                  case 0x3:                      //not quite sure                      break;                  case 0x4:                      //not quite sure                      break;                  case 0x5:                      newSEP.SetFEvenlySpaced(GetFlag(sprm.Operand));                      break;                  case 0x6:                      newSEP.SetFUnlocked(GetFlag(sprm.Operand));                      break;                  case 0x7:                      newSEP.SetDmBinFirst((short)sprm.Operand);                      break;                  case 0x8:                      newSEP.SetDmBinOther((short)sprm.Operand);                      break;                  case 0x9:                      newSEP.SetBkc((byte)sprm.Operand);                      break;                  case 0xa:                      newSEP.SetFTitlePage(GetFlag(sprm.Operand));                      break;                  case 0xb:                      newSEP.SetCcolM1((short)sprm.Operand);                      break;                  case 0xc:                      newSEP.SetDxaColumns(sprm.Operand);                      break;                  case 0xd:                      newSEP.SetFAutoPgn(GetFlag(sprm.Operand));                      break;                  case 0xe:                      newSEP.SetNfcPgn((byte)sprm.Operand);                      break;                  case 0xf:                      newSEP.SetDyaPgn((short)sprm.Operand);                      break;                  case 0x10:                      newSEP.SetDxaPgn((short)sprm.Operand);                      break;                  case 0x11:                      newSEP.SetFPgnRestart(GetFlag(sprm.Operand));                      break;                  case 0x12:                      newSEP.SetFEndNote(GetFlag(sprm.Operand));                      break;                  case 0x13:                      newSEP.SetLnc((byte)sprm.Operand);                      break;                  case 0x14:                      newSEP.SetGrpfIhdt((byte)sprm.Operand);                      break;                  case 0x15:                      newSEP.SetNLnnMod((short)sprm.Operand);                      break;                  case 0x16:                      newSEP.SetDxaLnn(sprm.Operand);                      break;                  case 0x17:                      newSEP.SetDyaHdrTop(sprm.Operand);                      break;                  case 0x18:                      newSEP.SetDyaHdrBottom(sprm.Operand);                      break;                  case 0x19:                      newSEP.SetFLBetween(GetFlag(sprm.Operand));                      break;                  case 0x1a:                      newSEP.SetVjc((byte)sprm.Operand);                      break;                  case 0x1b:                      newSEP.SetLnnMin((short)sprm.Operand);                      break;                  case 0x1c:                      newSEP.SetPgnStart((short)sprm.Operand);                      break;                  case 0x1d:                      newSEP.SetDmOrientPage(sprm.Operand!=0);                      break;                  case 0x1e:                        //nothing                      break;                  case 0x1f:                      newSEP.SetXaPage(sprm.Operand);                      break;                  case 0x20:                      newSEP.SetYaPage(sprm.Operand);                      break;                  case 0x21:                      newSEP.SetDxaLeft(sprm.Operand);                      break;                  case 0x22:                      newSEP.SetDxaRight(sprm.Operand);                      break;                  case 0x23:                      newSEP.SetDyaTop(sprm.Operand);                      break;                  case 0x24:                      newSEP.SetDyaBottom(sprm.Operand);                      break;                  case 0x25:                      newSEP.SetDzaGutter(sprm.Operand);                      break;                  case 0x26:                      newSEP.SetDmPaperReq((short)sprm.Operand);                      break;                  case 0x27:                      newSEP.SetFPropMark(GetFlag(sprm.Operand));                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      newSEP.SetBrcTop(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2c:                      newSEP.SetBrcLeft(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2d:                      newSEP.SetBrcBottom(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2e:                      newSEP.SetBrcRight(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x2f:                      newSEP.SetPgbProp(sprm.Operand);                      break;                  case 0x30:                      newSEP.SetDxtCharSpace(sprm.Operand);                      break;                  case 0x31:                      newSEP.SetDyaLinePitch(sprm.Operand);                      break;                  case 0x33:                      newSEP.SetWTextFlow((short)sprm.Operand);                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,SprmBuffer,The following statement contains a magic number: _buf = new byte[sprmsStartOffset + 4];
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,SprmBuffer,The following statement contains a magic number: _buf = new byte[4];
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,FindSprm,The following statement contains a magic number: SprmIterator si = new SprmIterator(_buf' 2);
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmBuffer.cs,EnsureCapacity,The following statement contains a magic number: byte[] newBuf = new byte[_offset + Addition + 6];
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,SprmOperation,The following statement contains a magic number: _gOffset = offset + 2;
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,FindSprm,The following statement contains a magic number: SprmIterator si = new SprmIterator(_buf' 2);
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmOperation,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode)              {                  case 0:                  case 1:                      return 3;                  case 2:                  case 4:                  case 5:                      return 4;                  case 3:                      return 6;                  case 6:                      if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH)                      {                          int retVal = (0x0000ffff & LittleEndian.GetShort(_grpprl' _gOffset)) + 3;                          _gOffset += 2;                          return retVal;                      }                      else                      {                          return (0x000000ff & _grpprl[_gOffset++]) + 3;                      }                  case 7:                      return 5;                  default:                      throw new ArgumentException("SPRM contains an invalid size code");              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: byte[] sprm = new byte[varParam.Length + 4];
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: System.Array.Copy(varParam' 0' sprm' 4' varParam.Length);
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: LittleEndian.PutShort(sprm' 2' (short)(varParam.Length + 1));
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: int type = (instruction & 0xe000) >> 13;
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type)              {                  case 0:                  case 1:                      sprm = new byte[3];                      sprm[2] = (byte)param;                      break;                  case 2:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 3:                      sprm = new byte[6];                      LittleEndian.PutInt(sprm' 2' param);                      break;                  case 4:                  case 5:                      sprm = new byte[4];                      LittleEndian.PutShort(sprm' 2' (short)param);                      break;                  case 6:                      int varLength=0;                      if (varParam != null)                      {                          varLength=varParam.Length;                      }                      sprm = new byte[3 + varLength];                      sprm[2] = (byte)varLength;                      if (varLength != 0)                      {                          System.Array.Copy(varParam' 0' sprm' 3' varLength);                      }                      break;                  case 7:                      sprm = new byte[5];                      // this Is a three byte int so it has to be handled special                      byte[] temp = new byte[4];                      LittleEndian.PutInt(temp' 0' param);                      System.Array.Copy(temp' 0' sprm' 2' 3);                      break;                  default:                      //should never happen                      break;              }
Magic Number,NPOI.HWPF.SPRM,SprmUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\SprmUtils.cs,ConvertBrcToInt,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,NPOI.HWPF.SPRM,TableSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,The following statement contains a magic number: byte[] brcBuf = new byte[6 * BorderCode.SIZE];
Magic Number,NPOI.HWPF.SPRM,TableSprmCompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,The following statement contains a magic number: byte[] compare = new byte[6 * BorderCode.SIZE];
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation)              {                  case 0:                      newTAP.SetJc((short)sprm.Operand);                      break;                  case 0x01:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          short itcMac = newTAP.GetItcMac();                          int adjust = sprm.Operand - (rgdxaCenter[0] + newTAP.GetDxaGapHalf());                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] += (short)adjust;                          }                          break;                      }                  case 0x02:                      {                          short[] rgdxaCenter = newTAP.GetRgdxaCenter();                          if (rgdxaCenter != null)                          {                              int adjust = newTAP.GetDxaGapHalf() - sprm.Operand;                              rgdxaCenter[0] += (short)adjust;                          }                          newTAP.SetDxaGapHalf(sprm.Operand);                          break;                      }                  case 0x03:                      newTAP.SetFCantSplit(GetFlag(sprm.Operand));                      break;                  case 0x04:                      newTAP.SetFTableHeader(GetFlag(sprm.Operand));                      break;                  case 0x05:                      {                          byte[] buf = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          newTAP.SetBrcTop(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcLeft(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcBottom(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcRight(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcHorizontal(new BorderCode(buf' offset));                          offset += BorderCode.SIZE;                          newTAP.SetBrcVertical(new BorderCode(buf' offset));                          break;                      }                  case 0x06:                        //obsolete' used in word 1.x                      break;                  case 0x07:                      newTAP.SetDyaRowHeight(sprm.Operand);                      break;                  case 0x08:                      {                          byte[] grpprl = sprm.Grpprl;                          int offset = sprm.GrpprlOffset;                          short itcMac = grpprl[offset];                          short[] rgdxaCenter = new short[itcMac + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];                          //I use varParam[0] and newTAP._itcMac interchangably                          newTAP.SetItcMac(itcMac);                          newTAP.SetRgdxaCenter(rgdxaCenter);                          newTAP.SetRgtc(rgtc);                            // get the rgdxaCenters                          for (int x = 0; x < itcMac; x++)                          {                              rgdxaCenter[x] = LittleEndian.GetShort(grpprl' offset + (1 + (x * 2)));                          }                            // only try to get the TC entries if they exist...                          int endOfSprm = offset + sprm.Size - 6; // -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based                          int startOfTCs = offset + (1 + (itcMac + 1) * 2);                            bool hasTCs = startOfTCs < endOfSprm;                            for (int x = 0; x < itcMac; x++)                          {                              // Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.                              if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)                                  rgtc[x] = TableCellDescriptor.ConvertBytesToTC(grpprl'                                     offset + (1 + ((itcMac + 1) * 2) + (x * 20)));                              else                                  rgtc[x] = new TableCellDescriptor();                          }                            rgdxaCenter[itcMac] = LittleEndian.GetShort(grpprl' offset + (1 + (itcMac * 2)));                          break;                      }                  case 0x09:                        /** @todo handle cell shading*/                      break;                  case 0x0a:                        /** @todo handle word defined table styles*/                      break;                  case 0x20:                      //      {                      //        TableCellDescriptor[] rgtc = newTAP.GetRgtc();                      //                      //        for (int x = varParam[0]; x < varParam[1]; x++)                      //        {                      //                      //          if ((varParam[2] & 0x08) > 0)                      //          {                      //            short[] brcRight = rgtc[x].GetBrcRight ();                      //            brcRight[0] = LittleEndian.Getshort (varParam' 6);                      //            brcRight[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x04) > 0)                      //          {                      //            short[] brcBottom = rgtc[x].GetBrcBottom ();                      //            brcBottom[0] = LittleEndian.Getshort (varParam' 6);                      //            brcBottom[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x02) > 0)                      //          {                      //            short[] brcLeft = rgtc[x].GetBrcLeft ();                      //            brcLeft[0] = LittleEndian.Getshort (varParam' 6);                      //            brcLeft[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //          else if ((varParam[2] & 0x01) > 0)                      //          {                      //            short[] brcTop = rgtc[x].GetBrcTop ();                      //            brcTop[0] = LittleEndian.Getshort (varParam' 6);                      //            brcTop[1] = LittleEndian.Getshort (varParam' 8);                      //          }                      //        }                      //        break;                      //      }                      break;                  case 0x21:                      {                          int param = sprm.Operand;                          int index = (int)(param & 0xff000000) >> 24;                          int count = (param & 0x00ff0000) >> 16;                          int width = (param & 0x0000ffff);                          int itcMac = newTAP.GetItcMac();                            short[] rgdxaCenter = new short[itcMac + count + 1];                          TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];                          if (index >= itcMac)                          {                              index = itcMac;                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               itcMac + 1);                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' itcMac);                          }                          else                          {                              //copy rgdxaCenter                              Array.Copy(newTAP.GetRgdxaCenter()' 0' rgdxaCenter' 0'                                               index + 1);                              Array.Copy(newTAP.GetRgdxaCenter()' index + 1' rgdxaCenter'                                               index + count' itcMac - (index));                              //copy rgtc                              Array.Copy(newTAP.GetRgtc()' 0' rgtc' 0' index);                              Array.Copy(newTAP.GetRgtc()' index' rgtc' index + count'                                               itcMac - index);                          }                            for (int x = index; x < index + count; x++)                          {                              rgtc[x] = new TableCellDescriptor();                              rgdxaCenter[x] = (short)(rgdxaCenter[x - 1] + width);                          }                          rgdxaCenter[index +                            count] = (short)(rgdxaCenter[(index + count) - 1] + width);                          break;                      }                  /**@todo handle table sprms from complex files*/                  case 0x22:                  case 0x23:                  case 0x24:                  case 0x25:                  case 0x26:                  case 0x27:                  case 0x28:                  case 0x29:                  case 0x2a:                  case 0x2b:                  case 0x2c:                      break;                  default:                      break;              }
Magic Number,NPOI.HWPF.UserModel,BookmarkImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\BookmarksImpl.cs,GetHashCode,The following statement contains a magic number: return 31 + (first == null ? 0 : first.GetHashCode());
Magic Number,NPOI.HWPF.UserModel,BorderCode,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\BorderCode.cs,ToInt,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_41_xstDispFldRMark = new byte[36];
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_7_hps = 20;
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_24_istd = 10;
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_16_wCharScale = 100;
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Magic Number,NPOI.HWPF.UserModel,FieldsImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\FieldsImpl.cs,BinarySearch,The following statement contains a magic number: return -mid - (result >= 0 ? 1 : 2);
Magic Number,NPOI.HWPF.UserModel,FieldsImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\FieldsImpl.cs,ParseFieldStructure,The following statement contains a magic number: List<FieldImpl> fields = new List<FieldImpl>(                      plexOfFields.Count / 3 + 1);
Magic Number,NPOI.HWPF.UserModel,HeaderStories,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\HeaderStories.cs,GetHeader,The following statement contains a magic number: pageNumber % 2 == 0
Magic Number,NPOI.HWPF.UserModel,HeaderStories,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\HeaderStories.cs,GetFooter,The following statement contains a magic number: pageNumber % 2 == 0
Magic Number,NPOI.HWPF.UserModel,HWPFList,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\HWPFList.cs,HWPFList,The following statement contains a magic number: _listData = new ListData((int)(new Random((int)DateTime.Now.Ticks).Next(0'100)/100 * DateTime.Now.Millisecond)' numbered);
Magic Number,NPOI.HWPF.UserModel,HWPFList,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\HWPFList.cs,HWPFList,The following statement contains a magic number: _listData = new ListData((int)(new Random((int)DateTime.Now.Ticks).Next(0'100)/100 * DateTime.Now.Millisecond)' numbered);
Magic Number,NPOI.HWPF.UserModel,LineSpacingDescriptor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\LineSpacingDescriptor.cs,ToInt,The following statement contains a magic number: byte[] intHolder = new byte[4];
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following statement contains a magic number: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following statement contains a magic number: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following statement contains a magic number: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following statement contains a magic number: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following statement contains a magic number: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following statement contains a magic number: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
Magic Number,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following statement contains a magic number: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
Magic Number,NPOI.HWPF.UserModel,Paragraph,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: retVal |= 2;
Magic Number,NPOI.HWPF.UserModel,Paragraph,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: retVal |= 4;
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,ParagraphProperties,The following statement contains a magic number: SetAnld(new byte[84]);
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,ParagraphProperties,The following statement contains a magic number: SetPhe(new byte[12]);
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: switch (GetJc())                  {                      case 0:                          return 2;                      case 2:                          return 0;                      default:                          return GetJc();                  }
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: switch (GetJc())                  {                      case 0:                          return 2;                      case 2:                          return 0;                      default:                          return GetJc();                  }
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: ZlibStream gzip = new ZlibStream(new MemoryStream(rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: byte[] buf = new byte[4096];
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: (readBytes = gzip.Read(buf'0'4096)) > 0
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32)
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: MatchSignature(rawContent' COMPRESSED1' 32) || MatchSignature(rawContent' COMPRESSED2' 32)
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The following statement contains a magic number: short MM_TYPE = LittleEndian.GetShort(_dataStream' dataBlockStartOffset + PICT_HEADER_OFFSET + 2);
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: int pointer = pictureBytesStartOffset + 2;
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: pointer += 2;
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: int HEADER_START = pictureBytesStartOffset + PictureType.PNG.Signatures[0].Length + 4;
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: int IHDR_CHUNK_WIDTH = HEADER_START + 4;
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: this.height = GetBigEndianInt(_dataStream' IHDR_CHUNK_WIDTH + 4);
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data[offset] & 0xFF) << 24) + ((data[offset + 1] & 0xFF) << 16) + ((data[offset + 2] & 0xFF) << 8) + (data[offset + 3] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Picture,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianShort,The following statement contains a magic number: return (((data[offset] & 0xFF) << 8) + (data[offset + 1] & 0xFF));
Magic Number,NPOI.HWPF.UserModel,Shape,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _left = LittleEndian.GetInt(contenuto' 4);
Magic Number,NPOI.HWPF.UserModel,Shape,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _top = LittleEndian.GetInt(contenuto' 8);
Magic Number,NPOI.HWPF.UserModel,Shape,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _right = LittleEndian.GetInt(contenuto' 12);
Magic Number,NPOI.HWPF.UserModel,Shape,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _bottom = LittleEndian.GetInt(contenuto' 16);
Magic Number,NPOI.HWPF.UserModel,TableAutoformatLookSpecifier,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\TableAutoformatLookSpecifier.cs,GetHashCode,The following statement contains a magic number: int prime = 31;
Missing Default,NPOI.HWPF.Converter,AbstractWordConverter,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following switch statement is missing a default case: switch (field.Type)              {                  case 37: // page reference                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex pagerefPattern = new Regex("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              Match match = pagerefPattern.Match(formula);                              if (match.Success)                              {                                  String pageref = match.Groups[1].Value;                                  ProcessPageref(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' pageref);                                  return;                              }                              //Pattern pagerefPattern = Pattern                              //        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");                              //Matcher matcher = pagerefPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String pageref = matcher.group(1);                              //    processPageref(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' pageref);                              //    return;                              //}                          }                          break;                      }                  case 58: // Embedded Object                      {                          if (!field.HasSeparator())                          {                              logger.Log(POILogger.WARN' parentRange + " contains " + field                                      + " with 'Embedded Object' but without separator mark");                              return;                          }                            CharacterRun separator = field.GetMarkSeparatorCharacterRun(parentRange);                            if (separator.IsOle2())                          {                              // the only supported so far                              bool processed = ProcessOle2(wordDocument' separator'                                      currentBlock);                                // if we didn't output OLE - output field value                              if (!processed)                              {                                  ProcessCharacters(wordDocument' currentTableLevel'                                          field.SecondSubrange(parentRange)' currentBlock);                              }                                return;                          }                            break;                      }                  case 88: // hyperlink                      {                          Range firstSubrange = field.FirstSubrange(parentRange);                          if (firstSubrange != null)                          {                              String formula = firstSubrange.Text;                              Regex hyperlinkPattern = new Regex("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              Match match = hyperlinkPattern.Match(formula);                              if (match.Success)                              {                                  String hyperlink = match.Groups[1].Value;                                  ProcessHyperlink(wordDocument' currentBlock'                                          field.SecondSubrange(parentRange)'                                          currentTableLevel' hyperlink);                                  return;                              }                              //Pattern hyperlinkPattern = Pattern                              //        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");                              //Matcher matcher = hyperlinkPattern.matcher(formula);                              //if (matcher.find())                              //{                              //    String hyperlink = matcher.group(1);                              //    processHyperlink(wordDocument' currentBlock'                              //            field.secondSubrange(parentRange)'                              //            currentTableLevel' hyperlink);                              //    return;                              //}                          }                          break;                      }              }
Missing Default,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following switch statement is missing a default case: switch (rgbValue)              {                  case 0xFFFFFF:                      return "white";                  case 0xC0C0C0:                      return "silver";                  case 0x808080:                      return "gray";                  case 0x000000:                      return "black";                  case 0xFF0000:                      return "red";                  case 0x800000:                      return "maroon";                  case 0xFFFF00:                      return "yellow";                  case 0x808000:                      return "olive";                  case 0x00FF00:                      return "lime";                  case 0x008000:                      return "green";                  case 0x00FFFF:                      return "aqua";                  case 0x008080:                      return "teal";                  case 0x0000FF:                      return "blue";                  case 0x000080:                      return "navy";                  case 0xFF00FF:                      return "fuchsia";                  case 0x800080:                      return "purple";              }
Missing Default,NPOI.HWPF.Converter,AbstractWordUtils,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following switch statement is missing a default case: switch (js)              {                  case 0:                      return "start";                  case 1:                      return "center";                  case 2:                      return "end";                  case 3:                  case 4:                      return "justify";                  case 5:                      return "center";                  case 6:                      return "left";                  case 7:                      return "start";                  case 8:                      return "end";                  case 9:                      return "justify";              }
Missing Default,NPOI.HWPF.SPRM,CharacterSprmUncompressor,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following switch statement is missing a default case: switch (sprm.Operation)              {                  case 0:                      newCHP.SetFRMarkDel(GetFlag(sprm.Operand));                      break;                  case 0x1:                      newCHP.SetFRMark(GetFlag(sprm.Operand));                      break;                  case 0x2:                      newCHP.SetFFldVanish(GetFlag(sprm.Operand));                      break;                  case 0x3:                      newCHP.SetFcPic(sprm.Operand);                      newCHP.SetFSpec(true);                      break;                  case 0x4:                      newCHP.SetIbstRMark((short)sprm.Operand);                      break;                  case 0x5:                      newCHP.SetDttmRMark(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x6:                      newCHP.SetFData(GetFlag(sprm.Operand));                      break;                  case 0x7:                      //don't care about this                      break;                  case 0x8:                      //short chsDiff = (short)((param & 0xff0000) >>> 16);                      int operand = sprm.Operand;                      short chsDiff = (short)(operand & 0x0000ff);                      newCHP.SetFChsDiff(GetFlag(chsDiff));                      newCHP.SetChse((short)(operand & 0xffff00));                      break;                  case 0x9:                      newCHP.SetFSpec(true);                      newCHP.SetFtcSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      newCHP.SetXchSym(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset + 2));                      break;                  case 0xa:                      newCHP.SetFOle2(GetFlag(sprm.Operand));                      break;                  case 0xb:                        // Obsolete                      break;                  case 0xc:                      newCHP.SetIcoHighlight((byte)sprm.Operand);                      newCHP.SetFHighlight(GetFlag(sprm.Operand));                      break;                  case 0xd:                        //	undocumented                      break;                  case 0xe:                      newCHP.SetFcObj(sprm.Operand);                      break;                  case 0xf:                        // undocumented                      break;                  case 0x10:                        // undocumented                      break;                    // undocumented till 0x30                    case 0x11:                      // sprmCFWebHidden                      break;                  case 0x12:                      break;                  case 0x13:                      break;                  case 0x14:                      break;                  case 0x15:                      // sprmCRsidProp                      break;                  case 0x16:                      // sprmCRsidText                      break;                  case 0x17:                      // sprmCRsidRMDel                      break;                  case 0x18:                      // sprmCFSpecVanish                      break;                  case 0x19:                      break;                  case 0x1a:                      // sprmCFMathPr                      break;                  case 0x1b:                      break;                  case 0x1c:                      break;                  case 0x1d:                      break;                  case 0x1e:                      break;                  case 0x1f:                      break;                  case 0x20:                      break;                  case 0x21:                      break;                  case 0x22:                      break;                  case 0x23:                      break;                  case 0x24:                      break;                  case 0x25:                      break;                  case 0x26:                      break;                  case 0x27:                      break;                  case 0x28:                      break;                  case 0x29:                      break;                  case 0x2a:                      break;                  case 0x2b:                      break;                  case 0x2c:                      break;                  case 0x2d:                      break;                  case 0x2e:                      break;                  case 0x2f:                      break;                  case 0x30:                      newCHP.SetIstd(sprm.Operand);                      break;                  case 0x31:                        //permutation vector for fast saves' who cares!                      break;                  case 0x32:                      newCHP.SetFBold(false);                      newCHP.SetFItalic(false);                      newCHP.SetFOutline(false);                      newCHP.SetFStrike(false);                      newCHP.SetFShadow(false);                      newCHP.SetFSmallCaps(false);                      newCHP.SetFCaps(false);                      newCHP.SetFVanish(false);                      newCHP.SetKul((byte)0);                      newCHP.SetIco((byte)0);                      break;                  case 0x33:                      // preserve the fSpec Setting from the original CHP                      bool fSpec = newCHP.IsFSpec();                      newCHP = (CharacterProperties)oldCHP.Clone();                      newCHP.SetFSpec(fSpec);                        return;                  case 0x34:                      // sprmCKcd                      break;                  case 0x35:                      newCHP.SetFBold(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFBold()));                      break;                  case 0x36:                      newCHP.SetFItalic(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFItalic()));                      break;                  case 0x37:                      newCHP.SetFStrike(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFStrike()));                      break;                  case 0x38:                      newCHP.SetFOutline(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFOutline()));                      break;                  case 0x39:                      newCHP.SetFShadow(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFShadow()));                      break;                  case 0x3a:                      newCHP.SetFSmallCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFSmallCaps()));                      break;                  case 0x3b:                      newCHP.SetFCaps(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFCaps()));                      break;                  case 0x3c:                      newCHP.SetFVanish(GetCHPFlag((byte)sprm.Operand' oldCHP.IsFVanish()));                      break;                  case 0x3d:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x3e:                      newCHP.SetKul((byte)sprm.Operand);                      break;                  case 0x3f:                      operand = sprm.Operand;                      int hps = operand & 0xff;                      if (hps != 0)                      {                          newCHP.SetHps(hps);                      }                        //byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);                      byte cInc = (byte)((operand & 0xff00) >> 8);                      cInc = (byte)(cInc >> 1);                      if (cInc != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (cInc * 2)' 2));                      }                        //byte hpsPos = (byte)((param & 0xff0000) >>> 8);                      byte hpsPos = (byte)((operand & 0xff0000) >> 16);                      if (hpsPos != 0x80)                      {                          newCHP.SetHpsPos(hpsPos);                      }                      bool fAdjust = (operand & 0x0100) > 0;                      if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos() == 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                      }                      if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos() != 0)                      {                          newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                      }                      break;                  case 0x40:                      newCHP.SetDxaSpace(sprm.Operand);                      break;                  case 0x41:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x42:                      newCHP.SetIco((byte)sprm.Operand);                      break;                  case 0x43:                      newCHP.SetHps(sprm.Operand);                      break;                  case 0x44:                      byte hpsLvl = (byte)sprm.Operand;                      newCHP.SetHps(Math.Max(newCHP.GetHps() + (hpsLvl * 2)' 2));                      break;                  case 0x45:                      newCHP.SetHpsPos((short)sprm.Operand);                      break;                  case 0x46:                      if (sprm.Operand != 0)                      {                          if (oldCHP.GetHpsPos() == 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + (-2)' 2));                          }                      }                      else                      {                          if (oldCHP.GetHpsPos() != 0)                          {                              newCHP.SetHps(Math.Max(newCHP.GetHps() + 2' 2));                          }                      }                      break;                  case 0x47:                      /*CharacterProperties genCHP = new CharacterProperties ();                      genCHP.SetFtcAscii (4);                      genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                        styleSheet);                      CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                        GetBaseIstd ()).GetCHP ();                      if (genCHP.IsFBold () == newCHP.IsFBold ())                      {                        newCHP.SetFBold (styleCHP.IsFBold ());                      }                      if (genCHP.IsFItalic () == newCHP.IsFItalic ())                      {                        newCHP.SetFItalic (styleCHP.IsFItalic ());                      }                      if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                      {                        newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                      }                      if (genCHP.IsFVanish () == newCHP.IsFVanish ())                      {                        newCHP.SetFVanish (styleCHP.IsFVanish ());                      }                      if (genCHP.IsFStrike () == newCHP.IsFStrike ())                      {                        newCHP.SetFStrike (styleCHP.IsFStrike ());                      }                      if (genCHP.IsFCaps () == newCHP.IsFCaps ())                      {                        newCHP.SetFCaps (styleCHP.IsFCaps ());                      }                      if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                      {                        newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                      }                      if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                      {                        newCHP.SetFtcFE (styleCHP.GetFtcFE ());                      }                      if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                      {                        newCHP.SetFtcOther (styleCHP.GetFtcOther ());                      }                      if (genCHP.GetHps () == newCHP.GetHps ())                      {                        newCHP.SetHps (styleCHP.GetHps ());                      }                      if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                      {                        newCHP.SetHpsPos (styleCHP.GetHpsPos ());                      }                      if (genCHP.GetKul () == newCHP.GetKul ())                      {                        newCHP.SetKul (styleCHP.GetKul ());                      }                      if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                      {                        newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                      }                      if (genCHP.GetIco () == newCHP.GetIco ())                      {                        newCHP.SetIco (styleCHP.GetIco ());                      }                      if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                      {                        newCHP.SetLidDefault (styleCHP.GetLidDefault ());                      }                      if (genCHP.GetLidFE () == newCHP.GetLidFE ())                      {                        newCHP.SetLidFE (styleCHP.GetLidFE ());                      }*/                      break;                  case 0x48:                      newCHP.SetIss((byte)sprm.Operand);                      break;                  case 0x49:                      newCHP.SetHps(LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x4a:                      int increment = LittleEndian.GetShort(sprm.Grpprl' sprm.GrpprlOffset);                      newCHP.SetHps(Math.Max(newCHP.GetHps() + increment' 8));                      break;                  case 0x4b:                      newCHP.SetHpsKern(sprm.Operand);                      break;                  case 0x4c:                      //        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'                      //                                styleSheet' opSize);                      break;                  case 0x4d:                      float percentage = sprm.Operand / 100.0f;                      int add = (int)(percentage * newCHP.GetHps());                      newCHP.SetHps(newCHP.GetHps() + add);                      break;                  case 0x4e:                      newCHP.SetYsr((byte)sprm.Operand);                      break;                  case 0x4f:                      newCHP.SetFtcAscii((short)sprm.Operand);                      break;                  case 0x50:                      newCHP.SetFtcFE((short)sprm.Operand);                      break;                  case 0x51:                      newCHP.SetFtcOther((short)sprm.Operand);                      break;                  case 0x52:                      // sprmCCharScale                      break;                  case 0x53:                      newCHP.SetFDStrike(GetFlag(sprm.Operand));                      break;                  case 0x54:                      newCHP.SetFImprint(GetFlag(sprm.Operand));                      break;                  case 0x55:                      newCHP.SetFSpec(GetFlag(sprm.Operand));                      break;                  case 0x56:                      newCHP.SetFObj(GetFlag(sprm.Operand));                      break;                  case 0x57:                      byte[] buf = sprm.Grpprl;                      int offset = sprm.GrpprlOffset;                      newCHP.SetFPropMark(buf[offset]);                      newCHP.SetIbstPropRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmPropRMark(new DateAndTime(buf' offset + 3));                      break;                  case 0x58:                      newCHP.SetFEmboss(GetFlag(sprm.Operand));                      break;                  case 0x59:                      newCHP.SetSfxtText((byte)sprm.Operand);                      break;                  case 0x5a:                      // sprmCFBiDi                      break;                  case 0x5b:                      break;                  case 0x5c:                      // sprmCFBoldBi                      break;                  case 0x5d:                      // sprmCFItalicBi                      break;                  case 0x5e:                      // sprmCFtcBi                      break;                  case 0x5f:                      // sprmCLidBi                       break;                  case 0x60:                      // sprmCIcoBi                      break;                  case 0x61:                      // sprmCHpsBi                      break;                  case 0x62:                      byte[] xstDispFldRMark = new byte[32];                      buf = sprm.Grpprl;                      offset = sprm.GrpprlOffset;                      newCHP.SetFDispFldRMark(buf[offset]);                      newCHP.SetIbstDispFldRMark(LittleEndian.GetShort(buf' offset + 1));                      newCHP.SetDttmDispFldRMark(new DateAndTime(buf' offset + 3));                      Array.Copy(buf' offset + 7' xstDispFldRMark' 0' 32);                      newCHP.SetXstDispFldRMark(xstDispFldRMark);                      break;                  case 0x63:                      newCHP.SetIbstRMarkDel((short)sprm.Operand);                      break;                  case 0x64:                      newCHP.SetDttmRMarkDel(new DateAndTime(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x65:                      newCHP.SetBrc(new BorderCode(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x66:                      newCHP.SetShd(new ShadingDescriptor(sprm.Grpprl' sprm.GrpprlOffset));                      break;                  case 0x67:                      // Obsolete                      break;                  case 0x68:                      //  sprmCFUsePgsuSettings                      break;                  case 0x69:                      break;                  case 0x6a:                      break;                  case 0x6b:                      break;                  case 0x6c:                      break;                  case 0x6d:                      newCHP.SetLidDefault((short)sprm.Operand);                      break;                  case 0x6e:                      newCHP.SetLidFE((short)sprm.Operand);                      break;                  case 0x6f:                      newCHP.SetIdctHint((byte)sprm.Operand);                      break;                  case 0x70:                      newCHP.SetIco24(sprm.Operand);                      break;                  case 0x71:                      // sprmCShd                      break;                  case 0x72:                      // sprmCBrc                      break;                  case 0x73:                      // sprmCRgLid0                      break;                  case 0x74:                      // sprmCRgLid1                      break;              }
Missing Default,NPOI.HWPF.UserModel,CharacterProperties,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following switch statement is missing a default case: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value                  {                      case 0: // auto                          return -1;                      case 1: // black                          return 0x000000;                      case 2: // blue                          return 0xFF0000;                      case 3: // cyan                          return 0xFFFF00;                      case 4: // green                          return 0x00FF00;                      case 5: // magenta                          return 0xFF00FF;                      case 6: // red                          return 0x0000FF;                      case 7: // yellow                          return 0x00FFFF;                      case 8: // white                          return 0x0FFFFFF;                      case 9: // dark blue                          return 0x800000;                      case 10: // dark cyan                          return 0x808000;                      case 11: // dark green                          return 0x008000;                      case 12: // dark magenta                          return 0x800080;                      case 13: // dark red                          return 0x000080;                      case 14: // dark yellow                          return 0x008080;                      case 15: // dark grey                          return 0x808080;                      case 16: // light grey                          return 0xC0C0C0;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalPositioning,The following switch statement is missing a default case: switch (value)                  {                      case 0:                          return HorizontalPositioning.ABSOLUTE;                      case 1:                          return HorizontalPositioning.LEFT;                      case 2:                          return HorizontalPositioning.CENTER;                      case 3:                          return HorizontalPositioning.RIGHT;                      case 4:                          return HorizontalPositioning.INSIDE;                      case 5:                          return HorizontalPositioning.OUTSIDE;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetHorizontalRelative,The following switch statement is missing a default case: switch (value)                  {                      case 1:                          return HorizontalRelativeElement.MARGIN;                      case 2:                          return HorizontalRelativeElement.PAGE;                      case 3:                          return HorizontalRelativeElement.TEXT;                      case 4:                          return HorizontalRelativeElement.CHAR;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalPositioning,The following switch statement is missing a default case: switch (value)                  {                      case 0:                          return VerticalPositioning.ABSOLUTE;                      case 1:                          return VerticalPositioning.TOP;                      case 2:                          return VerticalPositioning.CENTER;                      case 3:                          return VerticalPositioning.BOTTOM;                      case 4:                          return VerticalPositioning.INSIDE;                      case 5:                          return VerticalPositioning.OUTSIDE;                  }
Missing Default,NPOI.HWPF.UserModel,OfficeDrawingImpl,D:\research\architectureSmells\repos1\svn2github_npoi\scratchpad\HWPF\UserModel\OfficeDrawingsImpl.cs,GetVerticalRelativeElement,The following switch statement is missing a default case: switch (value)                  {                      case 1:                          return VerticalRelativeElement.MARGIN;                      case 2:                          return VerticalRelativeElement.PAGE;                      case 3:                          return VerticalRelativeElement.TEXT;                      case 4:                          return VerticalRelativeElement.LINE;                  }
