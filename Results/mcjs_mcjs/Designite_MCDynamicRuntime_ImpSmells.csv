Implementation smell,Namespace,Class,File,Method,Description
Complex Method,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,Cyclomatic complexity of the method is 15
Complex Method,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,Cyclomatic complexity of the method is 15
Complex Method,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,Cyclomatic complexity of the method is 15
Complex Method,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,Cyclomatic complexity of the method is 15
Complex Method,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,Cyclomatic complexity of the method is 15
Complex Method,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,Cyclomatic complexity of the method is 15
Complex Method,mdr,DRegExp,C:\repos\mcjs_mcjs\MCDynamicRuntime\DRegExp.cs,DRegExp,Cyclomatic complexity of the method is 23
Complex Method,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,GetPropertyDescriptor,Cyclomatic complexity of the method is 18
Complex Method,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddPropertyDescriptor,Cyclomatic complexity of the method is 18
Complex Method,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,DeletePropertyDescriptor,Cyclomatic complexity of the method is 18
Complex Method,mdr,DValue,C:\repos\mcjs_mcjs\MCDynamicRuntime\DValue.cs,ToString,Cyclomatic complexity of the method is 56
Complex Method,mdr,PropertyDescriptor,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyDescriptor.cs,SetAttributes,Cyclomatic complexity of the method is 8
Complex Method,mdr,PropertyMapMetadata,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMapMetadata.cs,PropagateAdditionDownPrototypeChain,Cyclomatic complexity of the method is 10
Complex Method,mdr,PropertyMapMetadata,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMapMetadata.cs,PropagateDeletionDownPrototypeChain,Cyclomatic complexity of the method is 10
Complex Method,mdr,BitArray,C:\repos\mcjs_mcjs\MCDynamicRuntime\TypedArray.cs,Set,Cyclomatic complexity of the method is 8
Long Parameter List,mdr,Runtime,C:\repos\mcjs_mcjs\MCDynamicRuntime\Runtime.cs,Runtime,The method has 13 parameters.
Long Parameter List,mdr,RuntimeConfiguration,C:\repos\mcjs_mcjs\MCDynamicRuntime\RuntimeConfiguration.cs,RuntimeConfiguration,The method has 8 parameters.
Long Parameter List,mdr,DForwardingProperty,C:\repos\mcjs_mcjs\MCDynamicRuntime\DForwardingProperty.cs,DForwardingProperty,The method has 6 parameters.
Long Statement,mdr,DArray,C:\repos\mcjs_mcjs\MCDynamicRuntime\DArray.cs,RemoveElements,The length of the statement  "	//even after the above adjustment of count' still count + startIndex can be equal to Length. In that case no copying is needed. " is 127.
Long Statement,mdr,DFunctionCodeCache,C:\repos\mcjs_mcjs\MCDynamicRuntime\DFunctionCodeCache.cs,Add,The length of the statement  "		Debug.Assert (code.Signature.Value != _items [i].Code.Signature.Value' "Code signature {0} already exists in the cache"' code.Signature.ToString ()); " is 149.
Long Statement,mdr,DFunctionSignature,C:\repos\mcjs_mcjs\MCDynamicRuntime\DFunctionSignature.cs,GetMask,The length of the statement  "			///TODO: we used to have the following code so that higher types can capture lowe types. (e.g. Object captures also Array). However " is 131.
Long Statement,mdr,DProperty,C:\repos\mcjs_mcjs\MCDynamicRuntime\DProperty.cs,Set,The length of the statement  "		Trace.Fail (new NotSupportedException (string.Format ("Cannot find setter for {0}:{1} on property {2}"' v' typeof(DValue)' base.ToString ()))); " is 143.
Long Statement,mdr,DRegExp,C:\repos\mcjs_mcjs\MCDynamicRuntime\DRegExp.cs,ToString,The length of the statement  "	return "/" + Value.ToString () + "/" + (Global ? "g" : String.Empty) + (IgnoreCase ? "i" : String.Empty) + (Multiline ? "m" : String.Empty); " is 140.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,FirstInPrototypeChainAs,The length of the statement  "		throw new InvalidCastException (string.Format ("Could not find type {0} in prorotype chain of object {1}"' typeof(T).Name' ToString ())); " is 137.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,InvalidAssignment,The length of the statement  "	Trace.Fail (new NotSupportedException (string.Format ("Cannot assign {0}:{1} to {2}"' v' typeof(T)' this.ToString ()))); " is 120.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,GetPropertyDescriptorByFieldId,The length of the statement  "			pd = Map.Metadata.AddInheritedProperty (Runtime.Instance.GetFieldName (fieldId)' Runtime.InvalidFieldIndex' fieldId' PropertyDescriptor.Attributes.Undefined); " is 158.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,GetPropertyDescriptor,The length of the statement  "		pd = Map.Metadata.AddInheritedProperty (field' Runtime.Instance.GetFieldId (field)' Runtime.InvalidFieldIndex' PropertyDescriptor.Attributes.Undefined); " is 152.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,GetPropertyDescriptor,The length of the statement  "	Trace.Fail (new InvalidOperationException (string.Format ("Cannot lookup property using field index type {0}"' field.ValueType))); " is 130.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddPropertyDescriptorByFieldId,The length of the statement  "	if (MustAddOwnPropertyDescriptor (propDesc) && newMap == null//this means either there was no hit in the cache' or maps matched " is 127.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddPropertyDescriptorByFieldId,The length of the statement  "		propDesc = Map.AddOwnProperty (this' Runtime.Instance.GetFieldName (fieldId)' fieldId' PropertyDescriptor.Attributes.Data); " is 123.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddPropertyDescriptorByFieldId,The length of the statement  "			Debug.Assert (propDesc == newMap.Property && propDesc.NameId == fieldId && newMap.Property.Name == Runtime.Instance.GetFieldName (fieldId)' "Invalid situation!"); " is 162.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddPropertyDescriptor,The length of the statement  "	Trace.Fail (new InvalidOperationException (string.Format ("Cannot add property using field index type {0}"' field.ValueType))); " is 127.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,DeletePropertyDescriptor,The length of the statement  "	Trace.Fail (new InvalidOperationException (string.Format ("Cannot delete property using field index type {0}"' field.ValueType))); " is 130.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddOwnPropertyDescriptorByFieldId,The length of the statement  "		Trace.Assert (attributes == propDesc.GetAttributes ()' "Updating existing own propery with different attributes is not supported via FieldID"); " is 143.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddOwnPropertyDescriptorByFieldId,The length of the statement  "	Debug.Assert (!propDesc.IsInherited && (propDesc.IsDataDescriptor || propDesc.IsAccessorDescriptor)' "You can use this method only for own properties"); " is 152.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddOwnPropertyDescriptor,The length of the statement  "		Debug.Assert (propDesc != null && m != null && m.Parent != null' "Invalid situation' we must have found a proper map pointing to existing property descriptor"); " is 160.
Long Statement,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddOwnPropertyDescriptor,The length of the statement  "	Debug.Assert (!propDesc.IsInherited && (propDesc.IsDataDescriptor || propDesc.IsAccessorDescriptor)' "You can use this method only for own properties"); " is 152.
Long Statement,mdr,PropertyDescriptor,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyDescriptor.cs,SetAttributes,The length of the statement  "			Debug.Assert (IsUndefined || _flags == Attributes.None' "Property descriptor of {0} has invalid type {1}"' Name' _flags); " is 121.
Long Statement,mdr,PropertyMap,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMap.cs,AddOwnProperty,The length of the statement  "	Debug.Assert (GetOwnPropertyDescriptorByFieldId (fieldId) == null' "Invalid situation! Field {0} alread exists in the map"' field); " is 131.
Long Statement,mdr,PropertyMap,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMap.cs,AddOwnProperty,The length of the statement  "		newMap = new PropertyMap (Metadata' this' new PropertyDescriptor (field' fieldId' this.Property.Index + 1' attributes)' overridenProperty); " is 139.
Long Statement,mdr,PropertyMap,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMap.cs,DeleteOwnPropertyDescriptor,The length of the statement  "	var newMap = (delMap == currMap.Parent || delMap == currMap) ? delMap.Parent : DeleteOwnPropertyDescriptor (obj' currMap.Parent' delMap); " is 137.
Long Statement,mdr,PropertyMap,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMap.cs,DeleteOwnPropertyDescriptor,The length of the statement  "		Debug.Assert (this.Property.Index == newMap.Property.Index + 1' "Invalid situation' we should delete on one field here!"); " is 122.
Long Statement,mdr,PropertyMap,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMap.cs,DeleteOwnPropertyDescriptor,The length of the statement  "			Array.Copy (obj.Fields' delMap.Property.Index + 1' obj.Fields' delMap.Property.Index' this.Property.Index - delMap.Property.Index); " is 131.
Long Statement,mdr,PropertyMapMetadata,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMapMetadata.cs,AddInheritedProperty,The length of the statement  "		var inheritedPD = AddInheritedProperty (propDesc.Name' propDesc.NameId' propDesc.Index' propDesc.GetAttributes () | PropertyDescriptor.Attributes.Inherited); " is 157.
Long Statement,mdr,PropertyMapMetadata,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMapMetadata.cs,GetInheritedPropertyDescriptor,The length of the statement  "		//  return AddInheritedProperty(field' Runtime.Instance.GetFieldId(field)' Runtime.InvalidFieldIndex' PropertyDescriptor.Attributes.Undefined); " is 143.
Long Statement,mdr,PropertyMapMetadata,C:\repos\mcjs_mcjs\MCDynamicRuntime\PropertyMapMetadata.cs,GetInheritedPropertyDescriptorByFieldId,The length of the statement  "		//  return AddInheritedProperty(Runtime.Instance.GetFieldName(fieldId)' fieldId' Runtime.InvalidFieldIndex' PropertyDescriptor.Attributes.Undefined); " is 149.
Long Statement,mdr,Runtime,C:\repos\mcjs_mcjs\MCDynamicRuntime\Runtime.cs,ShutDown,The length of the statement  "		profileOut = System.IO.File.Exists (profileFilename) ? System.IO.File.AppendText (profileFilename) : System.IO.File.CreateText (profileFilename); " is 145.
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,Arg,The following statement contains a magic number: switch (i) {  case 0:  	return Arg0;  case 1:  	return Arg1;  case 2:  	return Arg2;  case 3:  	return Arg3;  default:  	return Arguments [i - InlineArgsCount];  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,Arg,The following statement contains a magic number: switch (i) {  case 0:  	return Arg0;  case 1:  	return Arg1;  case 2:  	return Arg2;  case 3:  	return Arg3;  default:  	return Arguments [i - InlineArgsCount];  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,The following statement contains a magic number: switch (i) {  case 0:  	Signature.InitArgType (0' Arg0.ValueType);  	break;  case 1:  	Signature.InitArgType (1' Arg1.ValueType);  	break;  case 2:  	Signature.InitArgType (2' Arg2.ValueType);  	break;  case 3:  	Signature.InitArgType (3' Arg3.ValueType);  	break;  default:  	Signature.InitArgType (i' Arguments [i - InlineArgsCount].ValueType);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,The following statement contains a magic number: switch (i) {  case 0:  	Signature.InitArgType (0' Arg0.ValueType);  	break;  case 1:  	Signature.InitArgType (1' Arg1.ValueType);  	break;  case 2:  	Signature.InitArgType (2' Arg2.ValueType);  	break;  case 3:  	Signature.InitArgType (3' Arg3.ValueType);  	break;  default:  	Signature.InitArgType (i' Arguments [i - InlineArgsCount].ValueType);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,The following statement contains a magic number: switch (i) {  case 0:  	Signature.InitArgType (0' Arg0.ValueType);  	break;  case 1:  	Signature.InitArgType (1' Arg1.ValueType);  	break;  case 2:  	Signature.InitArgType (2' Arg2.ValueType);  	break;  case 3:  	Signature.InitArgType (3' Arg3.ValueType);  	break;  default:  	Signature.InitArgType (i' Arguments [i - InlineArgsCount].ValueType);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,The following statement contains a magic number: switch (i) {  case 0:  	Signature.InitArgType (0' Arg0.ValueType);  	break;  case 1:  	Signature.InitArgType (1' Arg1.ValueType);  	break;  case 2:  	Signature.InitArgType (2' Arg2.ValueType);  	break;  case 3:  	Signature.InitArgType (3' Arg3.ValueType);  	break;  default:  	Signature.InitArgType (i' Arguments [i - InlineArgsCount].ValueType);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,The following statement contains a magic number: Signature.InitArgType (2' Arg2.ValueType);  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,UpdateSignature,The following statement contains a magic number: Signature.InitArgType (3' Arg3.ValueType);  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (v);  	break;  case 1:  	Arg1.Set (v);  	break;  case 2:  	Arg2.Set (v);  	break;  case 3:  	Arg3.Set (v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (ref v);  	break;  case 1:  	Arg1.Set (ref v);  	break;  case 2:  	Arg2.Set (ref v);  	break;  case 3:  	Arg3.Set (ref v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (ref v);  	break;  }  
Magic Number,mdr,CallFrame,C:\repos\mcjs_mcjs\MCDynamicRuntime\CallFrame.cs,SetArg,The following statement contains a magic number: switch (i) {  case 0:  	Arg0.Set (ref v);  	break;  case 1:  	Arg1.Set (ref v);  	break;  case 2:  	Arg2.Set (ref v);  	break;  case 3:  	Arg3.Set (ref v);  	break;  default:  	Arguments [i - InlineArgsCount].Set (ref v);  	break;  }  
Magic Number,mdr,DArray,C:\repos\mcjs_mcjs\MCDynamicRuntime\DArray.cs,DArray,The following statement contains a magic number: if (initialSize == 0)  	initialSize = 10;  
Magic Number,mdr,DArray,C:\repos\mcjs_mcjs\MCDynamicRuntime\DArray.cs,DArray,The following statement contains a magic number: initialSize = 10;  
Magic Number,mdr,DArray,C:\repos\mcjs_mcjs\MCDynamicRuntime\DArray.cs,ResizeElements,The following statement contains a magic number: if (maxIndex >= capacity) {  	int newCapacity = Math.Min (maxIndex * 2' MaxElementsCount);  	if (newCapacity == capacity)  		Trace.Fail ("Element index is too big!");  	var newElements = new DValue[newCapacity];  	Array.Copy (Elements' newElements' Elements.Length);  	Elements = newElements;  }  
Magic Number,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,ResizeFields,The following statement contains a magic number: if (maxIndex >= Fields.Length) {  	int newCapacity = maxIndex + 8;  	//TODO: should we just extend by one?  	var newFields = new DValue[newCapacity];  	Array.Copy (Fields' newFields' Fields.Length);  	Fields = newFields;  }  
Magic Number,mdr,Runtime,C:\repos\mcjs_mcjs\MCDynamicRuntime\Runtime.cs,GetFieldId,The following statement contains a magic number: lock (_fieldName2IdMap)//Does not matter which one we lock!   {  	if (!_fieldName2IdMap.TryGetValue (field' out fieldId)) {  		///Technically we should lock here to prevent data corruption when parallelism is enabled  		///But' we never execute in parallel' only paralle analyze may call this function  		///To prevent runtime overhead' we do the locking the Analyzer algorithm' rather than here.   		///  		fieldId = _fieldName2IdMap.Count;  		_fieldName2IdMap [field] = fieldId;  		_fieldId2NameMap.Add (field);  		Debug.Assert (_fieldId2NameMap [fieldId] == field' "Invalid situation!");  		if (fieldId >= _lastAccessedPropertyCache.Length) {  			Array.Resize (ref _lastAccessedPropertyCache' 5 * _lastAccessedPropertyCache.Length);  		}  		Debug.Assert (fieldId == _fieldId2NameMap.Count - 1);  	}  }  
Magic Number,mdr,Runtime,C:\repos\mcjs_mcjs\MCDynamicRuntime\Runtime.cs,GetFieldId,The following statement contains a magic number: if (!_fieldName2IdMap.TryGetValue (field' out fieldId)) {  	///Technically we should lock here to prevent data corruption when parallelism is enabled  	///But' we never execute in parallel' only paralle analyze may call this function  	///To prevent runtime overhead' we do the locking the Analyzer algorithm' rather than here.   	///  	fieldId = _fieldName2IdMap.Count;  	_fieldName2IdMap [field] = fieldId;  	_fieldId2NameMap.Add (field);  	Debug.Assert (_fieldId2NameMap [fieldId] == field' "Invalid situation!");  	if (fieldId >= _lastAccessedPropertyCache.Length) {  		Array.Resize (ref _lastAccessedPropertyCache' 5 * _lastAccessedPropertyCache.Length);  	}  	Debug.Assert (fieldId == _fieldId2NameMap.Count - 1);  }  
Magic Number,mdr,Runtime,C:\repos\mcjs_mcjs\MCDynamicRuntime\Runtime.cs,GetFieldId,The following statement contains a magic number: if (fieldId >= _lastAccessedPropertyCache.Length) {  	Array.Resize (ref _lastAccessedPropertyCache' 5 * _lastAccessedPropertyCache.Length);  }  
Magic Number,mdr,Runtime,C:\repos\mcjs_mcjs\MCDynamicRuntime\Runtime.cs,GetFieldId,The following statement contains a magic number: Array.Resize (ref _lastAccessedPropertyCache' 5 * _lastAccessedPropertyCache.Length);  
Magic Number,mdr,TypedArray,C:\repos\mcjs_mcjs\MCDynamicRuntime\TypedArray.cs,SetLength,The following statement contains a magic number: if (value > Capacity) {  	int newCapacity = Math.Min (value * 2' MaxLength);  	if (newCapacity == Capacity)  		Trace.Fail ("Array index too big!");  	T[] newItems = new T[newCapacity];  	System.Array.Copy (_items' 0' newItems' 0' _items.Length);  	if (Initializer != null)  		Initializer (newItems' _items.Length' newItems.Length - _items.Length);  	_items = newItems;  }  
Missing Default,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,GetPropertyDescriptor,The following switch statement is missing a default case: switch (field.ValueType) {  case ValueTypes.Undefined:  	return GetPropertyDescriptor (Runtime.Instance.DefaultDUndefined.ToString ());  case ValueTypes.String:  	return GetPropertyDescriptor (field.AsString ());  case ValueTypes.Char:  	return GetPropertyDescriptor (field.AsChar ());  case ValueTypes.Boolean:  	return GetPropertyDescriptor (field.AsBoolean ());  case ValueTypes.Float:  	return GetPropertyDescriptor (field.AsFloat ());  case ValueTypes.Double:  	return GetPropertyDescriptor (field.AsDouble ());  case ValueTypes.Int8:  	return GetPropertyDescriptor (field.AsInt8 ());  case ValueTypes.Int16:  	return GetPropertyDescriptor (field.AsInt16 ());  case ValueTypes.Int32:  	return GetPropertyDescriptor (field.AsInt32 ());  case ValueTypes.Int64:  	return GetPropertyDescriptor (field.AsInt64 ());  case ValueTypes.UInt8:  	return GetPropertyDescriptor (field.AsUInt8 ());  case ValueTypes.UInt16:  	return GetPropertyDescriptor (field.AsUInt16 ());  case ValueTypes.UInt32:  	return GetPropertyDescriptor (field.AsUInt32 ());  case ValueTypes.UInt64:  	return GetPropertyDescriptor (field.AsUInt64 ());  case ValueTypes.Object:  case ValueTypes.Function:  case ValueTypes.Array:  	//case ValueTypes.Property:  	return GetPropertyDescriptor (field.AsDObject ().ToString ());  case ValueTypes.Null:  	return GetPropertyDescriptor (Runtime.Instance.DefaultDNull.ToString ());  //default:  //    return GetPropertyDescriptor(field.ToString()); //This should never happen  }  
Missing Default,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,AddPropertyDescriptor,The following switch statement is missing a default case: switch (field.ValueType) {  case ValueTypes.Undefined:  	return AddPropertyDescriptor (Runtime.Instance.DefaultDUndefined.ToString ());  case ValueTypes.String:  	return AddPropertyDescriptor (field.AsString ());  case ValueTypes.Char:  	return AddPropertyDescriptor (field.AsChar ());  case ValueTypes.Boolean:  	return AddPropertyDescriptor (field.AsBoolean ());  case ValueTypes.Float:  	return AddPropertyDescriptor (field.AsFloat ());  case ValueTypes.Double:  	return AddPropertyDescriptor (field.AsDouble ());  case ValueTypes.Int8:  	return AddPropertyDescriptor (field.AsInt8 ());  case ValueTypes.Int16:  	return AddPropertyDescriptor (field.AsInt16 ());  case ValueTypes.Int32:  	return AddPropertyDescriptor (field.AsInt32 ());  case ValueTypes.Int64:  	return AddPropertyDescriptor (field.AsInt64 ());  case ValueTypes.UInt8:  	return AddPropertyDescriptor (field.AsUInt8 ());  case ValueTypes.UInt16:  	return AddPropertyDescriptor (field.AsUInt16 ());  case ValueTypes.UInt32:  	return AddPropertyDescriptor (field.AsUInt32 ());  case ValueTypes.UInt64:  	return AddPropertyDescriptor (field.AsUInt64 ());  case ValueTypes.Object:  case ValueTypes.Function:  case ValueTypes.Array:  	//case ValueTypes.Property:  	return AddPropertyDescriptor (field.AsDObject ().ToString ());  case ValueTypes.Null:  	return AddPropertyDescriptor (Runtime.Instance.DefaultDNull.ToString ());  //default:  //    return AddPropertyDescriptor(field.ToString()); //This should never happen  }  
Missing Default,mdr,DObject,C:\repos\mcjs_mcjs\MCDynamicRuntime\DObject.cs,DeletePropertyDescriptor,The following switch statement is missing a default case: switch (field.ValueType) {  case ValueTypes.Undefined:  	return DeletePropertyDescriptor (Runtime.Instance.DefaultDUndefined.ToString ());  case ValueTypes.String:  	return DeletePropertyDescriptor (field.AsString ());  case ValueTypes.Char:  	return DeletePropertyDescriptor (field.AsChar ());  case ValueTypes.Boolean:  	return DeletePropertyDescriptor (field.AsBoolean ());  case ValueTypes.Float:  	return DeletePropertyDescriptor (field.AsFloat ());  case ValueTypes.Double:  	return DeletePropertyDescriptor (field.AsDouble ());  case ValueTypes.Int8:  	return DeletePropertyDescriptor (field.AsInt8 ());  case ValueTypes.Int16:  	return DeletePropertyDescriptor (field.AsInt16 ());  case ValueTypes.Int32:  	return DeletePropertyDescriptor (field.AsInt32 ());  case ValueTypes.Int64:  	return DeletePropertyDescriptor (field.AsInt64 ());  case ValueTypes.UInt8:  	return DeletePropertyDescriptor (field.AsUInt8 ());  case ValueTypes.UInt16:  	return DeletePropertyDescriptor (field.AsUInt16 ());  case ValueTypes.UInt32:  	return DeletePropertyDescriptor (field.AsUInt32 ());  case ValueTypes.UInt64:  	return DeletePropertyDescriptor (field.AsUInt64 ());  case ValueTypes.Object:  case ValueTypes.Function:  case ValueTypes.Array:  	//case ValueTypes.Property:  	return DeletePropertyDescriptor (field.AsDObject ().ToString ());  case ValueTypes.Null:  	return DeletePropertyDescriptor (Runtime.Instance.DefaultDNull.ToString ());  //default:  //    return DeletePropertyDescriptor(field.ToString()); //This should never happen  }  
