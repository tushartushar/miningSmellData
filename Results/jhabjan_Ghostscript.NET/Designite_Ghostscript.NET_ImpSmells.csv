Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ghostscript.NET.Viewer,GhostscriptViewerPsFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPsFormatHandler.cs,OpenPsFile,The method has 110 lines of code.
Complex Method,Ghostscript.NET,GhostscriptLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptLibrary.cs,Initialize,Cyclomatic complexity of the method is 18
Complex Method,Ghostscript.NET,GhostscriptDevice,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\OutputDevices\GhostscriptDevice.cs,GetSwitches,Cyclomatic complexity of the method is 10
Complex Method,Ghostscript.NET,GhostscriptVersionInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptVersionInfo.cs,GetInstalledVersions,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,BuildImportTable,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,FinalizeSections,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,MemoryFreeLibrary,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,GetProcAddress,Cyclomatic complexity of the method is 9
Complex Method,Ghostscript.NET.Processor,GhostscriptProcessor,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Processor\GhostscriptProcessor.cs,StartProcessing,Cyclomatic complexity of the method is 11
Complex Method,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,ShowPage,Cyclomatic complexity of the method is 9
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,display_presize,The method has 6 parameters. Parameters: handle' device' width' height' raster' format
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,display_size,The method has 7 parameters. Parameters: handle' device' width' height' raster' format' pimage
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,display_update,The method has 6 parameters. Parameters: handle' device' x' y' w' h
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,display_separation,The method has 8 parameters. Parameters: handle' device' component' component_name' c' m' y' k
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,Presize,The method has 6 parameters. Parameters: handle' device' width' height' raster' format
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,Size,The method has 7 parameters. Parameters: handle' device' width' height' raster' format' pimage
Long Parameter List,Ghostscript.NET,GhostscriptDisplayDeviceHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptDisplayDeviceHandler.cs,Update,The method has 6 parameters. Parameters: handle' device' x' y' w' h
Long Parameter List,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,Set24bppRgbImageColor,The method has 6 parameters. Parameters: image' width' height' r' g' b
Long Parameter List,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,CopyImagePartFrom,The method has 8 parameters. Parameters: src' dest' x' y' width' height' stride' bytesPerPixel
Long Parameter List,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,CopyImagePartTo,The method has 8 parameters. Parameters: dest' src' x' y' width' height' stride' bytesPerPixel
Long Parameter List,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Presize,The method has 6 parameters. Parameters: handle' device' width' height' raster' format
Long Parameter List,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Size,The method has 7 parameters. Parameters: handle' device' width' height' raster' format' pimage
Long Parameter List,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The method has 6 parameters. Parameters: handle' device' x' y' w' h
Long Identifier,Ghostscript.NET.Interpreter,GhostscriptInterpreter,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Interpreter\GhostscriptInterpreter.cs,,The length of the parameter _displayDevice_callback_handle is 30.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_NUMBEROF_DIRECTORY_ENTRIES is 32.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_SCN_CNT_INITIALIZED_DATA is 30.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_SCN_CNT_UNINITIALIZED_DATA is 32.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_RESOURCE is 30.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_EXCEPTION is 31.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_SECURITY is 30.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_BASERELOC is 31.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_ARCHITECTURE is 34.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_GLOBALPTR is 31.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG is 33.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT is 34.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT is 34.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR is 36.
Long Identifier,Microsoft.WinAny,WinNT,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\_native\WinNT.h.cs,,The length of the parameter IMAGE_REL_BASED_MIPS_JMPADDR16 is 30.
Long Identifier,Ghostscript.NET.Viewer,GhostscriptViewerFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerFormatHandler.cs,,The length of the parameter _showPagePostScriptCommandInvoked is 33.
Long Statement,Ghostscript.NET,GhostscriptLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptLibrary.cs,Initialize,The length of the statement  "            this.gsapi_set_display_callback = _library.GetDelegateForFunction<gsapi_set_display_callback>("gsapi_set_display_callback"); " is 124.
Long Statement,Ghostscript.NET,GhostscriptLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptLibrary.cs,Initialize,The length of the statement  "            this.gsapi_run_string_continue = _library.GetDelegateForFunction<gsapi_run_string_continue>("gsapi_run_string_continue"); " is 121.
Long Statement,Ghostscript.NET,GhostscriptLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptLibrary.cs,Initialize,The length of the statement  "            this.gsapi_run_string_with_length = _library.GetDelegateForFunction<gsapi_run_string_with_length>("gsapi_run_string_with_length"); " is 130.
Long Statement,Ghostscript.NET,GhostscriptLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptLibrary.cs,ThrowIncompatibileNativeGhostscriptLibraryException,The length of the statement  "                                    "You are using native Ghostscript library (gsdll32.dll) compiled for 32bit systems in a 64bit process. You need to use gsdll64.dll. " + " is 135.
Long Statement,Ghostscript.NET,GhostscriptLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptLibrary.cs,ThrowIncompatibileNativeGhostscriptLibraryException,The length of the statement  "                                    "You are using native Ghostscript library (gsdll64.dll) compiled for 64bit systems in a 32bit process. You need to use gsdll32.dll. " + " is 135.
Long Statement,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The length of the statement  "            GhostscriptVersionInfo gvi = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL); " is 150.
Long Statement,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The length of the statement  "            GhostscriptVersionInfo gvi = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL); " is 150.
Long Statement,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The length of the statement  "            GhostscriptVersionInfo gvi = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL); " is 150.
Long Statement,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The length of the statement  "            GhostscriptVersionInfo gvi = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL); " is 150.
Long Statement,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The length of the statement  "            GhostscriptVersionInfo gvi = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL); " is 150.
Long Statement,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The length of the statement  "            GhostscriptVersionInfo gvi = GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL); " is 150.
Long Statement,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The length of the statement  "            // https://github.com/awslabs/aws-sdk-xamarin/blob/master/AWS.XamarinSDK/AWSSDK_Core/Amazon.Runtime/Internal/Util/HashStream.cs " is 127.
Long Statement,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The length of the statement  "            // Amazon.Runtime.Internal.Util.HashStream.Position {set; get;} throw NotSupportedException. First check CanSeek and default to PDF file extension " is 146.
Long Statement,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The length of the statement  "            else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6) " is 152.
Long Statement,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,WriteToTemporaryFile,The length of the statement  "            // https://github.com/awslabs/aws-sdk-xamarin/blob/master/AWS.XamarinSDK/AWSSDK_Core/Amazon.Runtime/Internal/Util/HashStream.cs " is 127.
Long Statement,Ghostscript.NET,GhostscriptDevice,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\OutputDevices\GhostscriptDevice.cs,Process,The length of the statement  "            this.Process(GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL)'  " is 134.
Long Statement,Ghostscript.NET,GhostscriptVersionInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptVersionInfo.cs,GetLastInstalledVersion,The length of the statement  "            return GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL | GhostscriptLicense.Artifex' GhostscriptLicense.GPL); " is 134.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,MemoryLoadLibrary,The length of the statement  "                    codeBase = WinBase.VirtualAlloc(old_header_oh_imageBase' old_header_oh_sizeOfImage' WinNT.MEM_RESERVE' WinNT.PAGE_READWRITE); " is 125.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,CopySections,The length of the statement  "                        dest = (byte*)WinBase.VirtualAlloc((IntPtr)(codeBase + section->VirtualAddress)' sectionAlignment' WinNT.MEM_COMMIT' WinNT.PAGE_READWRITE); " is 139.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,CopySections,The length of the statement  "                dest = (byte*)WinBase.VirtualAlloc((IntPtr)(codeBase + section->VirtualAddress)' section->SizeOfRawData' WinNT.MEM_COMMIT' WinNT.PAGE_READWRITE); " is 145.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,PerformBaseRelocation,The length of the statement  "            WinNT.IMAGE_DATA_DIRECTORY* directory = this.GET_HEADER_DIRECTORY(memory_module' WinNT.IMAGE_DIRECTORY_ENTRY_BASERELOC); " is 120.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,PerformBaseRelocation,The length of the statement  "                WinNT.IMAGE_BASE_RELOCATION* relocation = (WinNT.IMAGE_BASE_RELOCATION*)(memory_module->codeBase + directory->VirtualAddress); " is 126.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,BuildImportTable,The length of the statement  "                WinNT.IMAGE_IMPORT_DESCRIPTOR* importDesc = (WinNT.IMAGE_IMPORT_DESCRIPTOR*)(memory_module->codeBase + directory->VirtualAddress); " is 130.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,FinalizeSections,The length of the statement  "                    WinBase.VirtualFree((IntPtr)((long)section->PhysicalAddress | (long)image_offset)' section->SizeOfRawData' WinNT.MEM_DECOMMIT); " is 127.
Long Statement,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,FinalizeSections,The length of the statement  "                    WinBase.VirtualProtect((IntPtr)((long)section->PhysicalAddress | (long)image_offset)' rawDataSize' protect' &oldProtect); " is 121.
Long Statement,Ghostscript.NET.Rasterizer,GhostscriptRasterizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Rasterizer\GhostscriptRasterizer.cs,Open,The length of the statement  "            this.Open(stream' GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL)' false); " is 147.
Long Statement,Ghostscript.NET.Rasterizer,GhostscriptRasterizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Rasterizer\GhostscriptRasterizer.cs,Open,The length of the statement  "            this.Open(path' GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL)' false); " is 145.
Long Statement,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadUntil,The length of the statement  "                else if (c == ' ' && text.Length > 0 && lastAppendedChar != ' ' && (end & DSCTokenEnding.Whitespace) == DSCTokenEnding.Whitespace) " is 130.
Long Statement,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,Open,The length of the statement  "            this.Open(path' GhostscriptVersionInfo.GetLastInstalledVersion(GhostscriptLicense.GPL | GhostscriptLicense.AFPL' GhostscriptLicense.GPL)' false); " is 145.
Long Statement,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,ShowPage,The length of the statement  "            if ((_formatHandler.GetType() == typeof(GhostscriptViewerEpsFormatHandler) && this.EPSClip && boundingBox != GhostscriptRectangle.Empty)) " is 137.
Long Statement,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Page,The length of the statement  "                ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' 0' 0' _destImage.Width' _destImage.Height' _srcStride' bytesPerPixel); " is 127.
Long Statement,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Page,The length of the statement  "            _viewer.RaiseDisplayPage(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height))); " is 131.
Long Statement,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The length of the statement  "                        _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height))); " is 133.
Complex Conditional,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The conditional expression  "test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6"  is complex.
Complex Conditional,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The conditional expression  "test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46"  is complex.
Complex Conditional,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadUntil,The conditional expression  "c == ' ' && text.Length > 0 && lastAppendedChar != ' ' && (end & DSCTokenEnding.Whitespace) == DSCTokenEnding.Whitespace"  is complex.
Complex Conditional,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The conditional expression  "mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury)"  is complex.
Complex Conditional,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The conditional expression  "cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury)"  is complex.
Empty Catch Block,Ghostscript.NET,FileCleanupHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\FileCleanupHelper.cs,Cleanup,The method has an empty catch block.
Empty Catch Block,Ghostscript.NET,GhostscriptVersionInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptVersionInfo.cs,GetInstalledVersions,The method has an empty catch block.
Empty Catch Block,Ghostscript.NET.Viewer,GhostscriptViewerEpsFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerEpsFormatHandler.cs,Open,The method has an empty catch block.
Empty Catch Block,Ghostscript.NET.Viewer,GhostscriptViewerPsFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPsFormatHandler.cs,OpenPsFile,The method has an empty catch block.
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,GhostscriptPdfInfo,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\GhostscriptPdfInfo.cs,GetInkCoverage,The following statement contains a magic number: if (output.Length > 0)              {                  Dictionary<int' GhostscriptPageInkCoverage> result = new Dictionary<int' GhostscriptPageInkCoverage>();                    string[] outputLines = output.Split(new char[] { '\n' }' StringSplitOptions.RemoveEmptyEntries);                    int pageNumber = firstPage == 0 ? 1 : firstPage;                    foreach(string line in outputLines)                  {                      GhostscriptPageInkCoverage pic = new GhostscriptPageInkCoverage();                      pic.Page = pageNumber;                      pic.IsValid = false;                        string[] lineParts = line.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                        if (lineParts.Length == 6)                      {                          pic.C = Math.Round(float.Parse(lineParts[0]' CultureInfo.InvariantCulture) * 100' 2);                          pic.M = Math.Round(float.Parse(lineParts[1]' CultureInfo.InvariantCulture) * 100' 2);                          pic.Y = Math.Round(float.Parse(lineParts[2]' CultureInfo.InvariantCulture) * 100' 2);                          pic.K = Math.Round(float.Parse(lineParts[3]' CultureInfo.InvariantCulture) * 100' 2);                            if (lineParts[5] == "OK")                          {                              pic.IsValid = true;                          }                      }                        result.Add(pageNumber' pic);                        pageNumber++;                  }                    return result;              }              else              {                  return null;               }
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,Set24bppRgbImageColor,The following statement contains a magic number: int stride = (((width * 3) + 3) & ~3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,Set24bppRgbImageColor,The following statement contains a magic number: int stride = (((width * 3) + 3) & ~3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,Set24bppRgbImageColor,The following statement contains a magic number: int stride = (((width * 3) + 3) & ~3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,Set24bppRgbImageColor,The following statement contains a magic number: int padding = stride - (width * 3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,CopyImagePartFrom,The following statement contains a magic number: int destStride = (((width * bytesPerPixel) + 3) & ~3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,CopyImagePartFrom,The following statement contains a magic number: int destStride = (((width * bytesPerPixel) + 3) & ~3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,CopyImagePartTo,The following statement contains a magic number: int partStride = (((width * bytesPerPixel) + 3) & ~3);
Magic Number,Ghostscript.NET,ImageMemoryHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\ImageMemoryHelper.cs,CopyImagePartTo,The following statement contains a magic number: int partStride = (((width * bytesPerPixel) + 3) & ~3);
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (stream.Length < 4)              {                  throw new InvalidDataException("Less than 4 bytes found in stream.");              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: byte[] test = new byte[4];
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: stream.Read(test' 0' 4);
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Ghostscript.NET,StreamHelper,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Helpers\StreamHelper.cs,GetStreamExtension,The following statement contains a magic number: if (test[0] == 0x25 && test[1] == 0x21) // standard ps or eps signature              {                  extension = ".ps";                    if (stream.Length > 23)                  {                      test = new byte[23];                      stream.Read(test' 0' 23);                        stream.Position = 0;                        string tmp = System.Text.Encoding.ASCII.GetString(test);                        if (tmp.ToUpper().Contains("EPS"))                      {                          extension = ".eps";                      }                  }              }              else if (test[0] == 0xc5 && test[1] == 0xd0 && test[2] == 0xd3 && test[3] == 0xc6) // eps with preview header signature / magic number (always C5D0D3C6)              {                  extension = ".eps";              }              else if (test[0] == 0x25 && test[1] == 0x50 && test[2] == 0x44 && test[3] == 0x46) // pdf signature              {                  extension = ".pdf";              }              else              {                  // try to search for pdf signature once again                  // this time look into all first 32 bytes as I run into pdf's that has extra bytes                   // at the beginning of the pdf file before the actual signature                    stream.Position = 0;                    if (stream.Length > 32)                  {                      test = new byte[32];                      stream.Read(test' 0' 32);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46}) > -1)                      {                          extension = ".pdf";                      }                  }                                    if(string.IsNullOrWhiteSpace(extension))                  {                      // we didn't find pdf marker within first 32 bytes' read whole stream and search for pdf marker anywhere                      BinaryReader reader = new BinaryReader(stream);                      test = reader.ReadBytes((int)stream.Length);                        stream.Position = 0;                        if (BufferHelper.IndexOf(test' new byte[] { 0x25' 0x50' 0x44' 0x46 }) > -1)                      {                          extension = ".pdf";                      }                  }              }
Magic Number,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,PerformBaseRelocation,The following statement contains a magic number: if (directory->Size > 0)              {                  WinNT.IMAGE_BASE_RELOCATION* relocation = (WinNT.IMAGE_BASE_RELOCATION*)(memory_module->codeBase + directory->VirtualAddress);                    int sizeOfBaseRelocation = sizeof(WinNT.IMAGE_BASE_RELOCATION);                    int index;                    for (; relocation->VirtualAddress > 0; )                  {                      byte* dest = (byte*)(memory_module->codeBase + relocation->VirtualAddress);                      ushort* relInfo = (ushort*)((byte*)relocation + sizeOfBaseRelocation);                        for (index = 0; index < ((relocation->SizeOfBlock - sizeOfBaseRelocation) / 2); index++' relInfo++)                      {                          uint* patchAddrHL32;                          ulong* patchAddrHL64;                            uint type' offset;                            // the upper 4 bits define the type of relocation                          type = (uint)(*relInfo >> 12);                            // the lower 12 bits define the offset                          offset = (uint)(*relInfo & 0xfff);                            switch (type)                          {                              case WinNT.IMAGE_REL_BASED_ABSOLUTE:                                  break;                                case WinNT.IMAGE_REL_BASED_HIGHLOW:                                  patchAddrHL32 = (uint*)((uint)dest + offset);                                  *patchAddrHL32 += (uint)delta;                                  break;                                  case WinNT.IMAGE_REL_BASED_DIR64:                                  patchAddrHL64 = (ulong*)((ulong)dest + offset);                                  *patchAddrHL64 += delta;                                  break;                                default:                                  break;                          }                      }                        relocation = (WinNT.IMAGE_BASE_RELOCATION*)((byte*)relocation + relocation->SizeOfBlock);                  }              }
Magic Number,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,PerformBaseRelocation,The following statement contains a magic number: if (directory->Size > 0)              {                  WinNT.IMAGE_BASE_RELOCATION* relocation = (WinNT.IMAGE_BASE_RELOCATION*)(memory_module->codeBase + directory->VirtualAddress);                    int sizeOfBaseRelocation = sizeof(WinNT.IMAGE_BASE_RELOCATION);                    int index;                    for (; relocation->VirtualAddress > 0; )                  {                      byte* dest = (byte*)(memory_module->codeBase + relocation->VirtualAddress);                      ushort* relInfo = (ushort*)((byte*)relocation + sizeOfBaseRelocation);                        for (index = 0; index < ((relocation->SizeOfBlock - sizeOfBaseRelocation) / 2); index++' relInfo++)                      {                          uint* patchAddrHL32;                          ulong* patchAddrHL64;                            uint type' offset;                            // the upper 4 bits define the type of relocation                          type = (uint)(*relInfo >> 12);                            // the lower 12 bits define the offset                          offset = (uint)(*relInfo & 0xfff);                            switch (type)                          {                              case WinNT.IMAGE_REL_BASED_ABSOLUTE:                                  break;                                case WinNT.IMAGE_REL_BASED_HIGHLOW:                                  patchAddrHL32 = (uint*)((uint)dest + offset);                                  *patchAddrHL32 += (uint)delta;                                  break;                                  case WinNT.IMAGE_REL_BASED_DIR64:                                  patchAddrHL64 = (ulong*)((ulong)dest + offset);                                  *patchAddrHL64 += delta;                                  break;                                default:                                  break;                          }                      }                        relocation = (WinNT.IMAGE_BASE_RELOCATION*)((byte*)relocation + relocation->SizeOfBlock);                  }              }
Magic Number,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,BuildImportTable,The following statement contains a magic number: if (directory->Size > 0)              {                  WinNT.IMAGE_IMPORT_DESCRIPTOR* importDesc = (WinNT.IMAGE_IMPORT_DESCRIPTOR*)(memory_module->codeBase + directory->VirtualAddress);                    for (; importDesc->Name != 0; importDesc++)                  {                      IntPtr* thunkRef;                      IntPtr* funcRef;                        string moduleName = Marshal.PtrToStringAnsi((IntPtr)(memory_module->codeBase + importDesc->Name));                      IntPtr handle = WinBase.LoadLibrary(moduleName);                        if (handle == IntPtr.Zero)                      {                          result = false;                          break;                      }                        int size_of_pointer = sizeof(IntPtr);                        memory_module->modules = (IntPtr*)memory.realloc((byte*)memory_module->modules'                                                                       (uint)((memory_module->numModules) * size_of_pointer)'                                                                       (uint)((memory_module->numModules + 1) * size_of_pointer));                          if (memory_module->modules == null)                      {                          result = false;                          break;                      }                        memory_module->modules[memory_module->numModules++] = handle;                        if (importDesc->Characteristics != 0)                      {                          thunkRef = (IntPtr*)(memory_module->codeBase + importDesc->Characteristics);                          funcRef = (IntPtr*)(memory_module->codeBase + importDesc->FirstThunk);                      }                      else                      {                          thunkRef = (IntPtr*)(memory_module->codeBase + importDesc->FirstThunk);                          funcRef = (IntPtr*)(memory_module->codeBase + importDesc->FirstThunk);                      }                        for (; *thunkRef != IntPtr.Zero; thunkRef++' funcRef++)                      {                          if (WinNT.IMAGE_SNAP_BY_ORDINAL(thunkRef))                          {                              *funcRef = WinBase.GetProcAddress(handle' (byte*)WinNT.IMAGE_ORDINAL(thunkRef));                          }                          else                          {                              WinNT.IMAGE_IMPORT_BY_NAME* thunkData = (WinNT.IMAGE_IMPORT_BY_NAME*)(memory_module->codeBase + (ulong)*thunkRef);                              string procName = Marshal.PtrToStringAnsi((IntPtr)(byte*)(thunkData) + 2);                              *funcRef = WinBase.GetProcAddress(handle' procName);                          }                            if (*funcRef == IntPtr.Zero)                          {                              result = false;                              break;                          }                      }                        if (!result)                          break;                  }              }
Magic Number,Microsoft.WinAny.Interop,DynamicNativeLibrary,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Microsoft.WinAny.Helper\Interop\DynamicNativeLibrary.cs,GetProcAddress,The following statement contains a magic number: return (IntPtr)(codeBase + *(uint*)(codeBase + exports->AddressOfFunctions + (idx * 4)));
Magic Number,Ghostscript.NET.Processor,GhostscriptProcessor,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Processor\GhostscriptProcessor.cs,StartProcessing,The following statement contains a magic number: if (args.Length < 3)              {                  throw new ArgumentOutOfRangeException("args");              }
Magic Number,Ghostscript.NET.Processor,GhostscriptProcessor,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Processor\GhostscriptProcessor.cs,OnStdIoOutput,The following statement contains a magic number: lock (_outputMessages)              {                  _outputMessages.Append(output);                    int rIndex = _outputMessages.ToString().IndexOf("\r\n");                    while (rIndex > -1)                  {                      string line = _outputMessages.ToString().Substring(0' rIndex);                      _outputMessages = _outputMessages.Remove(0' rIndex + 2);                        this.ProcessOutputLine(line);                        rIndex = _outputMessages.ToString().IndexOf("\r\n");                  }                    if (_stdIO_Callback != null)                  {                      _stdIO_Callback.StdOut(output);                  }              }
Magic Number,Ghostscript.NET.Processor,GhostscriptProcessor,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Processor\GhostscriptProcessor.cs,OnStdIoError,The following statement contains a magic number: lock (_errorMessages)              {                  _outputMessages.Append(error);                    int rIndex = _errorMessages.ToString().IndexOf("\r\n");                    while (rIndex > -1)                  {                      string line = _errorMessages.ToString().Substring(0' rIndex);                      _errorMessages = _errorMessages.Remove(0' rIndex + 2);                        this.ProcessErrorLine(line);                        rIndex = _errorMessages.ToString().IndexOf("\r\n");                  }                    if (_stdIO_Callback != null)                  {                      _stdIO_Callback.StdError(error);                  }              }
Magic Number,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadUntil,The following statement contains a magic number: StringBuilder text = new StringBuilder(prefix' 64);
Magic Number,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadUntil,The following statement contains a magic number: while ((c = this.ReadChar()) > -1)              {                  if (c == '\n' && (end & DSCTokenEnding.LineEnd) == DSCTokenEnding.LineEnd)                  {                      token.Length = _bufferedStream.Position - 1 - token.StartPosition;                      token.Text = text.ToString().Trim();                      token.Ending = DSCTokenEnding.LineEnd;                      return token;                  }                  else if (c == '\r' && this.ReadChar() == '\n' && (end & DSCTokenEnding.LineEnd) == DSCTokenEnding.LineEnd)                  {                      token.Length = _bufferedStream.Position - 2 - token.StartPosition;                      token.Text = text.ToString().Trim();                      token.Ending = DSCTokenEnding.LineEnd;                      return token;                  }                  else if (c == ' ' && text.Length > 0 && lastAppendedChar != ' ' && (end & DSCTokenEnding.Whitespace) == DSCTokenEnding.Whitespace)                  {                      token.Length = _bufferedStream.Position - 1 - token.StartPosition;                      token.Text = text.ToString().Trim();                      token.Ending = DSCTokenEnding.Whitespace;                      return token;                  }                  else                  {                      text.Append((char)c);                      lastAppendedChar = c;                  }              }
Magic Number,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadChar,The following statement contains a magic number: if (_isUnicode)              {                   byte[] b = new byte[2];                    _bufferedStream.Read(b' 0' 2);                    if(_isLittleEndian)                  {                       return (int)(b[0] | b[1] << 8);                  }                  else                  {                      return (int)(b[0] << 8 | b[1]);                  }              }              else              {                  return _bufferedStream.ReadByte();              }
Magic Number,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadChar,The following statement contains a magic number: if (_isUnicode)              {                   byte[] b = new byte[2];                    _bufferedStream.Read(b' 0' 2);                    if(_isLittleEndian)                  {                       return (int)(b[0] | b[1] << 8);                  }                  else                  {                      return (int)(b[0] << 8 | b[1]);                  }              }              else              {                  return _bufferedStream.ReadByte();              }
Magic Number,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadChar,The following statement contains a magic number: if (_isUnicode)              {                   byte[] b = new byte[2];                    _bufferedStream.Read(b' 0' 2);                    if(_isLittleEndian)                  {                       return (int)(b[0] | b[1] << 8);                  }                  else                  {                      return (int)(b[0] << 8 | b[1]);                  }              }              else              {                  return _bufferedStream.ReadByte();              }
Magic Number,Ghostscript.NET.Viewer.DSC,DSCTokenizer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\DSC\DSCTokenizer.cs,ReadChar,The following statement contains a magic number: if (_isUnicode)              {                   byte[] b = new byte[2];                    _bufferedStream.Read(b' 0' 2);                    if(_isLittleEndian)                  {                       return (int)(b[0] | b[1] << 8);                  }                  else                  {                      return (int)(b[0] << 8 | b[1]);                  }              }              else              {                  return _bufferedStream.ReadByte();              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerEpsFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerEpsFormatHandler.cs,Open,The following statement contains a magic number: if (i > -1)              {                  _content = _content.Substring(0' i + 5);              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerPdfFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPdfFormatHandler.cs,StdOutput,The following statement contains a magic number: if (message.Contains(PDF_TAG))              {                  int startPos = message.IndexOf(PDF_TAG);                  int endPos = message.IndexOf(": ");                    string tag = message.Substring(startPos' endPos - startPos + 2);                  string rest = message.Substring(endPos + 2' message.Length - endPos - 2);                    switch (tag)                  {                      case PDF_PAGES_TAG:                          {                              string[] pages = rest.Split(new char[] { ' ' });                                int first' last;                                if (pages.Length >= 2 && int.TryParse(pages[0]' out first) && int.TryParse(pages[1]' out last))                              {                                  this.FirstPageNumber = first;                                  this.LastPageNumber = last;                              }                                break;                          }                      case PDF_PAGE_TAG:                          {                              int number;                                if (int.TryParse(rest' out number))                              {                                  this.CurrentPageNumber = number;                              }                                break;                          }                      case PDF_MEDIA_TAG:                          {                              string[] mb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (mb.Length >= 4 &&                                  float.TryParse(mb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(mb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(mb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(mb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.MediaBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_CROP_TAG:                          {                              string[] cb = rest.Split(new char[] { ' ' });                                float llx' lly' urx' ury;                                if (cb.Length >= 4 &&                                  float.TryParse(cb[0].TrimStart('[')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out llx) &&                                  float.TryParse(cb[1]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out lly) &&                                  float.TryParse(cb[2]' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out urx) &&                                  float.TryParse(cb[3].TrimEnd(']')' NumberStyles.Float' System.Globalization.CultureInfo.InvariantCulture' out ury))                              {                                  this.CropBox = new GhostscriptRectangle(llx' lly' urx' ury);                              }                                break;                          }                      case PDF_ROTATE_TAG:                          {                              int rotate;                                if (int.TryParse(rest' out rotate))                              {                                  while (rotate < 0)                                  {                                      rotate += 360;                                  }                                    while (rotate >= 360)                                  {                                      rotate -= 360;                                  }                                    switch (rotate)                                  {                                      case 90:                                          this.PageOrientation = GhostscriptPageOrientation.Landscape;                                          break;                                      case 180:                                          this.PageOrientation = GhostscriptPageOrientation.UpsideDown;                                          break;                                      case 270:                                          this.PageOrientation = GhostscriptPageOrientation.Seascape;                                          break;                                      default:                                          this.PageOrientation = GhostscriptPageOrientation.Portrait;                                          break;                                  }                              }                                break;                          }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,Open,The following statement contains a magic number: if (_interpreter.LibraryRevision > 910)              {                  args.Add("-dMaxBitmap=1g");              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,Zoom,The following statement contains a magic number: int tmpZoopX = (int)(_zoom_xDpi * scale + 0.5);
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,Zoom,The following statement contains a magic number: int tmpZoomY = (int)(_zoom_yDpi * scale + 0.5);
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,Zoom,The following statement contains a magic number: if (tmpZoopX < 39)                  return false;
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewer,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewer.cs,Zoom,The following statement contains a magic number: if (tmpZoopX > 496)                  return false;
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Page,The following statement contains a magic number: if (!_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    _destImage.Lock();                    IntPtr tempTile = Marshal.AllocHGlobal(_destImage.Stride * _destImage.Height);                    ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' 0' 0' _destImage.Width' _destImage.Height' _srcStride' bytesPerPixel);                  ImageMemoryHelper.FlipImageVertically(tempTile' _destImage.Scan0' _destImage.Height' _destImage.Stride);                    Marshal.FreeHGlobal(tempTile);                    _destImage.Unlock();              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerDisplayHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerDisplayHandler.cs,Update,The following statement contains a magic number: if (_viewer.ProgressiveUpdate)              {                  int bytesPerPixel = 3;                    if (_srcImage != IntPtr.Zero)                  {                      _destImage.Lock();                        int destStrideSize = (((_destImage.Width * bytesPerPixel) + 3) & ~3);                      int tileStride = (((w * bytesPerPixel) + 3) & ~3);                        if (_synchTriggered)                      {                          _synchTriggered = false;                            ImageMemoryHelper.Set24bppRgbImageColor(_destImage.Scan0' _destImage.Width' _destImage.Height' 255' 255' 255);                      }                        if (w == _destImage.Width && h == _destImage.Height)                      {                          _destImage.Unlock();                            return 0;                      }                        IntPtr tempTile = Marshal.AllocHGlobal(tileStride * h);                        ImageMemoryHelper.CopyImagePartFrom(_srcImage' tempTile' x' y' w' h' _srcStride' bytesPerPixel);                        ImageMemoryHelper.FlipImageVertically(tempTile' tempTile' h' tileStride);                        int tileMirrorY = _destImage.Height - y - h;                        ImageMemoryHelper.CopyImagePartTo(_destImage.Scan0' tempTile' x' tileMirrorY' w' h' destStrideSize' bytesPerPixel);                        Marshal.FreeHGlobal(tempTile);                        _destImage.Unlock();                        if (Environment.TickCount - _lastUpdateTime > _viewer.ProgressiveUpdateInterval)                      {                          _lastUpdateTime = Environment.TickCount;                            _viewer.RaiseDisplayUpdate(new GhostscriptViewerViewEventArgs(_destImage' new Rectangle(0' 0' _destImage.Width' _destImage.Height)));                      }                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerStdIOHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerStdIOHandler.cs,StdOut,The following statement contains a magic number: lock (_outputMessages)              {                  _outputMessages.Append(output);                    int rIndex = _outputMessages.ToString().IndexOf("\r\n");                    while (rIndex > -1)                  {                      string line = _outputMessages.ToString().Substring(0' rIndex);                      _outputMessages = _outputMessages.Remove(0' rIndex + 2);                        _viewer.StdOutput(line);                        if (_formatHandler != null)                      {                          _formatHandler.StdOutput(line);                      }                        rIndex = _outputMessages.ToString().IndexOf("\r\n");                  }              }
Magic Number,Ghostscript.NET.Viewer,GhostscriptViewerStdIOHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\GhostscriptViewerStdIOHandler.cs,StdError,The following statement contains a magic number: lock (_errorMessages)              {                  _errorMessages.Append(error);                    int rIndex = _errorMessages.ToString().IndexOf("\r\n");                    while (rIndex > -1)                  {                      string line = _errorMessages.ToString().Substring(0' rIndex);                      _errorMessages = _errorMessages.Remove(0' rIndex + 2);                        _viewer.StdError(line);                        if (_formatHandler != null)                      {                          _formatHandler.StdError(line);                      }                        rIndex = _errorMessages.ToString().IndexOf("\r\n");                  }              }
Missing Default,Ghostscript.NET.Viewer,GhostscriptViewerPsFormatHandler,C:\repos\jhabjan_Ghostscript.NET\Ghostscript.NET\Viewer\FormatHandlers\GhostscriptViewerPsFormatHandler.cs,OpenPsFile,The following switch statement is missing a default case: switch (token.Text)                  {                      case DSC_PAGES:        // %%Pages: <numpages> | (atend)                          {                              token = _tokenizer.GetNextDSCValueToken(DSCTokenEnding.Whitespace | DSCTokenEnding.LineEnd);                                                            // check if we need to ignore this comment because it's set at the end of the file                              if (!string.IsNullOrWhiteSpace(token.Text) && token.Text != "(atend)" && !token.Text.StartsWith("%"))                              {                                  // we got it' memorize it                                  this.LastPageNumber = int.Parse(token.Text);                              }                                break;                          }                      case DSC_BOUNDINGBOX:  // { %%BoundingBox: <llx> <lly> <urx> <ury> } | (atend)                          {                              try                              {                                  DSCToken llx = _tokenizer.GetNextDSCValueToken(DSCTokenEnding.Whitespace | DSCTokenEnding.LineEnd);                                    if (!string.IsNullOrWhiteSpace(llx.Text) && llx.Text != "(atend)" && !llx.Text.StartsWith("%"))                                  {                                      DSCToken lly = _tokenizer.GetNextDSCValueToken(DSCTokenEnding.Whitespace);                                      DSCToken urx = _tokenizer.GetNextDSCValueToken(DSCTokenEnding.Whitespace);                                      DSCToken ury = _tokenizer.GetNextDSCValueToken(DSCTokenEnding.Whitespace | DSCTokenEnding.LineEnd);                                        this.BoundingBox = new GhostscriptRectangle(                                          float.Parse(llx.Text' System.Globalization.CultureInfo.InvariantCulture)'                                          float.Parse(lly.Text' System.Globalization.CultureInfo.InvariantCulture)'                                          float.Parse(urx.Text' System.Globalization.CultureInfo.InvariantCulture)'                                          float.Parse(ury.Text' System.Globalization.CultureInfo.InvariantCulture));                                  }                              }                              catch { }                                break;                          }                      case DSC_PAGE:         // %%Page: <label> <ordinal>                          {                              // label can be anything' we need to get oridinal which is the last                              // value of the line                                DSCToken pageNumberToken;                                                            // loop through each comment value                              while ((pageNumberToken = _tokenizer.GetNextDSCValueToken(DSCTokenEnding.Whitespace | DSCTokenEnding.LineEnd)) != null)                              {                                  // check if this is the last comment value in this line                                  if (pageNumberToken.Ending == DSCTokenEnding.LineEnd)                                  {                                      // we got it' add this comment keyword to the page list                                      _pageTokens.Add(int.Parse(pageNumberToken.Text)' token);                                      break;                                  }                              }                                break;                          }                      case DSC_TRAILER:       // %%Trailer (no keywords)                          {                              // if the postscript is well formatted' we should get this one                              // save this comment so we can know the position when the last page is ending                              _lastPageEnding = token;                                break;                          }                      case DSC_EOF:           // %%EOF (no keywords)                          {                              // check if we already know where the last page is ending                              if (_lastPageEnding == null)                              {                                  // we don't know' use start of the %%EOF comment as the last page ending position                                   _lastPageEnding = token;                              }                                break;                          }                  }
