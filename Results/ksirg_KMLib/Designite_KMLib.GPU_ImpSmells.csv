Implementation smell,Namespace,Class,File,Method,Description
Long Method,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The method has 100 lines of code.
Long Method,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The method has 126 lines of code.
Long Method,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,UpdateAlpha,The method has 108 lines of code.
Long Method,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,UpdateAlpha,The method has 108 lines of code.
Long Method,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeModel,The method has 100 lines of code.
Long Method,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaParameters,The method has 149 lines of code.
Long Method,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,SetCudaParameters,The method has 146 lines of code.
Long Method,KMLib.GPU.Solvers,CUDALinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,solve_l2r_l2_svc_cuda,The method has 164 lines of code.
Complex Method,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,Cyclomatic complexity of the method is 8
Complex Method,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,Solve,Cyclomatic complexity of the method is 8
Complex Method,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,UpdateAlpha,Cyclomatic complexity of the method is 15
Complex Method,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,UpdateAlpha,Cyclomatic complexity of the method is 15
Complex Method,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 21
Complex Method,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 21
Complex Method,KMLib.GPU.Solvers,CUDALinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,ComputeModel,Cyclomatic complexity of the method is 21
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToEllpackRFormat,The method has 5 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToERTILPFormat,The method has 6 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSlicedEllpack,The method has 7 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSERTILP,The method has 8 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,InitBuffer,The method has 5 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,SetBufferIdx,The method has 5 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,SetTextureMemory,The method has 6 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,SetTextureMemory,The method has 5 parameters.
Long Parameter List,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The method has 5 parameters.
Long Parameter List,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,rbfSlicedEllpackKernel,The method has 10 parameters.
Long Parameter List,KMLib.GPU.GPUKernels,EllpackDenseVectorBuilder,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\EllpackDenseVectorBuilder.cs,EllpackDenseVectorBuilder,The method has 7 parameters.
Long Parameter List,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The method has 5 parameters.
Long Parameter List,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The method has 5 parameters.
Long Parameter List,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The method has 5 parameters.
Long Parameter List,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The method has 5 parameters.
Long Parameter List,KMLib.GPU.Solvers,CUDALinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,solve_l2r_l2_svc_cuda,The method has 5 parameters.
Long Statement,KMLib.GPU.GPUEvaluators,CuNChi2ERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2ERTILPEvaluator.cs,SetCudaDataForERTILP,The length of the statement  "	CudaHelpers.TransformToERTILPFormat (out vecVals' out vecColIdx' out vecLenght' TrainedModel.SupportElements' align' ThreadsPerRow); " is 132.
Long Statement,KMLib.GPU.GPUEvaluators,CuExpChiERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiERTILPEvaluator.cs,SetCudaDataForERTILP,The length of the statement  "	CudaHelpers.TransformToERTILPFormat (out vecVals' out vecColIdx' out vecLenght' TrainedModel.SupportElements' align' ThreadsPerRow); " is 132.
Long Statement,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,SetCudaDataForFormat,The length of the statement  "	CudaHelpers.TransformToSERTILP (out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize' preFechSize); " is 160.
Long Statement,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,SetCudaDataForFormat,The length of the statement  "	CudaHelpers.TransformToSERTILP (out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize' preFechSize); " is 160.
Long Statement,KMLib.GPU.GPUEvaluators,CuNChi2SlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SlEllEvaluator.cs,SetCudaDataForFormat,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize); " is 153.
Long Statement,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,SetCudaDataForFormat,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize); " is 153.
Long Statement,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,SetCudaDataForFormat,The length of the statement  "	CudaHelpers.TransformToSERTILP (out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize' preFechSize); " is 160.
Long Statement,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,SetCudaDataForFormat,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' TrainedModel.SupportElements' threadsPerRow' sliceSize); " is 153.
Long Statement,KMLib.GPU.GPUEvaluators,CuRBFERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFERTILPEvaluator.cs,SetCudaDataForERTILP,The length of the statement  "	CudaHelpers.TransformToERTILPFormat (out vecVals' out vecColIdx' out vecLenght' TrainedModel.SupportElements' align' ThreadsPerRow); " is 132.
Long Statement,KMLib.GPU,CuEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuEvaluator.cs,SetCudaRedFunctionParams,The length of the statement  "	CudaHelpers.GetNumThreadsAndBlocks (sizeSV' maxReductionBlocks' maxReductionThreads' ref reductionThreads' ref reductionBlocks); " is 128.
Long Statement,KMLib.GPU,CuExpChiSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSERTILP (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize' preFechSize); " is 147.
Long Statement,KMLib.GPU,CuNChi2SERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSERTILP (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize' preFechSize); " is 147.
Long Statement,KMLib.GPU,CuExpChiERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiERTILPKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CuNChi2ERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2ERTILPKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSERTILP (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize' preFechSize); " is 147.
Long Statement,KMLib.GPU,CuRBFERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CuRBFEllILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CuExpChiSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 140.
Long Statement,KMLib.GPU,CuNChi2SlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 140.
Long Statement,KMLib.GPU,CuExpChiEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiEllKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CuNChi2EllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2EllKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 140.
Long Statement,KMLib.GPU,CuRBFEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllpackKernel.cs,Init,The length of the statement  "		vecBuilder = new EllpackDenseVectorBuilder (cuda' mainVecPtr' valsPtr' idxPtr' vecLengthPtr' problemElements.Length' problemElements [0].Dim); " is 142.
Long Statement,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToCSRFormat,The length of the statement  "	//transform elements to specific array format -> CSR http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29 " is 134.
Long Statement,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToCSCFormat,The length of the statement  "	//transform elements to specific array format -> CSR http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29 " is 134.
Long Statement,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToCSCFormat2,The length of the statement  "	//transform elements to specific array format -> CSR http://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_.28CSR_or_CRS.29 " is 134.
Long Statement,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,TransformToSERTILP,The length of the statement  "		sliceStart [i + 1] = sliceStart [i] + (int)Math.Ceiling (1.0 * sliceMax [i] / (preFetch * threadsPerRow)) * preFetch * align; " is 125.
Long Statement,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,AllProducts,The length of the statement  "	gpu.Launch (blockPerGrid' blockSize' cudaFunctionName' valsPtr' idxPtr' vecLenghtPtr' sliceStartPtr' selfLinDotPtr' labelsPtr' outputPtr' mainVecIdx' problemElements.Length' Gamma' align); " is 188.
Long Statement,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The length of the statement  "	CudaHelpers.TransformToSlicedEllpack (out vecVals' out vecColIdx' out sliceStart' out vecLenght' problemElements' threadsPerRow' sliceSize); " is 140.
Long Statement,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The length of the statement  "	//outputIntPtr = gpu.HostAllocate<float>(problemElements.Length); // .HostAllocate(memSize' CUDADriver.CU_MEMHOSTALLOC_DEVICEMAP); " is 130.
Long Statement,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The length of the statement  "	CudaHelpers.GetNumThreadsAndBlocks (problemSize' maxReductionBlocks' threadsPerBlock' ref reductionThreads' ref reductionBlocks); " is 129.
Long Statement,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaData,The length of the statement  "	CudaHelpers.GetNumThreadsAndBlocks (problemSize' maxReductionBlocks' threadsPerBlock' ref reductionThreads' ref reductionBlocks); " is 129.
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,CuNChi2SERTILPEvaluator,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,CuNChi2SERTILPEvaluator,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,CuNChi2SERTILPEvaluator,The following statement contains a magic number: preFechSize = 2;  
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,CuExpChiSERTILPEvaluator,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,CuExpChiSERTILPEvaluator,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,CuExpChiSERTILPEvaluator,The following statement contains a magic number: preFechSize = 2;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuNChi2SlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuNChi2SlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,CuExpChiSlEllEvaluator,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,CuExpChiSlEllEvaluator,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuExpChiSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuExpChiSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,CuRBFSERTILPEvaluator,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,CuRBFSERTILPEvaluator,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,CuRBFSERTILPEvaluator,The following statement contains a magic number: preFechSize = 2;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSERTILPEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSERTILPEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,CuRBFSlEllEvaluator,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,CuRBFSlEllEvaluator,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU.GPUEvaluators,CuRBFSlEllEvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUEvaluators\CuRBFSlEllEvaluator.cs,SetCudaDataForFormat,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,CuExpChiSERTILPKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,CuExpChiSERTILPKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,CuExpChiSERTILPKernel,The following statement contains a magic number: preFechSize = 2;  
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuExpChiSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,CuNChi2SERTILPKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,CuNChi2SERTILPKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,CuNChi2SERTILPKernel,The following statement contains a magic number: preFechSize = 2;  
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuNChi2SERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuExpChiERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiERTILPKernel.cs,CuExpChiERTILPKernel,The following statement contains a magic number: ThreadsPerRow = 4;  
Magic Number,KMLib.GPU,CuExpChiERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiERTILPKernel.cs,CuExpChiERTILPKernel,The following statement contains a magic number: Prefetch = 2;  
Magic Number,KMLib.GPU,CuNChi2ERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2ERTILPKernel.cs,CuNChi2ERTILPKernel,The following statement contains a magic number: ThreadsPerRow = 4;  
Magic Number,KMLib.GPU,CuNChi2ERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2ERTILPKernel.cs,CuNChi2ERTILPKernel,The following statement contains a magic number: Prefetch = 2;  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,CuRBFSERTILPKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,CuRBFSERTILPKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,CuRBFSERTILPKernel,The following statement contains a magic number: preFechSize = 2;  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuRBFSERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSERTILPKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuRBFERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,CuRBFERTILPKernel,The following statement contains a magic number: ThreadsPerRow = 4;  
Magic Number,KMLib.GPU,CuRBFERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,CuRBFERTILPKernel,The following statement contains a magic number: Prefetch = 2;  
Magic Number,KMLib.GPU,CuRBFERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CuRBFERTILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFERTILPKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU,CuRBFEllILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CuRBFEllILPKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllILPKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,CuExpChiSlEllKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,CuExpChiSlEllKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuExpChiSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuExpChiSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,CuNChi2SlEllKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,CuNChi2SlEllKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuNChi2SlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuNChi2SlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,CuRBFSlEllKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,CuRBFSlEllKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuRBFSlEllKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFSlEllKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CuRBFEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllpackKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CuRBFEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFEllpackKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++) {  	//set the buffer values from k-th support vector  	CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  	cuda.SynchronizeStream (stream);  	//copy asynchronously from buffer to devece  	cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  	//set the last parameter in kernel (column index)     	// colIndexParamOffset  	cuda.SetParameter (cuFunc' lastParameterOffset' (uint)k);  	//launch kernl      	cuda.LaunchAsync (cuFunc' gridDimX' 1' stream);  	if (k > 0) {  		//clear the previous host buffer  		CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  	}  }  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++) {  	//set the buffer values from k-th support vector  	CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  	cuda.SynchronizeStream (stream);  	//copy asynchronously from buffer to devece  	cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  	//set the last parameter in kernel (column index)     	// colIndexParamOffset  	cuda.SetParameter (cuFunc' lastParameterOffset' (uint)k);  	//launch kernl      	cuda.LaunchAsync (cuFunc' gridDimX' 1' stream);  	if (k > 0) {  		//clear the previous host buffer  		CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  	}  }  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++) {  	//set the buffer values from k-th support vector  	CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  	cuda.SynchronizeStream (stream);  	//copy asynchronously from buffer to devece  	cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  	//set the last parameter in kernel (column index)     	// colIndexParamOffset  	cuda.SetParameter (cuFunc' lastParameterOffset' (uint)k);  	//launch kernl      	cuda.LaunchAsync (cuFunc' gridDimX' 1' stream);  	if (k > 0) {  		//clear the previous host buffer  		CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  	}  }  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: if (k > 0) {  	//clear the previous host buffer  	CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  }  
Magic Number,KMLib.GPU,CudaLinearCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaLinearCSREvaluator.cs,Predict,The following statement contains a magic number: CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2 ((size + 1) / 2) : maxThreadsPerBlock;  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2 ((size + 1) / 2) : maxThreadsPerBlock;  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 2;  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 4;  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 8;  
Magic Number,KMLib.GPU,CudaHelpers,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaHelpers.cs,nextPow2,The following statement contains a magic number: x |= x >> 16;  
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,CudafyRBFSlicedEllpackKernel,The following statement contains a magic number: threadsPerRow = 4;  
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,CudafyRBFSlicedEllpackKernel,The following statement contains a magic number: sliceSize = 64;  
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CudafyRBFSlicedEllpackKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CudafyRBFSlicedEllpackKernel.cs,Init,The following statement contains a magic number: align = (int)Math.Ceiling (1.0 * sliceSize * threadsPerRow / 64) * 64;  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++) {  	//set the buffer values from k-th support vector  	CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  	cuda.SynchronizeStream (stream);  	//copy asynchronously from buffer to device  	cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  	//set the last parameter in kernel (column index)     	// colIndexParamOffset  	cuda.SetParameter (cuFunc' lastParameterOffset' (uint)k);  	//launch kernel      	cuda.LaunchAsync (cuFunc' gridDimX' 1' stream);  	if (k > 0) {  		//clear the previous host buffer  		CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  	}  }  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++) {  	//set the buffer values from k-th support vector  	CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  	cuda.SynchronizeStream (stream);  	//copy asynchronously from buffer to device  	cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  	//set the last parameter in kernel (column index)     	// colIndexParamOffset  	cuda.SetParameter (cuFunc' lastParameterOffset' (uint)k);  	//launch kernel      	cuda.LaunchAsync (cuFunc' gridDimX' 1' stream);  	if (k > 0) {  		//clear the previous host buffer  		CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  	}  }  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: for (int k = 0; k < TrainedModel.SupportElements.Length; k++) {  	//set the buffer values from k-th support vector  	CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  	cuda.SynchronizeStream (stream);  	//copy asynchronously from buffer to device  	cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  	//set the last parameter in kernel (column index)     	// colIndexParamOffset  	cuda.SetParameter (cuFunc' lastParameterOffset' (uint)k);  	//launch kernel      	cuda.LaunchAsync (cuFunc' gridDimX' 1' stream);  	if (k > 0) {  		//clear the previous host buffer  		CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  	}  }  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: CudaHelpers.InitBuffer (TrainedModel.SupportElements [k]' svVecIntPtrs [k % 2]);  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: cuda.CopyHostToDeviceAsync (mainVecPtr' svVecIntPtrs [k % 2]' memSvSize' stream);  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: if (k > 0) {  	//clear the previous host buffer  	CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  }  
Magic Number,KMLib.GPU,CudaRBFCSREvaluator,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\CudaRBFCSREvaluator.cs,Predict,The following statement contains a magic number: CudaHelpers.SetBufferIdx (TrainedModel.SupportElements [k - 1]' svVecIntPtrs [(k + 1) % 2]' 0.0f);  
Magic Number,KMLib.GPU,CuRBFCSRKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFCSRKernel.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU,CuRBFCSRKernel,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\CuRBFCSRKernel.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,CuRBFEllILPKernelCol2,The following statement contains a magic number: preFetch = 2;  
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,Product,The following statement contains a magic number: if (element1 == element2) {  	if (DiagonalDotCacheBuilded)  		return DiagonalDotCache [element1];  	else {  		//all parts are the same  		// x1Squere = x2Squere = dot = linKernel.Product(element1' element1);  		//prod = (float)Math.Exp(-Gamma * (x1Squere + x2Squere - 2 * dot));  		// (x1Squere + x2Squere - 2 * dot)==0 this expresion is equal zero  		//so we can prod set to 1 beceause exp(0)==1  		prod = 1f;  	}  } else {  	//when element1 and element2 are different we have to compute all parts  	x1Squere = linKernel.Product (element1' element1);  	x2Squere = linKernel.Product (element2' element2);  	dot = linKernel.Product (element1' element2);  	prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  }  
Magic Number,KMLib.GPU.GPUKernels.Col2,CuRBFEllILPKernelCol2,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\GPUKernels\Col2\CuRBFEllILPKernelCol2.cs,Product,The following statement contains a magic number: prod = (float)Math.Exp (-Gamma * (x1Squere + x2Squere - 2 * dot));  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The following statement contains a magic number: reduceVal = new float[redSize * 2];  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaData,The following statement contains a magic number: reduceIdx = new int[redSize * 2];  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: alignSize = (uint)((problemSize / (reductionThreads * 2)) * reductionThreads * 2);  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: alignSize = (uint)((problemSize / (reductionThreads * 2)) * reductionThreads * 2);  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: updGThreadsPerBlock = 64;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)  	r = sum_free / nr_free;  else  	r = (ub + lb) / 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFOSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFOSolver.cs,calculate_rho,The following statement contains a magic number: r = (ub + lb) / 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,ComputeModel,The following statement contains a magic number: model.NumberOfClasses = 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,Solve,The following statement contains a magic number: while (iter < MaxIter) {  	//Find i: Maximizes -y_i * grad(f)_i' i in I_up(\alpha)  	Tuple<int' float> maxPair = FindMaxPair ();  	int i = maxPair.Item1;  	GMaxI = maxPair.Item2;  	if (iter % 250 == 0) {  		GMaxJ = FindStoppingGradVal ();  		if (GMaxI - GMaxJ < EPS)  			break;  	}  	//Compute i-th kernel collumn' set the specific memory region on GPU'   	ComputeKernel (i' kiPtr);  	// j: mimimizes the decrease of obj value  	//    (if quadratic coefficeint <= 0' replace it with tau)  	//    -y_j*grad(f)_j < -y_i*grad(f)_i' j in I_low(\alpha)  	int j = FindMinPair (i' GMaxI);  	//Compute j-th kernel collumn  	ComputeKernel (j' kjPtr);  	float old_alpha_i = alpha [i];  	float old_alpha_j = alpha [j];  	//update alpha - serial code' one iteration  	UpdateAlpha (i' j);  	// update gradient G  	float delta_alpha_i = alpha [i] - old_alpha_i;  	float delta_alpha_j = alpha [j] - old_alpha_j;  	UpdateGrad (i' j' delta_alpha_i' delta_alpha_j);  	//czy to potrzebne???  	// update alpha_status and G_bar'  	iter++;  }  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,Solve,The following statement contains a magic number: if (iter % 250 == 0) {  	GMaxJ = FindStoppingGradVal ();  	if (GMaxI - GMaxJ < EPS)  		break;  }  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,Solve,The following statement contains a magic number: si.obj = v / 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaParams,The following statement contains a magic number: updGThreadsPerBlock = 64;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,SetCudaParams,The following statement contains a magic number: updGBlocksPerGrid = (problemSize + 4 * updGThreadsPerBlock - 1) / (4 * updGThreadsPerBlock);  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)  	r = sum_free / nr_free;  else  	r = (ub + lb) / 2;  
Magic Number,KMLib.GPU.Solvers,GPUSmoFanSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUSmoFanSolver.cs,calculate_rho,The following statement contains a magic number: r = (ub + lb) / 2;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2) {  	float[] w = new float[w_size];  	int e0 = start [0] + count [0];  	int k = 0;  	for (; k < e0; k++)  		sub_prob.Y [k] = +1;  	for (; k < sub_prob.ElementsCount; k++)  		sub_prob.Y [k] = -1;  	Debug.WriteLine ("init data on cuda");  	//copy all needed data to CUDA device  	SetCudaData (sub_prob);  	Debug.WriteLine ("set cuda data complete");  	//Fill data on CUDA  	FillDataOnCuda (sub_prob' w' weighted_C [0]' weighted_C [1]);  	Stopwatch solverTime = Stopwatch.StartNew ();  	solve_l2r_l2_bb_svc_cuda (sub_prob' w' epsilon' weighted_C [0]' weighted_C [1]);  	//solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);  	solverTime.Stop ();  	Console.WriteLine ("------ solver time {0}"' solverTime.Elapsed);  	model.W = new double[w_size];  	for (int s = 0; s < w.Length; s++) {  		model.W [s] = w [s];  	}  } else {  	model.W = new double[w_size * nr_class];  	float[] w = new float[w_size];  	SetCudaData (sub_prob);  	///one against many  	for (int i = 0; i < nr_class; i++) {  		int si = start [i];  		int ei = si + count [i];  		int k = 0;  		for (; k < si; k++)  			sub_prob.Y [k] = -1;  		for (; k < ei; k++)  			sub_prob.Y [k] = +1;  		for (; k < sub_prob.ElementsCount; k++)  			sub_prob.Y [k] = -1;  		FillDataOnCuda (sub_prob' w' weighted_C [i]' C);  		//train_one(sub_prob' param' w' weighted_C[i]' param.C);  		solve_l2r_l2_bb_svc_cuda (sub_prob' w' epsilon' weighted_C [i]' C);  		for (j = 0; j < n; j++)  			model.W [j * nr_class + i] = w [j];  	}  }  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,DoBBstep,The following statement contains a magic number: if (sub_prob.FeaturesCount > 10000) {  	bpgUpdateW = (sub_prob.Elements [0].Dim + tpbUpdateW - 1) / tpbUpdateW;  } else {  	bpgUpdateW = (sub_prob.Elements [0].Dim * 32 + tpbUpdateW) / tpbUpdateW;  }  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,DoBBstep,The following statement contains a magic number: if (sub_prob.FeaturesCount > 10000) {  	bpgUpdateW = (sub_prob.Elements [0].Dim + tpbUpdateW - 1) / tpbUpdateW;  } else {  	bpgUpdateW = (sub_prob.Elements [0].Dim * 32 + tpbUpdateW) / tpbUpdateW;  }  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,DoBBstep,The following statement contains a magic number: bpgUpdateW = (sub_prob.Elements [0].Dim * 32 + tpbUpdateW) / tpbUpdateW;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,ComputeObjGPU,The following statement contains a magic number: val = val / 2;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks (vecDim' 64' threadsPerBlock' ref threadsForReduceObjW' ref bpgReduceW);  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks (problem.ElementsCount' 64' threadsPerBlock' ref threadsForReduceObjAlpha' ref bpgReduceAlpha);  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,SetCudaParameters,The following statement contains a magic number: tpbUpdateW = 64;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2 ((size + 1) / 2) : maxThreadsPerBlock;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2 ((size + 1) / 2) : maxThreadsPerBlock;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 2;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 4;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 8;  
Magic Number,KMLib.GPU.Solvers,GPUstdBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUstdBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 16;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2) {  	float[] w = new float[w_size];  	int e0 = start [0] + count [0];  	int k = 0;  	for (; k < e0; k++)  		sub_prob.Y [k] = +1;  	for (; k < sub_prob.ElementsCount; k++)  		sub_prob.Y [k] = -1;  	//copy all needed data to CUDA device  	SetCudaData (sub_prob);  	//Fill data on CUDA  	FillDataOnCuda (sub_prob' w' weighted_C [0]' weighted_C [1]);  	Stopwatch solverTime = Stopwatch.StartNew ();  	solve_l2r_l2_bb_svc_cuda (sub_prob' w' epsilon' weighted_C [0]' weighted_C [1]);  	//solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);  	solverTime.Stop ();  	Console.WriteLine ("------ solver time {0}"' solverTime.Elapsed);  	model.W = new double[w_size];  	for (int s = 0; s < w.Length; s++) {  		model.W [s] = w [s];  	}  } else {  	model.W = new double[w_size * nr_class];  	float[] w = new float[w_size];  	SetCudaData (sub_prob);  	///one against many  	for (int i = 0; i < nr_class; i++) {  		int si = start [i];  		int ei = si + count [i];  		int k = 0;  		for (; k < si; k++)  			sub_prob.Y [k] = -1;  		for (; k < ei; k++)  			sub_prob.Y [k] = +1;  		for (; k < sub_prob.ElementsCount; k++)  			sub_prob.Y [k] = -1;  		FillDataOnCuda (sub_prob' w' weighted_C [i]' C);  		//train_one(sub_prob' param' w' weighted_C[i]' param.C);  		solve_l2r_l2_bb_svc_cuda (sub_prob' w' epsilon' weighted_C [i]' C);  		for (j = 0; j < n; j++)  			model.W [j * nr_class + i] = w [j];  	}  }  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: while (iter <= maxIter) {  	maxFuncVal = func_vals.Max ();  	lambda = step;  	//nonemonotone line search  	for (int i = 0; i < 10; i++) {  		DoBBstep (-lambda' sub_prob);  		//compute Obj  		obj = ComputeObjGPU (wTempVecPtr' alphaTmpPtr);  		//compute linpart  		float linPart = ComputeLinPart (gamma' lambda);  		//* (alpha_tmp-alpha)'*grad  		if (obj <= (maxFuncVal + linPart)) {  			int idx = (iter + 1) % M;  			func_vals [idx] = obj;  			break;  		}  		lambda = (sig1 * lambda + sig2 * lambda) / 2;  	}  	//change alpha's pointers  	var tmpPtr = alphaOldPtr.Pointer;  	alphaOldPtr.Pointer = alphaPtr.Pointer;  	alphaPtr.Pointer = alphaTmpPtr.Pointer;  	alphaTmpPtr.Pointer = tmpPtr;  	//change w - pointers  	var tempPtr = wVecPtr.Pointer;  	wVecPtr.Pointer = wTempVecPtr.Pointer;  	wTempVecPtr.Pointer = tempPtr;  	//change gradients  	//gradOldPtr = grad  	//compute new grad  	float gradNorm = float.PositiveInfinity;  	ComputeGradient (sub_prob);  	if (gradNorm < epsilon) {  		break;  	}  	//compute BB step  	step = ComputeBBStep ();  	iter++;  }  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: while (iter <= maxIter) {  	maxFuncVal = func_vals.Max ();  	lambda = step;  	//nonemonotone line search  	for (int i = 0; i < 10; i++) {  		DoBBstep (-lambda' sub_prob);  		//compute Obj  		obj = ComputeObjGPU (wTempVecPtr' alphaTmpPtr);  		//compute linpart  		float linPart = ComputeLinPart (gamma' lambda);  		//* (alpha_tmp-alpha)'*grad  		if (obj <= (maxFuncVal + linPart)) {  			int idx = (iter + 1) % M;  			func_vals [idx] = obj;  			break;  		}  		lambda = (sig1 * lambda + sig2 * lambda) / 2;  	}  	//change alpha's pointers  	var tmpPtr = alphaOldPtr.Pointer;  	alphaOldPtr.Pointer = alphaPtr.Pointer;  	alphaPtr.Pointer = alphaTmpPtr.Pointer;  	alphaTmpPtr.Pointer = tmpPtr;  	//change w - pointers  	var tempPtr = wVecPtr.Pointer;  	wVecPtr.Pointer = wTempVecPtr.Pointer;  	wTempVecPtr.Pointer = tempPtr;  	//change gradients  	//gradOldPtr = grad  	//compute new grad  	float gradNorm = float.PositiveInfinity;  	ComputeGradient (sub_prob);  	if (gradNorm < epsilon) {  		break;  	}  	//compute BB step  	step = ComputeBBStep ();  	iter++;  }  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	DoBBstep (-lambda' sub_prob);  	//compute Obj  	obj = ComputeObjGPU (wTempVecPtr' alphaTmpPtr);  	//compute linpart  	float linPart = ComputeLinPart (gamma' lambda);  	//* (alpha_tmp-alpha)'*grad  	if (obj <= (maxFuncVal + linPart)) {  		int idx = (iter + 1) % M;  		func_vals [idx] = obj;  		break;  	}  	lambda = (sig1 * lambda + sig2 * lambda) / 2;  }  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	DoBBstep (-lambda' sub_prob);  	//compute Obj  	obj = ComputeObjGPU (wTempVecPtr' alphaTmpPtr);  	//compute linpart  	float linPart = ComputeLinPart (gamma' lambda);  	//* (alpha_tmp-alpha)'*grad  	if (obj <= (maxFuncVal + linPart)) {  		int idx = (iter + 1) % M;  		func_vals [idx] = obj;  		break;  	}  	lambda = (sig1 * lambda + sig2 * lambda) / 2;  }  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,solve_l2r_l2_bb_svc_cuda,The following statement contains a magic number: lambda = (sig1 * lambda + sig2 * lambda) / 2;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeObjGPU,The following statement contains a magic number: val = val / 2;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,ComputeBBStep,The following statement contains a magic number: if ((iter + 1) % 2 == 0) {  	step = step2;  }  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks (vecDim' 64' threadsPerBlock' ref threadsForReduceObjW' ref bpgReduceW);  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,SetCudaData,The following statement contains a magic number: GetNumThreadsAndBlocks (problem.ElementsCount' 64' threadsPerBlock' ref threadsForReduceObjAlpha' ref bpgReduceAlpha);  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2 ((size + 1) / 2) : maxThreadsPerBlock;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: threads = (size < 2 * maxThreadsPerBlock) ? nextPow2 ((size + 1) / 2) : maxThreadsPerBlock;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,GetNumThreadsAndBlocks,The following statement contains a magic number: blocks = (size + (threads * 2 - 1)) / (threads * 2);  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 2;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 4;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 8;  
Magic Number,KMLib.GPU.Solvers,GPUnmBBLinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\GPUnmBBLinSolver.cs,nextPow2,The following statement contains a magic number: x |= x >> 16;  
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,ComputeModel,The following statement contains a magic number: if (nr_class == 2) {  	float[] w = new float[w_size];  	//for (int z = 0; z < w.Length; z++)  	//{  	//    w[z] = 1.0f;  	//}  	int e0 = start [0] + count [0];  	int k = 0;  	for (; k < e0; k++)  		sub_prob.Y [k] = +1;  	for (; k < sub_prob.ElementsCount; k++)  		sub_prob.Y [k] = -1;  	//copy all needed data to CUDA device  	SetCudaData (sub_prob);  	//Fill data on CUDA  	FillDataOnCuda (sub_prob' w' weighted_C [0]' weighted_C [1]);  	solve_l2r_l2_svc_cuda (sub_prob' w' epsilon' weighted_C [0]' weighted_C [1]);  	//solve_l2r_l1l2_svc(model.W' epsilon' weighted_C[0]' weighted_C[1]' solverType);  	model.W = new double[w_size];  	for (int s = 0; s < w.Length; s++) {  		model.W [s] = w [s];  	}  } else {  	model.W = new double[w_size * nr_class];  	float[] w = new float[w_size];  	SetCudaData (sub_prob);  	///one against many  	for (int i = 0; i < nr_class; i++) {  		int si = start [i];  		int ei = si + count [i];  		int k = 0;  		for (; k < si; k++)  			sub_prob.Y [k] = -1;  		for (; k < ei; k++)  			sub_prob.Y [k] = +1;  		for (; k < sub_prob.ElementsCount; k++)  			sub_prob.Y [k] = -1;  		FillDataOnCuda (sub_prob' w' weighted_C [i]' C);  		//train_one(sub_prob' param' w' weighted_C[i]' param.C);  		solve_l2r_l2_svc_cuda (sub_prob' w' epsilon' weighted_C [i]' C);  		for (j = 0; j < n; j++)  			model.W [j * nr_class + i] = w [j];  	}  }  
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,FillDataOnCuda,The following statement contains a magic number: diag = new float[] {  	(float)(0.5 / Cn)'  	0'  	(float)(0.5 / Cp)  };  
Magic Number,KMLib.GPU.Solvers,CUDALinSolver,F:\newReposMay17\ksirg_KMLib\KMLib.CUDA\Solvers\CUDALinSolver.cs,FillDataOnCuda,The following statement contains a magic number: diag = new float[] {  	(float)(0.5 / Cn)'  	0'  	(float)(0.5 / Cp)  };  
